/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2019, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */

!function(r,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(r="undefined"!=typeof globalThis?globalThis:r||self).chroma=e()}(this,(function(){"use strict";for(var r=function(r,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),r<e?e:r>n?n:r},e=r,n={},t=0,a=["Boolean","Number","String","Function","Array","Date","RegExp","Undefined","Null"];t<a.length;t+=1){var f=a[t];n["[object "+f+"]"]=f.toLowerCase()}var o=function(r){return n[Object.prototype.toString.call(r)]||"object"},u=o,c=o,i=Math.PI,l={clip_rgb:function(r){r._clipped=!1,r._unclipped=r.slice(0);for(var n=0;n<=3;n++)n<3?((r[n]<0||r[n]>255)&&(r._clipped=!0),r[n]=e(r[n],0,255)):3===n&&(r[n]=e(r[n],0,1));return r},limit:r,type:o,unpack:function(r,e){return void 0===e&&(e=null),r.length>=3?Array.prototype.slice.call(r):"object"==u(r[0])&&e?e.split("").filter((function(e){return void 0!==r[0][e]})).map((function(e){return r[0][e]})):r[0]},last:function(r){if(r.length<2)return null;var e=r.length-1;return"string"==c(r[e])?r[e].toLowerCase():null},PI:i,TWOPI:2*i,PITHIRD:i/3,DEG2RAD:i/180,RAD2DEG:180/i},h={format:{},autodetect:[]},s=l.last,d=l.clip_rgb,b=l.type,p=h,g=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=this;if("object"===b(r[0])&&r[0].constructor&&r[0].constructor===this.constructor)return r[0];var t=s(r),a=!1;if(!t){a=!0,p.sorted||(p.autodetect=p.autodetect.sort((function(r,e){return e.p-r.p})),p.sorted=!0);for(var f=0,o=p.autodetect;f<o.length;f+=1){var u=o[f];if(t=u.test.apply(u,r))break}}if(!p.format[t])throw new Error("unknown format: "+r);var c=p.format[t].apply(null,a?r:r.slice(0,-1));n._rgb=d(c),3===n._rgb.length&&n._rgb.push(1)};g.prototype.toString=function(){return"function"==b(this.hex)?this.hex():"["+this._rgb.join(",")+"]"};var v=g,m=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(m.Color,[null].concat(r)))};m.Color=v,m.version="2.4.2";var y=m,k=l.unpack,w=Math.max,M=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=k(r,"rgb"),t=n[0],a=n[1],f=n[2],o=1-w(t/=255,w(a/=255,f/=255)),u=o<1?1/(1-o):0,c=(1-t-o)*u,i=(1-a-o)*u,l=(1-f-o)*u;return[c,i,l,o]},N=l.unpack,_=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=(r=N(r,"cmyk"))[0],t=r[1],a=r[2],f=r[3],o=r.length>4?r[4]:1;return 1===f?[0,0,0,o]:[n>=1?0:255*(1-n)*(1-f),t>=1?0:255*(1-t)*(1-f),a>=1?0:255*(1-a)*(1-f),o]},x=y,A=v,E=h,F=l.unpack,P=l.type,O=M;A.prototype.cmyk=function(){return O(this._rgb)},x.cmyk=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(A,[null].concat(r,["cmyk"])))},E.format.cmyk=_,E.autodetect.push({p:2,test:function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];if(r=F(r,"cmyk"),"array"===P(r)&&4===r.length)return"cmyk"}});var j=l.unpack,G=l.last,R=function(r){return Math.round(100*r)/100},q=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=j(r,"hsla"),t=G(r)||"lsa";return n[0]=R(n[0]||0),n[1]=R(100*n[1])+"%",n[2]=R(100*n[2])+"%","hsla"===t||n.length>3&&n[3]<1?(n[3]=n.length>3?n[3]:1,t="hsla"):n.length=3,t+"("+n.join(",")+")"},L=l.unpack,I=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=(r=L(r,"rgba"))[0],t=r[1],a=r[2];n/=255,t/=255,a/=255;var f,o,u=Math.min(n,t,a),c=Math.max(n,t,a),i=(c+u)/2;return c===u?(f=0,o=Number.NaN):f=i<.5?(c-u)/(c+u):(c-u)/(2-c-u),n==c?o=(t-a)/(c-u):t==c?o=2+(a-n)/(c-u):a==c&&(o=4+(n-t)/(c-u)),(o*=60)<0&&(o+=360),r.length>3&&void 0!==r[3]?[o,f,i,r[3]]:[o,f,i]},B=l.unpack,C=l.last,D=q,Y=I,S=Math.round,T=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=B(r,"rgba"),t=C(r)||"rgb";return"hsl"==t.substr(0,3)?D(Y(n),t):(n[0]=S(n[0]),n[1]=S(n[1]),n[2]=S(n[2]),("rgba"===t||n.length>3&&n[3]<1)&&(n[3]=n.length>3?n[3]:1,t="rgba"),t+"("+n.slice(0,"rgb"===t?3:4).join(",")+")")},$=l.unpack,z=Math.round,X=function(){for(var r,e=[],n=arguments.length;n--;)e[n]=arguments[n];var t,a,f,o=(e=$(e,"hsl"))[0],u=e[1],c=e[2];if(0===u)t=a=f=255*c;else{var i=[0,0,0],l=[0,0,0],h=c<.5?c*(1+u):c+u-c*u,s=2*c-h,d=o/360;i[0]=d+1/3,i[1]=d,i[2]=d-1/3;for(var b=0;b<3;b++)i[b]<0&&(i[b]+=1),i[b]>1&&(i[b]-=1),6*i[b]<1?l[b]=s+6*(h-s)*i[b]:2*i[b]<1?l[b]=h:3*i[b]<2?l[b]=s+(h-s)*(2/3-i[b])*6:l[b]=s;t=(r=[z(255*l[0]),z(255*l[1]),z(255*l[2])])[0],a=r[1],f=r[2]}return e.length>3?[t,a,f,e[3]]:[t,a,f,1]},U=X,V=h,W=/^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/,K=/^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/,Z=/^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/,H=/^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/,J=/^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/,Q=/^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/,rr=Math.round,er=function(r){var e;if(r=r.toLowerCase().trim(),V.format.named)try{return V.format.named(r)}catch(r){}if(e=r.match(W)){for(var n=e.slice(1,4),t=0;t<3;t++)n[t]=+n[t];return n[3]=1,n}if(e=r.match(K)){for(var a=e.slice(1,5),f=0;f<4;f++)a[f]=+a[f];return a}if(e=r.match(Z)){for(var o=e.slice(1,4),u=0;u<3;u++)o[u]=rr(2.55*o[u]);return o[3]=1,o}if(e=r.match(H)){for(var c=e.slice(1,5),i=0;i<3;i++)c[i]=rr(2.55*c[i]);return c[3]=+c[3],c}if(e=r.match(J)){var l=e.slice(1,4);l[1]*=.01,l[2]*=.01;var h=U(l);return h[3]=1,h}if(e=r.match(Q)){var s=e.slice(1,4);s[1]*=.01,s[2]*=.01;var d=U(s);return d[3]=+e[4],d}};er.test=function(r){return W.test(r)||K.test(r)||Z.test(r)||H.test(r)||J.test(r)||Q.test(r)};var nr=y,tr=v,ar=h,fr=l.type,or=T,ur=er;tr.prototype.css=function(r){return or(this._rgb,r)},nr.css=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(tr,[null].concat(r,["css"])))},ar.format.css=ur,ar.autodetect.push({p:5,test:function(r){for(var e=[],n=arguments.length-1;n-- >0;)e[n]=arguments[n+1];if(!e.length&&"string"===fr(r)&&ur.test(r))return"css"}});var cr=v,ir=y,lr=l.unpack;h.format.gl=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=lr(r,"rgba");return n[0]*=255,n[1]*=255,n[2]*=255,n},ir.gl=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(cr,[null].concat(r,["gl"])))},cr.prototype.gl=function(){var r=this._rgb;return[r[0]/255,r[1]/255,r[2]/255,r[3]]};var hr=l.unpack,sr=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n,t=hr(r,"rgb"),a=t[0],f=t[1],o=t[2],u=Math.min(a,f,o),c=Math.max(a,f,o),i=c-u,l=100*i/255,h=u/(255-i)*100;return 0===i?n=Number.NaN:(a===c&&(n=(f-o)/i),f===c&&(n=2+(o-a)/i),o===c&&(n=4+(a-f)/i),(n*=60)<0&&(n+=360)),[n,l,h]},dr=l.unpack,br=Math.floor,pr=function(){for(var r,e,n,t,a,f,o=[],u=arguments.length;u--;)o[u]=arguments[u];var c,i,l,h=(o=dr(o,"hcg"))[0],s=o[1],d=o[2];d*=255;var b=255*s;if(0===s)c=i=l=d;else{360===h&&(h=0),h>360&&(h-=360),h<0&&(h+=360);var p=br(h/=60),g=h-p,v=d*(1-s),m=v+b*(1-g),y=v+b*g,k=v+b;switch(p){case 0:c=(r=[k,y,v])[0],i=r[1],l=r[2];break;case 1:c=(e=[m,k,v])[0],i=e[1],l=e[2];break;case 2:c=(n=[v,k,y])[0],i=n[1],l=n[2];break;case 3:c=(t=[v,m,k])[0],i=t[1],l=t[2];break;case 4:c=(a=[y,v,k])[0],i=a[1],l=a[2];break;case 5:c=(f=[k,v,m])[0],i=f[1],l=f[2]}}return[c,i,l,o.length>3?o[3]:1]},gr=l.unpack,vr=l.type,mr=y,yr=v,kr=h,wr=sr;yr.prototype.hcg=function(){return wr(this._rgb)},mr.hcg=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(yr,[null].concat(r,["hcg"])))},kr.format.hcg=pr,kr.autodetect.push({p:1,test:function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];if(r=gr(r,"hcg"),"array"===vr(r)&&3===r.length)return"hcg"}});var Mr=l.unpack,Nr=l.last,_r=Math.round,xr=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=Mr(r,"rgba"),t=n[0],a=n[1],f=n[2],o=n[3],u=Nr(r)||"auto";void 0===o&&(o=1),"auto"===u&&(u=o<1?"rgba":"rgb");var c=(t=_r(t))<<16|(a=_r(a))<<8|(f=_r(f)),i="000000"+c.toString(16);i=i.substr(i.length-6);var l="0"+_r(255*o).toString(16);switch(l=l.substr(l.length-2),u.toLowerCase()){case"rgba":return"#"+i+l;case"argb":return"#"+l+i;default:return"#"+i}},Ar=/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/,Er=/^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/,Fr=function(r){if(r.match(Ar)){4!==r.length&&7!==r.length||(r=r.substr(1)),3===r.length&&(r=(r=r.split(""))[0]+r[0]+r[1]+r[1]+r[2]+r[2]);var e=parseInt(r,16);return[e>>16,e>>8&255,255&e,1]}if(r.match(Er)){5!==r.length&&9!==r.length||(r=r.substr(1)),4===r.length&&(r=(r=r.split(""))[0]+r[0]+r[1]+r[1]+r[2]+r[2]+r[3]+r[3]);var n=parseInt(r,16);return[n>>24&255,n>>16&255,n>>8&255,Math.round((255&n)/255*100)/100]}throw new Error("unknown hex color: "+r)},Pr=y,Or=v,jr=l.type,Gr=h,Rr=xr;Or.prototype.hex=function(r){return Rr(this._rgb,r)},Pr.hex=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(Or,[null].concat(r,["hex"])))},Gr.format.hex=Fr,Gr.autodetect.push({p:4,test:function(r){for(var e=[],n=arguments.length-1;n-- >0;)e[n]=arguments[n+1];if(!e.length&&"string"===jr(r)&&[3,4,5,6,7,8,9].indexOf(r.length)>=0)return"hex"}});var qr=l.unpack,Lr=l.TWOPI,Ir=Math.min,Br=Math.sqrt,Cr=Math.acos,Dr=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n,t=qr(r,"rgb"),a=t[0],f=t[1],o=t[2],u=Ir(a/=255,f/=255,o/=255),c=(a+f+o)/3,i=c>0?1-u/c:0;return 0===i?n=NaN:(n=(a-f+(a-o))/2,n/=Br((a-f)*(a-f)+(a-o)*(f-o)),n=Cr(n),o>f&&(n=Lr-n),n/=Lr),[360*n,i,c]},Yr=l.unpack,Sr=l.limit,Tr=l.TWOPI,$r=l.PITHIRD,zr=Math.cos,Xr=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n,t,a,f=(r=Yr(r,"hsi"))[0],o=r[1],u=r[2];return isNaN(f)&&(f=0),isNaN(o)&&(o=0),f>360&&(f-=360),f<0&&(f+=360),(f/=360)<1/3?t=1-((a=(1-o)/3)+(n=(1+o*zr(Tr*f)/zr($r-Tr*f))/3)):f<2/3?a=1-((n=(1-o)/3)+(t=(1+o*zr(Tr*(f-=1/3))/zr($r-Tr*f))/3)):n=1-((t=(1-o)/3)+(a=(1+o*zr(Tr*(f-=2/3))/zr($r-Tr*f))/3)),[255*(n=Sr(u*n*3)),255*(t=Sr(u*t*3)),255*(a=Sr(u*a*3)),r.length>3?r[3]:1]},Ur=l.unpack,Vr=l.type,Wr=y,Kr=v,Zr=h,Hr=Dr;Kr.prototype.hsi=function(){return Hr(this._rgb)},Wr.hsi=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(Kr,[null].concat(r,["hsi"])))},Zr.format.hsi=Xr,Zr.autodetect.push({p:2,test:function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];if(r=Ur(r,"hsi"),"array"===Vr(r)&&3===r.length)return"hsi"}});var Jr=l.unpack,Qr=l.type,re=y,ee=v,ne=h,te=I;ee.prototype.hsl=function(){return te(this._rgb)},re.hsl=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(ee,[null].concat(r,["hsl"])))},ne.format.hsl=X,ne.autodetect.push({p:2,test:function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];if(r=Jr(r,"hsl"),"array"===Qr(r)&&3===r.length)return"hsl"}});var ae=l.unpack,fe=Math.min,oe=Math.max,ue=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n,t,a,f=(r=ae(r,"rgb"))[0],o=r[1],u=r[2],c=fe(f,o,u),i=oe(f,o,u),l=i-c;return a=i/255,0===i?(n=Number.NaN,t=0):(t=l/i,f===i&&(n=(o-u)/l),o===i&&(n=2+(u-f)/l),u===i&&(n=4+(f-o)/l),(n*=60)<0&&(n+=360)),[n,t,a]},ce=l.unpack,ie=Math.floor,le=function(){for(var r,e,n,t,a,f,o=[],u=arguments.length;u--;)o[u]=arguments[u];var c,i,l,h=(o=ce(o,"hsv"))[0],s=o[1],d=o[2];if(d*=255,0===s)c=i=l=d;else{360===h&&(h=0),h>360&&(h-=360),h<0&&(h+=360);var b=ie(h/=60),p=h-b,g=d*(1-s),v=d*(1-s*p),m=d*(1-s*(1-p));switch(b){case 0:c=(r=[d,m,g])[0],i=r[1],l=r[2];break;case 1:c=(e=[v,d,g])[0],i=e[1],l=e[2];break;case 2:c=(n=[g,d,m])[0],i=n[1],l=n[2];break;case 3:c=(t=[g,v,d])[0],i=t[1],l=t[2];break;case 4:c=(a=[m,g,d])[0],i=a[1],l=a[2];break;case 5:c=(f=[d,g,v])[0],i=f[1],l=f[2]}}return[c,i,l,o.length>3?o[3]:1]},he=l.unpack,se=l.type,de=y,be=v,pe=h,ge=ue;be.prototype.hsv=function(){return ge(this._rgb)},de.hsv=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(be,[null].concat(r,["hsv"])))},pe.format.hsv=le,pe.autodetect.push({p:2,test:function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];if(r=he(r,"hsv"),"array"===se(r)&&3===r.length)return"hsv"}});var ve={Kn:18,Xn:.95047,Yn:1,Zn:1.08883,t0:.137931034,t1:.206896552,t2:.12841855,t3:.008856452},me=ve,ye=l.unpack,ke=Math.pow,we=function(r){return(r/=255)<=.04045?r/12.92:ke((r+.055)/1.055,2.4)},Me=function(r){return r>me.t3?ke(r,1/3):r/me.t2+me.t0},Ne=function(r,e,n){return r=we(r),e=we(e),n=we(n),[Me((.4124564*r+.3575761*e+.1804375*n)/me.Xn),Me((.2126729*r+.7151522*e+.072175*n)/me.Yn),Me((.0193339*r+.119192*e+.9503041*n)/me.Zn)]},_e=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=ye(r,"rgb"),t=n[0],a=n[1],f=n[2],o=Ne(t,a,f),u=o[0],c=o[1],i=o[2],l=116*c-16;return[l<0?0:l,500*(u-c),200*(c-i)]},xe=ve,Ae=l.unpack,Ee=Math.pow,Fe=function(r){return 255*(r<=.00304?12.92*r:1.055*Ee(r,1/2.4)-.055)},Pe=function(r){return r>xe.t1?r*r*r:xe.t2*(r-xe.t0)},Oe=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n,t,a,f=(r=Ae(r,"lab"))[0],o=r[1],u=r[2];return t=(f+16)/116,n=isNaN(o)?t:t+o/500,a=isNaN(u)?t:t-u/200,t=xe.Yn*Pe(t),n=xe.Xn*Pe(n),a=xe.Zn*Pe(a),[Fe(3.2404542*n-1.5371385*t-.4985314*a),Fe(-.969266*n+1.8760108*t+.041556*a),Fe(.0556434*n-.2040259*t+1.0572252*a),r.length>3?r[3]:1]},je=l.unpack,Ge=l.type,Re=y,qe=v,Le=h,Ie=_e;qe.prototype.lab=function(){return Ie(this._rgb)},Re.lab=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(qe,[null].concat(r,["lab"])))},Le.format.lab=Oe,Le.autodetect.push({p:2,test:function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];if(r=je(r,"lab"),"array"===Ge(r)&&3===r.length)return"lab"}});var Be=l.unpack,Ce=l.RAD2DEG,De=Math.sqrt,Ye=Math.atan2,Se=Math.round,Te=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=Be(r,"lab"),t=n[0],a=n[1],f=n[2],o=De(a*a+f*f),u=(Ye(f,a)*Ce+360)%360;return 0===Se(1e4*o)&&(u=Number.NaN),[t,o,u]},$e=l.unpack,ze=_e,Xe=Te,Ue=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=$e(r,"rgb"),t=n[0],a=n[1],f=n[2],o=ze(t,a,f),u=o[0],c=o[1],i=o[2];return Xe(u,c,i)},Ve=l.unpack,We=l.DEG2RAD,Ke=Math.sin,Ze=Math.cos,He=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=Ve(r,"lch"),t=n[0],a=n[1],f=n[2];return isNaN(f)&&(f=0),[t,Ze(f*=We)*a,Ke(f)*a]},Je=l.unpack,Qe=He,rn=Oe,en=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=(r=Je(r,"lch"))[0],t=r[1],a=r[2],f=Qe(n,t,a),o=f[0],u=f[1],c=f[2],i=rn(o,u,c),l=i[0],h=i[1],s=i[2];return[l,h,s,r.length>3?r[3]:1]},nn=l.unpack,tn=en,an=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=nn(r,"hcl").reverse();return tn.apply(void 0,n)},fn=l.unpack,on=l.type,un=y,cn=v,ln=h,hn=Ue;cn.prototype.lch=function(){return hn(this._rgb)},cn.prototype.hcl=function(){return hn(this._rgb).reverse()},un.lch=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(cn,[null].concat(r,["lch"])))},un.hcl=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(cn,[null].concat(r,["hcl"])))},ln.format.lch=en,ln.format.hcl=an,["lch","hcl"].forEach((function(r){return ln.autodetect.push({p:2,test:function(){for(var e=[],n=arguments.length;n--;)e[n]=arguments[n];if(e=fn(e,r),"array"===on(e)&&3===e.length)return r}})}));var sn={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflower:"#6495ed",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gray:"#808080",green:"#008000",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",laserlemon:"#ffff54",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrod:"#fafad2",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",maroon2:"#7f0000",maroon3:"#b03060",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",purple2:"#7f007f",purple3:"#a020f0",rebeccapurple:"#663399",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"},dn=h,bn=l.type,pn=sn,gn=Fr,vn=xr;v.prototype.name=function(){for(var r=vn(this._rgb,"rgb"),e=0,n=Object.keys(pn);e<n.length;e+=1){var t=n[e];if(pn[t]===r)return t.toLowerCase()}return r},dn.format.named=function(r){if(r=r.toLowerCase(),pn[r])return gn(pn[r]);throw new Error("unknown color name: "+r)},dn.autodetect.push({p:5,test:function(r){for(var e=[],n=arguments.length-1;n-- >0;)e[n]=arguments[n+1];if(!e.length&&"string"===bn(r)&&pn[r.toLowerCase()])return"named"}});var mn=l.unpack,yn=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=mn(r,"rgb"),t=n[0],a=n[1],f=n[2];return(t<<16)+(a<<8)+f},kn=l.type,wn=function(r){if("number"==kn(r)&&r>=0&&r<=16777215)return[r>>16,r>>8&255,255&r,1];throw new Error("unknown num color: "+r)},Mn=y,Nn=v,_n=h,xn=l.type,An=yn;Nn.prototype.num=function(){return An(this._rgb)},Mn.num=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(Nn,[null].concat(r,["num"])))},_n.format.num=wn,_n.autodetect.push({p:5,test:function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];if(1===r.length&&"number"===xn(r[0])&&r[0]>=0&&r[0]<=16777215)return"num"}});var En=y,Fn=v,Pn=h,On=l.unpack,jn=l.type,Gn=Math.round;Fn.prototype.rgb=function(r){return void 0===r&&(r=!0),!1===r?this._rgb.slice(0,3):this._rgb.slice(0,3).map(Gn)},Fn.prototype.rgba=function(r){return void 0===r&&(r=!0),this._rgb.slice(0,4).map((function(e,n){return n<3?!1===r?e:Gn(e):e}))},En.rgb=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(Fn,[null].concat(r,["rgb"])))},Pn.format.rgb=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=On(r,"rgba");return void 0===n[3]&&(n[3]=1),n},Pn.autodetect.push({p:3,test:function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];if(r=On(r,"rgba"),"array"===jn(r)&&(3===r.length||4===r.length&&"number"==jn(r[3])&&r[3]>=0&&r[3]<=1))return"rgb"}});var Rn=Math.log,qn=function(r){var e,n,t,a=r/100;return a<66?(e=255,n=a<6?0:-155.25485562709179-.44596950469579133*(n=a-2)+104.49216199393888*Rn(n),t=a<20?0:.8274096064007395*(t=a-10)-254.76935184120902+115.67994401066147*Rn(t)):(e=351.97690566805693+.114206453784165*(e=a-55)-40.25366309332127*Rn(e),n=325.4494125711974+.07943456536662342*(n=a-50)-28.0852963507957*Rn(n),t=255),[e,n,t,1]},Ln=qn,In=l.unpack,Bn=Math.round,Cn=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];for(var n,t=In(r,"rgb"),a=t[0],f=t[2],o=1e3,u=4e4,c=.4;u-o>c;){var i=Ln(n=.5*(u+o));i[2]/i[0]>=f/a?u=n:o=n}return Bn(n)},Dn=y,Yn=v,Sn=h,Tn=Cn;Yn.prototype.temp=Yn.prototype.kelvin=Yn.prototype.temperature=function(){return Tn(this._rgb)},Dn.temp=Dn.kelvin=Dn.temperature=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(Yn,[null].concat(r,["temp"])))},Sn.format.temp=Sn.format.kelvin=Sn.format.temperature=qn;var $n=l.unpack,zn=Math.cbrt,Xn=Math.pow,Un=Math.sign,Vn=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=$n(r,"rgb"),t=n[0],a=n[1],f=n[2],o=[Wn(t/255),Wn(a/255),Wn(f/255)],u=o[0],c=o[1],i=o[2],l=zn(.4122214708*u+.5363325363*c+.0514459929*i),h=zn(.2119034982*u+.6806995451*c+.1073969566*i),s=zn(.0883024619*u+.2817188376*c+.6299787005*i);return[.2104542553*l+.793617785*h-.0040720468*s,1.9779984951*l-2.428592205*h+.4505937099*s,.0259040371*l+.7827717662*h-.808675766*s]};function Wn(r){var e=Math.abs(r);return e<.04045?r/12.92:(Un(r)||1)*Xn((e+.055)/1.055,2.4)}var Kn=l.unpack,Zn=Math.pow,Hn=Math.sign,Jn=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=(r=Kn(r,"lab"))[0],t=r[1],a=r[2],f=Zn(n+.3963377774*t+.2158037573*a,3),o=Zn(n-.1055613458*t-.0638541728*a,3),u=Zn(n-.0894841775*t-1.291485548*a,3);return[255*Qn(4.0767416621*f-3.3077115913*o+.2309699292*u),255*Qn(-1.2684380046*f+2.6097574011*o-.3413193965*u),255*Qn(-.0041960863*f-.7034186147*o+1.707614701*u),r.length>3?r[3]:1]};function Qn(r){var e=Math.abs(r);return e>.0031308?(Hn(r)||1)*(1.055*Zn(e,1/2.4)-.055):12.92*r}var rt=l.unpack,et=l.type,nt=y,tt=v,at=h,ft=Vn;tt.prototype.oklab=function(){return ft(this._rgb)},nt.oklab=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(tt,[null].concat(r,["oklab"])))},at.format.oklab=Jn,at.autodetect.push({p:3,test:function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];if(r=rt(r,"oklab"),"array"===et(r)&&3===r.length)return"oklab"}});var ot=l.unpack,ut=Vn,ct=Te,it=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=ot(r,"rgb"),t=n[0],a=n[1],f=n[2],o=ut(t,a,f),u=o[0],c=o[1],i=o[2];return ct(u,c,i)},lt=l.unpack,ht=He,st=Jn,dt=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];var n=(r=lt(r,"lch"))[0],t=r[1],a=r[2],f=ht(n,t,a),o=f[0],u=f[1],c=f[2],i=st(o,u,c),l=i[0],h=i[1],s=i[2];return[l,h,s,r.length>3?r[3]:1]},bt=l.unpack,pt=l.type,gt=y,vt=v,mt=h,yt=it;vt.prototype.oklch=function(){return yt(this._rgb)},gt.oklch=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];return new(Function.prototype.bind.apply(vt,[null].concat(r,["oklch"])))},mt.format.oklch=dt,mt.autodetect.push({p:3,test:function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];if(r=bt(r,"oklch"),"array"===pt(r)&&3===r.length)return"oklch"}});var kt=v,wt=l.type;kt.prototype.alpha=function(r,e){return void 0===e&&(e=!1),void 0!==r&&"number"===wt(r)?e?(this._rgb[3]=r,this):new kt([this._rgb[0],this._rgb[1],this._rgb[2],r],"rgb"):this._rgb[3]},v.prototype.clipped=function(){return this._rgb._clipped||!1};var Mt=v,Nt=ve;Mt.prototype.darken=function(r){void 0===r&&(r=1);var e=this.lab();return e[0]-=Nt.Kn*r,new Mt(e,"lab").alpha(this.alpha(),!0)},Mt.prototype.brighten=function(r){return void 0===r&&(r=1),this.darken(-r)},Mt.prototype.darker=Mt.prototype.darken,Mt.prototype.brighter=Mt.prototype.brighten,v.prototype.get=function(r){var e=r.split("."),n=e[0],t=e[1],a=this[n]();if(t){var f=n.indexOf(t)-("ok"===n.substr(0,2)?2:0);if(f>-1)return a[f];throw new Error("unknown channel "+t+" in mode "+n)}return a};var _t=v,xt=l.type,At=Math.pow;_t.prototype.luminance=function(r){if(void 0!==r&&"number"===xt(r)){if(0===r)return new _t([0,0,0,this._rgb[3]],"rgb");if(1===r)return new _t([255,255,255,this._rgb[3]],"rgb");var e=this.luminance(),n=20,t=function(e,a){var f=e.interpolate(a,.5,"rgb"),o=f.luminance();return Math.abs(r-o)<1e-7||!n--?f:o>r?t(e,f):t(f,a)},a=(e>r?t(new _t([0,0,0]),this):t(this,new _t([255,255,255]))).rgb();return new _t(a.concat([this._rgb[3]]))}return Et.apply(void 0,this._rgb.slice(0,3))};var Et=function(r,e,n){return.2126*(r=Ft(r))+.7152*(e=Ft(e))+.0722*(n=Ft(n))},Ft=function(r){return(r/=255)<=.03928?r/12.92:At((r+.055)/1.055,2.4)},Pt={},Ot=v,jt=l.type,Gt=Pt,Rt=function(r,e,n){void 0===n&&(n=.5);for(var t=[],a=arguments.length-3;a-- >0;)t[a]=arguments[a+3];var f=t[0]||"lrgb";if(Gt[f]||t.length||(f=Object.keys(Gt)[0]),!Gt[f])throw new Error("interpolation mode "+f+" is not defined");return"object"!==jt(r)&&(r=new Ot(r)),"object"!==jt(e)&&(e=new Ot(e)),Gt[f](r,e,n).alpha(r.alpha()+n*(e.alpha()-r.alpha()))},qt=v,Lt=Rt;qt.prototype.mix=qt.prototype.interpolate=function(r,e){void 0===e&&(e=.5);for(var n=[],t=arguments.length-2;t-- >0;)n[t]=arguments[t+2];return Lt.apply(void 0,[this,r,e].concat(n))};var It=v;It.prototype.premultiply=function(r){void 0===r&&(r=!1);var e=this._rgb,n=e[3];return r?(this._rgb=[e[0]*n,e[1]*n,e[2]*n,n],this):new It([e[0]*n,e[1]*n,e[2]*n,n],"rgb")};var Bt=v,Ct=ve;Bt.prototype.saturate=function(r){void 0===r&&(r=1);var e=this.lch();return e[1]+=Ct.Kn*r,e[1]<0&&(e[1]=0),new Bt(e,"lch").alpha(this.alpha(),!0)},Bt.prototype.desaturate=function(r){return void 0===r&&(r=1),this.saturate(-r)};var Dt=v,Yt=l.type;Dt.prototype.set=function(r,e,n){void 0===n&&(n=!1);var t=r.split("."),a=t[0],f=t[1],o=this[a]();if(f){var u=a.indexOf(f)-("ok"===a.substr(0,2)?2:0);if(u>-1){if("string"==Yt(e))switch(e.charAt(0)){case"+":case"-":o[u]+=+e;break;case"*":o[u]*=+e.substr(1);break;case"/":o[u]/=+e.substr(1);break;default:o[u]=+e}else{if("number"!==Yt(e))throw new Error("unsupported value for Color.set");o[u]=e}var c=new Dt(o,a);return n?(this._rgb=c._rgb,this):c}throw new Error("unknown channel "+f+" in mode "+a)}return o};var St=v;Pt.rgb=function(r,e,n){var t=r._rgb,a=e._rgb;return new St(t[0]+n*(a[0]-t[0]),t[1]+n*(a[1]-t[1]),t[2]+n*(a[2]-t[2]),"rgb")};var Tt=v,$t=Math.sqrt,zt=Math.pow;Pt.lrgb=function(r,e,n){var t=r._rgb,a=t[0],f=t[1],o=t[2],u=e._rgb,c=u[0],i=u[1],l=u[2];return new Tt($t(zt(a,2)*(1-n)+zt(c,2)*n),$t(zt(f,2)*(1-n)+zt(i,2)*n),$t(zt(o,2)*(1-n)+zt(l,2)*n),"rgb")};var Xt=v;Pt.lab=function(r,e,n){var t=r.lab(),a=e.lab();return new Xt(t[0]+n*(a[0]-t[0]),t[1]+n*(a[1]-t[1]),t[2]+n*(a[2]-t[2]),"lab")};var Ut=v,Vt=function(r,e,n,t){var a,f,o,u,c,i,l,h,s,d,b,p,g;return"hsl"===t?(o=r.hsl(),u=e.hsl()):"hsv"===t?(o=r.hsv(),u=e.hsv()):"hcg"===t?(o=r.hcg(),u=e.hcg()):"hsi"===t?(o=r.hsi(),u=e.hsi()):"lch"===t||"hcl"===t?(t="hcl",o=r.hcl(),u=e.hcl()):"oklch"===t&&(o=r.oklch().reverse(),u=e.oklch().reverse()),"h"!==t.substr(0,1)&&"oklch"!==t||(c=(a=o)[0],l=a[1],s=a[2],i=(f=u)[0],h=f[1],d=f[2]),isNaN(c)||isNaN(i)?isNaN(c)?isNaN(i)?p=Number.NaN:(p=i,1!=s&&0!=s||"hsv"==t||(b=h)):(p=c,1!=d&&0!=d||"hsv"==t||(b=l)):p=c+n*(i>c&&i-c>180?i-(c+360):i<c&&c-i>180?i+360-c:i-c),void 0===b&&(b=l+n*(h-l)),g=s+n*(d-s),new Ut("oklch"===t?[g,b,p]:[p,b,g],t)},Wt=Vt,Kt=function(r,e,n){return Wt(r,e,n,"lch")};Pt.lch=Kt,Pt.hcl=Kt;var Zt=v;Pt.num=function(r,e,n){var t=r.num(),a=e.num();return new Zt(t+n*(a-t),"num")};var Ht=Vt;Pt.hcg=function(r,e,n){return Ht(r,e,n,"hcg")};var Jt=Vt;Pt.hsi=function(r,e,n){return Jt(r,e,n,"hsi")};var Qt=Vt;Pt.hsl=function(r,e,n){return Qt(r,e,n,"hsl")};var ra=Vt;Pt.hsv=function(r,e,n){return ra(r,e,n,"hsv")};var ea=v;Pt.oklab=function(r,e,n){var t=r.oklab(),a=e.oklab();return new ea(t[0]+n*(a[0]-t[0]),t[1]+n*(a[1]-t[1]),t[2]+n*(a[2]-t[2]),"oklab")};var na=Vt;Pt.oklch=function(r,e,n){return na(r,e,n,"oklch")};var ta=v,aa=l.clip_rgb,fa=Math.pow,oa=Math.sqrt,ua=Math.PI,ca=Math.cos,ia=Math.sin,la=Math.atan2,ha=function(r,e){for(var n=r.length,t=[0,0,0,0],a=0;a<r.length;a++){var f=r[a],o=e[a]/n,u=f._rgb;t[0]+=fa(u[0],2)*o,t[1]+=fa(u[1],2)*o,t[2]+=fa(u[2],2)*o,t[3]+=u[3]*o}return t[0]=oa(t[0]),t[1]=oa(t[1]),t[2]=oa(t[2]),t[3]>.9999999&&(t[3]=1),new ta(aa(t))},sa=y,da=l.type,ba=Math.pow,pa=function(r){var e="rgb",n=sa("#ccc"),t=0,a=[0,1],f=[],o=[0,0],u=!1,c=[],i=!1,l=0,h=1,s=!1,d={},b=!0,p=1,g=function(r){if((r=r||["#fff","#000"])&&"string"===da(r)&&sa.brewer&&sa.brewer[r.toLowerCase()]&&(r=sa.brewer[r.toLowerCase()]),"array"===da(r)){1===r.length&&(r=[r[0],r[0]]),r=r.slice(0);for(var e=0;e<r.length;e++)r[e]=sa(r[e]);f.length=0;for(var n=0;n<r.length;n++)f.push(n/(r.length-1))}return k(),c=r},v=function(r){return r},m=function(r){return r},y=function(r,t){var a,i;if(null==t&&(t=!1),isNaN(r)||null===r)return n;if(t)i=r;else if(u&&u.length>2){var s=function(r){if(null!=u){for(var e=u.length-1,n=0;n<e&&r>=u[n];)n++;return n-1}return 0}(r);i=s/(u.length-2)}else i=h!==l?(r-l)/(h-l):1;i=m(i),t||(i=v(i)),1!==p&&(i=ba(i,p)),i=o[0]+i*(1-o[0]-o[1]),i=Math.min(1,Math.max(0,i));var g=Math.floor(1e4*i);if(b&&d[g])a=d[g];else{if("array"===da(c))for(var y=0;y<f.length;y++){var k=f[y];if(i<=k){a=c[y];break}if(i>=k&&y===f.length-1){a=c[y];break}if(i>k&&i<f[y+1]){i=(i-k)/(f[y+1]-k),a=sa.interpolate(c[y],c[y+1],i,e);break}}else"function"===da(c)&&(a=c(i));b&&(d[g]=a)}return a},k=function(){return d={}};g(r);var w=function(r){var e=sa(y(r));return i&&e[i]?e[i]():e};return w.classes=function(r){if(null!=r){if("array"===da(r))u=r,a=[r[0],r[r.length-1]];else{var e=sa.analyze(a);u=0===r?[e.min,e.max]:sa.limits(e,"e",r)}return w}return u},w.domain=function(r){if(!arguments.length)return a;l=r[0],h=r[r.length-1],f=[];var e=c.length;if(r.length===e&&l!==h)for(var n=0,t=Array.from(r);n<t.length;n+=1){var o=t[n];f.push((o-l)/(h-l))}else{for(var u=0;u<e;u++)f.push(u/(e-1));if(r.length>2){var i=r.map((function(e,n){return n/(r.length-1)})),s=r.map((function(r){return(r-l)/(h-l)}));s.every((function(r,e){return i[e]===r}))||(m=function(r){if(r<=0||r>=1)return r;for(var e=0;r>=s[e+1];)e++;var n=(r-s[e])/(s[e+1]-s[e]);return i[e]+n*(i[e+1]-i[e])})}}return a=[l,h],w},w.mode=function(r){return arguments.length?(e=r,k(),w):e},w.range=function(r,e){return g(r),w},w.out=function(r){return i=r,w},w.spread=function(r){return arguments.length?(t=r,w):t},w.correctLightness=function(r){return null==r&&(r=!0),s=r,k(),v=s?function(r){for(var e=y(0,!0).lab()[0],n=y(1,!0).lab()[0],t=e>n,a=y(r,!0).lab()[0],f=e+(n-e)*r,o=a-f,u=0,c=1,i=20;Math.abs(o)>.01&&i-- >0;)t&&(o*=-1),o<0?(u=r,r+=.5*(c-r)):(c=r,r+=.5*(u-r)),a=y(r,!0).lab()[0],o=a-f;return r}:function(r){return r},w},w.padding=function(r){return null!=r?("number"===da(r)&&(r=[r,r]),o=r,w):o},w.colors=function(e,n){arguments.length<2&&(n="hex");var t=[];if(0===arguments.length)t=c.slice(0);else if(1===e)t=[w(.5)];else if(e>1){var f=a[0],o=a[1]-f;t=ga(0,e,!1).map((function(r){return w(f+r/(e-1)*o)}))}else{r=[];var i=[];if(u&&u.length>2)for(var l=1,h=u.length,s=1<=h;s?l<h:l>h;s?l++:l--)i.push(.5*(u[l-1]+u[l]));else i=a;t=i.map((function(r){return w(r)}))}return sa[n]&&(t=t.map((function(r){return r[n]()}))),t},w.cache=function(r){return null!=r?(b=r,w):b},w.gamma=function(r){return null!=r?(p=r,w):p},w.nodata=function(r){return null!=r?(n=sa(r),w):n},w};function ga(r,e,n){for(var t=[],a=r<e,f=n?a?e+1:e-1:e,o=r;a?o<f:o>f;a?o++:o--)t.push(o);return t}var va=v,ma=pa,ya=y,ka=function(r,e,n){if(!ka[n])throw new Error("unknown blend mode "+n);return ka[n](r,e)},wa=function(r){return function(e,n){var t=ya(n).rgb(),a=ya(e).rgb();return ya.rgb(r(t,a))}},Ma=function(r){return function(e,n){var t=[];return t[0]=r(e[0],n[0]),t[1]=r(e[1],n[1]),t[2]=r(e[2],n[2]),t}};ka.normal=wa(Ma((function(r){return r}))),ka.multiply=wa(Ma((function(r,e){return r*e/255}))),ka.screen=wa(Ma((function(r,e){return 255*(1-(1-r/255)*(1-e/255))}))),ka.overlay=wa(Ma((function(r,e){return e<128?2*r*e/255:255*(1-2*(1-r/255)*(1-e/255))}))),ka.darken=wa(Ma((function(r,e){return r>e?e:r}))),ka.lighten=wa(Ma((function(r,e){return r>e?r:e}))),ka.dodge=wa(Ma((function(r,e){return 255===r||(r=e/255*255/(1-r/255))>255?255:r}))),ka.burn=wa(Ma((function(r,e){return 255*(1-(1-e/255)/(r/255))})));for(var Na=ka,_a=l.type,xa=l.clip_rgb,Aa=l.TWOPI,Ea=Math.pow,Fa=Math.sin,Pa=Math.cos,Oa=y,ja=v,Ga=Math.floor,Ra=Math.random,qa=o,La=Math.log,Ia=Math.pow,Ba=Math.floor,Ca=Math.abs,Da=function(r,e){void 0===e&&(e=null);var n={min:Number.MAX_VALUE,max:-1*Number.MAX_VALUE,sum:0,values:[],count:0};return"object"===qa(r)&&(r=Object.values(r)),r.forEach((function(r){e&&"object"===qa(r)&&(r=r[e]),null==r||isNaN(r)||(n.values.push(r),n.sum+=r,r<n.min&&(n.min=r),r>n.max&&(n.max=r),n.count+=1)})),n.domain=[n.min,n.max],n.limits=function(r,e){return Ya(n,r,e)},n},Ya=function(r,e,n){void 0===e&&(e="equal"),void 0===n&&(n=7),"array"==qa(r)&&(r=Da(r));var t=r.min,a=r.max,f=r.values.sort((function(r,e){return r-e}));if(1===n)return[t,a];var o=[];if("c"===e.substr(0,1)&&(o.push(t),o.push(a)),"e"===e.substr(0,1)){o.push(t);for(var u=1;u<n;u++)o.push(t+u/n*(a-t));o.push(a)}else if("l"===e.substr(0,1)){if(t<=0)throw new Error("Logarithmic scales are only possible for values > 0");var c=Math.LOG10E*La(t),i=Math.LOG10E*La(a);o.push(t);for(var l=1;l<n;l++)o.push(Ia(10,c+l/n*(i-c)));o.push(a)}else if("q"===e.substr(0,1)){o.push(t);for(var h=1;h<n;h++){var s=(f.length-1)*h/n,d=Ba(s);if(d===s)o.push(f[d]);else{var b=s-d;o.push(f[d]*(1-b)+f[d+1]*b)}}o.push(a)}else if("k"===e.substr(0,1)){var p,g=f.length,v=new Array(g),m=new Array(n),y=!0,k=0,w=null;(w=[]).push(t);for(var M=1;M<n;M++)w.push(t+M/n*(a-t));for(w.push(a);y;){for(var N=0;N<n;N++)m[N]=0;for(var _=0;_<g;_++)for(var x=f[_],A=Number.MAX_VALUE,E=void 0,F=0;F<n;F++){var P=Ca(w[F]-x);P<A&&(A=P,E=F),m[E]++,v[_]=E}for(var O=new Array(n),j=0;j<n;j++)O[j]=null;for(var G=0;G<g;G++)null===O[p=v[G]]?O[p]=f[G]:O[p]+=f[G];for(var R=0;R<n;R++)O[R]*=1/m[R];y=!1;for(var q=0;q<n;q++)if(O[q]!==w[q]){y=!0;break}w=O,++k>200&&(y=!1)}for(var L={},I=0;I<n;I++)L[I]=[];for(var B=0;B<g;B++)L[p=v[B]].push(f[B]);for(var C=[],D=0;D<n;D++)C.push(L[D][0]),C.push(L[D][L[D].length-1]);C=C.sort((function(r,e){return r-e})),o.push(C[0]);for(var Y=1;Y<C.length;Y+=2){var S=C[Y];isNaN(S)||-1!==o.indexOf(S)||o.push(S)}}return o},Sa={analyze:Da,limits:Ya},Ta=v,$a=v,za=Math.sqrt,Xa=Math.pow,Ua=Math.min,Va=Math.max,Wa=Math.atan2,Ka=Math.abs,Za=Math.cos,Ha=Math.sin,Ja=Math.exp,Qa=Math.PI,rf=v,ef=v,nf=y,tf=pa,af={cool:function(){return tf([nf.hsl(180,1,.9),nf.hsl(250,.7,.4)])},hot:function(){return tf(["#000","#f00","#ff0","#fff"]).mode("rgb")}},ff={OrRd:["#fff7ec","#fee8c8","#fdd49e","#fdbb84","#fc8d59","#ef6548","#d7301f","#b30000","#7f0000"],PuBu:["#fff7fb","#ece7f2","#d0d1e6","#a6bddb","#74a9cf","#3690c0","#0570b0","#045a8d","#023858"],BuPu:["#f7fcfd","#e0ecf4","#bfd3e6","#9ebcda","#8c96c6","#8c6bb1","#88419d","#810f7c","#4d004b"],Oranges:["#fff5eb","#fee6ce","#fdd0a2","#fdae6b","#fd8d3c","#f16913","#d94801","#a63603","#7f2704"],BuGn:["#f7fcfd","#e5f5f9","#ccece6","#99d8c9","#66c2a4","#41ae76","#238b45","#006d2c","#00441b"],YlOrBr:["#ffffe5","#fff7bc","#fee391","#fec44f","#fe9929","#ec7014","#cc4c02","#993404","#662506"],YlGn:["#ffffe5","#f7fcb9","#d9f0a3","#addd8e","#78c679","#41ab5d","#238443","#006837","#004529"],Reds:["#fff5f0","#fee0d2","#fcbba1","#fc9272","#fb6a4a","#ef3b2c","#cb181d","#a50f15","#67000d"],RdPu:["#fff7f3","#fde0dd","#fcc5c0","#fa9fb5","#f768a1","#dd3497","#ae017e","#7a0177","#49006a"],Greens:["#f7fcf5","#e5f5e0","#c7e9c0","#a1d99b","#74c476","#41ab5d","#238b45","#006d2c","#00441b"],YlGnBu:["#ffffd9","#edf8b1","#c7e9b4","#7fcdbb","#41b6c4","#1d91c0","#225ea8","#253494","#081d58"],Purples:["#fcfbfd","#efedf5","#dadaeb","#bcbddc","#9e9ac8","#807dba","#6a51a3","#54278f","#3f007d"],GnBu:["#f7fcf0","#e0f3db","#ccebc5","#a8ddb5","#7bccc4","#4eb3d3","#2b8cbe","#0868ac","#084081"],Greys:["#ffffff","#f0f0f0","#d9d9d9","#bdbdbd","#969696","#737373","#525252","#252525","#000000"],YlOrRd:["#ffffcc","#ffeda0","#fed976","#feb24c","#fd8d3c","#fc4e2a","#e31a1c","#bd0026","#800026"],PuRd:["#f7f4f9","#e7e1ef","#d4b9da","#c994c7","#df65b0","#e7298a","#ce1256","#980043","#67001f"],Blues:["#f7fbff","#deebf7","#c6dbef","#9ecae1","#6baed6","#4292c6","#2171b5","#08519c","#08306b"],PuBuGn:["#fff7fb","#ece2f0","#d0d1e6","#a6bddb","#67a9cf","#3690c0","#02818a","#016c59","#014636"],Viridis:["#440154","#482777","#3f4a8a","#31678e","#26838f","#1f9d8a","#6cce5a","#b6de2b","#fee825"],Spectral:["#9e0142","#d53e4f","#f46d43","#fdae61","#fee08b","#ffffbf","#e6f598","#abdda4","#66c2a5","#3288bd","#5e4fa2"],RdYlGn:["#a50026","#d73027","#f46d43","#fdae61","#fee08b","#ffffbf","#d9ef8b","#a6d96a","#66bd63","#1a9850","#006837"],RdBu:["#67001f","#b2182b","#d6604d","#f4a582","#fddbc7","#f7f7f7","#d1e5f0","#92c5de","#4393c3","#2166ac","#053061"],PiYG:["#8e0152","#c51b7d","#de77ae","#f1b6da","#fde0ef","#f7f7f7","#e6f5d0","#b8e186","#7fbc41","#4d9221","#276419"],PRGn:["#40004b","#762a83","#9970ab","#c2a5cf","#e7d4e8","#f7f7f7","#d9f0d3","#a6dba0","#5aae61","#1b7837","#00441b"],RdYlBu:["#a50026","#d73027","#f46d43","#fdae61","#fee090","#ffffbf","#e0f3f8","#abd9e9","#74add1","#4575b4","#313695"],BrBG:["#543005","#8c510a","#bf812d","#dfc27d","#f6e8c3","#f5f5f5","#c7eae5","#80cdc1","#35978f","#01665e","#003c30"],RdGy:["#67001f","#b2182b","#d6604d","#f4a582","#fddbc7","#ffffff","#e0e0e0","#bababa","#878787","#4d4d4d","#1a1a1a"],PuOr:["#7f3b08","#b35806","#e08214","#fdb863","#fee0b6","#f7f7f7","#d8daeb","#b2abd2","#8073ac","#542788","#2d004b"],Set2:["#66c2a5","#fc8d62","#8da0cb","#e78ac3","#a6d854","#ffd92f","#e5c494","#b3b3b3"],Accent:["#7fc97f","#beaed4","#fdc086","#ffff99","#386cb0","#f0027f","#bf5b17","#666666"],Set1:["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#ffff33","#a65628","#f781bf","#999999"],Set3:["#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3","#fdb462","#b3de69","#fccde5","#d9d9d9","#bc80bd","#ccebc5","#ffed6f"],Dark2:["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e","#e6ab02","#a6761d","#666666"],Paired:["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a","#ffff99","#b15928"],Pastel2:["#b3e2cd","#fdcdac","#cbd5e8","#f4cae4","#e6f5c9","#fff2ae","#f1e2cc","#cccccc"],Pastel1:["#fbb4ae","#b3cde3","#ccebc5","#decbe4","#fed9a6","#ffffcc","#e5d8bd","#fddaec","#f2f2f2"]},of=0,uf=Object.keys(ff);of<uf.length;of+=1){var cf=uf[of];ff[cf.toLowerCase()]=ff[cf]}var lf=ff,hf=y;return hf.average=function(r,e,n){void 0===e&&(e="lrgb"),void 0===n&&(n=null);var t=r.length;n||(n=Array.from(new Array(t)).map((function(){return 1})));var a=t/n.reduce((function(r,e){return r+e}));if(n.forEach((function(r,e){n[e]*=a})),r=r.map((function(r){return new ta(r)})),"lrgb"===e)return ha(r,n);for(var f=r.shift(),o=f.get(e),u=[],c=0,i=0,l=0;l<o.length;l++)if(o[l]=(o[l]||0)*n[0],u.push(isNaN(o[l])?0:n[0]),"h"===e.charAt(l)&&!isNaN(o[l])){var h=o[l]/180*ua;c+=ca(h)*n[0],i+=ia(h)*n[0]}var s=f.alpha()*n[0];r.forEach((function(r,t){var a=r.get(e);s+=r.alpha()*n[t+1];for(var f=0;f<o.length;f++)if(!isNaN(a[f]))if(u[f]+=n[t+1],"h"===e.charAt(f)){var l=a[f]/180*ua;c+=ca(l)*n[t+1],i+=ia(l)*n[t+1]}else o[f]+=a[f]*n[t+1]}));for(var d=0;d<o.length;d++)if("h"===e.charAt(d)){for(var b=la(i/u[d],c/u[d])/ua*180;b<0;)b+=360;for(;b>=360;)b-=360;o[d]=b}else o[d]=o[d]/u[d];return s/=t,new ta(o,e).alpha(s>.99999?1:s,!0)},hf.bezier=function(r){var e=function(r){var e,n,t,a,f,o,u;if(2===(r=r.map((function(r){return new va(r)}))).length)e=r.map((function(r){return r.lab()})),f=e[0],o=e[1],a=function(r){var e=[0,1,2].map((function(e){return f[e]+r*(o[e]-f[e])}));return new va(e,"lab")};else if(3===r.length)n=r.map((function(r){return r.lab()})),f=n[0],o=n[1],u=n[2],a=function(r){var e=[0,1,2].map((function(e){return(1-r)*(1-r)*f[e]+2*(1-r)*r*o[e]+r*r*u[e]}));return new va(e,"lab")};else if(4===r.length){var c;t=r.map((function(r){return r.lab()})),f=t[0],o=t[1],u=t[2],c=t[3],a=function(r){var e=[0,1,2].map((function(e){return(1-r)*(1-r)*(1-r)*f[e]+3*(1-r)*(1-r)*r*o[e]+3*(1-r)*r*r*u[e]+r*r*r*c[e]}));return new va(e,"lab")}}else{if(!(r.length>=5))throw new RangeError("No point in running bezier with only one color.");var i,l,h;i=r.map((function(r){return r.lab()})),h=r.length-1,l=function(r){for(var e=[1,1],n=1;n<r;n++){for(var t=[1],a=1;a<=e.length;a++)t[a]=(e[a]||0)+e[a-1];e=t}return e}(h),a=function(r){var e=1-r,n=[0,1,2].map((function(n){return i.reduce((function(t,a,f){return t+l[f]*Math.pow(e,h-f)*Math.pow(r,f)*a[n]}),0)}));return new va(n,"lab")}}return a}(r);return e.scale=function(){return ma(e)},e},hf.blend=Na,hf.cubehelix=function(r,e,n,t,a){void 0===r&&(r=300),void 0===e&&(e=-1.5),void 0===n&&(n=1),void 0===t&&(t=1),void 0===a&&(a=[0,1]);var f,o=0;"array"===_a(a)?f=a[1]-a[0]:(f=0,a=[a,a]);var u=function(u){var c=Aa*((r+120)/360+e*u),i=Ea(a[0]+f*u,t),l=(0!==o?n[0]+u*o:n)*i*(1-i)/2,h=Pa(c),s=Fa(c);return Oa(xa([255*(i+l*(-.14861*h+1.78277*s)),255*(i+l*(-.29227*h-.90649*s)),255*(i+l*(1.97294*h)),1]))};return u.start=function(e){return null==e?r:(r=e,u)},u.rotations=function(r){return null==r?e:(e=r,u)},u.gamma=function(r){return null==r?t:(t=r,u)},u.hue=function(r){return null==r?n:("array"===_a(n=r)?0===(o=n[1]-n[0])&&(n=n[1]):o=0,u)},u.lightness=function(r){return null==r?a:("array"===_a(r)?(a=r,f=r[1]-r[0]):(a=[r,r],f=0),u)},u.scale=function(){return Oa.scale(u)},u.hue(n),u},hf.mix=hf.interpolate=Rt,hf.random=function(){for(var r="#",e=0;e<6;e++)r+="0123456789abcdef".charAt(Ga(16*Ra()));return new ja(r,"hex")},hf.scale=pa,hf.analyze=Sa.analyze,hf.contrast=function(r,e){r=new Ta(r),e=new Ta(e);var n=r.luminance(),t=e.luminance();return n>t?(n+.05)/(t+.05):(t+.05)/(n+.05)},hf.deltaE=function(r,e,n,t,a){void 0===n&&(n=1),void 0===t&&(t=1),void 0===a&&(a=1);var f=function(r){return 360*r/(2*Qa)},o=function(r){return 2*Qa*r/360};r=new $a(r),e=new $a(e);var u=Array.from(r.lab()),c=u[0],i=u[1],l=u[2],h=Array.from(e.lab()),s=h[0],d=h[1],b=h[2],p=(c+s)/2,g=(za(Xa(i,2)+Xa(l,2))+za(Xa(d,2)+Xa(b,2)))/2,v=.5*(1-za(Xa(g,7)/(Xa(g,7)+Xa(25,7)))),m=i*(1+v),y=d*(1+v),k=za(Xa(m,2)+Xa(l,2)),w=za(Xa(y,2)+Xa(b,2)),M=(k+w)/2,N=f(Wa(l,m)),_=f(Wa(b,y)),x=N>=0?N:N+360,A=_>=0?_:_+360,E=Ka(x-A)>180?(x+A+360)/2:(x+A)/2,F=1-.17*Za(o(E-30))+.24*Za(o(2*E))+.32*Za(o(3*E+6))-.2*Za(o(4*E-63)),P=A-x;P=Ka(P)<=180?P:A<=x?P+360:P-360,P=2*za(k*w)*Ha(o(P)/2);var O=s-c,j=w-k,G=1+.015*Xa(p-50,2)/za(20+Xa(p-50,2)),R=1+.045*M,q=1+.015*M*F,L=30*Ja(-Xa((E-275)/25,2)),I=-(2*za(Xa(M,7)/(Xa(M,7)+Xa(25,7))))*Ha(2*o(L)),B=za(Xa(O/(n*G),2)+Xa(j/(t*R),2)+Xa(P/(a*q),2)+I*(j/(t*R))*(P/(a*q)));return Va(0,Ua(100,B))},hf.distance=function(r,e,n){void 0===n&&(n="lab"),r=new rf(r),e=new rf(e);var t=r.get(n),a=e.get(n),f=0;for(var o in t){var u=(t[o]||0)-(a[o]||0);f+=u*u}return Math.sqrt(f)},hf.limits=Sa.limits,hf.valid=function(){for(var r=[],e=arguments.length;e--;)r[e]=arguments[e];try{return new(Function.prototype.bind.apply(ef,[null].concat(r))),!0}catch(r){return!1}},hf.scales=af,hf.colors=sn,hf.brewer=lf,hf}));
;
/*
 AngularJS v1.4.7
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(Q,X,w){'use strict';function I(b){return function(){var a=arguments[0],c;c="["+(b?b+":":"")+a+"] http://errors.angularjs.org/1.4.7/"+(b?b+"/":"")+a;for(a=1;a<arguments.length;a++){c=c+(1==a?"?":"&")+"p"+(a-1)+"=";var d=encodeURIComponent,e;e=arguments[a];e="function"==typeof e?e.toString().replace(/ \{[\s\S]*$/,""):"undefined"==typeof e?"undefined":"string"!=typeof e?JSON.stringify(e):e;c+=d(e)}return Error(c)}}function Da(b){if(null==b||Za(b))return!1;var a="length"in Object(b)&&b.length;
return b.nodeType===pa&&a?!0:G(b)||J(b)||0===a||"number"===typeof a&&0<a&&a-1 in b}function m(b,a,c){var d,e;if(b)if(x(b))for(d in b)"prototype"==d||"length"==d||"name"==d||b.hasOwnProperty&&!b.hasOwnProperty(d)||a.call(c,b[d],d,b);else if(J(b)||Da(b)){var f="object"!==typeof b;d=0;for(e=b.length;d<e;d++)(f||d in b)&&a.call(c,b[d],d,b)}else if(b.forEach&&b.forEach!==m)b.forEach(a,c,b);else if(mc(b))for(d in b)a.call(c,b[d],d,b);else if("function"===typeof b.hasOwnProperty)for(d in b)b.hasOwnProperty(d)&&
a.call(c,b[d],d,b);else for(d in b)ta.call(b,d)&&a.call(c,b[d],d,b);return b}function nc(b,a,c){for(var d=Object.keys(b).sort(),e=0;e<d.length;e++)a.call(c,b[d[e]],d[e]);return d}function oc(b){return function(a,c){b(c,a)}}function Ud(){return++nb}function pc(b,a){a?b.$$hashKey=a:delete b.$$hashKey}function Mb(b,a,c){for(var d=b.$$hashKey,e=0,f=a.length;e<f;++e){var h=a[e];if(C(h)||x(h))for(var g=Object.keys(h),l=0,k=g.length;l<k;l++){var n=g[l],p=h[n];c&&C(p)?ea(p)?b[n]=new Date(p.valueOf()):Oa(p)?
b[n]=new RegExp(p):(C(b[n])||(b[n]=J(p)?[]:{}),Mb(b[n],[p],!0)):b[n]=p}}pc(b,d);return b}function P(b){return Mb(b,ua.call(arguments,1),!1)}function Vd(b){return Mb(b,ua.call(arguments,1),!0)}function Y(b){return parseInt(b,10)}function Nb(b,a){return P(Object.create(b),a)}function y(){}function $a(b){return b}function qa(b){return function(){return b}}function qc(b){return x(b.toString)&&b.toString!==Object.prototype.toString}function v(b){return"undefined"===typeof b}function A(b){return"undefined"!==
typeof b}function C(b){return null!==b&&"object"===typeof b}function mc(b){return null!==b&&"object"===typeof b&&!rc(b)}function G(b){return"string"===typeof b}function V(b){return"number"===typeof b}function ea(b){return"[object Date]"===va.call(b)}function x(b){return"function"===typeof b}function Oa(b){return"[object RegExp]"===va.call(b)}function Za(b){return b&&b.window===b}function ab(b){return b&&b.$evalAsync&&b.$watch}function bb(b){return"boolean"===typeof b}function sc(b){return!(!b||!(b.nodeName||
b.prop&&b.attr&&b.find))}function Wd(b){var a={};b=b.split(",");var c;for(c=0;c<b.length;c++)a[b[c]]=!0;return a}function wa(b){return F(b.nodeName||b[0]&&b[0].nodeName)}function cb(b,a){var c=b.indexOf(a);0<=c&&b.splice(c,1);return c}function ha(b,a,c,d){if(Za(b)||ab(b))throw Ea("cpws");if(tc.test(va.call(a)))throw Ea("cpta");if(a){if(b===a)throw Ea("cpi");c=c||[];d=d||[];C(b)&&(c.push(b),d.push(a));var e;if(J(b))for(e=a.length=0;e<b.length;e++)a.push(ha(b[e],null,c,d));else{var f=a.$$hashKey;J(a)?
a.length=0:m(a,function(b,c){delete a[c]});if(mc(b))for(e in b)a[e]=ha(b[e],null,c,d);else if(b&&"function"===typeof b.hasOwnProperty)for(e in b)b.hasOwnProperty(e)&&(a[e]=ha(b[e],null,c,d));else for(e in b)ta.call(b,e)&&(a[e]=ha(b[e],null,c,d));pc(a,f)}}else if(a=b,C(b)){if(c&&-1!==(f=c.indexOf(b)))return d[f];if(J(b))return ha(b,[],c,d);if(tc.test(va.call(b)))a=new b.constructor(b);else if(ea(b))a=new Date(b.getTime());else if(Oa(b))a=new RegExp(b.source,b.toString().match(/[^\/]*$/)[0]),a.lastIndex=
b.lastIndex;else if(x(b.cloneNode))a=b.cloneNode(!0);else return e=Object.create(rc(b)),ha(b,e,c,d);d&&(c.push(b),d.push(a))}return a}function ja(b,a){if(J(b)){a=a||[];for(var c=0,d=b.length;c<d;c++)a[c]=b[c]}else if(C(b))for(c in a=a||{},b)if("$"!==c.charAt(0)||"$"!==c.charAt(1))a[c]=b[c];return a||b}function ka(b,a){if(b===a)return!0;if(null===b||null===a)return!1;if(b!==b&&a!==a)return!0;var c=typeof b,d;if(c==typeof a&&"object"==c)if(J(b)){if(!J(a))return!1;if((c=b.length)==a.length){for(d=0;d<
c;d++)if(!ka(b[d],a[d]))return!1;return!0}}else{if(ea(b))return ea(a)?ka(b.getTime(),a.getTime()):!1;if(Oa(b))return Oa(a)?b.toString()==a.toString():!1;if(ab(b)||ab(a)||Za(b)||Za(a)||J(a)||ea(a)||Oa(a))return!1;c=fa();for(d in b)if("$"!==d.charAt(0)&&!x(b[d])){if(!ka(b[d],a[d]))return!1;c[d]=!0}for(d in a)if(!(d in c)&&"$"!==d.charAt(0)&&A(a[d])&&!x(a[d]))return!1;return!0}return!1}function db(b,a,c){return b.concat(ua.call(a,c))}function uc(b,a){var c=2<arguments.length?ua.call(arguments,2):[];
return!x(a)||a instanceof RegExp?a:c.length?function(){return arguments.length?a.apply(b,db(c,arguments,0)):a.apply(b,c)}:function(){return arguments.length?a.apply(b,arguments):a.call(b)}}function Xd(b,a){var c=a;"string"===typeof b&&"$"===b.charAt(0)&&"$"===b.charAt(1)?c=w:Za(a)?c="$WINDOW":a&&X===a?c="$DOCUMENT":ab(a)&&(c="$SCOPE");return c}function eb(b,a){if("undefined"===typeof b)return w;V(a)||(a=a?2:null);return JSON.stringify(b,Xd,a)}function vc(b){return G(b)?JSON.parse(b):b}function wc(b,
a){var c=Date.parse("Jan 01, 1970 00:00:00 "+b)/6E4;return isNaN(c)?a:c}function Ob(b,a,c){c=c?-1:1;var d=wc(a,b.getTimezoneOffset());a=b;b=c*(d-b.getTimezoneOffset());a=new Date(a.getTime());a.setMinutes(a.getMinutes()+b);return a}function xa(b){b=B(b).clone();try{b.empty()}catch(a){}var c=B("<div>").append(b).html();try{return b[0].nodeType===Pa?F(c):c.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/,function(a,b){return"<"+F(b)})}catch(d){return F(c)}}function xc(b){try{return decodeURIComponent(b)}catch(a){}}
function yc(b){var a={};m((b||"").split("&"),function(b){var d,e,f;b&&(e=b=b.replace(/\+/g,"%20"),d=b.indexOf("="),-1!==d&&(e=b.substring(0,d),f=b.substring(d+1)),e=xc(e),A(e)&&(f=A(f)?xc(f):!0,ta.call(a,e)?J(a[e])?a[e].push(f):a[e]=[a[e],f]:a[e]=f))});return a}function Pb(b){var a=[];m(b,function(b,d){J(b)?m(b,function(b){a.push(la(d,!0)+(!0===b?"":"="+la(b,!0)))}):a.push(la(d,!0)+(!0===b?"":"="+la(b,!0)))});return a.length?a.join("&"):""}function ob(b){return la(b,!0).replace(/%26/gi,"&").replace(/%3D/gi,
"=").replace(/%2B/gi,"+")}function la(b,a){return encodeURIComponent(b).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%3B/gi,";").replace(/%20/g,a?"%20":"+")}function Yd(b,a){var c,d,e=Qa.length;for(d=0;d<e;++d)if(c=Qa[d]+a,G(c=b.getAttribute(c)))return c;return null}function Zd(b,a){var c,d,e={};m(Qa,function(a){a+="app";!c&&b.hasAttribute&&b.hasAttribute(a)&&(c=b,d=b.getAttribute(a))});m(Qa,function(a){a+="app";var e;!c&&(e=b.querySelector("["+a.replace(":",
"\\:")+"]"))&&(c=e,d=e.getAttribute(a))});c&&(e.strictDi=null!==Yd(c,"strict-di"),a(c,d?[d]:[],e))}function zc(b,a,c){C(c)||(c={});c=P({strictDi:!1},c);var d=function(){b=B(b);if(b.injector()){var d=b[0]===X?"document":xa(b);throw Ea("btstrpd",d.replace(/</,"&lt;").replace(/>/,"&gt;"));}a=a||[];a.unshift(["$provide",function(a){a.value("$rootElement",b)}]);c.debugInfoEnabled&&a.push(["$compileProvider",function(a){a.debugInfoEnabled(!0)}]);a.unshift("ng");d=fb(a,c.strictDi);d.invoke(["$rootScope",
"$rootElement","$compile","$injector",function(a,b,c,d){a.$apply(function(){b.data("$injector",d);c(b)(a)})}]);return d},e=/^NG_ENABLE_DEBUG_INFO!/,f=/^NG_DEFER_BOOTSTRAP!/;Q&&e.test(Q.name)&&(c.debugInfoEnabled=!0,Q.name=Q.name.replace(e,""));if(Q&&!f.test(Q.name))return d();Q.name=Q.name.replace(f,"");da.resumeBootstrap=function(b){m(b,function(b){a.push(b)});return d()};x(da.resumeDeferredBootstrap)&&da.resumeDeferredBootstrap()}function $d(){Q.name="NG_ENABLE_DEBUG_INFO!"+Q.name;Q.location.reload()}
function ae(b){b=da.element(b).injector();if(!b)throw Ea("test");return b.get("$$testability")}function Ac(b,a){a=a||"_";return b.replace(be,function(b,d){return(d?a:"")+b.toLowerCase()})}function ce(){var b;if(!Bc){var a=pb();(ra=v(a)?Q.jQuery:a?Q[a]:w)&&ra.fn.on?(B=ra,P(ra.fn,{scope:Ra.scope,isolateScope:Ra.isolateScope,controller:Ra.controller,injector:Ra.injector,inheritedData:Ra.inheritedData}),b=ra.cleanData,ra.cleanData=function(a){var d;if(Qb)Qb=!1;else for(var e=0,f;null!=(f=a[e]);e++)(d=
ra._data(f,"events"))&&d.$destroy&&ra(f).triggerHandler("$destroy");b(a)}):B=R;da.element=B;Bc=!0}}function qb(b,a,c){if(!b)throw Ea("areq",a||"?",c||"required");return b}function Sa(b,a,c){c&&J(b)&&(b=b[b.length-1]);qb(x(b),a,"not a function, got "+(b&&"object"===typeof b?b.constructor.name||"Object":typeof b));return b}function Ta(b,a){if("hasOwnProperty"===b)throw Ea("badname",a);}function Cc(b,a,c){if(!a)return b;a=a.split(".");for(var d,e=b,f=a.length,h=0;h<f;h++)d=a[h],b&&(b=(e=b)[d]);return!c&&
x(b)?uc(e,b):b}function rb(b){for(var a=b[0],c=b[b.length-1],d,e=1;a!==c&&(a=a.nextSibling);e++)if(d||b[e]!==a)d||(d=B(ua.call(b,0,e))),d.push(a);return d||b}function fa(){return Object.create(null)}function de(b){function a(a,b,c){return a[b]||(a[b]=c())}var c=I("$injector"),d=I("ng");b=a(b,"angular",Object);b.$$minErr=b.$$minErr||I;return a(b,"module",function(){var b={};return function(f,h,g){if("hasOwnProperty"===f)throw d("badname","module");h&&b.hasOwnProperty(f)&&(b[f]=null);return a(b,f,function(){function a(b,
c,e,f){f||(f=d);return function(){f[e||"push"]([b,c,arguments]);return E}}function b(a,c){return function(b,e){e&&x(e)&&(e.$$moduleName=f);d.push([a,c,arguments]);return E}}if(!h)throw c("nomod",f);var d=[],e=[],r=[],t=a("$injector","invoke","push",e),E={_invokeQueue:d,_configBlocks:e,_runBlocks:r,requires:h,name:f,provider:b("$provide","provider"),factory:b("$provide","factory"),service:b("$provide","service"),value:a("$provide","value"),constant:a("$provide","constant","unshift"),decorator:b("$provide",
"decorator"),animation:b("$animateProvider","register"),filter:b("$filterProvider","register"),controller:b("$controllerProvider","register"),directive:b("$compileProvider","directive"),config:t,run:function(a){r.push(a);return this}};g&&t(g);return E})}})}function ee(b){P(b,{bootstrap:zc,copy:ha,extend:P,merge:Vd,equals:ka,element:B,forEach:m,injector:fb,noop:y,bind:uc,toJson:eb,fromJson:vc,identity:$a,isUndefined:v,isDefined:A,isString:G,isFunction:x,isObject:C,isNumber:V,isElement:sc,isArray:J,
version:fe,isDate:ea,lowercase:F,uppercase:sb,callbacks:{counter:0},getTestability:ae,$$minErr:I,$$csp:Fa,reloadWithDebugInfo:$d});Rb=de(Q);Rb("ng",["ngLocale"],["$provide",function(a){a.provider({$$sanitizeUri:ge});a.provider("$compile",Dc).directive({a:he,input:Ec,textarea:Ec,form:ie,script:je,select:ke,style:le,option:me,ngBind:ne,ngBindHtml:oe,ngBindTemplate:pe,ngClass:qe,ngClassEven:re,ngClassOdd:se,ngCloak:te,ngController:ue,ngForm:ve,ngHide:we,ngIf:xe,ngInclude:ye,ngInit:ze,ngNonBindable:Ae,
ngPluralize:Be,ngRepeat:Ce,ngShow:De,ngStyle:Ee,ngSwitch:Fe,ngSwitchWhen:Ge,ngSwitchDefault:He,ngOptions:Ie,ngTransclude:Je,ngModel:Ke,ngList:Le,ngChange:Me,pattern:Fc,ngPattern:Fc,required:Gc,ngRequired:Gc,minlength:Hc,ngMinlength:Hc,maxlength:Ic,ngMaxlength:Ic,ngValue:Ne,ngModelOptions:Oe}).directive({ngInclude:Pe}).directive(tb).directive(Jc);a.provider({$anchorScroll:Qe,$animate:Re,$animateCss:Se,$$animateQueue:Te,$$AnimateRunner:Ue,$browser:Ve,$cacheFactory:We,$controller:Xe,$document:Ye,$exceptionHandler:Ze,
$filter:Kc,$$forceReflow:$e,$interpolate:af,$interval:bf,$http:cf,$httpParamSerializer:df,$httpParamSerializerJQLike:ef,$httpBackend:ff,$xhrFactory:gf,$location:hf,$log:jf,$parse:kf,$rootScope:lf,$q:mf,$$q:nf,$sce:of,$sceDelegate:pf,$sniffer:qf,$templateCache:rf,$templateRequest:sf,$$testability:tf,$timeout:uf,$window:vf,$$rAF:wf,$$jqLite:xf,$$HashMap:yf,$$cookieReader:zf})}])}function gb(b){return b.replace(Af,function(a,b,d,e){return e?d.toUpperCase():d}).replace(Bf,"Moz$1")}function Lc(b){b=b.nodeType;
return b===pa||!b||9===b}function Mc(b,a){var c,d,e=a.createDocumentFragment(),f=[];if(Sb.test(b)){c=c||e.appendChild(a.createElement("div"));d=(Cf.exec(b)||["",""])[1].toLowerCase();d=ma[d]||ma._default;c.innerHTML=d[1]+b.replace(Df,"<$1></$2>")+d[2];for(d=d[0];d--;)c=c.lastChild;f=db(f,c.childNodes);c=e.firstChild;c.textContent=""}else f.push(a.createTextNode(b));e.textContent="";e.innerHTML="";m(f,function(a){e.appendChild(a)});return e}function R(b){if(b instanceof R)return b;var a;G(b)&&(b=T(b),
a=!0);if(!(this instanceof R)){if(a&&"<"!=b.charAt(0))throw Tb("nosel");return new R(b)}if(a){a=X;var c;b=(c=Ef.exec(b))?[a.createElement(c[1])]:(c=Mc(b,a))?c.childNodes:[]}Nc(this,b)}function Ub(b){return b.cloneNode(!0)}function ub(b,a){a||vb(b);if(b.querySelectorAll)for(var c=b.querySelectorAll("*"),d=0,e=c.length;d<e;d++)vb(c[d])}function Oc(b,a,c,d){if(A(d))throw Tb("offargs");var e=(d=wb(b))&&d.events,f=d&&d.handle;if(f)if(a)m(a.split(" "),function(a){if(A(c)){var d=e[a];cb(d||[],c);if(d&&0<
d.length)return}b.removeEventListener(a,f,!1);delete e[a]});else for(a in e)"$destroy"!==a&&b.removeEventListener(a,f,!1),delete e[a]}function vb(b,a){var c=b.ng339,d=c&&hb[c];d&&(a?delete d.data[a]:(d.handle&&(d.events.$destroy&&d.handle({},"$destroy"),Oc(b)),delete hb[c],b.ng339=w))}function wb(b,a){var c=b.ng339,c=c&&hb[c];a&&!c&&(b.ng339=c=++Ff,c=hb[c]={events:{},data:{},handle:w});return c}function Vb(b,a,c){if(Lc(b)){var d=A(c),e=!d&&a&&!C(a),f=!a;b=(b=wb(b,!e))&&b.data;if(d)b[a]=c;else{if(f)return b;
if(e)return b&&b[a];P(b,a)}}}function xb(b,a){return b.getAttribute?-1<(" "+(b.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ").indexOf(" "+a+" "):!1}function yb(b,a){a&&b.setAttribute&&m(a.split(" "),function(a){b.setAttribute("class",T((" "+(b.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ").replace(" "+T(a)+" "," ")))})}function zb(b,a){if(a&&b.setAttribute){var c=(" "+(b.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ");m(a.split(" "),function(a){a=T(a);-1===c.indexOf(" "+a+" ")&&
(c+=a+" ")});b.setAttribute("class",T(c))}}function Nc(b,a){if(a)if(a.nodeType)b[b.length++]=a;else{var c=a.length;if("number"===typeof c&&a.window!==a){if(c)for(var d=0;d<c;d++)b[b.length++]=a[d]}else b[b.length++]=a}}function Pc(b,a){return Ab(b,"$"+(a||"ngController")+"Controller")}function Ab(b,a,c){9==b.nodeType&&(b=b.documentElement);for(a=J(a)?a:[a];b;){for(var d=0,e=a.length;d<e;d++)if(A(c=B.data(b,a[d])))return c;b=b.parentNode||11===b.nodeType&&b.host}}function Qc(b){for(ub(b,!0);b.firstChild;)b.removeChild(b.firstChild)}
function Wb(b,a){a||ub(b);var c=b.parentNode;c&&c.removeChild(b)}function Gf(b,a){a=a||Q;if("complete"===a.document.readyState)a.setTimeout(b);else B(a).on("load",b)}function Rc(b,a){var c=Bb[a.toLowerCase()];return c&&Sc[wa(b)]&&c}function Hf(b,a){var c=function(c,e){c.isDefaultPrevented=function(){return c.defaultPrevented};var f=a[e||c.type],h=f?f.length:0;if(h){if(v(c.immediatePropagationStopped)){var g=c.stopImmediatePropagation;c.stopImmediatePropagation=function(){c.immediatePropagationStopped=
!0;c.stopPropagation&&c.stopPropagation();g&&g.call(c)}}c.isImmediatePropagationStopped=function(){return!0===c.immediatePropagationStopped};1<h&&(f=ja(f));for(var l=0;l<h;l++)c.isImmediatePropagationStopped()||f[l].call(b,c)}};c.elem=b;return c}function xf(){this.$get=function(){return P(R,{hasClass:function(b,a){b.attr&&(b=b[0]);return xb(b,a)},addClass:function(b,a){b.attr&&(b=b[0]);return zb(b,a)},removeClass:function(b,a){b.attr&&(b=b[0]);return yb(b,a)}})}}function Ga(b,a){var c=b&&b.$$hashKey;
if(c)return"function"===typeof c&&(c=b.$$hashKey()),c;c=typeof b;return c="function"==c||"object"==c&&null!==b?b.$$hashKey=c+":"+(a||Ud)():c+":"+b}function Ua(b,a){if(a){var c=0;this.nextUid=function(){return++c}}m(b,this.put,this)}function If(b){return(b=b.toString().replace(Tc,"").match(Uc))?"function("+(b[1]||"").replace(/[\s\r\n]+/," ")+")":"fn"}function fb(b,a){function c(a){return function(b,c){if(C(b))m(b,oc(a));else return a(b,c)}}function d(a,b){Ta(a,"service");if(x(b)||J(b))b=r.instantiate(b);
if(!b.$get)throw Ha("pget",a);return p[a+"Provider"]=b}function e(a,b){return function(){var c=E.invoke(b,this);if(v(c))throw Ha("undef",a);return c}}function f(a,b,c){return d(a,{$get:!1!==c?e(a,b):b})}function h(a){qb(v(a)||J(a),"modulesToLoad","not an array");var b=[],c;m(a,function(a){function d(a){var b,c;b=0;for(c=a.length;b<c;b++){var e=a[b],f=r.get(e[0]);f[e[1]].apply(f,e[2])}}if(!n.get(a)){n.put(a,!0);try{G(a)?(c=Rb(a),b=b.concat(h(c.requires)).concat(c._runBlocks),d(c._invokeQueue),d(c._configBlocks)):
x(a)?b.push(r.invoke(a)):J(a)?b.push(r.invoke(a)):Sa(a,"module")}catch(e){throw J(a)&&(a=a[a.length-1]),e.message&&e.stack&&-1==e.stack.indexOf(e.message)&&(e=e.message+"\n"+e.stack),Ha("modulerr",a,e.stack||e.message||e);}}});return b}function g(b,c){function d(a,e){if(b.hasOwnProperty(a)){if(b[a]===l)throw Ha("cdep",a+" <- "+k.join(" <- "));return b[a]}try{return k.unshift(a),b[a]=l,b[a]=c(a,e)}catch(f){throw b[a]===l&&delete b[a],f;}finally{k.shift()}}function e(b,c,f,g){"string"===typeof f&&(g=
f,f=null);var h=[],k=fb.$$annotate(b,a,g),l,r,p;r=0;for(l=k.length;r<l;r++){p=k[r];if("string"!==typeof p)throw Ha("itkn",p);h.push(f&&f.hasOwnProperty(p)?f[p]:d(p,g))}J(b)&&(b=b[l]);return b.apply(c,h)}return{invoke:e,instantiate:function(a,b,c){var d=Object.create((J(a)?a[a.length-1]:a).prototype||null);a=e(a,d,b,c);return C(a)||x(a)?a:d},get:d,annotate:fb.$$annotate,has:function(a){return p.hasOwnProperty(a+"Provider")||b.hasOwnProperty(a)}}}a=!0===a;var l={},k=[],n=new Ua([],!0),p={$provide:{provider:c(d),
factory:c(f),service:c(function(a,b){return f(a,["$injector",function(a){return a.instantiate(b)}])}),value:c(function(a,b){return f(a,qa(b),!1)}),constant:c(function(a,b){Ta(a,"constant");p[a]=b;t[a]=b}),decorator:function(a,b){var c=r.get(a+"Provider"),d=c.$get;c.$get=function(){var a=E.invoke(d,c);return E.invoke(b,null,{$delegate:a})}}}},r=p.$injector=g(p,function(a,b){da.isString(b)&&k.push(b);throw Ha("unpr",k.join(" <- "));}),t={},E=t.$injector=g(t,function(a,b){var c=r.get(a+"Provider",b);
return E.invoke(c.$get,c,w,a)});m(h(b),function(a){a&&E.invoke(a)});return E}function Qe(){var b=!0;this.disableAutoScrolling=function(){b=!1};this.$get=["$window","$location","$rootScope",function(a,c,d){function e(a){var b=null;Array.prototype.some.call(a,function(a){if("a"===wa(a))return b=a,!0});return b}function f(b){if(b){b.scrollIntoView();var c;c=h.yOffset;x(c)?c=c():sc(c)?(c=c[0],c="fixed"!==a.getComputedStyle(c).position?0:c.getBoundingClientRect().bottom):V(c)||(c=0);c&&(b=b.getBoundingClientRect().top,
a.scrollBy(0,b-c))}else a.scrollTo(0,0)}function h(a){a=G(a)?a:c.hash();var b;a?(b=g.getElementById(a))?f(b):(b=e(g.getElementsByName(a)))?f(b):"top"===a&&f(null):f(null)}var g=a.document;b&&d.$watch(function(){return c.hash()},function(a,b){a===b&&""===a||Gf(function(){d.$evalAsync(h)})});return h}]}function ib(b,a){if(!b&&!a)return"";if(!b)return a;if(!a)return b;J(b)&&(b=b.join(" "));J(a)&&(a=a.join(" "));return b+" "+a}function Jf(b){G(b)&&(b=b.split(" "));var a=fa();m(b,function(b){b.length&&
(a[b]=!0)});return a}function Ia(b){return C(b)?b:{}}function Kf(b,a,c,d){function e(a){try{a.apply(null,ua.call(arguments,1))}finally{if(E--,0===E)for(;K.length;)try{K.pop()()}catch(b){c.error(b)}}}function f(){ia=null;h();g()}function h(){a:{try{u=n.state;break a}catch(a){}u=void 0}u=v(u)?null:u;ka(u,L)&&(u=L);L=u}function g(){if(z!==l.url()||q!==u)z=l.url(),q=u,m(O,function(a){a(l.url(),u)})}var l=this,k=b.location,n=b.history,p=b.setTimeout,r=b.clearTimeout,t={};l.isMock=!1;var E=0,K=[];l.$$completeOutstandingRequest=
e;l.$$incOutstandingRequestCount=function(){E++};l.notifyWhenNoOutstandingRequests=function(a){0===E?a():K.push(a)};var u,q,z=k.href,N=a.find("base"),ia=null;h();q=u;l.url=function(a,c,e){v(e)&&(e=null);k!==b.location&&(k=b.location);n!==b.history&&(n=b.history);if(a){var f=q===e;if(z===a&&(!d.history||f))return l;var g=z&&Ja(z)===Ja(a);z=a;q=e;if(!d.history||g&&f){if(!g||ia)ia=a;c?k.replace(a):g?(c=k,e=a.indexOf("#"),e=-1===e?"":a.substr(e),c.hash=e):k.href=a;k.href!==a&&(ia=a)}else n[c?"replaceState":
"pushState"](e,"",a),h(),q=u;return l}return ia||k.href.replace(/%27/g,"'")};l.state=function(){return u};var O=[],H=!1,L=null;l.onUrlChange=function(a){if(!H){if(d.history)B(b).on("popstate",f);B(b).on("hashchange",f);H=!0}O.push(a);return a};l.$$applicationDestroyed=function(){B(b).off("hashchange popstate",f)};l.$$checkUrlChange=g;l.baseHref=function(){var a=N.attr("href");return a?a.replace(/^(https?\:)?\/\/[^\/]*/,""):""};l.defer=function(a,b){var c;E++;c=p(function(){delete t[c];e(a)},b||0);
t[c]=!0;return c};l.defer.cancel=function(a){return t[a]?(delete t[a],r(a),e(y),!0):!1}}function Ve(){this.$get=["$window","$log","$sniffer","$document",function(b,a,c,d){return new Kf(b,d,a,c)}]}function We(){this.$get=function(){function b(b,d){function e(a){a!=p&&(r?r==a&&(r=a.n):r=a,f(a.n,a.p),f(a,p),p=a,p.n=null)}function f(a,b){a!=b&&(a&&(a.p=b),b&&(b.n=a))}if(b in a)throw I("$cacheFactory")("iid",b);var h=0,g=P({},d,{id:b}),l={},k=d&&d.capacity||Number.MAX_VALUE,n={},p=null,r=null;return a[b]=
{put:function(a,b){if(!v(b)){if(k<Number.MAX_VALUE){var c=n[a]||(n[a]={key:a});e(c)}a in l||h++;l[a]=b;h>k&&this.remove(r.key);return b}},get:function(a){if(k<Number.MAX_VALUE){var b=n[a];if(!b)return;e(b)}return l[a]},remove:function(a){if(k<Number.MAX_VALUE){var b=n[a];if(!b)return;b==p&&(p=b.p);b==r&&(r=b.n);f(b.n,b.p);delete n[a]}delete l[a];h--},removeAll:function(){l={};h=0;n={};p=r=null},destroy:function(){n=g=l=null;delete a[b]},info:function(){return P({},g,{size:h})}}}var a={};b.info=function(){var b=
{};m(a,function(a,e){b[e]=a.info()});return b};b.get=function(b){return a[b]};return b}}function rf(){this.$get=["$cacheFactory",function(b){return b("templates")}]}function Dc(b,a){function c(a,b,c){var d=/^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/,e={};m(a,function(a,f){var g=a.match(d);if(!g)throw ga("iscp",b,f,a,c?"controller bindings definition":"isolate scope definition");e[f]={mode:g[1][0],collection:"*"===g[2],optional:"?"===g[3],attrName:g[4]||f}});return e}function d(a){var b=a.charAt(0);if(!b||
b!==F(b))throw ga("baddir",a);if(a!==a.trim())throw ga("baddir",a);}var e={},f=/^\s*directive\:\s*([\w\-]+)\s+(.*)$/,h=/(([\w\-]+)(?:\:([^;]+))?;?)/,g=Wd("ngSrc,ngSrcset,src,srcset"),l=/^(?:(\^\^?)?(\?)?(\^\^?)?)?/,k=/^(on[a-z]+|formaction)$/;this.directive=function r(a,f){Ta(a,"directive");G(a)?(d(a),qb(f,"directiveFactory"),e.hasOwnProperty(a)||(e[a]=[],b.factory(a+"Directive",["$injector","$exceptionHandler",function(b,d){var f=[];m(e[a],function(e,g){try{var h=b.invoke(e);x(h)?h={compile:qa(h)}:
!h.compile&&h.link&&(h.compile=qa(h.link));h.priority=h.priority||0;h.index=g;h.name=h.name||a;h.require=h.require||h.controller&&h.name;h.restrict=h.restrict||"EA";var k=h,l=h,r=h.name,n={isolateScope:null,bindToController:null};C(l.scope)&&(!0===l.bindToController?(n.bindToController=c(l.scope,r,!0),n.isolateScope={}):n.isolateScope=c(l.scope,r,!1));C(l.bindToController)&&(n.bindToController=c(l.bindToController,r,!0));if(C(n.bindToController)){var S=l.controller,E=l.controllerAs;if(!S)throw ga("noctrl",
r);var ca;a:if(E&&G(E))ca=E;else{if(G(S)){var m=Vc.exec(S);if(m){ca=m[3];break a}}ca=void 0}if(!ca)throw ga("noident",r);}var s=k.$$bindings=n;C(s.isolateScope)&&(h.$$isolateBindings=s.isolateScope);h.$$moduleName=e.$$moduleName;f.push(h)}catch(w){d(w)}});return f}])),e[a].push(f)):m(a,oc(r));return this};this.aHrefSanitizationWhitelist=function(b){return A(b)?(a.aHrefSanitizationWhitelist(b),this):a.aHrefSanitizationWhitelist()};this.imgSrcSanitizationWhitelist=function(b){return A(b)?(a.imgSrcSanitizationWhitelist(b),
this):a.imgSrcSanitizationWhitelist()};var n=!0;this.debugInfoEnabled=function(a){return A(a)?(n=a,this):n};this.$get=["$injector","$interpolate","$exceptionHandler","$templateRequest","$parse","$controller","$rootScope","$document","$sce","$animate","$$sanitizeUri",function(a,b,c,d,u,q,z,N,ia,O,H){function L(a,b){try{a.addClass(b)}catch(c){}}function W(a,b,c,d,e){a instanceof B||(a=B(a));m(a,function(b,c){b.nodeType==Pa&&b.nodeValue.match(/\S+/)&&(a[c]=B(b).wrap("<span></span>").parent()[0])});var f=
S(a,b,a,c,d,e);W.$$addScopeClass(a);var g=null;return function(b,c,d){qb(b,"scope");d=d||{};var e=d.parentBoundTranscludeFn,h=d.transcludeControllers;d=d.futureParentElement;e&&e.$$boundTransclude&&(e=e.$$boundTransclude);g||(g=(d=d&&d[0])?"foreignobject"!==wa(d)&&d.toString().match(/SVG/)?"svg":"html":"html");d="html"!==g?B(Xb(g,B("<div>").append(a).html())):c?Ra.clone.call(a):a;if(h)for(var k in h)d.data("$"+k+"Controller",h[k].instance);W.$$addScopeInfo(d,b);c&&c(d,b);f&&f(b,d,d,e);return d}}function S(a,
b,c,d,e,f){function g(a,c,d,e){var f,k,l,r,n,t,O;if(q)for(O=Array(c.length),r=0;r<h.length;r+=3)f=h[r],O[f]=c[f];else O=c;r=0;for(n=h.length;r<n;)if(k=O[h[r++]],c=h[r++],f=h[r++],c){if(c.scope){if(l=a.$new(),W.$$addScopeInfo(B(k),l),t=c.$$destroyBindings)c.$$destroyBindings=null,l.$on("$destroyed",t)}else l=a;t=c.transcludeOnThisElement?ba(a,c.transclude,e):!c.templateOnThisElement&&e?e:!e&&b?ba(a,b):null;c(f,l,k,d,t,c)}else f&&f(a,k.childNodes,w,e)}for(var h=[],k,l,r,n,q,t=0;t<a.length;t++){k=new Z;
l=ca(a[t],[],k,0===t?d:w,e);(f=l.length?D(l,a[t],k,b,c,null,[],[],f):null)&&f.scope&&W.$$addScopeClass(k.$$element);k=f&&f.terminal||!(r=a[t].childNodes)||!r.length?null:S(r,f?(f.transcludeOnThisElement||!f.templateOnThisElement)&&f.transclude:b);if(f||k)h.push(t,f,k),n=!0,q=q||f;f=null}return n?g:null}function ba(a,b,c){return function(d,e,f,g,h){d||(d=a.$new(!1,h),d.$$transcluded=!0);return b(d,e,{parentBoundTranscludeFn:c,transcludeControllers:f,futureParentElement:g})}}function ca(a,b,c,d,e){var g=
c.$attr,k;switch(a.nodeType){case pa:na(b,ya(wa(a)),"E",d,e);for(var l,r,n,q=a.attributes,t=0,O=q&&q.length;t<O;t++){var K=!1,H=!1;l=q[t];k=l.name;r=T(l.value);l=ya(k);if(n=ja.test(l))k=k.replace(Wc,"").substr(8).replace(/_(.)/g,function(a,b){return b.toUpperCase()});var S=l.replace(/(Start|End)$/,"");I(S)&&l===S+"Start"&&(K=k,H=k.substr(0,k.length-5)+"end",k=k.substr(0,k.length-6));l=ya(k.toLowerCase());g[l]=k;if(n||!c.hasOwnProperty(l))c[l]=r,Rc(a,l)&&(c[l]=!0);V(a,b,r,l,n);na(b,l,"A",d,e,K,H)}a=
a.className;C(a)&&(a=a.animVal);if(G(a)&&""!==a)for(;k=h.exec(a);)l=ya(k[2]),na(b,l,"C",d,e)&&(c[l]=T(k[3])),a=a.substr(k.index+k[0].length);break;case Pa:if(11===Wa)for(;a.parentNode&&a.nextSibling&&a.nextSibling.nodeType===Pa;)a.nodeValue+=a.nextSibling.nodeValue,a.parentNode.removeChild(a.nextSibling);Ka(b,a.nodeValue);break;case 8:try{if(k=f.exec(a.nodeValue))l=ya(k[1]),na(b,l,"M",d,e)&&(c[l]=T(k[2]))}catch(E){}}b.sort(M);return b}function za(a,b,c){var d=[],e=0;if(b&&a.hasAttribute&&a.hasAttribute(b)){do{if(!a)throw ga("uterdir",
b,c);a.nodeType==pa&&(a.hasAttribute(b)&&e++,a.hasAttribute(c)&&e--);d.push(a);a=a.nextSibling}while(0<e)}else d.push(a);return B(d)}function s(a,b,c){return function(d,e,f,g,h){e=za(e[0],b,c);return a(d,e,f,g,h)}}function D(a,b,d,e,f,g,h,k,r){function n(a,b,c,d){if(a){c&&(a=s(a,c,d));a.require=D.require;a.directiveName=y;if(u===D||D.$$isolateScope)a=$(a,{isolateScope:!0});h.push(a)}if(b){c&&(b=s(b,c,d));b.require=D.require;b.directiveName=y;if(u===D||D.$$isolateScope)b=$(b,{isolateScope:!0});k.push(b)}}
function t(a,b,c,d){var e;if(G(b)){var f=b.match(l);b=b.substring(f[0].length);var g=f[1]||f[3],f="?"===f[2];"^^"===g?c=c.parent():e=(e=d&&d[b])&&e.instance;e||(d="$"+b+"Controller",e=g?c.inheritedData(d):c.data(d));if(!e&&!f)throw ga("ctreq",b,a);}else if(J(b))for(e=[],g=0,f=b.length;g<f;g++)e[g]=t(a,b[g],c,d);return e||null}function O(a,b,c,d,e,f){var g=fa(),h;for(h in d){var k=d[h],l={$scope:k===u||k.$$isolateScope?e:f,$element:a,$attrs:b,$transclude:c},r=k.controller;"@"==r&&(r=b[k.name]);l=q(r,
l,!0,k.controllerAs);g[k.name]=l;ia||a.data("$"+k.name+"Controller",l.instance)}return g}function K(a,c,e,f,g,l){function r(a,b,c){var d;ab(a)||(c=b,b=a,a=w);ia&&(d=ca);c||(c=ia?N.parent():N);return g(a,b,d,c,za)}var n,q,H,E,ca,z,N;b===e?(f=d,N=d.$$element):(N=B(e),f=new Z(N,d));u&&(E=c.$new(!0));g&&(z=r,z.$$boundTransclude=g);ba&&(ca=O(N,f,z,ba,E,c));u&&(W.$$addScopeInfo(N,E,!0,!(L&&(L===u||L===u.$$originalDirective))),W.$$addScopeClass(N,!0),E.$$isolateBindings=u.$$isolateBindings,Y(c,f,E,E.$$isolateBindings,
u,E));if(ca){var Va=u||S,m;Va&&ca[Va.name]&&(q=Va.$$bindings.bindToController,(H=ca[Va.name])&&H.identifier&&q&&(m=H,l.$$destroyBindings=Y(c,f,H.instance,q,Va)));for(n in ca){H=ca[n];var D=H();D!==H.instance&&(H.instance=D,N.data("$"+n+"Controller",D),H===m&&(l.$$destroyBindings(),l.$$destroyBindings=Y(c,f,D,q,Va)))}}n=0;for(l=h.length;n<l;n++)q=h[n],aa(q,q.isolateScope?E:c,N,f,q.require&&t(q.directiveName,q.require,N,ca),z);var za=c;u&&(u.template||null===u.templateUrl)&&(za=E);a&&a(za,e.childNodes,
w,g);for(n=k.length-1;0<=n;n--)q=k[n],aa(q,q.isolateScope?E:c,N,f,q.require&&t(q.directiveName,q.require,N,ca),z)}r=r||{};for(var H=-Number.MAX_VALUE,S=r.newScopeDirective,ba=r.controllerDirectives,u=r.newIsolateScopeDirective,L=r.templateDirective,z=r.nonTlbTranscludeDirective,N=!1,m=!1,ia=r.hasElementTranscludeDirective,v=d.$$element=B(b),D,y,M,Ka=e,na,I=0,F=a.length;I<F;I++){D=a[I];var P=D.$$start,R=D.$$end;P&&(v=za(b,P,R));M=w;if(H>D.priority)break;if(M=D.scope)D.templateUrl||(C(M)?(Q("new/isolated scope",
u||S,D,v),u=D):Q("new/isolated scope",u,D,v)),S=S||D;y=D.name;!D.templateUrl&&D.controller&&(M=D.controller,ba=ba||fa(),Q("'"+y+"' controller",ba[y],D,v),ba[y]=D);if(M=D.transclude)N=!0,D.$$tlb||(Q("transclusion",z,D,v),z=D),"element"==M?(ia=!0,H=D.priority,M=v,v=d.$$element=B(X.createComment(" "+y+": "+d[y]+" ")),b=v[0],U(f,ua.call(M,0),b),Ka=W(M,e,H,g&&g.name,{nonTlbTranscludeDirective:z})):(M=B(Ub(b)).contents(),v.empty(),Ka=W(M,e));if(D.template)if(m=!0,Q("template",L,D,v),L=D,M=x(D.template)?
D.template(v,d):D.template,M=ha(M),D.replace){g=D;M=Sb.test(M)?Xc(Xb(D.templateNamespace,T(M))):[];b=M[0];if(1!=M.length||b.nodeType!==pa)throw ga("tplrt",y,"");U(f,v,b);F={$attr:{}};M=ca(b,[],F);var Lf=a.splice(I+1,a.length-(I+1));u&&A(M);a=a.concat(M).concat(Lf);Yc(d,F);F=a.length}else v.html(M);if(D.templateUrl)m=!0,Q("template",L,D,v),L=D,D.replace&&(g=D),K=Mf(a.splice(I,a.length-I),v,d,f,N&&Ka,h,k,{controllerDirectives:ba,newScopeDirective:S!==D&&S,newIsolateScopeDirective:u,templateDirective:L,
nonTlbTranscludeDirective:z}),F=a.length;else if(D.compile)try{na=D.compile(v,d,Ka),x(na)?n(null,na,P,R):na&&n(na.pre,na.post,P,R)}catch(V){c(V,xa(v))}D.terminal&&(K.terminal=!0,H=Math.max(H,D.priority))}K.scope=S&&!0===S.scope;K.transcludeOnThisElement=N;K.templateOnThisElement=m;K.transclude=Ka;r.hasElementTranscludeDirective=ia;return K}function A(a){for(var b=0,c=a.length;b<c;b++)a[b]=Nb(a[b],{$$isolateScope:!0})}function na(b,d,f,g,h,k,l){if(d===h)return null;h=null;if(e.hasOwnProperty(d)){var n;
d=a.get(d+"Directive");for(var q=0,t=d.length;q<t;q++)try{n=d[q],(v(g)||g>n.priority)&&-1!=n.restrict.indexOf(f)&&(k&&(n=Nb(n,{$$start:k,$$end:l})),b.push(n),h=n)}catch(H){c(H)}}return h}function I(b){if(e.hasOwnProperty(b))for(var c=a.get(b+"Directive"),d=0,f=c.length;d<f;d++)if(b=c[d],b.multiElement)return!0;return!1}function Yc(a,b){var c=b.$attr,d=a.$attr,e=a.$$element;m(a,function(d,e){"$"!=e.charAt(0)&&(b[e]&&b[e]!==d&&(d+=("style"===e?";":" ")+b[e]),a.$set(e,d,!0,c[e]))});m(b,function(b,f){"class"==
f?(L(e,b),a["class"]=(a["class"]?a["class"]+" ":"")+b):"style"==f?(e.attr("style",e.attr("style")+";"+b),a.style=(a.style?a.style+";":"")+b):"$"==f.charAt(0)||a.hasOwnProperty(f)||(a[f]=b,d[f]=c[f])})}function Mf(a,b,c,e,f,g,h,k){var l=[],r,n,q=b[0],t=a.shift(),H=Nb(t,{templateUrl:null,transclude:null,replace:null,$$originalDirective:t}),O=x(t.templateUrl)?t.templateUrl(b,c):t.templateUrl,E=t.templateNamespace;b.empty();d(O).then(function(d){var K,u;d=ha(d);if(t.replace){d=Sb.test(d)?Xc(Xb(E,T(d))):
[];K=d[0];if(1!=d.length||K.nodeType!==pa)throw ga("tplrt",t.name,O);d={$attr:{}};U(e,b,K);var z=ca(K,[],d);C(t.scope)&&A(z);a=z.concat(a);Yc(c,d)}else K=q,b.html(d);a.unshift(H);r=D(a,K,c,f,b,t,g,h,k);m(e,function(a,c){a==K&&(e[c]=b[0])});for(n=S(b[0].childNodes,f);l.length;){d=l.shift();u=l.shift();var N=l.shift(),W=l.shift(),z=b[0];if(!d.$$destroyed){if(u!==q){var za=u.className;k.hasElementTranscludeDirective&&t.replace||(z=Ub(K));U(N,B(u),z);L(B(z),za)}u=r.transcludeOnThisElement?ba(d,r.transclude,
W):W;r(n,d,z,e,u,r)}}l=null});return function(a,b,c,d,e){a=e;b.$$destroyed||(l?l.push(b,c,d,a):(r.transcludeOnThisElement&&(a=ba(b,r.transclude,e)),r(n,b,c,d,a,r)))}}function M(a,b){var c=b.priority-a.priority;return 0!==c?c:a.name!==b.name?a.name<b.name?-1:1:a.index-b.index}function Q(a,b,c,d){function e(a){return a?" (module: "+a+")":""}if(b)throw ga("multidir",b.name,e(b.$$moduleName),c.name,e(c.$$moduleName),a,xa(d));}function Ka(a,c){var d=b(c,!0);d&&a.push({priority:0,compile:function(a){a=
a.parent();var b=!!a.length;b&&W.$$addBindingClass(a);return function(a,c){var e=c.parent();b||W.$$addBindingClass(e);W.$$addBindingInfo(e,d.expressions);a.$watch(d,function(a){c[0].nodeValue=a})}}})}function Xb(a,b){a=F(a||"html");switch(a){case "svg":case "math":var c=X.createElement("div");c.innerHTML="<"+a+">"+b+"</"+a+">";return c.childNodes[0].childNodes;default:return b}}function R(a,b){if("srcdoc"==b)return ia.HTML;var c=wa(a);if("xlinkHref"==b||"form"==c&&"action"==b||"img"!=c&&("src"==b||
"ngSrc"==b))return ia.RESOURCE_URL}function V(a,c,d,e,f){var h=R(a,e);f=g[e]||f;var l=b(d,!0,h,f);if(l){if("multiple"===e&&"select"===wa(a))throw ga("selmulti",xa(a));c.push({priority:100,compile:function(){return{pre:function(a,c,g){c=g.$$observers||(g.$$observers=fa());if(k.test(e))throw ga("nodomevents");var r=g[e];r!==d&&(l=r&&b(r,!0,h,f),d=r);l&&(g[e]=l(a),(c[e]||(c[e]=[])).$$inter=!0,(g.$$observers&&g.$$observers[e].$$scope||a).$watch(l,function(a,b){"class"===e&&a!=b?g.$updateClass(a,b):g.$set(e,
a)}))}}}})}}function U(a,b,c){var d=b[0],e=b.length,f=d.parentNode,g,h;if(a)for(g=0,h=a.length;g<h;g++)if(a[g]==d){a[g++]=c;h=g+e-1;for(var k=a.length;g<k;g++,h++)h<k?a[g]=a[h]:delete a[g];a.length-=e-1;a.context===d&&(a.context=c);break}f&&f.replaceChild(c,d);a=X.createDocumentFragment();a.appendChild(d);B.hasData(d)&&(B(c).data(B(d).data()),ra?(Qb=!0,ra.cleanData([d])):delete B.cache[d[B.expando]]);d=1;for(e=b.length;d<e;d++)f=b[d],B(f).remove(),a.appendChild(f),delete b[d];b[0]=c;b.length=1}function $(a,
b){return P(function(){return a.apply(null,arguments)},a,b)}function aa(a,b,d,e,f,g){try{a(b,d,e,f,g)}catch(h){c(h,xa(d))}}function Y(a,c,d,e,f,g){var h;m(e,function(e,g){var k=e.attrName,l=e.optional,r,n,q,K;switch(e.mode){case "@":l||ta.call(c,k)||(d[g]=c[k]=void 0);c.$observe(k,function(a){G(a)&&(d[g]=a)});c.$$observers[k].$$scope=a;G(c[k])&&(d[g]=b(c[k])(a));break;case "=":if(!ta.call(c,k)){if(l)break;c[k]=void 0}if(l&&!c[k])break;n=u(c[k]);K=n.literal?ka:function(a,b){return a===b||a!==a&&b!==
b};q=n.assign||function(){r=d[g]=n(a);throw ga("nonassign",c[k],f.name);};r=d[g]=n(a);l=function(b){K(b,d[g])||(K(b,r)?q(a,b=d[g]):d[g]=b);return r=b};l.$stateful=!0;l=e.collection?a.$watchCollection(c[k],l):a.$watch(u(c[k],l),null,n.literal);h=h||[];h.push(l);break;case "&":n=c.hasOwnProperty(k)?u(c[k]):y;if(n===y&&l)break;d[g]=function(b){return n(a,b)}}});e=h?function(){for(var a=0,b=h.length;a<b;++a)h[a]()}:y;return g&&e!==y?(g.$on("$destroy",e),y):e}var Z=function(a,b){if(b){var c=Object.keys(b),
d,e,f;d=0;for(e=c.length;d<e;d++)f=c[d],this[f]=b[f]}else this.$attr={};this.$$element=a};Z.prototype={$normalize:ya,$addClass:function(a){a&&0<a.length&&O.addClass(this.$$element,a)},$removeClass:function(a){a&&0<a.length&&O.removeClass(this.$$element,a)},$updateClass:function(a,b){var c=Zc(a,b);c&&c.length&&O.addClass(this.$$element,c);(c=Zc(b,a))&&c.length&&O.removeClass(this.$$element,c)},$set:function(a,b,d,e){var f=Rc(this.$$element[0],a),g=$c[a],h=a;f?(this.$$element.prop(a,b),e=f):g&&(this[g]=
b,h=g);this[a]=b;e?this.$attr[a]=e:(e=this.$attr[a])||(this.$attr[a]=e=Ac(a,"-"));f=wa(this.$$element);if("a"===f&&"href"===a||"img"===f&&"src"===a)this[a]=b=H(b,"src"===a);else if("img"===f&&"srcset"===a){for(var f="",g=T(b),k=/(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/,k=/\s/.test(g)?k:/(,)/,g=g.split(k),k=Math.floor(g.length/2),l=0;l<k;l++)var r=2*l,f=f+H(T(g[r]),!0),f=f+(" "+T(g[r+1]));g=T(g[2*l]).split(/\s/);f+=H(T(g[0]),!0);2===g.length&&(f+=" "+T(g[1]));this[a]=b=f}!1!==d&&(null===b||v(b)?this.$$element.removeAttr(e):
this.$$element.attr(e,b));(a=this.$$observers)&&m(a[h],function(a){try{a(b)}catch(d){c(d)}})},$observe:function(a,b){var c=this,d=c.$$observers||(c.$$observers=fa()),e=d[a]||(d[a]=[]);e.push(b);z.$evalAsync(function(){e.$$inter||!c.hasOwnProperty(a)||v(c[a])||b(c[a])});return function(){cb(e,b)}}};var da=b.startSymbol(),ea=b.endSymbol(),ha="{{"==da||"}}"==ea?$a:function(a){return a.replace(/\{\{/g,da).replace(/}}/g,ea)},ja=/^ngAttr[A-Z]/;W.$$addBindingInfo=n?function(a,b){var c=a.data("$binding")||
[];J(b)?c=c.concat(b):c.push(b);a.data("$binding",c)}:y;W.$$addBindingClass=n?function(a){L(a,"ng-binding")}:y;W.$$addScopeInfo=n?function(a,b,c,d){a.data(c?d?"$isolateScopeNoTemplate":"$isolateScope":"$scope",b)}:y;W.$$addScopeClass=n?function(a,b){L(a,b?"ng-isolate-scope":"ng-scope")}:y;return W}]}function ya(b){return gb(b.replace(Wc,""))}function Zc(b,a){var c="",d=b.split(/\s+/),e=a.split(/\s+/),f=0;a:for(;f<d.length;f++){for(var h=d[f],g=0;g<e.length;g++)if(h==e[g])continue a;c+=(0<c.length?
" ":"")+h}return c}function Xc(b){b=B(b);var a=b.length;if(1>=a)return b;for(;a--;)8===b[a].nodeType&&Nf.call(b,a,1);return b}function Xe(){var b={},a=!1;this.register=function(a,d){Ta(a,"controller");C(a)?P(b,a):b[a]=d};this.allowGlobals=function(){a=!0};this.$get=["$injector","$window",function(c,d){function e(a,b,c,d){if(!a||!C(a.$scope))throw I("$controller")("noscp",d,b);a.$scope[b]=c}return function(f,h,g,l){var k,n,p;g=!0===g;l&&G(l)&&(p=l);if(G(f)){l=f.match(Vc);if(!l)throw Of("ctrlfmt",f);
n=l[1];p=p||l[3];f=b.hasOwnProperty(n)?b[n]:Cc(h.$scope,n,!0)||(a?Cc(d,n,!0):w);Sa(f,n,!0)}if(g)return g=(J(f)?f[f.length-1]:f).prototype,k=Object.create(g||null),p&&e(h,p,k,n||f.name),P(function(){var a=c.invoke(f,k,h,n);a!==k&&(C(a)||x(a))&&(k=a,p&&e(h,p,k,n||f.name));return k},{instance:k,identifier:p});k=c.instantiate(f,h,n);p&&e(h,p,k,n||f.name);return k}}]}function Ye(){this.$get=["$window",function(b){return B(b.document)}]}function Ze(){this.$get=["$log",function(b){return function(a,c){b.error.apply(b,
arguments)}}]}function Yb(b){return C(b)?ea(b)?b.toISOString():eb(b):b}function df(){this.$get=function(){return function(b){if(!b)return"";var a=[];nc(b,function(b,d){null===b||v(b)||(J(b)?m(b,function(b,c){a.push(la(d)+"="+la(Yb(b)))}):a.push(la(d)+"="+la(Yb(b))))});return a.join("&")}}}function ef(){this.$get=function(){return function(b){function a(b,e,f){null===b||v(b)||(J(b)?m(b,function(b,c){a(b,e+"["+(C(b)?c:"")+"]")}):C(b)&&!ea(b)?nc(b,function(b,c){a(b,e+(f?"":"[")+c+(f?"":"]"))}):c.push(la(e)+
"="+la(Yb(b))))}if(!b)return"";var c=[];a(b,"",!0);return c.join("&")}}}function Zb(b,a){if(G(b)){var c=b.replace(Pf,"").trim();if(c){var d=a("Content-Type");(d=d&&0===d.indexOf(ad))||(d=(d=c.match(Qf))&&Rf[d[0]].test(c));d&&(b=vc(c))}}return b}function bd(b){var a=fa(),c;G(b)?m(b.split("\n"),function(b){c=b.indexOf(":");var e=F(T(b.substr(0,c)));b=T(b.substr(c+1));e&&(a[e]=a[e]?a[e]+", "+b:b)}):C(b)&&m(b,function(b,c){var f=F(c),h=T(b);f&&(a[f]=a[f]?a[f]+", "+h:h)});return a}function cd(b){var a;
return function(c){a||(a=bd(b));return c?(c=a[F(c)],void 0===c&&(c=null),c):a}}function dd(b,a,c,d){if(x(d))return d(b,a,c);m(d,function(d){b=d(b,a,c)});return b}function cf(){var b=this.defaults={transformResponse:[Zb],transformRequest:[function(a){return C(a)&&"[object File]"!==va.call(a)&&"[object Blob]"!==va.call(a)&&"[object FormData]"!==va.call(a)?eb(a):a}],headers:{common:{Accept:"application/json, text/plain, */*"},post:ja($b),put:ja($b),patch:ja($b)},xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",
paramSerializer:"$httpParamSerializer"},a=!1;this.useApplyAsync=function(b){return A(b)?(a=!!b,this):a};var c=!0;this.useLegacyPromiseExtensions=function(a){return A(a)?(c=!!a,this):c};var d=this.interceptors=[];this.$get=["$httpBackend","$$cookieReader","$cacheFactory","$rootScope","$q","$injector",function(e,f,h,g,l,k){function n(a){function d(a){var b=P({},a);b.data=a.data?dd(a.data,a.headers,a.status,f.transformResponse):a.data;a=a.status;return 200<=a&&300>a?b:l.reject(b)}function e(a,b){var c,
d={};m(a,function(a,e){x(a)?(c=a(b),null!=c&&(d[e]=c)):d[e]=a});return d}if(!da.isObject(a))throw I("$http")("badreq",a);var f=P({method:"get",transformRequest:b.transformRequest,transformResponse:b.transformResponse,paramSerializer:b.paramSerializer},a);f.headers=function(a){var c=b.headers,d=P({},a.headers),f,g,h,c=P({},c.common,c[F(a.method)]);a:for(f in c){g=F(f);for(h in d)if(F(h)===g)continue a;d[f]=c[f]}return e(d,ja(a))}(a);f.method=sb(f.method);f.paramSerializer=G(f.paramSerializer)?k.get(f.paramSerializer):
f.paramSerializer;var g=[function(a){var c=a.headers,e=dd(a.data,cd(c),w,a.transformRequest);v(e)&&m(c,function(a,b){"content-type"===F(b)&&delete c[b]});v(a.withCredentials)&&!v(b.withCredentials)&&(a.withCredentials=b.withCredentials);return p(a,e).then(d,d)},w],h=l.when(f);for(m(E,function(a){(a.request||a.requestError)&&g.unshift(a.request,a.requestError);(a.response||a.responseError)&&g.push(a.response,a.responseError)});g.length;){a=g.shift();var r=g.shift(),h=h.then(a,r)}c?(h.success=function(a){Sa(a,
"fn");h.then(function(b){a(b.data,b.status,b.headers,f)});return h},h.error=function(a){Sa(a,"fn");h.then(null,function(b){a(b.data,b.status,b.headers,f)});return h}):(h.success=ed("success"),h.error=ed("error"));return h}function p(c,d){function h(b,c,d,e){function f(){k(c,b,d,e)}L&&(200<=b&&300>b?L.put(ba,[b,c,bd(d),e]):L.remove(ba));a?g.$applyAsync(f):(f(),g.$$phase||g.$apply())}function k(a,b,d,e){b=-1<=b?b:0;(200<=b&&300>b?O.resolve:O.reject)({data:a,status:b,headers:cd(d),config:c,statusText:e})}
function p(a){k(a.data,a.status,ja(a.headers()),a.statusText)}function E(){var a=n.pendingRequests.indexOf(c);-1!==a&&n.pendingRequests.splice(a,1)}var O=l.defer(),H=O.promise,L,m,S=c.headers,ba=r(c.url,c.paramSerializer(c.params));n.pendingRequests.push(c);H.then(E,E);!c.cache&&!b.cache||!1===c.cache||"GET"!==c.method&&"JSONP"!==c.method||(L=C(c.cache)?c.cache:C(b.cache)?b.cache:t);L&&(m=L.get(ba),A(m)?m&&x(m.then)?m.then(p,p):J(m)?k(m[1],m[0],ja(m[2]),m[3]):k(m,200,{},"OK"):L.put(ba,H));v(m)&&((m=
fd(c.url)?f()[c.xsrfCookieName||b.xsrfCookieName]:w)&&(S[c.xsrfHeaderName||b.xsrfHeaderName]=m),e(c.method,ba,d,h,S,c.timeout,c.withCredentials,c.responseType));return H}function r(a,b){0<b.length&&(a+=(-1==a.indexOf("?")?"?":"&")+b);return a}var t=h("$http");b.paramSerializer=G(b.paramSerializer)?k.get(b.paramSerializer):b.paramSerializer;var E=[];m(d,function(a){E.unshift(G(a)?k.get(a):k.invoke(a))});n.pendingRequests=[];(function(a){m(arguments,function(a){n[a]=function(b,c){return n(P({},c||{},
{method:a,url:b}))}})})("get","delete","head","jsonp");(function(a){m(arguments,function(a){n[a]=function(b,c,d){return n(P({},d||{},{method:a,url:b,data:c}))}})})("post","put","patch");n.defaults=b;return n}]}function gf(){this.$get=function(){return function(){return new Q.XMLHttpRequest}}}function ff(){this.$get=["$browser","$window","$document","$xhrFactory",function(b,a,c,d){return Sf(b,d,b.defer,a.angular.callbacks,c[0])}]}function Sf(b,a,c,d,e){function f(a,b,c){var f=e.createElement("script"),
n=null;f.type="text/javascript";f.src=a;f.async=!0;n=function(a){f.removeEventListener("load",n,!1);f.removeEventListener("error",n,!1);e.body.removeChild(f);f=null;var h=-1,t="unknown";a&&("load"!==a.type||d[b].called||(a={type:"error"}),t=a.type,h="error"===a.type?404:200);c&&c(h,t)};f.addEventListener("load",n,!1);f.addEventListener("error",n,!1);e.body.appendChild(f);return n}return function(e,g,l,k,n,p,r,t){function E(){q&&q();z&&z.abort()}function K(a,d,e,f,g){A(s)&&c.cancel(s);q=z=null;a(d,
e,f,g);b.$$completeOutstandingRequest(y)}b.$$incOutstandingRequestCount();g=g||b.url();if("jsonp"==F(e)){var u="_"+(d.counter++).toString(36);d[u]=function(a){d[u].data=a;d[u].called=!0};var q=f(g.replace("JSON_CALLBACK","angular.callbacks."+u),u,function(a,b){K(k,a,d[u].data,"",b);d[u]=y})}else{var z=a(e,g);z.open(e,g,!0);m(n,function(a,b){A(a)&&z.setRequestHeader(b,a)});z.onload=function(){var a=z.statusText||"",b="response"in z?z.response:z.responseText,c=1223===z.status?204:z.status;0===c&&(c=
b?200:"file"==Aa(g).protocol?404:0);K(k,c,b,z.getAllResponseHeaders(),a)};e=function(){K(k,-1,null,null,"")};z.onerror=e;z.onabort=e;r&&(z.withCredentials=!0);if(t)try{z.responseType=t}catch(N){if("json"!==t)throw N;}z.send(v(l)?null:l)}if(0<p)var s=c(E,p);else p&&x(p.then)&&p.then(E)}}function af(){var b="{{",a="}}";this.startSymbol=function(a){return a?(b=a,this):b};this.endSymbol=function(b){return b?(a=b,this):a};this.$get=["$parse","$exceptionHandler","$sce",function(c,d,e){function f(a){return"\\\\\\"+
a}function h(c){return c.replace(n,b).replace(p,a)}function g(f,g,n,p){function u(a){try{var b=a;a=n?e.getTrusted(n,b):e.valueOf(b);var c;if(p&&!A(a))c=a;else if(null==a)c="";else{switch(typeof a){case "string":break;case "number":a=""+a;break;default:a=eb(a)}c=a}return c}catch(g){d(La.interr(f,g))}}p=!!p;for(var q,m,N=0,s=[],O=[],H=f.length,L=[],W=[];N<H;)if(-1!=(q=f.indexOf(b,N))&&-1!=(m=f.indexOf(a,q+l)))N!==q&&L.push(h(f.substring(N,q))),N=f.substring(q+l,m),s.push(N),O.push(c(N,u)),N=m+k,W.push(L.length),
L.push("");else{N!==H&&L.push(h(f.substring(N)));break}n&&1<L.length&&La.throwNoconcat(f);if(!g||s.length){var S=function(a){for(var b=0,c=s.length;b<c;b++){if(p&&v(a[b]))return;L[W[b]]=a[b]}return L.join("")};return P(function(a){var b=0,c=s.length,e=Array(c);try{for(;b<c;b++)e[b]=O[b](a);return S(e)}catch(g){d(La.interr(f,g))}},{exp:f,expressions:s,$$watchDelegate:function(a,b){var c;return a.$watchGroup(O,function(d,e){var f=S(d);x(b)&&b.call(this,f,d!==e?c:f,a);c=f})}})}}var l=b.length,k=a.length,
n=new RegExp(b.replace(/./g,f),"g"),p=new RegExp(a.replace(/./g,f),"g");g.startSymbol=function(){return b};g.endSymbol=function(){return a};return g}]}function bf(){this.$get=["$rootScope","$window","$q","$$q",function(b,a,c,d){function e(e,g,l,k){var n=4<arguments.length,p=n?ua.call(arguments,4):[],r=a.setInterval,t=a.clearInterval,E=0,K=A(k)&&!k,u=(K?d:c).defer(),q=u.promise;l=A(l)?l:0;q.then(null,null,n?function(){e.apply(null,p)}:e);q.$$intervalId=r(function(){u.notify(E++);0<l&&E>=l&&(u.resolve(E),
t(q.$$intervalId),delete f[q.$$intervalId]);K||b.$apply()},g);f[q.$$intervalId]=u;return q}var f={};e.cancel=function(b){return b&&b.$$intervalId in f?(f[b.$$intervalId].reject("canceled"),a.clearInterval(b.$$intervalId),delete f[b.$$intervalId],!0):!1};return e}]}function ac(b){b=b.split("/");for(var a=b.length;a--;)b[a]=ob(b[a]);return b.join("/")}function gd(b,a){var c=Aa(b);a.$$protocol=c.protocol;a.$$host=c.hostname;a.$$port=Y(c.port)||Tf[c.protocol]||null}function hd(b,a){var c="/"!==b.charAt(0);
c&&(b="/"+b);var d=Aa(b);a.$$path=decodeURIComponent(c&&"/"===d.pathname.charAt(0)?d.pathname.substring(1):d.pathname);a.$$search=yc(d.search);a.$$hash=decodeURIComponent(d.hash);a.$$path&&"/"!=a.$$path.charAt(0)&&(a.$$path="/"+a.$$path)}function sa(b,a){if(0===a.indexOf(b))return a.substr(b.length)}function Ja(b){var a=b.indexOf("#");return-1==a?b:b.substr(0,a)}function Cb(b){return b.replace(/(#.+)|#$/,"$1")}function bc(b,a,c){this.$$html5=!0;c=c||"";gd(b,this);this.$$parse=function(b){var c=sa(a,
b);if(!G(c))throw Db("ipthprfx",b,a);hd(c,this);this.$$path||(this.$$path="/");this.$$compose()};this.$$compose=function(){var b=Pb(this.$$search),c=this.$$hash?"#"+ob(this.$$hash):"";this.$$url=ac(this.$$path)+(b?"?"+b:"")+c;this.$$absUrl=a+this.$$url.substr(1)};this.$$parseLinkUrl=function(d,e){if(e&&"#"===e[0])return this.hash(e.slice(1)),!0;var f,h;A(f=sa(b,d))?(h=f,h=A(f=sa(c,f))?a+(sa("/",f)||f):b+h):A(f=sa(a,d))?h=a+f:a==d+"/"&&(h=a);h&&this.$$parse(h);return!!h}}function cc(b,a,c){gd(b,this);
this.$$parse=function(d){var e=sa(b,d)||sa(a,d),f;v(e)||"#"!==e.charAt(0)?this.$$html5?f=e:(f="",v(e)&&(b=d,this.replace())):(f=sa(c,e),v(f)&&(f=e));hd(f,this);d=this.$$path;var e=b,h=/^\/[A-Z]:(\/.*)/;0===f.indexOf(e)&&(f=f.replace(e,""));h.exec(f)||(d=(f=h.exec(d))?f[1]:d);this.$$path=d;this.$$compose()};this.$$compose=function(){var a=Pb(this.$$search),e=this.$$hash?"#"+ob(this.$$hash):"";this.$$url=ac(this.$$path)+(a?"?"+a:"")+e;this.$$absUrl=b+(this.$$url?c+this.$$url:"")};this.$$parseLinkUrl=
function(a,c){return Ja(b)==Ja(a)?(this.$$parse(a),!0):!1}}function id(b,a,c){this.$$html5=!0;cc.apply(this,arguments);this.$$parseLinkUrl=function(d,e){if(e&&"#"===e[0])return this.hash(e.slice(1)),!0;var f,h;b==Ja(d)?f=d:(h=sa(a,d))?f=b+c+h:a===d+"/"&&(f=a);f&&this.$$parse(f);return!!f};this.$$compose=function(){var a=Pb(this.$$search),e=this.$$hash?"#"+ob(this.$$hash):"";this.$$url=ac(this.$$path)+(a?"?"+a:"")+e;this.$$absUrl=b+c+this.$$url}}function Eb(b){return function(){return this[b]}}function jd(b,
a){return function(c){if(v(c))return this[b];this[b]=a(c);this.$$compose();return this}}function hf(){var b="",a={enabled:!1,requireBase:!0,rewriteLinks:!0};this.hashPrefix=function(a){return A(a)?(b=a,this):b};this.html5Mode=function(b){return bb(b)?(a.enabled=b,this):C(b)?(bb(b.enabled)&&(a.enabled=b.enabled),bb(b.requireBase)&&(a.requireBase=b.requireBase),bb(b.rewriteLinks)&&(a.rewriteLinks=b.rewriteLinks),this):a};this.$get=["$rootScope","$browser","$sniffer","$rootElement","$window",function(c,
d,e,f,h){function g(a,b,c){var e=k.url(),f=k.$$state;try{d.url(a,b,c),k.$$state=d.state()}catch(g){throw k.url(e),k.$$state=f,g;}}function l(a,b){c.$broadcast("$locationChangeSuccess",k.absUrl(),a,k.$$state,b)}var k,n;n=d.baseHref();var p=d.url(),r;if(a.enabled){if(!n&&a.requireBase)throw Db("nobase");r=p.substring(0,p.indexOf("/",p.indexOf("//")+2))+(n||"/");n=e.history?bc:id}else r=Ja(p),n=cc;var t=r.substr(0,Ja(r).lastIndexOf("/")+1);k=new n(r,t,"#"+b);k.$$parseLinkUrl(p,p);k.$$state=d.state();
var E=/^\s*(javascript|mailto):/i;f.on("click",function(b){if(a.rewriteLinks&&!b.ctrlKey&&!b.metaKey&&!b.shiftKey&&2!=b.which&&2!=b.button){for(var e=B(b.target);"a"!==wa(e[0]);)if(e[0]===f[0]||!(e=e.parent())[0])return;var g=e.prop("href"),l=e.attr("href")||e.attr("xlink:href");C(g)&&"[object SVGAnimatedString]"===g.toString()&&(g=Aa(g.animVal).href);E.test(g)||!g||e.attr("target")||b.isDefaultPrevented()||!k.$$parseLinkUrl(g,l)||(b.preventDefault(),k.absUrl()!=d.url()&&(c.$apply(),h.angular["ff-684208-preventDefault"]=
!0))}});Cb(k.absUrl())!=Cb(p)&&d.url(k.absUrl(),!0);var K=!0;d.onUrlChange(function(a,b){v(sa(t,a))?h.location.href=a:(c.$evalAsync(function(){var d=k.absUrl(),e=k.$$state,f;k.$$parse(a);k.$$state=b;f=c.$broadcast("$locationChangeStart",a,d,b,e).defaultPrevented;k.absUrl()===a&&(f?(k.$$parse(d),k.$$state=e,g(d,!1,e)):(K=!1,l(d,e)))}),c.$$phase||c.$digest())});c.$watch(function(){var a=Cb(d.url()),b=Cb(k.absUrl()),f=d.state(),h=k.$$replace,r=a!==b||k.$$html5&&e.history&&f!==k.$$state;if(K||r)K=!1,
c.$evalAsync(function(){var b=k.absUrl(),d=c.$broadcast("$locationChangeStart",b,a,k.$$state,f).defaultPrevented;k.absUrl()===b&&(d?(k.$$parse(a),k.$$state=f):(r&&g(b,h,f===k.$$state?null:k.$$state),l(a,f)))});k.$$replace=!1});return k}]}function jf(){var b=!0,a=this;this.debugEnabled=function(a){return A(a)?(b=a,this):b};this.$get=["$window",function(c){function d(a){a instanceof Error&&(a.stack?a=a.message&&-1===a.stack.indexOf(a.message)?"Error: "+a.message+"\n"+a.stack:a.stack:a.sourceURL&&(a=
a.message+"\n"+a.sourceURL+":"+a.line));return a}function e(a){var b=c.console||{},e=b[a]||b.log||y;a=!1;try{a=!!e.apply}catch(l){}return a?function(){var a=[];m(arguments,function(b){a.push(d(b))});return e.apply(b,a)}:function(a,b){e(a,null==b?"":b)}}return{log:e("log"),info:e("info"),warn:e("warn"),error:e("error"),debug:function(){var c=e("debug");return function(){b&&c.apply(a,arguments)}}()}}]}function Xa(b,a){if("__defineGetter__"===b||"__defineSetter__"===b||"__lookupGetter__"===b||"__lookupSetter__"===
b||"__proto__"===b)throw Z("isecfld",a);return b}function kd(b,a){b+="";if(!G(b))throw Z("iseccst",a);return b}function Ba(b,a){if(b){if(b.constructor===b)throw Z("isecfn",a);if(b.window===b)throw Z("isecwindow",a);if(b.children&&(b.nodeName||b.prop&&b.attr&&b.find))throw Z("isecdom",a);if(b===Object)throw Z("isecobj",a);}return b}function ld(b,a){if(b){if(b.constructor===b)throw Z("isecfn",a);if(b===Uf||b===Vf||b===Wf)throw Z("isecff",a);}}function md(b,a){if(b&&(b===(0).constructor||b===(!1).constructor||
b==="".constructor||b==={}.constructor||b===[].constructor||b===Function.constructor))throw Z("isecaf",a);}function Xf(b,a){return"undefined"!==typeof b?b:a}function nd(b,a){return"undefined"===typeof b?a:"undefined"===typeof a?b:b+a}function U(b,a){var c,d;switch(b.type){case s.Program:c=!0;m(b.body,function(b){U(b.expression,a);c=c&&b.expression.constant});b.constant=c;break;case s.Literal:b.constant=!0;b.toWatch=[];break;case s.UnaryExpression:U(b.argument,a);b.constant=b.argument.constant;b.toWatch=
b.argument.toWatch;break;case s.BinaryExpression:U(b.left,a);U(b.right,a);b.constant=b.left.constant&&b.right.constant;b.toWatch=b.left.toWatch.concat(b.right.toWatch);break;case s.LogicalExpression:U(b.left,a);U(b.right,a);b.constant=b.left.constant&&b.right.constant;b.toWatch=b.constant?[]:[b];break;case s.ConditionalExpression:U(b.test,a);U(b.alternate,a);U(b.consequent,a);b.constant=b.test.constant&&b.alternate.constant&&b.consequent.constant;b.toWatch=b.constant?[]:[b];break;case s.Identifier:b.constant=
!1;b.toWatch=[b];break;case s.MemberExpression:U(b.object,a);b.computed&&U(b.property,a);b.constant=b.object.constant&&(!b.computed||b.property.constant);b.toWatch=[b];break;case s.CallExpression:c=b.filter?!a(b.callee.name).$stateful:!1;d=[];m(b.arguments,function(b){U(b,a);c=c&&b.constant;b.constant||d.push.apply(d,b.toWatch)});b.constant=c;b.toWatch=b.filter&&!a(b.callee.name).$stateful?d:[b];break;case s.AssignmentExpression:U(b.left,a);U(b.right,a);b.constant=b.left.constant&&b.right.constant;
b.toWatch=[b];break;case s.ArrayExpression:c=!0;d=[];m(b.elements,function(b){U(b,a);c=c&&b.constant;b.constant||d.push.apply(d,b.toWatch)});b.constant=c;b.toWatch=d;break;case s.ObjectExpression:c=!0;d=[];m(b.properties,function(b){U(b.value,a);c=c&&b.value.constant;b.value.constant||d.push.apply(d,b.value.toWatch)});b.constant=c;b.toWatch=d;break;case s.ThisExpression:b.constant=!1,b.toWatch=[]}}function od(b){if(1==b.length){b=b[0].expression;var a=b.toWatch;return 1!==a.length?a:a[0]!==b?a:w}}
function pd(b){return b.type===s.Identifier||b.type===s.MemberExpression}function qd(b){if(1===b.body.length&&pd(b.body[0].expression))return{type:s.AssignmentExpression,left:b.body[0].expression,right:{type:s.NGValueParameter},operator:"="}}function rd(b){return 0===b.body.length||1===b.body.length&&(b.body[0].expression.type===s.Literal||b.body[0].expression.type===s.ArrayExpression||b.body[0].expression.type===s.ObjectExpression)}function sd(b,a){this.astBuilder=b;this.$filter=a}function td(b,
a){this.astBuilder=b;this.$filter=a}function Fb(b){return"constructor"==b}function dc(b){return x(b.valueOf)?b.valueOf():Yf.call(b)}function kf(){var b=fa(),a=fa();this.$get=["$filter",function(c){function d(a,b){return null==a||null==b?a===b:"object"===typeof a&&(a=dc(a),"object"===typeof a)?!1:a===b||a!==a&&b!==b}function e(a,b,c,e,f){var g=e.inputs,h;if(1===g.length){var k=d,g=g[0];return a.$watch(function(a){var b=g(a);d(b,k)||(h=e(a,w,w,[b]),k=b&&dc(b));return h},b,c,f)}for(var l=[],n=[],p=0,
m=g.length;p<m;p++)l[p]=d,n[p]=null;return a.$watch(function(a){for(var b=!1,c=0,f=g.length;c<f;c++){var k=g[c](a);if(b||(b=!d(k,l[c])))n[c]=k,l[c]=k&&dc(k)}b&&(h=e(a,w,w,n));return h},b,c,f)}function f(a,b,c,d){var e,f;return e=a.$watch(function(a){return d(a)},function(a,c,d){f=a;x(b)&&b.apply(this,arguments);A(a)&&d.$$postDigest(function(){A(f)&&e()})},c)}function h(a,b,c,d){function e(a){var b=!0;m(a,function(a){A(a)||(b=!1)});return b}var f,g;return f=a.$watch(function(a){return d(a)},function(a,
c,d){g=a;x(b)&&b.call(this,a,c,d);e(a)&&d.$$postDigest(function(){e(g)&&f()})},c)}function g(a,b,c,d){var e;return e=a.$watch(function(a){return d(a)},function(a,c,d){x(b)&&b.apply(this,arguments);e()},c)}function l(a,b){if(!b)return a;var c=a.$$watchDelegate,c=c!==h&&c!==f?function(c,d,e,f){e=a(c,d,e,f);return b(e,c,d)}:function(c,d,e,f){e=a(c,d,e,f);c=b(e,c,d);return A(e)?c:e};a.$$watchDelegate&&a.$$watchDelegate!==e?c.$$watchDelegate=a.$$watchDelegate:b.$stateful||(c.$$watchDelegate=e,c.inputs=
a.inputs?a.inputs:[a]);return c}var k=Fa().noUnsafeEval,n={csp:k,expensiveChecks:!1},p={csp:k,expensiveChecks:!0};return function(d,k,E){var m,u,q;switch(typeof d){case "string":q=d=d.trim();var s=E?a:b;m=s[q];m||(":"===d.charAt(0)&&":"===d.charAt(1)&&(u=!0,d=d.substring(2)),E=E?p:n,m=new ec(E),m=(new fc(m,c,E)).parse(d),m.constant?m.$$watchDelegate=g:u?m.$$watchDelegate=m.literal?h:f:m.inputs&&(m.$$watchDelegate=e),s[q]=m);return l(m,k);case "function":return l(d,k);default:return y}}}]}function mf(){this.$get=
["$rootScope","$exceptionHandler",function(b,a){return ud(function(a){b.$evalAsync(a)},a)}]}function nf(){this.$get=["$browser","$exceptionHandler",function(b,a){return ud(function(a){b.defer(a)},a)}]}function ud(b,a){function c(a,b,c){function d(b){return function(c){e||(e=!0,b.call(a,c))}}var e=!1;return[d(b),d(c)]}function d(){this.$$state={status:0}}function e(a,b){return function(c){b.call(a,c)}}function f(c){!c.processScheduled&&c.pending&&(c.processScheduled=!0,b(function(){var b,d,e;e=c.pending;
c.processScheduled=!1;c.pending=w;for(var f=0,g=e.length;f<g;++f){d=e[f][0];b=e[f][c.status];try{x(b)?d.resolve(b(c.value)):1===c.status?d.resolve(c.value):d.reject(c.value)}catch(h){d.reject(h),a(h)}}}))}function h(){this.promise=new d;this.resolve=e(this,this.resolve);this.reject=e(this,this.reject);this.notify=e(this,this.notify)}var g=I("$q",TypeError);P(d.prototype,{then:function(a,b,c){if(v(a)&&v(b)&&v(c))return this;var d=new h;this.$$state.pending=this.$$state.pending||[];this.$$state.pending.push([d,
a,b,c]);0<this.$$state.status&&f(this.$$state);return d.promise},"catch":function(a){return this.then(null,a)},"finally":function(a,b){return this.then(function(b){return k(b,!0,a)},function(b){return k(b,!1,a)},b)}});P(h.prototype,{resolve:function(a){this.promise.$$state.status||(a===this.promise?this.$$reject(g("qcycle",a)):this.$$resolve(a))},$$resolve:function(b){var d,e;e=c(this,this.$$resolve,this.$$reject);try{if(C(b)||x(b))d=b&&b.then;x(d)?(this.promise.$$state.status=-1,d.call(b,e[0],e[1],
this.notify)):(this.promise.$$state.value=b,this.promise.$$state.status=1,f(this.promise.$$state))}catch(g){e[1](g),a(g)}},reject:function(a){this.promise.$$state.status||this.$$reject(a)},$$reject:function(a){this.promise.$$state.value=a;this.promise.$$state.status=2;f(this.promise.$$state)},notify:function(c){var d=this.promise.$$state.pending;0>=this.promise.$$state.status&&d&&d.length&&b(function(){for(var b,e,f=0,g=d.length;f<g;f++){e=d[f][0];b=d[f][3];try{e.notify(x(b)?b(c):c)}catch(h){a(h)}}})}});
var l=function(a,b){var c=new h;b?c.resolve(a):c.reject(a);return c.promise},k=function(a,b,c){var d=null;try{x(c)&&(d=c())}catch(e){return l(e,!1)}return d&&x(d.then)?d.then(function(){return l(a,b)},function(a){return l(a,!1)}):l(a,b)},n=function(a,b,c,d){var e=new h;e.resolve(a);return e.promise.then(b,c,d)},p=function t(a){if(!x(a))throw g("norslvr",a);if(!(this instanceof t))return new t(a);var b=new h;a(function(a){b.resolve(a)},function(a){b.reject(a)});return b.promise};p.defer=function(){return new h};
p.reject=function(a){var b=new h;b.reject(a);return b.promise};p.when=n;p.resolve=n;p.all=function(a){var b=new h,c=0,d=J(a)?[]:{};m(a,function(a,e){c++;n(a).then(function(a){d.hasOwnProperty(e)||(d[e]=a,--c||b.resolve(d))},function(a){d.hasOwnProperty(e)||b.reject(a)})});0===c&&b.resolve(d);return b.promise};return p}function wf(){this.$get=["$window","$timeout",function(b,a){var c=b.requestAnimationFrame||b.webkitRequestAnimationFrame,d=b.cancelAnimationFrame||b.webkitCancelAnimationFrame||b.webkitCancelRequestAnimationFrame,
e=!!c,f=e?function(a){var b=c(a);return function(){d(b)}}:function(b){var c=a(b,16.66,!1);return function(){a.cancel(c)}};f.supported=e;return f}]}function lf(){function b(a){function b(){this.$$watchers=this.$$nextSibling=this.$$childHead=this.$$childTail=null;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$id=++nb;this.$$ChildScope=null}b.prototype=a;return b}var a=10,c=I("$rootScope"),d=null,e=null;this.digestTtl=function(b){arguments.length&&(a=b);return a};this.$get=
["$injector","$exceptionHandler","$parse","$browser",function(f,h,g,l){function k(a){a.currentScope.$$destroyed=!0}function n(){this.$id=++nb;this.$$phase=this.$parent=this.$$watchers=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=null;this.$root=this;this.$$destroyed=!1;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$$isolateBindings=null}function p(a){if(q.$$phase)throw c("inprog",q.$$phase);q.$$phase=a}function r(a,b){do a.$$watchersCount+=b;while(a=
a.$parent)}function t(a,b,c){do a.$$listenerCount[c]-=b,0===a.$$listenerCount[c]&&delete a.$$listenerCount[c];while(a=a.$parent)}function E(){}function s(){for(;w.length;)try{w.shift()()}catch(a){h(a)}e=null}function u(){null===e&&(e=l.defer(function(){q.$apply(s)}))}n.prototype={constructor:n,$new:function(a,c){var d;c=c||this;a?(d=new n,d.$root=this.$root):(this.$$ChildScope||(this.$$ChildScope=b(this)),d=new this.$$ChildScope);d.$parent=c;d.$$prevSibling=c.$$childTail;c.$$childHead?(c.$$childTail.$$nextSibling=
d,c.$$childTail=d):c.$$childHead=c.$$childTail=d;(a||c!=this)&&d.$on("$destroy",k);return d},$watch:function(a,b,c,e){var f=g(a);if(f.$$watchDelegate)return f.$$watchDelegate(this,b,c,f,a);var h=this,k=h.$$watchers,l={fn:b,last:E,get:f,exp:e||a,eq:!!c};d=null;x(b)||(l.fn=y);k||(k=h.$$watchers=[]);k.unshift(l);r(this,1);return function(){0<=cb(k,l)&&r(h,-1);d=null}},$watchGroup:function(a,b){function c(){h=!1;k?(k=!1,b(e,e,g)):b(e,d,g)}var d=Array(a.length),e=Array(a.length),f=[],g=this,h=!1,k=!0;
if(!a.length){var l=!0;g.$evalAsync(function(){l&&b(e,e,g)});return function(){l=!1}}if(1===a.length)return this.$watch(a[0],function(a,c,f){e[0]=a;d[0]=c;b(e,a===c?e:d,f)});m(a,function(a,b){var k=g.$watch(a,function(a,f){e[b]=a;d[b]=f;h||(h=!0,g.$evalAsync(c))});f.push(k)});return function(){for(;f.length;)f.shift()()}},$watchCollection:function(a,b){function c(a){e=a;var b,d,g,h;if(!v(e)){if(C(e))if(Da(e))for(f!==p&&(f=p,t=f.length=0,l++),a=e.length,t!==a&&(l++,f.length=t=a),b=0;b<a;b++)h=f[b],
g=e[b],d=h!==h&&g!==g,d||h===g||(l++,f[b]=g);else{f!==r&&(f=r={},t=0,l++);a=0;for(b in e)ta.call(e,b)&&(a++,g=e[b],h=f[b],b in f?(d=h!==h&&g!==g,d||h===g||(l++,f[b]=g)):(t++,f[b]=g,l++));if(t>a)for(b in l++,f)ta.call(e,b)||(t--,delete f[b])}else f!==e&&(f=e,l++);return l}}c.$stateful=!0;var d=this,e,f,h,k=1<b.length,l=0,n=g(a,c),p=[],r={},q=!0,t=0;return this.$watch(n,function(){q?(q=!1,b(e,e,d)):b(e,h,d);if(k)if(C(e))if(Da(e)){h=Array(e.length);for(var a=0;a<e.length;a++)h[a]=e[a]}else for(a in h=
{},e)ta.call(e,a)&&(h[a]=e[a]);else h=e})},$digest:function(){var b,f,g,k,n,r,t=a,m,u=[],D,v;p("$digest");l.$$checkUrlChange();this===q&&null!==e&&(l.defer.cancel(e),s());d=null;do{r=!1;for(m=this;z.length;){try{v=z.shift(),v.scope.$eval(v.expression,v.locals)}catch(w){h(w)}d=null}a:do{if(k=m.$$watchers)for(n=k.length;n--;)try{if(b=k[n])if((f=b.get(m))!==(g=b.last)&&!(b.eq?ka(f,g):"number"===typeof f&&"number"===typeof g&&isNaN(f)&&isNaN(g)))r=!0,d=b,b.last=b.eq?ha(f,null):f,b.fn(f,g===E?f:g,m),5>
t&&(D=4-t,u[D]||(u[D]=[]),u[D].push({msg:x(b.exp)?"fn: "+(b.exp.name||b.exp.toString()):b.exp,newVal:f,oldVal:g}));else if(b===d){r=!1;break a}}catch(y){h(y)}if(!(k=m.$$watchersCount&&m.$$childHead||m!==this&&m.$$nextSibling))for(;m!==this&&!(k=m.$$nextSibling);)m=m.$parent}while(m=k);if((r||z.length)&&!t--)throw q.$$phase=null,c("infdig",a,u);}while(r||z.length);for(q.$$phase=null;N.length;)try{N.shift()()}catch(A){h(A)}},$destroy:function(){if(!this.$$destroyed){var a=this.$parent;this.$broadcast("$destroy");
this.$$destroyed=!0;this===q&&l.$$applicationDestroyed();r(this,-this.$$watchersCount);for(var b in this.$$listenerCount)t(this,this.$$listenerCount[b],b);a&&a.$$childHead==this&&(a.$$childHead=this.$$nextSibling);a&&a.$$childTail==this&&(a.$$childTail=this.$$prevSibling);this.$$prevSibling&&(this.$$prevSibling.$$nextSibling=this.$$nextSibling);this.$$nextSibling&&(this.$$nextSibling.$$prevSibling=this.$$prevSibling);this.$destroy=this.$digest=this.$apply=this.$evalAsync=this.$applyAsync=y;this.$on=
this.$watch=this.$watchGroup=function(){return y};this.$$listeners={};this.$parent=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=this.$root=this.$$watchers=null}},$eval:function(a,b){return g(a)(this,b)},$evalAsync:function(a,b){q.$$phase||z.length||l.defer(function(){z.length&&q.$digest()});z.push({scope:this,expression:a,locals:b})},$$postDigest:function(a){N.push(a)},$apply:function(a){try{p("$apply");try{return this.$eval(a)}finally{q.$$phase=null}}catch(b){h(b)}finally{try{q.$digest()}catch(c){throw h(c),
c;}}},$applyAsync:function(a){function b(){c.$eval(a)}var c=this;a&&w.push(b);u()},$on:function(a,b){var c=this.$$listeners[a];c||(this.$$listeners[a]=c=[]);c.push(b);var d=this;do d.$$listenerCount[a]||(d.$$listenerCount[a]=0),d.$$listenerCount[a]++;while(d=d.$parent);var e=this;return function(){var d=c.indexOf(b);-1!==d&&(c[d]=null,t(e,1,a))}},$emit:function(a,b){var c=[],d,e=this,f=!1,g={name:a,targetScope:e,stopPropagation:function(){f=!0},preventDefault:function(){g.defaultPrevented=!0},defaultPrevented:!1},
k=db([g],arguments,1),l,n;do{d=e.$$listeners[a]||c;g.currentScope=e;l=0;for(n=d.length;l<n;l++)if(d[l])try{d[l].apply(null,k)}catch(p){h(p)}else d.splice(l,1),l--,n--;if(f)return g.currentScope=null,g;e=e.$parent}while(e);g.currentScope=null;return g},$broadcast:function(a,b){var c=this,d=this,e={name:a,targetScope:this,preventDefault:function(){e.defaultPrevented=!0},defaultPrevented:!1};if(!this.$$listenerCount[a])return e;for(var f=db([e],arguments,1),g,k;c=d;){e.currentScope=c;d=c.$$listeners[a]||
[];g=0;for(k=d.length;g<k;g++)if(d[g])try{d[g].apply(null,f)}catch(l){h(l)}else d.splice(g,1),g--,k--;if(!(d=c.$$listenerCount[a]&&c.$$childHead||c!==this&&c.$$nextSibling))for(;c!==this&&!(d=c.$$nextSibling);)c=c.$parent}e.currentScope=null;return e}};var q=new n,z=q.$$asyncQueue=[],N=q.$$postDigestQueue=[],w=q.$$applyAsyncQueue=[];return q}]}function ge(){var b=/^\s*(https?|ftp|mailto|tel|file):/,a=/^\s*((https?|ftp|file|blob):|data:image\/)/;this.aHrefSanitizationWhitelist=function(a){return A(a)?
(b=a,this):b};this.imgSrcSanitizationWhitelist=function(b){return A(b)?(a=b,this):a};this.$get=function(){return function(c,d){var e=d?a:b,f;f=Aa(c).href;return""===f||f.match(e)?c:"unsafe:"+f}}}function Zf(b){if("self"===b)return b;if(G(b)){if(-1<b.indexOf("***"))throw Ca("iwcard",b);b=vd(b).replace("\\*\\*",".*").replace("\\*","[^:/.?&;]*");return new RegExp("^"+b+"$")}if(Oa(b))return new RegExp("^"+b.source+"$");throw Ca("imatcher");}function wd(b){var a=[];A(b)&&m(b,function(b){a.push(Zf(b))});
return a}function pf(){this.SCE_CONTEXTS=oa;var b=["self"],a=[];this.resourceUrlWhitelist=function(a){arguments.length&&(b=wd(a));return b};this.resourceUrlBlacklist=function(b){arguments.length&&(a=wd(b));return a};this.$get=["$injector",function(c){function d(a,b){return"self"===a?fd(b):!!a.exec(b.href)}function e(a){var b=function(a){this.$$unwrapTrustedValue=function(){return a}};a&&(b.prototype=new a);b.prototype.valueOf=function(){return this.$$unwrapTrustedValue()};b.prototype.toString=function(){return this.$$unwrapTrustedValue().toString()};
return b}var f=function(a){throw Ca("unsafe");};c.has("$sanitize")&&(f=c.get("$sanitize"));var h=e(),g={};g[oa.HTML]=e(h);g[oa.CSS]=e(h);g[oa.URL]=e(h);g[oa.JS]=e(h);g[oa.RESOURCE_URL]=e(g[oa.URL]);return{trustAs:function(a,b){var c=g.hasOwnProperty(a)?g[a]:null;if(!c)throw Ca("icontext",a,b);if(null===b||v(b)||""===b)return b;if("string"!==typeof b)throw Ca("itype",a);return new c(b)},getTrusted:function(c,e){if(null===e||v(e)||""===e)return e;var h=g.hasOwnProperty(c)?g[c]:null;if(h&&e instanceof
h)return e.$$unwrapTrustedValue();if(c===oa.RESOURCE_URL){var h=Aa(e.toString()),p,r,t=!1;p=0;for(r=b.length;p<r;p++)if(d(b[p],h)){t=!0;break}if(t)for(p=0,r=a.length;p<r;p++)if(d(a[p],h)){t=!1;break}if(t)return e;throw Ca("insecurl",e.toString());}if(c===oa.HTML)return f(e);throw Ca("unsafe");},valueOf:function(a){return a instanceof h?a.$$unwrapTrustedValue():a}}}]}function of(){var b=!0;this.enabled=function(a){arguments.length&&(b=!!a);return b};this.$get=["$parse","$sceDelegate",function(a,c){if(b&&
8>Wa)throw Ca("iequirks");var d=ja(oa);d.isEnabled=function(){return b};d.trustAs=c.trustAs;d.getTrusted=c.getTrusted;d.valueOf=c.valueOf;b||(d.trustAs=d.getTrusted=function(a,b){return b},d.valueOf=$a);d.parseAs=function(b,c){var e=a(c);return e.literal&&e.constant?e:a(c,function(a){return d.getTrusted(b,a)})};var e=d.parseAs,f=d.getTrusted,h=d.trustAs;m(oa,function(a,b){var c=F(b);d[gb("parse_as_"+c)]=function(b){return e(a,b)};d[gb("get_trusted_"+c)]=function(b){return f(a,b)};d[gb("trust_as_"+
c)]=function(b){return h(a,b)}});return d}]}function qf(){this.$get=["$window","$document",function(b,a){var c={},d=Y((/android (\d+)/.exec(F((b.navigator||{}).userAgent))||[])[1]),e=/Boxee/i.test((b.navigator||{}).userAgent),f=a[0]||{},h,g=/^(Moz|webkit|ms)(?=[A-Z])/,l=f.body&&f.body.style,k=!1,n=!1;if(l){for(var p in l)if(k=g.exec(p)){h=k[0];h=h.substr(0,1).toUpperCase()+h.substr(1);break}h||(h="WebkitOpacity"in l&&"webkit");k=!!("transition"in l||h+"Transition"in l);n=!!("animation"in l||h+"Animation"in
l);!d||k&&n||(k=G(l.webkitTransition),n=G(l.webkitAnimation))}return{history:!(!b.history||!b.history.pushState||4>d||e),hasEvent:function(a){if("input"===a&&11>=Wa)return!1;if(v(c[a])){var b=f.createElement("div");c[a]="on"+a in b}return c[a]},csp:Fa(),vendorPrefix:h,transitions:k,animations:n,android:d}}]}function sf(){this.$get=["$templateCache","$http","$q","$sce",function(b,a,c,d){function e(f,h){e.totalPendingRequests++;G(f)&&b.get(f)||(f=d.getTrustedResourceUrl(f));var g=a.defaults&&a.defaults.transformResponse;
J(g)?g=g.filter(function(a){return a!==Zb}):g===Zb&&(g=null);return a.get(f,{cache:b,transformResponse:g})["finally"](function(){e.totalPendingRequests--}).then(function(a){b.put(f,a.data);return a.data},function(a){if(!h)throw ga("tpload",f,a.status,a.statusText);return c.reject(a)})}e.totalPendingRequests=0;return e}]}function tf(){this.$get=["$rootScope","$browser","$location",function(b,a,c){return{findBindings:function(a,b,c){a=a.getElementsByClassName("ng-binding");var h=[];m(a,function(a){var d=
da.element(a).data("$binding");d&&m(d,function(d){c?(new RegExp("(^|\\s)"+vd(b)+"(\\s|\\||$)")).test(d)&&h.push(a):-1!=d.indexOf(b)&&h.push(a)})});return h},findModels:function(a,b,c){for(var h=["ng-","data-ng-","ng\\:"],g=0;g<h.length;++g){var l=a.querySelectorAll("["+h[g]+"model"+(c?"=":"*=")+'"'+b+'"]');if(l.length)return l}},getLocation:function(){return c.url()},setLocation:function(a){a!==c.url()&&(c.url(a),b.$digest())},whenStable:function(b){a.notifyWhenNoOutstandingRequests(b)}}}]}function uf(){this.$get=
["$rootScope","$browser","$q","$$q","$exceptionHandler",function(b,a,c,d,e){function f(f,l,k){x(f)||(k=l,l=f,f=y);var n=ua.call(arguments,3),p=A(k)&&!k,r=(p?d:c).defer(),t=r.promise,m;m=a.defer(function(){try{r.resolve(f.apply(null,n))}catch(a){r.reject(a),e(a)}finally{delete h[t.$$timeoutId]}p||b.$apply()},l);t.$$timeoutId=m;h[m]=r;return t}var h={};f.cancel=function(b){return b&&b.$$timeoutId in h?(h[b.$$timeoutId].reject("canceled"),delete h[b.$$timeoutId],a.defer.cancel(b.$$timeoutId)):!1};return f}]}
function Aa(b){Wa&&($.setAttribute("href",b),b=$.href);$.setAttribute("href",b);return{href:$.href,protocol:$.protocol?$.protocol.replace(/:$/,""):"",host:$.host,search:$.search?$.search.replace(/^\?/,""):"",hash:$.hash?$.hash.replace(/^#/,""):"",hostname:$.hostname,port:$.port,pathname:"/"===$.pathname.charAt(0)?$.pathname:"/"+$.pathname}}function fd(b){b=G(b)?Aa(b):b;return b.protocol===xd.protocol&&b.host===xd.host}function vf(){this.$get=qa(Q)}function yd(b){function a(a){try{return decodeURIComponent(a)}catch(b){return a}}
var c=b[0]||{},d={},e="";return function(){var b,h,g,l,k;b=c.cookie||"";if(b!==e)for(e=b,b=e.split("; "),d={},g=0;g<b.length;g++)h=b[g],l=h.indexOf("="),0<l&&(k=a(h.substring(0,l)),v(d[k])&&(d[k]=a(h.substring(l+1))));return d}}function zf(){this.$get=yd}function Kc(b){function a(c,d){if(C(c)){var e={};m(c,function(b,c){e[c]=a(c,b)});return e}return b.factory(c+"Filter",d)}this.register=a;this.$get=["$injector",function(a){return function(b){return a.get(b+"Filter")}}];a("currency",zd);a("date",Ad);
a("filter",$f);a("json",ag);a("limitTo",bg);a("lowercase",cg);a("number",Bd);a("orderBy",Cd);a("uppercase",dg)}function $f(){return function(b,a,c){if(!Da(b)){if(null==b)return b;throw I("filter")("notarray",b);}var d;switch(gc(a)){case "function":break;case "boolean":case "null":case "number":case "string":d=!0;case "object":a=eg(a,c,d);break;default:return b}return Array.prototype.filter.call(b,a)}}function eg(b,a,c){var d=C(b)&&"$"in b;!0===a?a=ka:x(a)||(a=function(a,b){if(v(a))return!1;if(null===
a||null===b)return a===b;if(C(b)||C(a)&&!qc(a))return!1;a=F(""+a);b=F(""+b);return-1!==a.indexOf(b)});return function(e){return d&&!C(e)?Ma(e,b.$,a,!1):Ma(e,b,a,c)}}function Ma(b,a,c,d,e){var f=gc(b),h=gc(a);if("string"===h&&"!"===a.charAt(0))return!Ma(b,a.substring(1),c,d);if(J(b))return b.some(function(b){return Ma(b,a,c,d)});switch(f){case "object":var g;if(d){for(g in b)if("$"!==g.charAt(0)&&Ma(b[g],a,c,!0))return!0;return e?!1:Ma(b,a,c,!1)}if("object"===h){for(g in a)if(e=a[g],!x(e)&&!v(e)&&
(f="$"===g,!Ma(f?b:b[g],e,c,f,f)))return!1;return!0}return c(b,a);case "function":return!1;default:return c(b,a)}}function gc(b){return null===b?"null":typeof b}function zd(b){var a=b.NUMBER_FORMATS;return function(b,d,e){v(d)&&(d=a.CURRENCY_SYM);v(e)&&(e=a.PATTERNS[1].maxFrac);return null==b?b:Dd(b,a.PATTERNS[1],a.GROUP_SEP,a.DECIMAL_SEP,e).replace(/\u00A4/g,d)}}function Bd(b){var a=b.NUMBER_FORMATS;return function(b,d){return null==b?b:Dd(b,a.PATTERNS[0],a.GROUP_SEP,a.DECIMAL_SEP,d)}}function Dd(b,
a,c,d,e){if(C(b))return"";var f=0>b;b=Math.abs(b);var h=Infinity===b;if(!h&&!isFinite(b))return"";var g=b+"",l="",k=!1,n=[];h&&(l="\u221e");if(!h&&-1!==g.indexOf("e")){var p=g.match(/([\d\.]+)e(-?)(\d+)/);p&&"-"==p[2]&&p[3]>e+1?b=0:(l=g,k=!0)}if(h||k)0<e&&1>b&&(l=b.toFixed(e),b=parseFloat(l),l=l.replace(hc,d));else{h=(g.split(hc)[1]||"").length;v(e)&&(e=Math.min(Math.max(a.minFrac,h),a.maxFrac));b=+(Math.round(+(b.toString()+"e"+e)).toString()+"e"+-e);var h=(""+b).split(hc),g=h[0],h=h[1]||"",p=0,
r=a.lgSize,t=a.gSize;if(g.length>=r+t)for(p=g.length-r,k=0;k<p;k++)0===(p-k)%t&&0!==k&&(l+=c),l+=g.charAt(k);for(k=p;k<g.length;k++)0===(g.length-k)%r&&0!==k&&(l+=c),l+=g.charAt(k);for(;h.length<e;)h+="0";e&&"0"!==e&&(l+=d+h.substr(0,e))}0===b&&(f=!1);n.push(f?a.negPre:a.posPre,l,f?a.negSuf:a.posSuf);return n.join("")}function Gb(b,a,c){var d="";0>b&&(d="-",b=-b);for(b=""+b;b.length<a;)b="0"+b;c&&(b=b.substr(b.length-a));return d+b}function aa(b,a,c,d){c=c||0;return function(e){e=e["get"+b]();if(0<
c||e>-c)e+=c;0===e&&-12==c&&(e=12);return Gb(e,a,d)}}function Hb(b,a){return function(c,d){var e=c["get"+b](),f=sb(a?"SHORT"+b:b);return d[f][e]}}function Ed(b){var a=(new Date(b,0,1)).getDay();return new Date(b,0,(4>=a?5:12)-a)}function Fd(b){return function(a){var c=Ed(a.getFullYear());a=+new Date(a.getFullYear(),a.getMonth(),a.getDate()+(4-a.getDay()))-+c;a=1+Math.round(a/6048E5);return Gb(a,b)}}function ic(b,a){return 0>=b.getFullYear()?a.ERAS[0]:a.ERAS[1]}function Ad(b){function a(a){var b;if(b=
a.match(c)){a=new Date(0);var f=0,h=0,g=b[8]?a.setUTCFullYear:a.setFullYear,l=b[8]?a.setUTCHours:a.setHours;b[9]&&(f=Y(b[9]+b[10]),h=Y(b[9]+b[11]));g.call(a,Y(b[1]),Y(b[2])-1,Y(b[3]));f=Y(b[4]||0)-f;h=Y(b[5]||0)-h;g=Y(b[6]||0);b=Math.round(1E3*parseFloat("0."+(b[7]||0)));l.call(a,f,h,g,b)}return a}var c=/^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;return function(c,e,f){var h="",g=[],l,k;e=e||"mediumDate";e=b.DATETIME_FORMATS[e]||e;G(c)&&(c=
fg.test(c)?Y(c):a(c));V(c)&&(c=new Date(c));if(!ea(c)||!isFinite(c.getTime()))return c;for(;e;)(k=gg.exec(e))?(g=db(g,k,1),e=g.pop()):(g.push(e),e=null);var n=c.getTimezoneOffset();f&&(n=wc(f,c.getTimezoneOffset()),c=Ob(c,f,!0));m(g,function(a){l=hg[a];h+=l?l(c,b.DATETIME_FORMATS,n):a.replace(/(^'|'$)/g,"").replace(/''/g,"'")});return h}}function ag(){return function(b,a){v(a)&&(a=2);return eb(b,a)}}function bg(){return function(b,a,c){a=Infinity===Math.abs(Number(a))?Number(a):Y(a);if(isNaN(a))return b;
V(b)&&(b=b.toString());if(!J(b)&&!G(b))return b;c=!c||isNaN(c)?0:Y(c);c=0>c&&c>=-b.length?b.length+c:c;return 0<=a?b.slice(c,c+a):0===c?b.slice(a,b.length):b.slice(Math.max(0,c+a),c)}}function Cd(b){function a(a,c){c=c?-1:1;return a.map(function(a){var d=1,g=$a;if(x(a))g=a;else if(G(a)){if("+"==a.charAt(0)||"-"==a.charAt(0))d="-"==a.charAt(0)?-1:1,a=a.substring(1);if(""!==a&&(g=b(a),g.constant))var l=g(),g=function(a){return a[l]}}return{get:g,descending:d*c}})}function c(a){switch(typeof a){case "number":case "boolean":case "string":return!0;
default:return!1}}return function(b,e,f){if(!Da(b))return b;J(e)||(e=[e]);0===e.length&&(e=["+"]);var h=a(e,f);h.push({get:function(){return{}},descending:f?-1:1});b=Array.prototype.map.call(b,function(a,b){return{value:a,predicateValues:h.map(function(d){var e=d.get(a);d=typeof e;if(null===e)d="string",e="null";else if("string"===d)e=e.toLowerCase();else if("object"===d)a:{if("function"===typeof e.valueOf&&(e=e.valueOf(),c(e)))break a;if(qc(e)&&(e=e.toString(),c(e)))break a;e=b}return{value:e,type:d}})}});
b.sort(function(a,b){for(var c=0,d=0,e=h.length;d<e;++d){var c=a.predicateValues[d],f=b.predicateValues[d],t=0;c.type===f.type?c.value!==f.value&&(t=c.value<f.value?-1:1):t=c.type<f.type?-1:1;if(c=t*h[d].descending)break}return c});return b=b.map(function(a){return a.value})}}function Na(b){x(b)&&(b={link:b});b.restrict=b.restrict||"AC";return qa(b)}function Gd(b,a,c,d,e){var f=this,h=[];f.$error={};f.$$success={};f.$pending=w;f.$name=e(a.name||a.ngForm||"")(c);f.$dirty=!1;f.$pristine=!0;f.$valid=
!0;f.$invalid=!1;f.$submitted=!1;f.$$parentForm=Ib;f.$rollbackViewValue=function(){m(h,function(a){a.$rollbackViewValue()})};f.$commitViewValue=function(){m(h,function(a){a.$commitViewValue()})};f.$addControl=function(a){Ta(a.$name,"input");h.push(a);a.$name&&(f[a.$name]=a);a.$$parentForm=f};f.$$renameControl=function(a,b){var c=a.$name;f[c]===a&&delete f[c];f[b]=a;a.$name=b};f.$removeControl=function(a){a.$name&&f[a.$name]===a&&delete f[a.$name];m(f.$pending,function(b,c){f.$setValidity(c,null,a)});
m(f.$error,function(b,c){f.$setValidity(c,null,a)});m(f.$$success,function(b,c){f.$setValidity(c,null,a)});cb(h,a);a.$$parentForm=Ib};Hd({ctrl:this,$element:b,set:function(a,b,c){var d=a[b];d?-1===d.indexOf(c)&&d.push(c):a[b]=[c]},unset:function(a,b,c){var d=a[b];d&&(cb(d,c),0===d.length&&delete a[b])},$animate:d});f.$setDirty=function(){d.removeClass(b,Ya);d.addClass(b,Jb);f.$dirty=!0;f.$pristine=!1;f.$$parentForm.$setDirty()};f.$setPristine=function(){d.setClass(b,Ya,Jb+" ng-submitted");f.$dirty=
!1;f.$pristine=!0;f.$submitted=!1;m(h,function(a){a.$setPristine()})};f.$setUntouched=function(){m(h,function(a){a.$setUntouched()})};f.$setSubmitted=function(){d.addClass(b,"ng-submitted");f.$submitted=!0;f.$$parentForm.$setSubmitted()}}function jc(b){b.$formatters.push(function(a){return b.$isEmpty(a)?a:a.toString()})}function jb(b,a,c,d,e,f){var h=F(a[0].type);if(!e.android){var g=!1;a.on("compositionstart",function(a){g=!0});a.on("compositionend",function(){g=!1;l()})}var l=function(b){k&&(f.defer.cancel(k),
k=null);if(!g){var e=a.val();b=b&&b.type;"password"===h||c.ngTrim&&"false"===c.ngTrim||(e=T(e));(d.$viewValue!==e||""===e&&d.$$hasNativeValidators)&&d.$setViewValue(e,b)}};if(e.hasEvent("input"))a.on("input",l);else{var k,n=function(a,b,c){k||(k=f.defer(function(){k=null;b&&b.value===c||l(a)}))};a.on("keydown",function(a){var b=a.keyCode;91===b||15<b&&19>b||37<=b&&40>=b||n(a,this,this.value)});if(e.hasEvent("paste"))a.on("paste cut",n)}a.on("change",l);d.$render=function(){var b=d.$isEmpty(d.$viewValue)?
"":d.$viewValue;a.val()!==b&&a.val(b)}}function Kb(b,a){return function(c,d){var e,f;if(ea(c))return c;if(G(c)){'"'==c.charAt(0)&&'"'==c.charAt(c.length-1)&&(c=c.substring(1,c.length-1));if(ig.test(c))return new Date(c);b.lastIndex=0;if(e=b.exec(c))return e.shift(),f=d?{yyyy:d.getFullYear(),MM:d.getMonth()+1,dd:d.getDate(),HH:d.getHours(),mm:d.getMinutes(),ss:d.getSeconds(),sss:d.getMilliseconds()/1E3}:{yyyy:1970,MM:1,dd:1,HH:0,mm:0,ss:0,sss:0},m(e,function(b,c){c<a.length&&(f[a[c]]=+b)}),new Date(f.yyyy,
f.MM-1,f.dd,f.HH,f.mm,f.ss||0,1E3*f.sss||0)}return NaN}}function kb(b,a,c,d){return function(e,f,h,g,l,k,n){function p(a){return a&&!(a.getTime&&a.getTime()!==a.getTime())}function r(a){return A(a)&&!ea(a)?c(a)||w:a}Id(e,f,h,g);jb(e,f,h,g,l,k);var t=g&&g.$options&&g.$options.timezone,m;g.$$parserName=b;g.$parsers.push(function(b){return g.$isEmpty(b)?null:a.test(b)?(b=c(b,m),t&&(b=Ob(b,t)),b):w});g.$formatters.push(function(a){if(a&&!ea(a))throw lb("datefmt",a);if(p(a))return(m=a)&&t&&(m=Ob(m,t,!0)),
n("date")(a,d,t);m=null;return""});if(A(h.min)||h.ngMin){var s;g.$validators.min=function(a){return!p(a)||v(s)||c(a)>=s};h.$observe("min",function(a){s=r(a);g.$validate()})}if(A(h.max)||h.ngMax){var u;g.$validators.max=function(a){return!p(a)||v(u)||c(a)<=u};h.$observe("max",function(a){u=r(a);g.$validate()})}}}function Id(b,a,c,d){(d.$$hasNativeValidators=C(a[0].validity))&&d.$parsers.push(function(b){var c=a.prop("validity")||{};return c.badInput&&!c.typeMismatch?w:b})}function Jd(b,a,c,d,e){if(A(d)){b=
b(d);if(!b.constant)throw lb("constexpr",c,d);return b(a)}return e}function kc(b,a){b="ngClass"+b;return["$animate",function(c){function d(a,b){var c=[],d=0;a:for(;d<a.length;d++){for(var e=a[d],n=0;n<b.length;n++)if(e==b[n])continue a;c.push(e)}return c}function e(a){var b=[];return J(a)?(m(a,function(a){b=b.concat(e(a))}),b):G(a)?a.split(" "):C(a)?(m(a,function(a,c){a&&(b=b.concat(c.split(" ")))}),b):a}return{restrict:"AC",link:function(f,h,g){function l(a,b){var c=h.data("$classCounts")||fa(),
d=[];m(a,function(a){if(0<b||c[a])c[a]=(c[a]||0)+b,c[a]===+(0<b)&&d.push(a)});h.data("$classCounts",c);return d.join(" ")}function k(b){if(!0===a||f.$index%2===a){var k=e(b||[]);if(!n){var m=l(k,1);g.$addClass(m)}else if(!ka(b,n)){var s=e(n),m=d(k,s),k=d(s,k),m=l(m,1),k=l(k,-1);m&&m.length&&c.addClass(h,m);k&&k.length&&c.removeClass(h,k)}}n=ja(b)}var n;f.$watch(g[b],k,!0);g.$observe("class",function(a){k(f.$eval(g[b]))});"ngClass"!==b&&f.$watch("$index",function(c,d){var h=c&1;if(h!==(d&1)){var k=
e(f.$eval(g[b]));h===a?(h=l(k,1),g.$addClass(h)):(h=l(k,-1),g.$removeClass(h))}})}}}]}function Hd(b){function a(a,b){b&&!f[a]?(l.addClass(e,a),f[a]=!0):!b&&f[a]&&(l.removeClass(e,a),f[a]=!1)}function c(b,c){b=b?"-"+Ac(b,"-"):"";a(mb+b,!0===c);a(Kd+b,!1===c)}var d=b.ctrl,e=b.$element,f={},h=b.set,g=b.unset,l=b.$animate;f[Kd]=!(f[mb]=e.hasClass(mb));d.$setValidity=function(b,e,f){v(e)?(d.$pending||(d.$pending={}),h(d.$pending,b,f)):(d.$pending&&g(d.$pending,b,f),Ld(d.$pending)&&(d.$pending=w));bb(e)?
e?(g(d.$error,b,f),h(d.$$success,b,f)):(h(d.$error,b,f),g(d.$$success,b,f)):(g(d.$error,b,f),g(d.$$success,b,f));d.$pending?(a(Md,!0),d.$valid=d.$invalid=w,c("",null)):(a(Md,!1),d.$valid=Ld(d.$error),d.$invalid=!d.$valid,c("",d.$valid));e=d.$pending&&d.$pending[b]?w:d.$error[b]?!1:d.$$success[b]?!0:null;c(b,e);d.$$parentForm.$setValidity(b,e,d)}}function Ld(b){if(b)for(var a in b)if(b.hasOwnProperty(a))return!1;return!0}var jg=/^\/(.+)\/([a-z]*)$/,F=function(b){return G(b)?b.toLowerCase():b},ta=Object.prototype.hasOwnProperty,
sb=function(b){return G(b)?b.toUpperCase():b},Wa,B,ra,ua=[].slice,Nf=[].splice,kg=[].push,va=Object.prototype.toString,rc=Object.getPrototypeOf,Ea=I("ng"),da=Q.angular||(Q.angular={}),Rb,nb=0;Wa=X.documentMode;y.$inject=[];$a.$inject=[];var J=Array.isArray,tc=/^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/,T=function(b){return G(b)?b.trim():b},vd=function(b){return b.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")},Fa=function(){if(!A(Fa.rules)){var b=
X.querySelector("[ng-csp]")||X.querySelector("[data-ng-csp]");if(b){var a=b.getAttribute("ng-csp")||b.getAttribute("data-ng-csp");Fa.rules={noUnsafeEval:!a||-1!==a.indexOf("no-unsafe-eval"),noInlineStyle:!a||-1!==a.indexOf("no-inline-style")}}else{b=Fa;try{new Function(""),a=!1}catch(c){a=!0}b.rules={noUnsafeEval:a,noInlineStyle:!1}}}return Fa.rules},pb=function(){if(A(pb.name_))return pb.name_;var b,a,c=Qa.length,d,e;for(a=0;a<c;++a)if(d=Qa[a],b=X.querySelector("["+d.replace(":","\\:")+"jq]")){e=
b.getAttribute(d+"jq");break}return pb.name_=e},Qa=["ng-","data-ng-","ng:","x-ng-"],be=/[A-Z]/g,Bc=!1,Qb,pa=1,Pa=3,fe={full:"1.4.7",major:1,minor:4,dot:7,codeName:"dark-luminescence"};R.expando="ng339";var hb=R.cache={},Ff=1;R._data=function(b){return this.cache[b[this.expando]]||{}};var Af=/([\:\-\_]+(.))/g,Bf=/^moz([A-Z])/,lg={mouseleave:"mouseout",mouseenter:"mouseover"},Tb=I("jqLite"),Ef=/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,Sb=/<|&#?\w+;/,Cf=/<([\w:-]+)/,Df=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
ma={option:[1,'<select multiple="multiple">',"</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ma.optgroup=ma.option;ma.tbody=ma.tfoot=ma.colgroup=ma.caption=ma.thead;ma.th=ma.td;var Ra=R.prototype={ready:function(b){function a(){c||(c=!0,b())}var c=!1;"complete"===X.readyState?setTimeout(a):(this.on("DOMContentLoaded",a),R(Q).on("load",a))},
toString:function(){var b=[];m(this,function(a){b.push(""+a)});return"["+b.join(", ")+"]"},eq:function(b){return 0<=b?B(this[b]):B(this[this.length+b])},length:0,push:kg,sort:[].sort,splice:[].splice},Bb={};m("multiple selected checked disabled readOnly required open".split(" "),function(b){Bb[F(b)]=b});var Sc={};m("input select option textarea button form details".split(" "),function(b){Sc[b]=!0});var $c={ngMinlength:"minlength",ngMaxlength:"maxlength",ngMin:"min",ngMax:"max",ngPattern:"pattern"};
m({data:Vb,removeData:vb,hasData:function(b){for(var a in hb[b.ng339])return!0;return!1}},function(b,a){R[a]=b});m({data:Vb,inheritedData:Ab,scope:function(b){return B.data(b,"$scope")||Ab(b.parentNode||b,["$isolateScope","$scope"])},isolateScope:function(b){return B.data(b,"$isolateScope")||B.data(b,"$isolateScopeNoTemplate")},controller:Pc,injector:function(b){return Ab(b,"$injector")},removeAttr:function(b,a){b.removeAttribute(a)},hasClass:xb,css:function(b,a,c){a=gb(a);if(A(c))b.style[a]=c;else return b.style[a]},
attr:function(b,a,c){var d=b.nodeType;if(d!==Pa&&2!==d&&8!==d)if(d=F(a),Bb[d])if(A(c))c?(b[a]=!0,b.setAttribute(a,d)):(b[a]=!1,b.removeAttribute(d));else return b[a]||(b.attributes.getNamedItem(a)||y).specified?d:w;else if(A(c))b.setAttribute(a,c);else if(b.getAttribute)return b=b.getAttribute(a,2),null===b?w:b},prop:function(b,a,c){if(A(c))b[a]=c;else return b[a]},text:function(){function b(a,b){if(v(b)){var d=a.nodeType;return d===pa||d===Pa?a.textContent:""}a.textContent=b}b.$dv="";return b}(),
val:function(b,a){if(v(a)){if(b.multiple&&"select"===wa(b)){var c=[];m(b.options,function(a){a.selected&&c.push(a.value||a.text)});return 0===c.length?null:c}return b.value}b.value=a},html:function(b,a){if(v(a))return b.innerHTML;ub(b,!0);b.innerHTML=a},empty:Qc},function(b,a){R.prototype[a]=function(a,d){var e,f,h=this.length;if(b!==Qc&&v(2==b.length&&b!==xb&&b!==Pc?a:d)){if(C(a)){for(e=0;e<h;e++)if(b===Vb)b(this[e],a);else for(f in a)b(this[e],f,a[f]);return this}e=b.$dv;h=v(e)?Math.min(h,1):h;
for(f=0;f<h;f++){var g=b(this[f],a,d);e=e?e+g:g}return e}for(e=0;e<h;e++)b(this[e],a,d);return this}});m({removeData:vb,on:function a(c,d,e,f){if(A(f))throw Tb("onargs");if(Lc(c)){var h=wb(c,!0);f=h.events;var g=h.handle;g||(g=h.handle=Hf(c,f));for(var h=0<=d.indexOf(" ")?d.split(" "):[d],l=h.length;l--;){d=h[l];var k=f[d];k||(f[d]=[],"mouseenter"===d||"mouseleave"===d?a(c,lg[d],function(a){var c=a.relatedTarget;c&&(c===this||this.contains(c))||g(a,d)}):"$destroy"!==d&&c.addEventListener(d,g,!1),
k=f[d]);k.push(e)}}},off:Oc,one:function(a,c,d){a=B(a);a.on(c,function f(){a.off(c,d);a.off(c,f)});a.on(c,d)},replaceWith:function(a,c){var d,e=a.parentNode;ub(a);m(new R(c),function(c){d?e.insertBefore(c,d.nextSibling):e.replaceChild(c,a);d=c})},children:function(a){var c=[];m(a.childNodes,function(a){a.nodeType===pa&&c.push(a)});return c},contents:function(a){return a.contentDocument||a.childNodes||[]},append:function(a,c){var d=a.nodeType;if(d===pa||11===d){c=new R(c);for(var d=0,e=c.length;d<
e;d++)a.appendChild(c[d])}},prepend:function(a,c){if(a.nodeType===pa){var d=a.firstChild;m(new R(c),function(c){a.insertBefore(c,d)})}},wrap:function(a,c){c=B(c).eq(0).clone()[0];var d=a.parentNode;d&&d.replaceChild(c,a);c.appendChild(a)},remove:Wb,detach:function(a){Wb(a,!0)},after:function(a,c){var d=a,e=a.parentNode;c=new R(c);for(var f=0,h=c.length;f<h;f++){var g=c[f];e.insertBefore(g,d.nextSibling);d=g}},addClass:zb,removeClass:yb,toggleClass:function(a,c,d){c&&m(c.split(" "),function(c){var f=
d;v(f)&&(f=!xb(a,c));(f?zb:yb)(a,c)})},parent:function(a){return(a=a.parentNode)&&11!==a.nodeType?a:null},next:function(a){return a.nextElementSibling},find:function(a,c){return a.getElementsByTagName?a.getElementsByTagName(c):[]},clone:Ub,triggerHandler:function(a,c,d){var e,f,h=c.type||c,g=wb(a);if(g=(g=g&&g.events)&&g[h])e={preventDefault:function(){this.defaultPrevented=!0},isDefaultPrevented:function(){return!0===this.defaultPrevented},stopImmediatePropagation:function(){this.immediatePropagationStopped=
!0},isImmediatePropagationStopped:function(){return!0===this.immediatePropagationStopped},stopPropagation:y,type:h,target:a},c.type&&(e=P(e,c)),c=ja(g),f=d?[e].concat(d):[e],m(c,function(c){e.isImmediatePropagationStopped()||c.apply(a,f)})}},function(a,c){R.prototype[c]=function(c,e,f){for(var h,g=0,l=this.length;g<l;g++)v(h)?(h=a(this[g],c,e,f),A(h)&&(h=B(h))):Nc(h,a(this[g],c,e,f));return A(h)?h:this};R.prototype.bind=R.prototype.on;R.prototype.unbind=R.prototype.off});Ua.prototype={put:function(a,
c){this[Ga(a,this.nextUid)]=c},get:function(a){return this[Ga(a,this.nextUid)]},remove:function(a){var c=this[a=Ga(a,this.nextUid)];delete this[a];return c}};var yf=[function(){this.$get=[function(){return Ua}]}],Uc=/^[^\(]*\(\s*([^\)]*)\)/m,mg=/,/,ng=/^\s*(_?)(\S+?)\1\s*$/,Tc=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg,Ha=I("$injector");fb.$$annotate=function(a,c,d){var e;if("function"===typeof a){if(!(e=a.$inject)){e=[];if(a.length){if(c)throw G(d)&&d||(d=a.name||If(a)),Ha("strictdi",d);c=a.toString().replace(Tc,
"");c=c.match(Uc);m(c[1].split(mg),function(a){a.replace(ng,function(a,c,d){e.push(d)})})}a.$inject=e}}else J(a)?(c=a.length-1,Sa(a[c],"fn"),e=a.slice(0,c)):Sa(a,"fn",!0);return e};var Nd=I("$animate"),Ue=function(){this.$get=["$q","$$rAF",function(a,c){function d(){}d.all=y;d.chain=y;d.prototype={end:y,cancel:y,resume:y,pause:y,complete:y,then:function(d,f){return a(function(a){c(function(){a()})}).then(d,f)}};return d}]},Te=function(){var a=new Ua,c=[];this.$get=["$$AnimateRunner","$rootScope",
function(d,e){function f(a,c,d){var e=!1;c&&(c=G(c)?c.split(" "):J(c)?c:[],m(c,function(c){c&&(e=!0,a[c]=d)}));return e}function h(){m(c,function(c){var d=a.get(c);if(d){var e=Jf(c.attr("class")),f="",h="";m(d,function(a,c){a!==!!e[c]&&(a?f+=(f.length?" ":"")+c:h+=(h.length?" ":"")+c)});m(c,function(a){f&&zb(a,f);h&&yb(a,h)});a.remove(c)}});c.length=0}return{enabled:y,on:y,off:y,pin:y,push:function(g,l,k,n){n&&n();k=k||{};k.from&&g.css(k.from);k.to&&g.css(k.to);if(k.addClass||k.removeClass)if(l=k.addClass,
n=k.removeClass,k=a.get(g)||{},l=f(k,l,!0),n=f(k,n,!1),l||n)a.put(g,k),c.push(g),1===c.length&&e.$$postDigest(h);return new d}}}]},Re=["$provide",function(a){var c=this;this.$$registeredAnimations=Object.create(null);this.register=function(d,e){if(d&&"."!==d.charAt(0))throw Nd("notcsel",d);var f=d+"-animation";c.$$registeredAnimations[d.substr(1)]=f;a.factory(f,e)};this.classNameFilter=function(a){if(1===arguments.length&&(this.$$classNameFilter=a instanceof RegExp?a:null)&&/(\s+|\/)ng-animate(\s+|\/)/.test(this.$$classNameFilter.toString()))throw Nd("nongcls",
"ng-animate");return this.$$classNameFilter};this.$get=["$$animateQueue",function(a){function c(a,d,e){if(e){var l;a:{for(l=0;l<e.length;l++){var k=e[l];if(1===k.nodeType){l=k;break a}}l=void 0}!l||l.parentNode||l.previousElementSibling||(e=null)}e?e.after(a):d.prepend(a)}return{on:a.on,off:a.off,pin:a.pin,enabled:a.enabled,cancel:function(a){a.end&&a.end()},enter:function(f,h,g,l){h=h&&B(h);g=g&&B(g);h=h||g.parent();c(f,h,g);return a.push(f,"enter",Ia(l))},move:function(f,h,g,l){h=h&&B(h);g=g&&B(g);
h=h||g.parent();c(f,h,g);return a.push(f,"move",Ia(l))},leave:function(c,e){return a.push(c,"leave",Ia(e),function(){c.remove()})},addClass:function(c,e,g){g=Ia(g);g.addClass=ib(g.addclass,e);return a.push(c,"addClass",g)},removeClass:function(c,e,g){g=Ia(g);g.removeClass=ib(g.removeClass,e);return a.push(c,"removeClass",g)},setClass:function(c,e,g,l){l=Ia(l);l.addClass=ib(l.addClass,e);l.removeClass=ib(l.removeClass,g);return a.push(c,"setClass",l)},animate:function(c,e,g,l,k){k=Ia(k);k.from=k.from?
P(k.from,e):e;k.to=k.to?P(k.to,g):g;k.tempClasses=ib(k.tempClasses,l||"ng-inline-animate");return a.push(c,"animate",k)}}}]}],Se=function(){this.$get=["$$rAF","$q",function(a,c){var d=function(){};d.prototype={done:function(a){this.defer&&this.defer[!0===a?"reject":"resolve"]()},end:function(){this.done()},cancel:function(){this.done(!0)},getPromise:function(){this.defer||(this.defer=c.defer());return this.defer.promise},then:function(a,c){return this.getPromise().then(a,c)},"catch":function(a){return this.getPromise()["catch"](a)},
"finally":function(a){return this.getPromise()["finally"](a)}};return function(c,f){function h(){a(function(){f.addClass&&(c.addClass(f.addClass),f.addClass=null);f.removeClass&&(c.removeClass(f.removeClass),f.removeClass=null);f.to&&(c.css(f.to),f.to=null);g||l.done();g=!0});return l}f.cleanupStyles&&(f.from=f.to=null);f.from&&(c.css(f.from),f.from=null);var g,l=new d;return{start:h,end:h}}}]},ga=I("$compile");Dc.$inject=["$provide","$$sanitizeUriProvider"];var Wc=/^((?:x|data)[\:\-_])/i,Of=I("$controller"),
Vc=/^(\S+)(\s+as\s+(\w+))?$/,$e=function(){this.$get=["$document",function(a){return function(c){c?!c.nodeType&&c instanceof B&&(c=c[0]):c=a[0].body;return c.offsetWidth+1}}]},ad="application/json",$b={"Content-Type":ad+";charset=utf-8"},Qf=/^\[|^\{(?!\{)/,Rf={"[":/]$/,"{":/}$/},Pf=/^\)\]\}',?\n/,og=I("$http"),ed=function(a){return function(){throw og("legacy",a);}},La=da.$interpolateMinErr=I("$interpolate");La.throwNoconcat=function(a){throw La("noconcat",a);};La.interr=function(a,c){return La("interr",
a,c.toString())};var pg=/^([^\?#]*)(\?([^#]*))?(#(.*))?$/,Tf={http:80,https:443,ftp:21},Db=I("$location"),qg={$$html5:!1,$$replace:!1,absUrl:Eb("$$absUrl"),url:function(a){if(v(a))return this.$$url;var c=pg.exec(a);(c[1]||""===a)&&this.path(decodeURIComponent(c[1]));(c[2]||c[1]||""===a)&&this.search(c[3]||"");this.hash(c[5]||"");return this},protocol:Eb("$$protocol"),host:Eb("$$host"),port:Eb("$$port"),path:jd("$$path",function(a){a=null!==a?a.toString():"";return"/"==a.charAt(0)?a:"/"+a}),search:function(a,
c){switch(arguments.length){case 0:return this.$$search;case 1:if(G(a)||V(a))a=a.toString(),this.$$search=yc(a);else if(C(a))a=ha(a,{}),m(a,function(c,e){null==c&&delete a[e]}),this.$$search=a;else throw Db("isrcharg");break;default:v(c)||null===c?delete this.$$search[a]:this.$$search[a]=c}this.$$compose();return this},hash:jd("$$hash",function(a){return null!==a?a.toString():""}),replace:function(){this.$$replace=!0;return this}};m([id,cc,bc],function(a){a.prototype=Object.create(qg);a.prototype.state=
function(c){if(!arguments.length)return this.$$state;if(a!==bc||!this.$$html5)throw Db("nostate");this.$$state=v(c)?null:c;return this}});var Z=I("$parse"),Uf=Function.prototype.call,Vf=Function.prototype.apply,Wf=Function.prototype.bind,Lb=fa();m("+ - * / % === !== == != < > <= >= && || ! = |".split(" "),function(a){Lb[a]=!0});var rg={n:"\n",f:"\f",r:"\r",t:"\t",v:"\v","'":"'",'"':'"'},ec=function(a){this.options=a};ec.prototype={constructor:ec,lex:function(a){this.text=a;this.index=0;for(this.tokens=
[];this.index<this.text.length;)if(a=this.text.charAt(this.index),'"'===a||"'"===a)this.readString(a);else if(this.isNumber(a)||"."===a&&this.isNumber(this.peek()))this.readNumber();else if(this.isIdent(a))this.readIdent();else if(this.is(a,"(){}[].,;:?"))this.tokens.push({index:this.index,text:a}),this.index++;else if(this.isWhitespace(a))this.index++;else{var c=a+this.peek(),d=c+this.peek(2),e=Lb[c],f=Lb[d];Lb[a]||e||f?(a=f?d:e?c:a,this.tokens.push({index:this.index,text:a,operator:!0}),this.index+=
a.length):this.throwError("Unexpected next character ",this.index,this.index+1)}return this.tokens},is:function(a,c){return-1!==c.indexOf(a)},peek:function(a){a=a||1;return this.index+a<this.text.length?this.text.charAt(this.index+a):!1},isNumber:function(a){return"0"<=a&&"9">=a&&"string"===typeof a},isWhitespace:function(a){return" "===a||"\r"===a||"\t"===a||"\n"===a||"\v"===a||"\u00a0"===a},isIdent:function(a){return"a"<=a&&"z">=a||"A"<=a&&"Z">=a||"_"===a||"$"===a},isExpOperator:function(a){return"-"===
a||"+"===a||this.isNumber(a)},throwError:function(a,c,d){d=d||this.index;c=A(c)?"s "+c+"-"+this.index+" ["+this.text.substring(c,d)+"]":" "+d;throw Z("lexerr",a,c,this.text);},readNumber:function(){for(var a="",c=this.index;this.index<this.text.length;){var d=F(this.text.charAt(this.index));if("."==d||this.isNumber(d))a+=d;else{var e=this.peek();if("e"==d&&this.isExpOperator(e))a+=d;else if(this.isExpOperator(d)&&e&&this.isNumber(e)&&"e"==a.charAt(a.length-1))a+=d;else if(!this.isExpOperator(d)||
e&&this.isNumber(e)||"e"!=a.charAt(a.length-1))break;else this.throwError("Invalid exponent")}this.index++}this.tokens.push({index:c,text:a,constant:!0,value:Number(a)})},readIdent:function(){for(var a=this.index;this.index<this.text.length;){var c=this.text.charAt(this.index);if(!this.isIdent(c)&&!this.isNumber(c))break;this.index++}this.tokens.push({index:a,text:this.text.slice(a,this.index),identifier:!0})},readString:function(a){var c=this.index;this.index++;for(var d="",e=a,f=!1;this.index<this.text.length;){var h=
this.text.charAt(this.index),e=e+h;if(f)"u"===h?(f=this.text.substring(this.index+1,this.index+5),f.match(/[\da-f]{4}/i)||this.throwError("Invalid unicode escape [\\u"+f+"]"),this.index+=4,d+=String.fromCharCode(parseInt(f,16))):d+=rg[h]||h,f=!1;else if("\\"===h)f=!0;else{if(h===a){this.index++;this.tokens.push({index:c,text:e,constant:!0,value:d});return}d+=h}this.index++}this.throwError("Unterminated quote",c)}};var s=function(a,c){this.lexer=a;this.options=c};s.Program="Program";s.ExpressionStatement=
"ExpressionStatement";s.AssignmentExpression="AssignmentExpression";s.ConditionalExpression="ConditionalExpression";s.LogicalExpression="LogicalExpression";s.BinaryExpression="BinaryExpression";s.UnaryExpression="UnaryExpression";s.CallExpression="CallExpression";s.MemberExpression="MemberExpression";s.Identifier="Identifier";s.Literal="Literal";s.ArrayExpression="ArrayExpression";s.Property="Property";s.ObjectExpression="ObjectExpression";s.ThisExpression="ThisExpression";s.NGValueParameter="NGValueParameter";
s.prototype={ast:function(a){this.text=a;this.tokens=this.lexer.lex(a);a=this.program();0!==this.tokens.length&&this.throwError("is an unexpected token",this.tokens[0]);return a},program:function(){for(var a=[];;)if(0<this.tokens.length&&!this.peek("}",")",";","]")&&a.push(this.expressionStatement()),!this.expect(";"))return{type:s.Program,body:a}},expressionStatement:function(){return{type:s.ExpressionStatement,expression:this.filterChain()}},filterChain:function(){for(var a=this.expression();this.expect("|");)a=
this.filter(a);return a},expression:function(){return this.assignment()},assignment:function(){var a=this.ternary();this.expect("=")&&(a={type:s.AssignmentExpression,left:a,right:this.assignment(),operator:"="});return a},ternary:function(){var a=this.logicalOR(),c,d;return this.expect("?")&&(c=this.expression(),this.consume(":"))?(d=this.expression(),{type:s.ConditionalExpression,test:a,alternate:c,consequent:d}):a},logicalOR:function(){for(var a=this.logicalAND();this.expect("||");)a={type:s.LogicalExpression,
operator:"||",left:a,right:this.logicalAND()};return a},logicalAND:function(){for(var a=this.equality();this.expect("&&");)a={type:s.LogicalExpression,operator:"&&",left:a,right:this.equality()};return a},equality:function(){for(var a=this.relational(),c;c=this.expect("==","!=","===","!==");)a={type:s.BinaryExpression,operator:c.text,left:a,right:this.relational()};return a},relational:function(){for(var a=this.additive(),c;c=this.expect("<",">","<=",">=");)a={type:s.BinaryExpression,operator:c.text,
left:a,right:this.additive()};return a},additive:function(){for(var a=this.multiplicative(),c;c=this.expect("+","-");)a={type:s.BinaryExpression,operator:c.text,left:a,right:this.multiplicative()};return a},multiplicative:function(){for(var a=this.unary(),c;c=this.expect("*","/","%");)a={type:s.BinaryExpression,operator:c.text,left:a,right:this.unary()};return a},unary:function(){var a;return(a=this.expect("+","-","!"))?{type:s.UnaryExpression,operator:a.text,prefix:!0,argument:this.unary()}:this.primary()},
primary:function(){var a;this.expect("(")?(a=this.filterChain(),this.consume(")")):this.expect("[")?a=this.arrayDeclaration():this.expect("{")?a=this.object():this.constants.hasOwnProperty(this.peek().text)?a=ha(this.constants[this.consume().text]):this.peek().identifier?a=this.identifier():this.peek().constant?a=this.constant():this.throwError("not a primary expression",this.peek());for(var c;c=this.expect("(","[",".");)"("===c.text?(a={type:s.CallExpression,callee:a,arguments:this.parseArguments()},
this.consume(")")):"["===c.text?(a={type:s.MemberExpression,object:a,property:this.expression(),computed:!0},this.consume("]")):"."===c.text?a={type:s.MemberExpression,object:a,property:this.identifier(),computed:!1}:this.throwError("IMPOSSIBLE");return a},filter:function(a){a=[a];for(var c={type:s.CallExpression,callee:this.identifier(),arguments:a,filter:!0};this.expect(":");)a.push(this.expression());return c},parseArguments:function(){var a=[];if(")"!==this.peekToken().text){do a.push(this.expression());
while(this.expect(","))}return a},identifier:function(){var a=this.consume();a.identifier||this.throwError("is not a valid identifier",a);return{type:s.Identifier,name:a.text}},constant:function(){return{type:s.Literal,value:this.consume().value}},arrayDeclaration:function(){var a=[];if("]"!==this.peekToken().text){do{if(this.peek("]"))break;a.push(this.expression())}while(this.expect(","))}this.consume("]");return{type:s.ArrayExpression,elements:a}},object:function(){var a=[],c;if("}"!==this.peekToken().text){do{if(this.peek("}"))break;
c={type:s.Property,kind:"init"};this.peek().constant?c.key=this.constant():this.peek().identifier?c.key=this.identifier():this.throwError("invalid key",this.peek());this.consume(":");c.value=this.expression();a.push(c)}while(this.expect(","))}this.consume("}");return{type:s.ObjectExpression,properties:a}},throwError:function(a,c){throw Z("syntax",c.text,a,c.index+1,this.text,this.text.substring(c.index));},consume:function(a){if(0===this.tokens.length)throw Z("ueoe",this.text);var c=this.expect(a);
c||this.throwError("is unexpected, expecting ["+a+"]",this.peek());return c},peekToken:function(){if(0===this.tokens.length)throw Z("ueoe",this.text);return this.tokens[0]},peek:function(a,c,d,e){return this.peekAhead(0,a,c,d,e)},peekAhead:function(a,c,d,e,f){if(this.tokens.length>a){a=this.tokens[a];var h=a.text;if(h===c||h===d||h===e||h===f||!(c||d||e||f))return a}return!1},expect:function(a,c,d,e){return(a=this.peek(a,c,d,e))?(this.tokens.shift(),a):!1},constants:{"true":{type:s.Literal,value:!0},
"false":{type:s.Literal,value:!1},"null":{type:s.Literal,value:null},undefined:{type:s.Literal,value:w},"this":{type:s.ThisExpression}}};sd.prototype={compile:function(a,c){var d=this,e=this.astBuilder.ast(a);this.state={nextId:0,filters:{},expensiveChecks:c,fn:{vars:[],body:[],own:{}},assign:{vars:[],body:[],own:{}},inputs:[]};U(e,d.$filter);var f="",h;this.stage="assign";if(h=qd(e))this.state.computing="assign",f=this.nextId(),this.recurse(h,f),this.return_(f),f="fn.assign="+this.generateFunction("assign",
"s,v,l");h=od(e.body);d.stage="inputs";m(h,function(a,c){var e="fn"+c;d.state[e]={vars:[],body:[],own:{}};d.state.computing=e;var f=d.nextId();d.recurse(a,f);d.return_(f);d.state.inputs.push(e);a.watchId=c});this.state.computing="fn";this.stage="main";this.recurse(e);f='"'+this.USE+" "+this.STRICT+'";\n'+this.filterPrefix()+"var fn="+this.generateFunction("fn","s,l,a,i")+f+this.watchFns()+"return fn;";f=(new Function("$filter","ensureSafeMemberName","ensureSafeObject","ensureSafeFunction","getStringValue",
"ensureSafeAssignContext","ifDefined","plus","text",f))(this.$filter,Xa,Ba,ld,kd,md,Xf,nd,a);this.state=this.stage=w;f.literal=rd(e);f.constant=e.constant;return f},USE:"use",STRICT:"strict",watchFns:function(){var a=[],c=this.state.inputs,d=this;m(c,function(c){a.push("var "+c+"="+d.generateFunction(c,"s"))});c.length&&a.push("fn.inputs=["+c.join(",")+"];");return a.join("")},generateFunction:function(a,c){return"function("+c+"){"+this.varsPrefix(a)+this.body(a)+"};"},filterPrefix:function(){var a=
[],c=this;m(this.state.filters,function(d,e){a.push(d+"=$filter("+c.escape(e)+")")});return a.length?"var "+a.join(",")+";":""},varsPrefix:function(a){return this.state[a].vars.length?"var "+this.state[a].vars.join(",")+";":""},body:function(a){return this.state[a].body.join("")},recurse:function(a,c,d,e,f,h){var g,l,k=this,n,p;e=e||y;if(!h&&A(a.watchId))c=c||this.nextId(),this.if_("i",this.lazyAssign(c,this.computedMember("i",a.watchId)),this.lazyRecurse(a,c,d,e,f,!0));else switch(a.type){case s.Program:m(a.body,
function(c,d){k.recurse(c.expression,w,w,function(a){l=a});d!==a.body.length-1?k.current().body.push(l,";"):k.return_(l)});break;case s.Literal:p=this.escape(a.value);this.assign(c,p);e(p);break;case s.UnaryExpression:this.recurse(a.argument,w,w,function(a){l=a});p=a.operator+"("+this.ifDefined(l,0)+")";this.assign(c,p);e(p);break;case s.BinaryExpression:this.recurse(a.left,w,w,function(a){g=a});this.recurse(a.right,w,w,function(a){l=a});p="+"===a.operator?this.plus(g,l):"-"===a.operator?this.ifDefined(g,
0)+a.operator+this.ifDefined(l,0):"("+g+")"+a.operator+"("+l+")";this.assign(c,p);e(p);break;case s.LogicalExpression:c=c||this.nextId();k.recurse(a.left,c);k.if_("&&"===a.operator?c:k.not(c),k.lazyRecurse(a.right,c));e(c);break;case s.ConditionalExpression:c=c||this.nextId();k.recurse(a.test,c);k.if_(c,k.lazyRecurse(a.alternate,c),k.lazyRecurse(a.consequent,c));e(c);break;case s.Identifier:c=c||this.nextId();d&&(d.context="inputs"===k.stage?"s":this.assign(this.nextId(),this.getHasOwnProperty("l",
a.name)+"?l:s"),d.computed=!1,d.name=a.name);Xa(a.name);k.if_("inputs"===k.stage||k.not(k.getHasOwnProperty("l",a.name)),function(){k.if_("inputs"===k.stage||"s",function(){f&&1!==f&&k.if_(k.not(k.nonComputedMember("s",a.name)),k.lazyAssign(k.nonComputedMember("s",a.name),"{}"));k.assign(c,k.nonComputedMember("s",a.name))})},c&&k.lazyAssign(c,k.nonComputedMember("l",a.name)));(k.state.expensiveChecks||Fb(a.name))&&k.addEnsureSafeObject(c);e(c);break;case s.MemberExpression:g=d&&(d.context=this.nextId())||
this.nextId();c=c||this.nextId();k.recurse(a.object,g,w,function(){k.if_(k.notNull(g),function(){if(a.computed)l=k.nextId(),k.recurse(a.property,l),k.getStringValue(l),k.addEnsureSafeMemberName(l),f&&1!==f&&k.if_(k.not(k.computedMember(g,l)),k.lazyAssign(k.computedMember(g,l),"{}")),p=k.ensureSafeObject(k.computedMember(g,l)),k.assign(c,p),d&&(d.computed=!0,d.name=l);else{Xa(a.property.name);f&&1!==f&&k.if_(k.not(k.nonComputedMember(g,a.property.name)),k.lazyAssign(k.nonComputedMember(g,a.property.name),
"{}"));p=k.nonComputedMember(g,a.property.name);if(k.state.expensiveChecks||Fb(a.property.name))p=k.ensureSafeObject(p);k.assign(c,p);d&&(d.computed=!1,d.name=a.property.name)}},function(){k.assign(c,"undefined")});e(c)},!!f);break;case s.CallExpression:c=c||this.nextId();a.filter?(l=k.filter(a.callee.name),n=[],m(a.arguments,function(a){var c=k.nextId();k.recurse(a,c);n.push(c)}),p=l+"("+n.join(",")+")",k.assign(c,p),e(c)):(l=k.nextId(),g={},n=[],k.recurse(a.callee,l,g,function(){k.if_(k.notNull(l),
function(){k.addEnsureSafeFunction(l);m(a.arguments,function(a){k.recurse(a,k.nextId(),w,function(a){n.push(k.ensureSafeObject(a))})});g.name?(k.state.expensiveChecks||k.addEnsureSafeObject(g.context),p=k.member(g.context,g.name,g.computed)+"("+n.join(",")+")"):p=l+"("+n.join(",")+")";p=k.ensureSafeObject(p);k.assign(c,p)},function(){k.assign(c,"undefined")});e(c)}));break;case s.AssignmentExpression:l=this.nextId();g={};if(!pd(a.left))throw Z("lval");this.recurse(a.left,w,g,function(){k.if_(k.notNull(g.context),
function(){k.recurse(a.right,l);k.addEnsureSafeObject(k.member(g.context,g.name,g.computed));k.addEnsureSafeAssignContext(g.context);p=k.member(g.context,g.name,g.computed)+a.operator+l;k.assign(c,p);e(c||p)})},1);break;case s.ArrayExpression:n=[];m(a.elements,function(a){k.recurse(a,k.nextId(),w,function(a){n.push(a)})});p="["+n.join(",")+"]";this.assign(c,p);e(p);break;case s.ObjectExpression:n=[];m(a.properties,function(a){k.recurse(a.value,k.nextId(),w,function(c){n.push(k.escape(a.key.type===
s.Identifier?a.key.name:""+a.key.value)+":"+c)})});p="{"+n.join(",")+"}";this.assign(c,p);e(p);break;case s.ThisExpression:this.assign(c,"s");e("s");break;case s.NGValueParameter:this.assign(c,"v"),e("v")}},getHasOwnProperty:function(a,c){var d=a+"."+c,e=this.current().own;e.hasOwnProperty(d)||(e[d]=this.nextId(!1,a+"&&("+this.escape(c)+" in "+a+")"));return e[d]},assign:function(a,c){if(a)return this.current().body.push(a,"=",c,";"),a},filter:function(a){this.state.filters.hasOwnProperty(a)||(this.state.filters[a]=
this.nextId(!0));return this.state.filters[a]},ifDefined:function(a,c){return"ifDefined("+a+","+this.escape(c)+")"},plus:function(a,c){return"plus("+a+","+c+")"},return_:function(a){this.current().body.push("return ",a,";")},if_:function(a,c,d){if(!0===a)c();else{var e=this.current().body;e.push("if(",a,"){");c();e.push("}");d&&(e.push("else{"),d(),e.push("}"))}},not:function(a){return"!("+a+")"},notNull:function(a){return a+"!=null"},nonComputedMember:function(a,c){return a+"."+c},computedMember:function(a,
c){return a+"["+c+"]"},member:function(a,c,d){return d?this.computedMember(a,c):this.nonComputedMember(a,c)},addEnsureSafeObject:function(a){this.current().body.push(this.ensureSafeObject(a),";")},addEnsureSafeMemberName:function(a){this.current().body.push(this.ensureSafeMemberName(a),";")},addEnsureSafeFunction:function(a){this.current().body.push(this.ensureSafeFunction(a),";")},addEnsureSafeAssignContext:function(a){this.current().body.push(this.ensureSafeAssignContext(a),";")},ensureSafeObject:function(a){return"ensureSafeObject("+
a+",text)"},ensureSafeMemberName:function(a){return"ensureSafeMemberName("+a+",text)"},ensureSafeFunction:function(a){return"ensureSafeFunction("+a+",text)"},getStringValue:function(a){this.assign(a,"getStringValue("+a+",text)")},ensureSafeAssignContext:function(a){return"ensureSafeAssignContext("+a+",text)"},lazyRecurse:function(a,c,d,e,f,h){var g=this;return function(){g.recurse(a,c,d,e,f,h)}},lazyAssign:function(a,c){var d=this;return function(){d.assign(a,c)}},stringEscapeRegex:/[^ a-zA-Z0-9]/g,
stringEscapeFn:function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)},escape:function(a){if(G(a))return"'"+a.replace(this.stringEscapeRegex,this.stringEscapeFn)+"'";if(V(a))return a.toString();if(!0===a)return"true";if(!1===a)return"false";if(null===a)return"null";if("undefined"===typeof a)return"undefined";throw Z("esc");},nextId:function(a,c){var d="v"+this.state.nextId++;a||this.current().vars.push(d+(c?"="+c:""));return d},current:function(){return this.state[this.state.computing]}};
td.prototype={compile:function(a,c){var d=this,e=this.astBuilder.ast(a);this.expression=a;this.expensiveChecks=c;U(e,d.$filter);var f,h;if(f=qd(e))h=this.recurse(f);f=od(e.body);var g;f&&(g=[],m(f,function(a,c){var e=d.recurse(a);a.input=e;g.push(e);a.watchId=c}));var l=[];m(e.body,function(a){l.push(d.recurse(a.expression))});f=0===e.body.length?function(){}:1===e.body.length?l[0]:function(a,c){var d;m(l,function(e){d=e(a,c)});return d};h&&(f.assign=function(a,c,d){return h(a,d,c)});g&&(f.inputs=
g);f.literal=rd(e);f.constant=e.constant;return f},recurse:function(a,c,d){var e,f,h=this,g;if(a.input)return this.inputs(a.input,a.watchId);switch(a.type){case s.Literal:return this.value(a.value,c);case s.UnaryExpression:return f=this.recurse(a.argument),this["unary"+a.operator](f,c);case s.BinaryExpression:return e=this.recurse(a.left),f=this.recurse(a.right),this["binary"+a.operator](e,f,c);case s.LogicalExpression:return e=this.recurse(a.left),f=this.recurse(a.right),this["binary"+a.operator](e,
f,c);case s.ConditionalExpression:return this["ternary?:"](this.recurse(a.test),this.recurse(a.alternate),this.recurse(a.consequent),c);case s.Identifier:return Xa(a.name,h.expression),h.identifier(a.name,h.expensiveChecks||Fb(a.name),c,d,h.expression);case s.MemberExpression:return e=this.recurse(a.object,!1,!!d),a.computed||(Xa(a.property.name,h.expression),f=a.property.name),a.computed&&(f=this.recurse(a.property)),a.computed?this.computedMember(e,f,c,d,h.expression):this.nonComputedMember(e,f,
h.expensiveChecks,c,d,h.expression);case s.CallExpression:return g=[],m(a.arguments,function(a){g.push(h.recurse(a))}),a.filter&&(f=this.$filter(a.callee.name)),a.filter||(f=this.recurse(a.callee,!0)),a.filter?function(a,d,e,h){for(var r=[],m=0;m<g.length;++m)r.push(g[m](a,d,e,h));a=f.apply(w,r,h);return c?{context:w,name:w,value:a}:a}:function(a,d,e,p){var r=f(a,d,e,p),m;if(null!=r.value){Ba(r.context,h.expression);ld(r.value,h.expression);m=[];for(var s=0;s<g.length;++s)m.push(Ba(g[s](a,d,e,p),
h.expression));m=Ba(r.value.apply(r.context,m),h.expression)}return c?{value:m}:m};case s.AssignmentExpression:return e=this.recurse(a.left,!0,1),f=this.recurse(a.right),function(a,d,g,p){var r=e(a,d,g,p);a=f(a,d,g,p);Ba(r.value,h.expression);md(r.context);r.context[r.name]=a;return c?{value:a}:a};case s.ArrayExpression:return g=[],m(a.elements,function(a){g.push(h.recurse(a))}),function(a,d,e,f){for(var h=[],m=0;m<g.length;++m)h.push(g[m](a,d,e,f));return c?{value:h}:h};case s.ObjectExpression:return g=
[],m(a.properties,function(a){g.push({key:a.key.type===s.Identifier?a.key.name:""+a.key.value,value:h.recurse(a.value)})}),function(a,d,e,f){for(var h={},m=0;m<g.length;++m)h[g[m].key]=g[m].value(a,d,e,f);return c?{value:h}:h};case s.ThisExpression:return function(a){return c?{value:a}:a};case s.NGValueParameter:return function(a,d,e,f){return c?{value:e}:e}}},"unary+":function(a,c){return function(d,e,f,h){d=a(d,e,f,h);d=A(d)?+d:0;return c?{value:d}:d}},"unary-":function(a,c){return function(d,e,
f,h){d=a(d,e,f,h);d=A(d)?-d:0;return c?{value:d}:d}},"unary!":function(a,c){return function(d,e,f,h){d=!a(d,e,f,h);return c?{value:d}:d}},"binary+":function(a,c,d){return function(e,f,h,g){var l=a(e,f,h,g);e=c(e,f,h,g);l=nd(l,e);return d?{value:l}:l}},"binary-":function(a,c,d){return function(e,f,h,g){var l=a(e,f,h,g);e=c(e,f,h,g);l=(A(l)?l:0)-(A(e)?e:0);return d?{value:l}:l}},"binary*":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)*c(e,f,h,g);return d?{value:e}:e}},"binary/":function(a,c,
d){return function(e,f,h,g){e=a(e,f,h,g)/c(e,f,h,g);return d?{value:e}:e}},"binary%":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)%c(e,f,h,g);return d?{value:e}:e}},"binary===":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)===c(e,f,h,g);return d?{value:e}:e}},"binary!==":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)!==c(e,f,h,g);return d?{value:e}:e}},"binary==":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)==c(e,f,h,g);return d?{value:e}:e}},"binary!=":function(a,c,
d){return function(e,f,h,g){e=a(e,f,h,g)!=c(e,f,h,g);return d?{value:e}:e}},"binary<":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)<c(e,f,h,g);return d?{value:e}:e}},"binary>":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)>c(e,f,h,g);return d?{value:e}:e}},"binary<=":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)<=c(e,f,h,g);return d?{value:e}:e}},"binary>=":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)>=c(e,f,h,g);return d?{value:e}:e}},"binary&&":function(a,c,d){return function(e,
f,h,g){e=a(e,f,h,g)&&c(e,f,h,g);return d?{value:e}:e}},"binary||":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)||c(e,f,h,g);return d?{value:e}:e}},"ternary?:":function(a,c,d,e){return function(f,h,g,l){f=a(f,h,g,l)?c(f,h,g,l):d(f,h,g,l);return e?{value:f}:f}},value:function(a,c){return function(){return c?{context:w,name:w,value:a}:a}},identifier:function(a,c,d,e,f){return function(h,g,l,k){h=g&&a in g?g:h;e&&1!==e&&h&&!h[a]&&(h[a]={});g=h?h[a]:w;c&&Ba(g,f);return d?{context:h,name:a,value:g}:
g}},computedMember:function(a,c,d,e,f){return function(h,g,l,k){var n=a(h,g,l,k),p,m;null!=n&&(p=c(h,g,l,k),p=kd(p),Xa(p,f),e&&1!==e&&n&&!n[p]&&(n[p]={}),m=n[p],Ba(m,f));return d?{context:n,name:p,value:m}:m}},nonComputedMember:function(a,c,d,e,f,h){return function(g,l,k,n){g=a(g,l,k,n);f&&1!==f&&g&&!g[c]&&(g[c]={});l=null!=g?g[c]:w;(d||Fb(c))&&Ba(l,h);return e?{context:g,name:c,value:l}:l}},inputs:function(a,c){return function(d,e,f,h){return h?h[c]:a(d,e,f)}}};var fc=function(a,c,d){this.lexer=
a;this.$filter=c;this.options=d;this.ast=new s(this.lexer);this.astCompiler=d.csp?new td(this.ast,c):new sd(this.ast,c)};fc.prototype={constructor:fc,parse:function(a){return this.astCompiler.compile(a,this.options.expensiveChecks)}};fa();fa();var Yf=Object.prototype.valueOf,Ca=I("$sce"),oa={HTML:"html",CSS:"css",URL:"url",RESOURCE_URL:"resourceUrl",JS:"js"},ga=I("$compile"),$=X.createElement("a"),xd=Aa(Q.location.href);yd.$inject=["$document"];Kc.$inject=["$provide"];zd.$inject=["$locale"];Bd.$inject=
["$locale"];var hc=".",hg={yyyy:aa("FullYear",4),yy:aa("FullYear",2,0,!0),y:aa("FullYear",1),MMMM:Hb("Month"),MMM:Hb("Month",!0),MM:aa("Month",2,1),M:aa("Month",1,1),dd:aa("Date",2),d:aa("Date",1),HH:aa("Hours",2),H:aa("Hours",1),hh:aa("Hours",2,-12),h:aa("Hours",1,-12),mm:aa("Minutes",2),m:aa("Minutes",1),ss:aa("Seconds",2),s:aa("Seconds",1),sss:aa("Milliseconds",3),EEEE:Hb("Day"),EEE:Hb("Day",!0),a:function(a,c){return 12>a.getHours()?c.AMPMS[0]:c.AMPMS[1]},Z:function(a,c,d){a=-1*d;return a=(0<=
a?"+":"")+(Gb(Math[0<a?"floor":"ceil"](a/60),2)+Gb(Math.abs(a%60),2))},ww:Fd(2),w:Fd(1),G:ic,GG:ic,GGG:ic,GGGG:function(a,c){return 0>=a.getFullYear()?c.ERANAMES[0]:c.ERANAMES[1]}},gg=/((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,fg=/^\-?\d+$/;Ad.$inject=["$locale"];var cg=qa(F),dg=qa(sb);Cd.$inject=["$parse"];var he=qa({restrict:"E",compile:function(a,c){if(!c.href&&!c.xlinkHref)return function(a,c){if("a"===c[0].nodeName.toLowerCase()){var f="[object SVGAnimatedString]"===
va.call(c.prop("href"))?"xlink:href":"href";c.on("click",function(a){c.attr(f)||a.preventDefault()})}}}}),tb={};m(Bb,function(a,c){function d(a,d,f){a.$watch(f[e],function(a){f.$set(c,!!a)})}if("multiple"!=a){var e=ya("ng-"+c),f=d;"checked"===a&&(f=function(a,c,f){f.ngModel!==f[e]&&d(a,c,f)});tb[e]=function(){return{restrict:"A",priority:100,link:f}}}});m($c,function(a,c){tb[c]=function(){return{priority:100,link:function(a,e,f){if("ngPattern"===c&&"/"==f.ngPattern.charAt(0)&&(e=f.ngPattern.match(jg))){f.$set("ngPattern",
new RegExp(e[1],e[2]));return}a.$watch(f[c],function(a){f.$set(c,a)})}}}});m(["src","srcset","href"],function(a){var c=ya("ng-"+a);tb[c]=function(){return{priority:99,link:function(d,e,f){var h=a,g=a;"href"===a&&"[object SVGAnimatedString]"===va.call(e.prop("href"))&&(g="xlinkHref",f.$attr[g]="xlink:href",h=null);f.$observe(c,function(c){c?(f.$set(g,c),Wa&&h&&e.prop(h,f[g])):"href"===a&&f.$set(g,null)})}}}});var Ib={$addControl:y,$$renameControl:function(a,c){a.$name=c},$removeControl:y,$setValidity:y,
$setDirty:y,$setPristine:y,$setSubmitted:y};Gd.$inject=["$element","$attrs","$scope","$animate","$interpolate"];var Od=function(a){return["$timeout","$parse",function(c,d){function e(a){return""===a?d('this[""]').assign:d(a).assign||y}return{name:"form",restrict:a?"EAC":"E",require:["form","^^?form"],controller:Gd,compile:function(d,h){d.addClass(Ya).addClass(mb);var g=h.name?"name":a&&h.ngForm?"ngForm":!1;return{pre:function(a,d,f,h){var m=h[0];if(!("action"in f)){var t=function(c){a.$apply(function(){m.$commitViewValue();
m.$setSubmitted()});c.preventDefault()};d[0].addEventListener("submit",t,!1);d.on("$destroy",function(){c(function(){d[0].removeEventListener("submit",t,!1)},0,!1)})}(h[1]||m.$$parentForm).$addControl(m);var s=g?e(m.$name):y;g&&(s(a,m),f.$observe(g,function(c){m.$name!==c&&(s(a,w),m.$$parentForm.$$renameControl(m,c),s=e(m.$name),s(a,m))}));d.on("$destroy",function(){m.$$parentForm.$removeControl(m);s(a,w);P(m,Ib)})}}}}}]},ie=Od(),ve=Od(!0),ig=/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/,
sg=/^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/,tg=/^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i,ug=/^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/,Pd=/^(\d{4})-(\d{2})-(\d{2})$/,Qd=/^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,lc=/^(\d{4})-W(\d\d)$/,Rd=/^(\d{4})-(\d\d)$/,Sd=/^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,Td={text:function(a,c,d,e,f,h){jb(a,c,d,e,f,h);jc(e)},date:kb("date",
Pd,Kb(Pd,["yyyy","MM","dd"]),"yyyy-MM-dd"),"datetime-local":kb("datetimelocal",Qd,Kb(Qd,"yyyy MM dd HH mm ss sss".split(" ")),"yyyy-MM-ddTHH:mm:ss.sss"),time:kb("time",Sd,Kb(Sd,["HH","mm","ss","sss"]),"HH:mm:ss.sss"),week:kb("week",lc,function(a,c){if(ea(a))return a;if(G(a)){lc.lastIndex=0;var d=lc.exec(a);if(d){var e=+d[1],f=+d[2],h=d=0,g=0,l=0,k=Ed(e),f=7*(f-1);c&&(d=c.getHours(),h=c.getMinutes(),g=c.getSeconds(),l=c.getMilliseconds());return new Date(e,0,k.getDate()+f,d,h,g,l)}}return NaN},"yyyy-Www"),
month:kb("month",Rd,Kb(Rd,["yyyy","MM"]),"yyyy-MM"),number:function(a,c,d,e,f,h){Id(a,c,d,e);jb(a,c,d,e,f,h);e.$$parserName="number";e.$parsers.push(function(a){return e.$isEmpty(a)?null:ug.test(a)?parseFloat(a):w});e.$formatters.push(function(a){if(!e.$isEmpty(a)){if(!V(a))throw lb("numfmt",a);a=a.toString()}return a});if(A(d.min)||d.ngMin){var g;e.$validators.min=function(a){return e.$isEmpty(a)||v(g)||a>=g};d.$observe("min",function(a){A(a)&&!V(a)&&(a=parseFloat(a,10));g=V(a)&&!isNaN(a)?a:w;e.$validate()})}if(A(d.max)||
d.ngMax){var l;e.$validators.max=function(a){return e.$isEmpty(a)||v(l)||a<=l};d.$observe("max",function(a){A(a)&&!V(a)&&(a=parseFloat(a,10));l=V(a)&&!isNaN(a)?a:w;e.$validate()})}},url:function(a,c,d,e,f,h){jb(a,c,d,e,f,h);jc(e);e.$$parserName="url";e.$validators.url=function(a,c){var d=a||c;return e.$isEmpty(d)||sg.test(d)}},email:function(a,c,d,e,f,h){jb(a,c,d,e,f,h);jc(e);e.$$parserName="email";e.$validators.email=function(a,c){var d=a||c;return e.$isEmpty(d)||tg.test(d)}},radio:function(a,c,
d,e){v(d.name)&&c.attr("name",++nb);c.on("click",function(a){c[0].checked&&e.$setViewValue(d.value,a&&a.type)});e.$render=function(){c[0].checked=d.value==e.$viewValue};d.$observe("value",e.$render)},checkbox:function(a,c,d,e,f,h,g,l){var k=Jd(l,a,"ngTrueValue",d.ngTrueValue,!0),n=Jd(l,a,"ngFalseValue",d.ngFalseValue,!1);c.on("click",function(a){e.$setViewValue(c[0].checked,a&&a.type)});e.$render=function(){c[0].checked=e.$viewValue};e.$isEmpty=function(a){return!1===a};e.$formatters.push(function(a){return ka(a,
k)});e.$parsers.push(function(a){return a?k:n})},hidden:y,button:y,submit:y,reset:y,file:y},Ec=["$browser","$sniffer","$filter","$parse",function(a,c,d,e){return{restrict:"E",require:["?ngModel"],link:{pre:function(f,h,g,l){l[0]&&(Td[F(g.type)]||Td.text)(f,h,g,l[0],c,a,d,e)}}}}],vg=/^(true|false|\d+)$/,Ne=function(){return{restrict:"A",priority:100,compile:function(a,c){return vg.test(c.ngValue)?function(a,c,f){f.$set("value",a.$eval(f.ngValue))}:function(a,c,f){a.$watch(f.ngValue,function(a){f.$set("value",
a)})}}}},ne=["$compile",function(a){return{restrict:"AC",compile:function(c){a.$$addBindingClass(c);return function(c,e,f){a.$$addBindingInfo(e,f.ngBind);e=e[0];c.$watch(f.ngBind,function(a){e.textContent=v(a)?"":a})}}}}],pe=["$interpolate","$compile",function(a,c){return{compile:function(d){c.$$addBindingClass(d);return function(d,f,h){d=a(f.attr(h.$attr.ngBindTemplate));c.$$addBindingInfo(f,d.expressions);f=f[0];h.$observe("ngBindTemplate",function(a){f.textContent=v(a)?"":a})}}}}],oe=["$sce","$parse",
"$compile",function(a,c,d){return{restrict:"A",compile:function(e,f){var h=c(f.ngBindHtml),g=c(f.ngBindHtml,function(a){return(a||"").toString()});d.$$addBindingClass(e);return function(c,e,f){d.$$addBindingInfo(e,f.ngBindHtml);c.$watch(g,function(){e.html(a.getTrustedHtml(h(c))||"")})}}}}],Me=qa({restrict:"A",require:"ngModel",link:function(a,c,d,e){e.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}),qe=kc("",!0),se=kc("Odd",0),re=kc("Even",1),te=Na({compile:function(a,c){c.$set("ngCloak",
w);a.removeClass("ng-cloak")}}),ue=[function(){return{restrict:"A",scope:!0,controller:"@",priority:500}}],Jc={},wg={blur:!0,focus:!0};m("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "),function(a){var c=ya("ng-"+a);Jc[c]=["$parse","$rootScope",function(d,e){return{restrict:"A",compile:function(f,h){var g=d(h[c],null,!0);return function(c,d){d.on(a,function(d){var f=function(){g(c,{$event:d})};
wg[a]&&e.$$phase?c.$evalAsync(f):c.$apply(f)})}}}}]});var xe=["$animate",function(a){return{multiElement:!0,transclude:"element",priority:600,terminal:!0,restrict:"A",$$tlb:!0,link:function(c,d,e,f,h){var g,l,k;c.$watch(e.ngIf,function(c){c?l||h(function(c,f){l=f;c[c.length++]=X.createComment(" end ngIf: "+e.ngIf+" ");g={clone:c};a.enter(c,d.parent(),d)}):(k&&(k.remove(),k=null),l&&(l.$destroy(),l=null),g&&(k=rb(g.clone),a.leave(k).then(function(){k=null}),g=null))})}}}],ye=["$templateRequest","$anchorScroll",
"$animate",function(a,c,d){return{restrict:"ECA",priority:400,terminal:!0,transclude:"element",controller:da.noop,compile:function(e,f){var h=f.ngInclude||f.src,g=f.onload||"",l=f.autoscroll;return function(e,f,m,r,t){var s=0,v,u,q,z=function(){u&&(u.remove(),u=null);v&&(v.$destroy(),v=null);q&&(d.leave(q).then(function(){u=null}),u=q,q=null)};e.$watch(h,function(h){var m=function(){!A(l)||l&&!e.$eval(l)||c()},p=++s;h?(a(h,!0).then(function(a){if(p===s){var c=e.$new();r.template=a;a=t(c,function(a){z();
d.enter(a,null,f).then(m)});v=c;q=a;v.$emit("$includeContentLoaded",h);e.$eval(g)}},function(){p===s&&(z(),e.$emit("$includeContentError",h))}),e.$emit("$includeContentRequested",h)):(z(),r.template=null)})}}}}],Pe=["$compile",function(a){return{restrict:"ECA",priority:-400,require:"ngInclude",link:function(c,d,e,f){/SVG/.test(d[0].toString())?(d.empty(),a(Mc(f.template,X).childNodes)(c,function(a){d.append(a)},{futureParentElement:d})):(d.html(f.template),a(d.contents())(c))}}}],ze=Na({priority:450,
compile:function(){return{pre:function(a,c,d){a.$eval(d.ngInit)}}}}),Le=function(){return{restrict:"A",priority:100,require:"ngModel",link:function(a,c,d,e){var f=c.attr(d.$attr.ngList)||", ",h="false"!==d.ngTrim,g=h?T(f):f;e.$parsers.push(function(a){if(!v(a)){var c=[];a&&m(a.split(g),function(a){a&&c.push(h?T(a):a)});return c}});e.$formatters.push(function(a){return J(a)?a.join(f):w});e.$isEmpty=function(a){return!a||!a.length}}}},mb="ng-valid",Kd="ng-invalid",Ya="ng-pristine",Jb="ng-dirty",Md=
"ng-pending",lb=I("ngModel"),xg=["$scope","$exceptionHandler","$attrs","$element","$parse","$animate","$timeout","$rootScope","$q","$interpolate",function(a,c,d,e,f,h,g,l,k,n){this.$modelValue=this.$viewValue=Number.NaN;this.$$rawModelValue=w;this.$validators={};this.$asyncValidators={};this.$parsers=[];this.$formatters=[];this.$viewChangeListeners=[];this.$untouched=!0;this.$touched=!1;this.$pristine=!0;this.$dirty=!1;this.$valid=!0;this.$invalid=!1;this.$error={};this.$$success={};this.$pending=
w;this.$name=n(d.name||"",!1)(a);this.$$parentForm=Ib;var p=f(d.ngModel),r=p.assign,t=p,s=r,K=null,u,q=this;this.$$setOptions=function(a){if((q.$options=a)&&a.getterSetter){var c=f(d.ngModel+"()"),g=f(d.ngModel+"($$$p)");t=function(a){var d=p(a);x(d)&&(d=c(a));return d};s=function(a,c){x(p(a))?g(a,{$$$p:q.$modelValue}):r(a,q.$modelValue)}}else if(!p.assign)throw lb("nonassign",d.ngModel,xa(e));};this.$render=y;this.$isEmpty=function(a){return v(a)||""===a||null===a||a!==a};var z=0;Hd({ctrl:this,$element:e,
set:function(a,c){a[c]=!0},unset:function(a,c){delete a[c]},$animate:h});this.$setPristine=function(){q.$dirty=!1;q.$pristine=!0;h.removeClass(e,Jb);h.addClass(e,Ya)};this.$setDirty=function(){q.$dirty=!0;q.$pristine=!1;h.removeClass(e,Ya);h.addClass(e,Jb);q.$$parentForm.$setDirty()};this.$setUntouched=function(){q.$touched=!1;q.$untouched=!0;h.setClass(e,"ng-untouched","ng-touched")};this.$setTouched=function(){q.$touched=!0;q.$untouched=!1;h.setClass(e,"ng-touched","ng-untouched")};this.$rollbackViewValue=
function(){g.cancel(K);q.$viewValue=q.$$lastCommittedViewValue;q.$render()};this.$validate=function(){if(!V(q.$modelValue)||!isNaN(q.$modelValue)){var a=q.$$rawModelValue,c=q.$valid,d=q.$modelValue,e=q.$options&&q.$options.allowInvalid;q.$$runValidators(a,q.$$lastCommittedViewValue,function(f){e||c===f||(q.$modelValue=f?a:w,q.$modelValue!==d&&q.$$writeModelToScope())})}};this.$$runValidators=function(a,c,d){function e(){var d=!0;m(q.$validators,function(e,f){var h=e(a,c);d=d&&h;g(f,h)});return d?
!0:(m(q.$asyncValidators,function(a,c){g(c,null)}),!1)}function f(){var d=[],e=!0;m(q.$asyncValidators,function(f,h){var k=f(a,c);if(!k||!x(k.then))throw lb("$asyncValidators",k);g(h,w);d.push(k.then(function(){g(h,!0)},function(a){e=!1;g(h,!1)}))});d.length?k.all(d).then(function(){h(e)},y):h(!0)}function g(a,c){l===z&&q.$setValidity(a,c)}function h(a){l===z&&d(a)}z++;var l=z;(function(){var a=q.$$parserName||"parse";if(v(u))g(a,null);else return u||(m(q.$validators,function(a,c){g(c,null)}),m(q.$asyncValidators,
function(a,c){g(c,null)})),g(a,u),u;return!0})()?e()?f():h(!1):h(!1)};this.$commitViewValue=function(){var a=q.$viewValue;g.cancel(K);if(q.$$lastCommittedViewValue!==a||""===a&&q.$$hasNativeValidators)q.$$lastCommittedViewValue=a,q.$pristine&&this.$setDirty(),this.$$parseAndValidate()};this.$$parseAndValidate=function(){var c=q.$$lastCommittedViewValue;if(u=v(c)?w:!0)for(var d=0;d<q.$parsers.length;d++)if(c=q.$parsers[d](c),v(c)){u=!1;break}V(q.$modelValue)&&isNaN(q.$modelValue)&&(q.$modelValue=t(a));
var e=q.$modelValue,f=q.$options&&q.$options.allowInvalid;q.$$rawModelValue=c;f&&(q.$modelValue=c,q.$modelValue!==e&&q.$$writeModelToScope());q.$$runValidators(c,q.$$lastCommittedViewValue,function(a){f||(q.$modelValue=a?c:w,q.$modelValue!==e&&q.$$writeModelToScope())})};this.$$writeModelToScope=function(){s(a,q.$modelValue);m(q.$viewChangeListeners,function(a){try{a()}catch(d){c(d)}})};this.$setViewValue=function(a,c){q.$viewValue=a;q.$options&&!q.$options.updateOnDefault||q.$$debounceViewValueCommit(c)};
this.$$debounceViewValueCommit=function(c){var d=0,e=q.$options;e&&A(e.debounce)&&(e=e.debounce,V(e)?d=e:V(e[c])?d=e[c]:V(e["default"])&&(d=e["default"]));g.cancel(K);d?K=g(function(){q.$commitViewValue()},d):l.$$phase?q.$commitViewValue():a.$apply(function(){q.$commitViewValue()})};a.$watch(function(){var c=t(a);if(c!==q.$modelValue&&(q.$modelValue===q.$modelValue||c===c)){q.$modelValue=q.$$rawModelValue=c;u=w;for(var d=q.$formatters,e=d.length,f=c;e--;)f=d[e](f);q.$viewValue!==f&&(q.$viewValue=
q.$$lastCommittedViewValue=f,q.$render(),q.$$runValidators(c,f,y))}return c})}],Ke=["$rootScope",function(a){return{restrict:"A",require:["ngModel","^?form","^?ngModelOptions"],controller:xg,priority:1,compile:function(c){c.addClass(Ya).addClass("ng-untouched").addClass(mb);return{pre:function(a,c,f,h){var g=h[0];c=h[1]||g.$$parentForm;g.$$setOptions(h[2]&&h[2].$options);c.$addControl(g);f.$observe("name",function(a){g.$name!==a&&g.$$parentForm.$$renameControl(g,a)});a.$on("$destroy",function(){g.$$parentForm.$removeControl(g)})},
post:function(c,e,f,h){var g=h[0];if(g.$options&&g.$options.updateOn)e.on(g.$options.updateOn,function(a){g.$$debounceViewValueCommit(a&&a.type)});e.on("blur",function(e){g.$touched||(a.$$phase?c.$evalAsync(g.$setTouched):c.$apply(g.$setTouched))})}}}}}],yg=/(\s+|^)default(\s+|$)/,Oe=function(){return{restrict:"A",controller:["$scope","$attrs",function(a,c){var d=this;this.$options=ha(a.$eval(c.ngModelOptions));A(this.$options.updateOn)?(this.$options.updateOnDefault=!1,this.$options.updateOn=T(this.$options.updateOn.replace(yg,
function(){d.$options.updateOnDefault=!0;return" "}))):this.$options.updateOnDefault=!0}]}},Ae=Na({terminal:!0,priority:1E3}),zg=I("ngOptions"),Ag=/^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,Ie=["$compile","$parse",function(a,c){function d(a,d,e){function f(a,c,d,e,g){this.selectValue=a;this.viewValue=c;this.label=
d;this.group=e;this.disabled=g}function n(a){var c;if(!s&&Da(a))c=a;else{c=[];for(var d in a)a.hasOwnProperty(d)&&"$"!==d.charAt(0)&&c.push(d)}return c}var m=a.match(Ag);if(!m)throw zg("iexp",a,xa(d));var r=m[5]||m[7],s=m[6];a=/ as /.test(m[0])&&m[1];var v=m[9];d=c(m[2]?m[1]:r);var w=a&&c(a)||d,u=v&&c(v),q=v?function(a,c){return u(e,c)}:function(a){return Ga(a)},z=function(a,c){return q(a,x(a,c))},y=c(m[2]||m[1]),A=c(m[3]||""),O=c(m[4]||""),H=c(m[8]),B={},x=s?function(a,c){B[s]=c;B[r]=a;return B}:
function(a){B[r]=a;return B};return{trackBy:v,getTrackByValue:z,getWatchables:c(H,function(a){var c=[];a=a||[];for(var d=n(a),f=d.length,g=0;g<f;g++){var h=a===d?g:d[g],k=x(a[h],h),h=q(a[h],k);c.push(h);if(m[2]||m[1])h=y(e,k),c.push(h);m[4]&&(k=O(e,k),c.push(k))}return c}),getOptions:function(){for(var a=[],c={},d=H(e)||[],g=n(d),h=g.length,m=0;m<h;m++){var p=d===g?m:g[m],r=x(d[p],p),s=w(e,r),p=q(s,r),t=y(e,r),u=A(e,r),r=O(e,r),s=new f(p,s,t,u,r);a.push(s);c[p]=s}return{items:a,selectValueMap:c,getOptionFromViewValue:function(a){return c[z(a)]},
getViewValueFromOption:function(a){return v?da.copy(a.viewValue):a.viewValue}}}}}var e=X.createElement("option"),f=X.createElement("optgroup");return{restrict:"A",terminal:!0,require:["select","?ngModel"],link:function(c,g,l,k){function n(a,c){a.element=c;c.disabled=a.disabled;a.label!==c.label&&(c.label=a.label,c.textContent=a.label);a.value!==c.value&&(c.value=a.selectValue)}function p(a,c,d,e){c&&F(c.nodeName)===d?d=c:(d=e.cloneNode(!1),c?a.insertBefore(d,c):a.appendChild(d));return d}function r(a){for(var c;a;)c=
a.nextSibling,Wb(a),a=c}function s(a){var c=q&&q[0],d=H&&H[0];if(c||d)for(;a&&(a===c||a===d||c&&8===c.nodeType);)a=a.nextSibling;return a}function v(){var a=x&&u.readValue();x=C.getOptions();var c={},d=g[0].firstChild;O&&g.prepend(q);d=s(d);x.items.forEach(function(a){var h,k;a.group?(h=c[a.group],h||(h=p(g[0],d,"optgroup",f),d=h.nextSibling,h.label=a.group,h=c[a.group]={groupElement:h,currentOptionElement:h.firstChild}),k=p(h.groupElement,h.currentOptionElement,"option",e),n(a,k),h.currentOptionElement=
k.nextSibling):(k=p(g[0],d,"option",e),n(a,k),d=k.nextSibling)});Object.keys(c).forEach(function(a){r(c[a].currentOptionElement)});r(d);w.$render();if(!w.$isEmpty(a)){var h=u.readValue();(C.trackBy?ka(a,h):a===h)||(w.$setViewValue(h),w.$render())}}var w=k[1];if(w){var u=k[0];k=l.multiple;for(var q,z=0,y=g.children(),A=y.length;z<A;z++)if(""===y[z].value){q=y.eq(z);break}var O=!!q,H=B(e.cloneNode(!1));H.val("?");var x,C=d(l.ngOptions,g,c);k?(w.$isEmpty=function(a){return!a||0===a.length},u.writeValue=
function(a){x.items.forEach(function(a){a.element.selected=!1});a&&a.forEach(function(a){(a=x.getOptionFromViewValue(a))&&!a.disabled&&(a.element.selected=!0)})},u.readValue=function(){var a=g.val()||[],c=[];m(a,function(a){(a=x.selectValueMap[a])&&!a.disabled&&c.push(x.getViewValueFromOption(a))});return c},C.trackBy&&c.$watchCollection(function(){if(J(w.$viewValue))return w.$viewValue.map(function(a){return C.getTrackByValue(a)})},function(){w.$render()})):(u.writeValue=function(a){var c=x.getOptionFromViewValue(a);
c&&!c.disabled?g[0].value!==c.selectValue&&(H.remove(),O||q.remove(),g[0].value=c.selectValue,c.element.selected=!0,c.element.setAttribute("selected","selected")):null===a||O?(H.remove(),O||g.prepend(q),g.val(""),q.prop("selected",!0),q.attr("selected",!0)):(O||q.remove(),g.prepend(H),g.val("?"),H.prop("selected",!0),H.attr("selected",!0))},u.readValue=function(){var a=x.selectValueMap[g.val()];return a&&!a.disabled?(O||q.remove(),H.remove(),x.getViewValueFromOption(a)):null},C.trackBy&&c.$watch(function(){return C.getTrackByValue(w.$viewValue)},
function(){w.$render()}));O?(q.remove(),a(q)(c),q.removeClass("ng-scope")):q=B(e.cloneNode(!1));v();c.$watchCollection(C.getWatchables,v)}}}}],Be=["$locale","$interpolate","$log",function(a,c,d){var e=/{}/g,f=/^when(Minus)?(.+)$/;return{link:function(h,g,l){function k(a){g.text(a||"")}var n=l.count,p=l.$attr.when&&g.attr(l.$attr.when),r=l.offset||0,s=h.$eval(p)||{},w={},A=c.startSymbol(),u=c.endSymbol(),q=A+n+"-"+r+u,z=da.noop,x;m(l,function(a,c){var d=f.exec(c);d&&(d=(d[1]?"-":"")+F(d[2]),s[d]=g.attr(l.$attr[c]))});
m(s,function(a,d){w[d]=c(a.replace(e,q))});h.$watch(n,function(c){var e=parseFloat(c),f=isNaN(e);f||e in s||(e=a.pluralCat(e-r));e===x||f&&V(x)&&isNaN(x)||(z(),f=w[e],v(f)?(null!=c&&d.debug("ngPluralize: no rule defined for '"+e+"' in "+p),z=y,k()):z=h.$watch(f,k),x=e)})}}}],Ce=["$parse","$animate",function(a,c){var d=I("ngRepeat"),e=function(a,c,d,e,k,m,p){a[d]=e;k&&(a[k]=m);a.$index=c;a.$first=0===c;a.$last=c===p-1;a.$middle=!(a.$first||a.$last);a.$odd=!(a.$even=0===(c&1))};return{restrict:"A",
multiElement:!0,transclude:"element",priority:1E3,terminal:!0,$$tlb:!0,compile:function(f,h){var g=h.ngRepeat,l=X.createComment(" end ngRepeat: "+g+" "),k=g.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);if(!k)throw d("iexp",g);var n=k[1],p=k[2],r=k[3],s=k[4],k=n.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);if(!k)throw d("iidexp",n);var v=k[3]||k[1],y=k[2];if(r&&(!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(r)||/^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(r)))throw d("badident",
r);var u,q,z,A,x={$id:Ga};s?u=a(s):(z=function(a,c){return Ga(c)},A=function(a){return a});return function(a,f,h,k,n){u&&(q=function(c,d,e){y&&(x[y]=c);x[v]=d;x.$index=e;return u(a,x)});var s=fa();a.$watchCollection(p,function(h){var k,p,t=f[0],u,x=fa(),C,G,J,M,I,F,L;r&&(a[r]=h);if(Da(h))I=h,p=q||z;else for(L in p=q||A,I=[],h)ta.call(h,L)&&"$"!==L.charAt(0)&&I.push(L);C=I.length;L=Array(C);for(k=0;k<C;k++)if(G=h===I?k:I[k],J=h[G],M=p(G,J,k),s[M])F=s[M],delete s[M],x[M]=F,L[k]=F;else{if(x[M])throw m(L,
function(a){a&&a.scope&&(s[a.id]=a)}),d("dupes",g,M,J);L[k]={id:M,scope:w,clone:w};x[M]=!0}for(u in s){F=s[u];M=rb(F.clone);c.leave(M);if(M[0].parentNode)for(k=0,p=M.length;k<p;k++)M[k].$$NG_REMOVED=!0;F.scope.$destroy()}for(k=0;k<C;k++)if(G=h===I?k:I[k],J=h[G],F=L[k],F.scope){u=t;do u=u.nextSibling;while(u&&u.$$NG_REMOVED);F.clone[0]!=u&&c.move(rb(F.clone),null,B(t));t=F.clone[F.clone.length-1];e(F.scope,k,v,J,y,G,C)}else n(function(a,d){F.scope=d;var f=l.cloneNode(!1);a[a.length++]=f;c.enter(a,
null,B(t));t=f;F.clone=a;x[F.id]=F;e(F.scope,k,v,J,y,G,C)});s=x})}}}}],De=["$animate",function(a){return{restrict:"A",multiElement:!0,link:function(c,d,e){c.$watch(e.ngShow,function(c){a[c?"removeClass":"addClass"](d,"ng-hide",{tempClasses:"ng-hide-animate"})})}}}],we=["$animate",function(a){return{restrict:"A",multiElement:!0,link:function(c,d,e){c.$watch(e.ngHide,function(c){a[c?"addClass":"removeClass"](d,"ng-hide",{tempClasses:"ng-hide-animate"})})}}}],Ee=Na(function(a,c,d){a.$watch(d.ngStyle,
function(a,d){d&&a!==d&&m(d,function(a,d){c.css(d,"")});a&&c.css(a)},!0)}),Fe=["$animate",function(a){return{require:"ngSwitch",controller:["$scope",function(){this.cases={}}],link:function(c,d,e,f){var h=[],g=[],l=[],k=[],n=function(a,c){return function(){a.splice(c,1)}};c.$watch(e.ngSwitch||e.on,function(c){var d,e;d=0;for(e=l.length;d<e;++d)a.cancel(l[d]);d=l.length=0;for(e=k.length;d<e;++d){var s=rb(g[d].clone);k[d].$destroy();(l[d]=a.leave(s)).then(n(l,d))}g.length=0;k.length=0;(h=f.cases["!"+
c]||f.cases["?"])&&m(h,function(c){c.transclude(function(d,e){k.push(e);var f=c.element;d[d.length++]=X.createComment(" end ngSwitchWhen: ");g.push({clone:d});a.enter(d,f.parent(),f)})})})}}}],Ge=Na({transclude:"element",priority:1200,require:"^ngSwitch",multiElement:!0,link:function(a,c,d,e,f){e.cases["!"+d.ngSwitchWhen]=e.cases["!"+d.ngSwitchWhen]||[];e.cases["!"+d.ngSwitchWhen].push({transclude:f,element:c})}}),He=Na({transclude:"element",priority:1200,require:"^ngSwitch",multiElement:!0,link:function(a,
c,d,e,f){e.cases["?"]=e.cases["?"]||[];e.cases["?"].push({transclude:f,element:c})}}),Je=Na({restrict:"EAC",link:function(a,c,d,e,f){if(!f)throw I("ngTransclude")("orphan",xa(c));f(function(a){c.empty();c.append(a)})}}),je=["$templateCache",function(a){return{restrict:"E",terminal:!0,compile:function(c,d){"text/ng-template"==d.type&&a.put(d.id,c[0].text)}}}],Bg={$setViewValue:y,$render:y},Cg=["$element","$scope","$attrs",function(a,c,d){var e=this,f=new Ua;e.ngModelCtrl=Bg;e.unknownOption=B(X.createElement("option"));
e.renderUnknownOption=function(c){c="? "+Ga(c)+" ?";e.unknownOption.val(c);a.prepend(e.unknownOption);a.val(c)};c.$on("$destroy",function(){e.renderUnknownOption=y});e.removeUnknownOption=function(){e.unknownOption.parent()&&e.unknownOption.remove()};e.readValue=function(){e.removeUnknownOption();return a.val()};e.writeValue=function(c){e.hasOption(c)?(e.removeUnknownOption(),a.val(c),""===c&&e.emptyOption.prop("selected",!0)):null==c&&e.emptyOption?(e.removeUnknownOption(),a.val("")):e.renderUnknownOption(c)};
e.addOption=function(a,c){Ta(a,'"option value"');""===a&&(e.emptyOption=c);var d=f.get(a)||0;f.put(a,d+1)};e.removeOption=function(a){var c=f.get(a);c&&(1===c?(f.remove(a),""===a&&(e.emptyOption=w)):f.put(a,c-1))};e.hasOption=function(a){return!!f.get(a)}}],ke=function(){return{restrict:"E",require:["select","?ngModel"],controller:Cg,link:function(a,c,d,e){var f=e[1];if(f){var h=e[0];h.ngModelCtrl=f;f.$render=function(){h.writeValue(f.$viewValue)};c.on("change",function(){a.$apply(function(){f.$setViewValue(h.readValue())})});
if(d.multiple){h.readValue=function(){var a=[];m(c.find("option"),function(c){c.selected&&a.push(c.value)});return a};h.writeValue=function(a){var d=new Ua(a);m(c.find("option"),function(a){a.selected=A(d.get(a.value))})};var g,l=NaN;a.$watch(function(){l!==f.$viewValue||ka(g,f.$viewValue)||(g=ja(f.$viewValue),f.$render());l=f.$viewValue});f.$isEmpty=function(a){return!a||0===a.length}}}}}},me=["$interpolate",function(a){return{restrict:"E",priority:100,compile:function(c,d){if(A(d.value))var e=a(d.value,
!0);else{var f=a(c.text(),!0);f||d.$set("value",c.text())}return function(a,c,d){function k(a){p.addOption(a,c);p.ngModelCtrl.$render();c[0].hasAttribute("selected")&&(c[0].selected=!0)}var m=c.parent(),p=m.data("$selectController")||m.parent().data("$selectController");if(p&&p.ngModelCtrl){if(e){var r;d.$observe("value",function(a){A(r)&&p.removeOption(r);r=a;k(a)})}else f?a.$watch(f,function(a,c){d.$set("value",a);c!==a&&p.removeOption(c);k(a)}):k(d.value);c.on("$destroy",function(){p.removeOption(d.value);
p.ngModelCtrl.$render()})}}}}}],le=qa({restrict:"E",terminal:!1}),Gc=function(){return{restrict:"A",require:"?ngModel",link:function(a,c,d,e){e&&(d.required=!0,e.$validators.required=function(a,c){return!d.required||!e.$isEmpty(c)},d.$observe("required",function(){e.$validate()}))}}},Fc=function(){return{restrict:"A",require:"?ngModel",link:function(a,c,d,e){if(e){var f,h=d.ngPattern||d.pattern;d.$observe("pattern",function(a){G(a)&&0<a.length&&(a=new RegExp("^"+a+"$"));if(a&&!a.test)throw I("ngPattern")("noregexp",
h,a,xa(c));f=a||w;e.$validate()});e.$validators.pattern=function(a,c){return e.$isEmpty(c)||v(f)||f.test(c)}}}}},Ic=function(){return{restrict:"A",require:"?ngModel",link:function(a,c,d,e){if(e){var f=-1;d.$observe("maxlength",function(a){a=Y(a);f=isNaN(a)?-1:a;e.$validate()});e.$validators.maxlength=function(a,c){return 0>f||e.$isEmpty(c)||c.length<=f}}}}},Hc=function(){return{restrict:"A",require:"?ngModel",link:function(a,c,d,e){if(e){var f=0;d.$observe("minlength",function(a){f=Y(a)||0;e.$validate()});
e.$validators.minlength=function(a,c){return e.$isEmpty(c)||c.length>=f}}}}};Q.angular.bootstrap?console.log("WARNING: Tried to load angular more than once."):(ce(),ee(da),da.module("ngLocale",[],["$provide",function(a){function c(a){a+="";var c=a.indexOf(".");return-1==c?0:a.length-c-1}a.value("$locale",{DATETIME_FORMATS:{AMPMS:["AM","PM"],DAY:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ERANAMES:["Before Christ","Anno Domini"],ERAS:["BC","AD"],FIRSTDAYOFWEEK:6,MONTH:"January February March April May June July August September October November December".split(" "),
SHORTDAY:"Sun Mon Tue Wed Thu Fri Sat".split(" "),SHORTMONTH:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),WEEKENDRANGE:[5,6],fullDate:"EEEE, MMMM d, y",longDate:"MMMM d, y",medium:"MMM d, y h:mm:ss a",mediumDate:"MMM d, y",mediumTime:"h:mm:ss a","short":"M/d/yy h:mm a",shortDate:"M/d/yy",shortTime:"h:mm a"},NUMBER_FORMATS:{CURRENCY_SYM:"$",DECIMAL_SEP:".",GROUP_SEP:",",PATTERNS:[{gSize:3,lgSize:3,maxFrac:3,minFrac:0,minInt:1,negPre:"-",negSuf:"",posPre:"",posSuf:""},{gSize:3,lgSize:3,
maxFrac:2,minFrac:2,minInt:1,negPre:"-\u00a4",negSuf:"",posPre:"\u00a4",posSuf:""}]},id:"en-us",pluralCat:function(a,e){var f=a|0,h=e;w===h&&(h=Math.min(c(a),3));Math.pow(10,h);return 1==f&&0==h?"one":"other"}})}]),B(X).ready(function(){Zd(X,zc)}))})(window,document);!window.angular.$$csp().noInlineStyle&&window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
//# sourceMappingURL=angular.min.js.map
;
/*
 AngularJS v1.4.7
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(p,c,C){'use strict';function v(r,h,g){return{restrict:"ECA",terminal:!0,priority:400,transclude:"element",link:function(a,f,b,d,y){function z(){k&&(g.cancel(k),k=null);l&&(l.$destroy(),l=null);m&&(k=g.leave(m),k.then(function(){k=null}),m=null)}function x(){var b=r.current&&r.current.locals;if(c.isDefined(b&&b.$template)){var b=a.$new(),d=r.current;m=y(b,function(b){g.enter(b,null,m||f).then(function(){!c.isDefined(t)||t&&!a.$eval(t)||h()});z()});l=d.scope=b;l.$emit("$viewContentLoaded");
l.$eval(w)}else z()}var l,m,k,t=b.autoscroll,w=b.onload||"";a.$on("$routeChangeSuccess",x);x()}}}function A(c,h,g){return{restrict:"ECA",priority:-400,link:function(a,f){var b=g.current,d=b.locals;f.html(d.$template);var y=c(f.contents());b.controller&&(d.$scope=a,d=h(b.controller,d),b.controllerAs&&(a[b.controllerAs]=d),f.data("$ngControllerController",d),f.children().data("$ngControllerController",d));y(a)}}}p=c.module("ngRoute",["ng"]).provider("$route",function(){function r(a,f){return c.extend(Object.create(a),
f)}function h(a,c){var b=c.caseInsensitiveMatch,d={originalPath:a,regexp:a},g=d.keys=[];a=a.replace(/([().])/g,"\\$1").replace(/(\/)?:(\w+)([\?\*])?/g,function(a,c,b,d){a="?"===d?d:null;d="*"===d?d:null;g.push({name:b,optional:!!a});c=c||"";return""+(a?"":c)+"(?:"+(a?c:"")+(d&&"(.+?)"||"([^/]+)")+(a||"")+")"+(a||"")}).replace(/([\/$\*])/g,"\\$1");d.regexp=new RegExp("^"+a+"$",b?"i":"");return d}var g={};this.when=function(a,f){var b=c.copy(f);c.isUndefined(b.reloadOnSearch)&&(b.reloadOnSearch=!0);
c.isUndefined(b.caseInsensitiveMatch)&&(b.caseInsensitiveMatch=this.caseInsensitiveMatch);g[a]=c.extend(b,a&&h(a,b));if(a){var d="/"==a[a.length-1]?a.substr(0,a.length-1):a+"/";g[d]=c.extend({redirectTo:a},h(d,b))}return this};this.caseInsensitiveMatch=!1;this.otherwise=function(a){"string"===typeof a&&(a={redirectTo:a});this.when(null,a);return this};this.$get=["$rootScope","$location","$routeParams","$q","$injector","$templateRequest","$sce",function(a,f,b,d,h,p,x){function l(b){var e=s.current;
(v=(n=k())&&e&&n.$$route===e.$$route&&c.equals(n.pathParams,e.pathParams)&&!n.reloadOnSearch&&!w)||!e&&!n||a.$broadcast("$routeChangeStart",n,e).defaultPrevented&&b&&b.preventDefault()}function m(){var u=s.current,e=n;if(v)u.params=e.params,c.copy(u.params,b),a.$broadcast("$routeUpdate",u);else if(e||u)w=!1,(s.current=e)&&e.redirectTo&&(c.isString(e.redirectTo)?f.path(t(e.redirectTo,e.params)).search(e.params).replace():f.url(e.redirectTo(e.pathParams,f.path(),f.search())).replace()),d.when(e).then(function(){if(e){var a=
c.extend({},e.resolve),b,f;c.forEach(a,function(b,e){a[e]=c.isString(b)?h.get(b):h.invoke(b,null,null,e)});c.isDefined(b=e.template)?c.isFunction(b)&&(b=b(e.params)):c.isDefined(f=e.templateUrl)&&(c.isFunction(f)&&(f=f(e.params)),c.isDefined(f)&&(e.loadedTemplateUrl=x.valueOf(f),b=p(f)));c.isDefined(b)&&(a.$template=b);return d.all(a)}}).then(function(f){e==s.current&&(e&&(e.locals=f,c.copy(e.params,b)),a.$broadcast("$routeChangeSuccess",e,u))},function(b){e==s.current&&a.$broadcast("$routeChangeError",
e,u,b)})}function k(){var a,b;c.forEach(g,function(d,g){var q;if(q=!b){var h=f.path();q=d.keys;var l={};if(d.regexp)if(h=d.regexp.exec(h)){for(var k=1,m=h.length;k<m;++k){var n=q[k-1],p=h[k];n&&p&&(l[n.name]=p)}q=l}else q=null;else q=null;q=a=q}q&&(b=r(d,{params:c.extend({},f.search(),a),pathParams:a}),b.$$route=d)});return b||g[null]&&r(g[null],{params:{},pathParams:{}})}function t(a,b){var d=[];c.forEach((a||"").split(":"),function(a,c){if(0===c)d.push(a);else{var f=a.match(/(\w+)(?:[?*])?(.*)/),
g=f[1];d.push(b[g]);d.push(f[2]||"");delete b[g]}});return d.join("")}var w=!1,n,v,s={routes:g,reload:function(){w=!0;a.$evalAsync(function(){l();m()})},updateParams:function(a){if(this.current&&this.current.$$route)a=c.extend({},this.current.params,a),f.path(t(this.current.$$route.originalPath,a)),f.search(a);else throw B("norout");}};a.$on("$locationChangeStart",l);a.$on("$locationChangeSuccess",m);return s}]});var B=c.$$minErr("ngRoute");p.provider("$routeParams",function(){this.$get=function(){return{}}});
p.directive("ngView",v);p.directive("ngView",A);v.$inject=["$route","$anchorScroll","$animate"];A.$inject=["$compile","$controller","$route"]})(window,window.angular);
//# sourceMappingURL=angular-route.min.js.map
;
//! api-check version 7.5.5 built with ♥ by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us) (ó ì_í)=óò=(ì_í ò)
!function(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):"object"==typeof exports?exports.apiCheck=r():e.apiCheck=r()}(this,function(){return function(e){function r(n){if(t[n])return t[n].exports;var o=t[n]={exports:{},id:n,loaded:!1};return e[n].call(o.exports,o,o.exports,r),o.loaded=!0,o.exports}var t={};return r.m=e,r.c=t,r.p="",r(0)}([function(e,r,t){"use strict";function n(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(r,"__esModule",{value:!0});var o=t(3),i=n(o);r["default"]=i["default"],e.exports=r["default"]},function(e,r){function t(e,r){var t=[],o=[];return r=r||function(e,r){return"[Circular "+n(r,t,o)+"]"},function(n,i){var a=i;return"object"==typeof i&&i&&(-1!==t.indexOf(i)?a=r(n,i):(t.push(i),o.push(n))),e&&(a=e(n,a)),a}}function n(e,r,t){var n=r.indexOf(e),o=[t[n]];for(n--;n>=0;n--)r[n][o[0]]===e&&(e=r[n],o.unshift(t[n]));return"~"+o.join(".")}function o(e,r,n,o){return JSON.stringify(e,t(r,o),n)}e.exports=o,o.getSerialize=t},function(e,r,t){"use strict";function n(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function o(e){var r=i(e),t=void 0;if("array"===r)t=[];else{if("object"!==r)return e;t={}}return f(e,function(e,r){t[r]=e}),t}function i(e){return Array.isArray(e)?"array":e instanceof RegExp?"object":typeof e}function a(e,r){var t=void 0,n=r&&r["short"];return t=n&&e.shortType?e.shortType:!n&&"object"==typeof e.type||"function"===e.type?u(e,r):u(e,r)||e.displayName||e.name}function u(e,r){var t=e.type;if("function"==typeof t){var o=t.__apiCheckData,i=t(r);t=n({__apiCheckData:o},o.type,i)}return t}function p(e){return e?Array.isArray(e)?e:[e]:[]}function f(e,r,t){return Array.isArray(e)?s(e,r,t):c(e,r,t)}function c(e,r,t){var n=void 0,o=Object.prototype.hasOwnProperty;for(var i in e)if(o.call(e,i)&&(n=r.call(t,e[i],i,e),n===!1))return n;return!0}function s(e,r,t){for(var n=void 0,o=e.length,i=0;o>i;i++)if(n=r.call(t,e[i],i,e),n===!1)return n;return!0}function l(e){return e instanceof Error}function y(e,r,t){e=p(e);var n=e.slice(),o=n.pop();return 1===n.length&&(r=" "),n.join(r)+(""+(n.length?r+t:"")+o)}function h(e,r,t){"function"==typeof t&&(t=t({"short":!0}));var n="object"!=typeof t?t:A(t);return new Error(d(e,r)+" must be "+v(n))}function d(e,r){var t=v(e||"value"),n=r?" at "+v(r):"";return""+t+n}function v(e){return"`"+e+"`"}function g(e){return"undefined"==typeof e}function b(e,r,t){return t&&(e=_(),e.isNoop=!0),"string"==typeof e.type&&(e.shortType=e.type),f(r,function(r,t){return e[t]=r}),e.displayName||(e.displayName="apiCheck "+v(e.shortType||e.type||e.name)+" type checker"),e.notRequired||(e=m(e,t)),e.notNullable||k(e,t),e.notOptional||O(e,t),e}function m(e,r){var t=r?_():function(r,t,n,o){if(g(r)&&!e.isOptional){var i=n?" in "+v(n):"",u=a(e,{"short":!0}),p="object"!=typeof u?u:A(u);return new Error("Required "+v(t)+" not specified"+i+". Must be "+v(p))}return e(r,t,n,o)};return j(e,t),t.originalChecker=e,t}function O(e,r){var t=r?_():function(r,t,n,o){return g(r)?void 0:e(r,t,n,o)};j(e,t),t.isOptional=!0,t.displayName=e.displayName+" (optional)",t.originalChecker=e,e.optional=t,C(e,e.optional)}function k(e,r){var t=r?_():function(r,t,n,o){return null!==r?e(r,t,n,o):void 0};j(e,t),t.isNullable=!0,t.displayName=e.displayName+" (nullable)",t.originalChecker=e,e.nullable=t,C(e,e.nullable),e.notOptional||O(e.nullable,r)}function C(e,r){if("object"==typeof r.type)r.type=o(r.type);else{if("function"!=typeof r.type)return void(r.type+=" (optional)");r.type=function(){return e.type.apply(e,arguments)}}r.type.__apiCheckData=o(e.type.__apiCheckData)||{},r.type.__apiCheckData.optional=!0}function j(e,r){f(Object.keys(e),function(t){return r[t]=e[t]})}function x(){}function _(){return function(){}}var A=t(1),T={addOptional:O,getRequiredVersion:m,setupChecker:b,addNullable:k};e.exports={each:f,copy:o,typeOf:i,arrayify:p,getCheckerDisplay:a,isError:l,list:y,getError:h,nAtL:d,t:v,undef:g,checkerHelpers:T,noop:x}},function(e,r,t){"use strict";function n(){function r(n,i,a){if(r.config.disabled||e.exports.globalConfig.disabled)return{apiTypes:{},argTypes:{},passed:!0,message:"",failed:!1};t(arguments),Array.isArray(n)?i=Array.prototype.slice.call(i):(n=[n],i=[i]);var u=p(n,i);u.length||(u=o(n,i));var f=c(n,i);return f.args=i,u.length?(f.message=r.getErrorMessage(n,i,u,a),f.failed=!0,f.passed=!1):(f.message="",f.failed=!1,f.passed=!0),f}function t(e){var t=e[0],n=e[1],i=Array.isArray(n)||n&&"object"==typeof n&&"number"==typeof n.length;if(Array.isArray(t)&&!i)throw new Error(a(t,[n],["If an array is provided for the api, an array must be provided for the args as well."],{prefix:"apiCheck"}));var u=o(C.checkApiCheckApi,e);if(u.length){var p=r.getErrorMessage(C.checkApiCheckApi,e,u,{prefix:"apiCheck"});r.handleErrorMessage(p,!0)}}function n(e){return function(t,n,o){var i=r(t,n,o);return r.handleErrorMessage(i.message,e),i}}function i(e,r){if(r&&e)throw new Error(e);e&&console.warn(e)}function a(e,t){function n(){var e=p.onlyPrefix;return e||(e=((f.prefix||"")+" "+(p.prefix||"")).trim()),e}function o(){var e=p.onlySuffix;return e||(e=((p.suffix||"")+" "+(f.suffix||"")).trim()),e}function i(){var e=p.url;return e||(e=f.docsBaseUrl&&p.urlSuffix&&(""+f.docsBaseUrl+p.urlSuffix).trim()),e}var a=arguments.length<=2||void 0===arguments[2]?[]:arguments[2],p=arguments.length<=3||void 0===arguments[3]?{}:arguments[3],f=r.config.output||{},c=n(),s=o(),l=i(),y="apiCheck failed! "+a.join(", "),h="\n\n"+u(e,t);return(c+" "+y+" "+s+" "+(l||"")+h).trim()}function u(e,r){function t(e){h(e,function(r,n){-1===f.indexOf(r)&&(f.push(r),"object"==typeof r?t(e):"function"==typeof r&&(e[n]=r.displayName||r.name||"anonymous function"))})}function n(e){return e&&e.length?(e&&1===e.length&&(e=e[0]),l(e,null,2)):"nothing"}function o(){var e="\n",t=!0;r&&1===r.length&&(t="object"==typeof r[0]&&null!==r[0]?!!Object.keys(r[0]).length:!1);var n="type"+(t?"s":""),o=e+e;return"You passed:"+e+s+o+("With the "+n+":"+e+u+o)+("The API calls for:"+e+a)}var i=c(e,r),a=i.apiTypes,u=i.argTypes,p=Array.prototype.slice.call(r||[]),f=[];t(p);var s=n(p);return u=n(u),a=n(a),o()}function c(t,n){t=g(t),n=g(n);var o=t.map(function(t,o){var i=e.exports.globalConfig.hasOwnProperty("verbose");return b(t,{terse:i?!e.exports.globalConfig.verbose:!r.config.verbose,obj:n[o],addHelpers:!0})}),i=n.map(function(e){return f(e,[])});return{argTypes:i,apiTypes:o}}var s=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],d=arguments.length<=1||void 0===arguments[1]?{}:arguments[1];j&&arguments.length&&j["throw"](C.getApiCheckInstanceCheckers,arguments,{prefix:"creating an apiCheck instance"});var v={"throw":n(!0),warn:n(!1),getErrorMessage:a,handleErrorMessage:i,config:{output:s.output||{prefix:"",suffix:"",docsBaseUrl:""},verbose:s.verbose||!1,disabled:s.disabled||!1},utils:y};h(v,function(e,t){return r[t]=e});var m=r.disabled||e.exports.globalConfig.disabled;return h(k.getCheckers(m),function(e,t){return r[t]=e}),h(d,function(e,t){return r[t]=e}),r}function o(e,r){for(var t=[],n=!1,o=0,i=0,u=void 0,p=void 0,f=void 0,c=void 0,s=void 0,l=void 0,y=void 0;(p=e[o++])&&i<r.length;)u=r[i++],s="Argument "+i+(p.isOptional?" (optional)":""),f=p(u,"value",s),l=d(f),c=o>=e.length,y=o>1&&e[o-1].isOptional,l&&c||l&&!c&&!p.isOptional&&!y?(n=!0,t.push(a(f,p,u))):l&&p.isOptional?i--:t.push(v(s)+" passed");return n?t:[]}function i(e,r,t){var n=k.shape({type:k.string,optional:k.bool}),o=k.func.withProperties({__apiCheckData:n}),a=k.shape({__apiCheckData:n}),u=k.oneOfType([o,a])(e,r,t);return d(u)?u:"function"==typeof e||e.hasOwnProperty(e.__apiCheckData.type)?void 0:O(r,t,i.type)}function a(e,r,t){var n=u(r,t);return n=n?" - "+n:"",e.message+n}function u(e,r){var t=e.help;return t?("function"==typeof t&&(t=t(r)),t):""}function p(e,r){var t=e.filter(function(e){return!e.isOptional});return r.length<t.length?["Not enough arguments specified. Requires `"+t.length+"`, you passed `"+r.length+"`"]:[]}function f(e,r){function t(){return e&&Object.keys(e).length}function n(){return-1!==r.indexOf(e)?"[Circular]":(r.push(e),c(e,r))}var o=e&&e.constructor&&e.constructor.name,i=m(e);if("function"===i){if(t()){var a=l(n());return o+" (with properties: "+a+")"}return o}return null===e?"null":"array"!==i&&"object"!==i?i:t()?n():o}function c(e,r){var t={};return h(e,function(e,n){return t[n]=f(e,r)}),t}function s(){var e=k.string.optional,r=k.func.withProperties({type:k.oneOfType([k.string,i]).optional,displayName:k.string.optional,shortType:k.string.optional,notOptional:k.bool.optional,notRequired:k.bool.optional}),t=[k.shape({output:k.shape({prefix:k.string.optional,suffix:k.string.optional,docsBaseUrl:k.string.optional}).strict.optional,verbose:k.bool.optional,disabled:k.bool.optional}).strict.optional,k.objectOf(r).optional],n=[k.typeOrArrayOf(r),k.any.optional,k.shape({prefix:e,suffix:e,urlSuffix:e,onlyPrefix:e,onlySuffix:e,url:e}).strict.optional];return{checkerFnChecker:r,getApiCheckInstanceCheckers:t,checkApiCheckApi:n}}var l=t(1),y=t(2),h=y.each,d=y.isError,v=y.t,g=y.arrayify,b=y.getCheckerDisplay,m=y.typeOf,O=y.getError,k=t(4),C=s();e.exports=n,e.exports.VERSION="7.5.5",e.exports.utils=y,e.exports.globalConfig={verbose:!1,disabled:!1};var j=n({output:{prefix:"apiCheck"}});e.exports.internalChecker=j,h(k,function(r,t){return e.exports[t]=r}),i.type="function with __apiCheckData property and `${function.type}` property"},function(e,r,t){"use strict";function n(e){function r(r){var t=r.toLowerCase();return b(function(e,n,o){return a(e)!==t?y(n,o,r):void 0},{type:r},e)}function t(){var r="Function",t=b(function(e,t,n){return"function"!==a(e)?y(t,n,r):void 0},{type:r},e);return t.withProperties=function(r){var t=m.objectOf(m.func)(r,"properties","apiCheck.func.withProperties");if(c(t))throw t;var n=m.shape(r,!0);return n.type.__apiCheckData.type="func.withProperties",b(function(e,r,t){var o=m.func(e,r,t);return c(o)?o:n(e,r,t)},{type:n.type,shortType:"func.withProperties"},e)},t}function n(){var r="Object",t="Object (null ok)",n=b(function(e,r,n){return"object"!==a(e)?y(r,n,t):void 0},{type:t},e),o=b(function(e,r,t){return null===e||c(n(e,r,t))?y(r,t,o.type):void 0},{type:r,nullOk:n},e);return o}function i(r){return b(function(e,t,n){return e instanceof r?void 0:y(t,n,r.name)},{type:r.name},e)}function v(r){var t={__apiCheckData:{optional:!1,type:"enum"},"enum":r},n="oneOf["+r.map(function(e){return o(e)}).join(", ")+"]";return b(function(e,t,o){return r.some(function(r){return r===e})?void 0:y(t,o,n)},{type:t,shortType:n},e)}function O(r){function t(e){return e&&e["short"]?o:r.map(function(r){return f(r,e)})}var n=r.map(function(e){return f(e,{"short":!0})}),o="oneOfType["+n.join(", ")+"]";return t.__apiCheckData={optional:!1,type:"oneOfType"},b(function(e,t,n){return r.some(function(r){return!c(r(e,t,n))})?void 0:y(t,n,o)},{type:t,shortType:o},e)}function k(r){function t(e){return e&&e["short"]?o:f(r,e)}var n=f(r,{"short":!0}),o="arrayOf["+n+"]";return t.__apiCheckData={optional:!1,type:"arrayOf"},b(function(e,t,n){return c(m.array(e))||!e.every(function(e){return!c(r(e))})?y(t,n,o):void 0},{type:t,shortType:o},e)}function C(r){function t(e){return e&&e["short"]?o:f(r,e)}var n=f(r,{"short":!0}),o="objectOf["+n+"]";return t.__apiCheckData={optional:!1,type:"objectOf"},b(function(e,t,n){var i=m.object(e,t,n);if(c(i))return i;var a=u(e,function(e,n){return c(r(e,n,t))?!1:void 0});return a?void 0:y(t,n,o)},{type:t,shortType:o},e)}function j(r){function t(e){return e&&e["short"]?o:f(r,e)}var n=f(r,{"short":!0}),o="typeOrArrayOf["+n+"]";return t.__apiCheckData={optional:!1,type:"typeOrArrayOf"},b(function(e,t,n,i){return c(m.oneOfType([r,m.arrayOf(r)])(e,t,n,i))?y(t,n,o):void 0},{type:t,shortType:o},e)}function x(){function r(r,t){function n(){function e(e,r,t,n,o){function a(t,n,o){"string"==typeof e[r]?e[r]+=o:e[r].__apiCheckData[t]=n}if(t||!o||n.isOptional){if(t){var u=n(i[r],r,null,i);c(u)&&a("error","THIS IS THE PROBLEM: "+u.message," <-- THIS IS THE PROBLEM: "+u.message)}}else{var p="ITEM";n.type&&n.type.__apiCheckData&&(p=n.type.__apiCheckData.type.toUpperCase()),a("missing","MISSING THIS "+p," <-- YOU ARE MISSING THIS")}}var t=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],n={},o=t.terse,i=t.obj,a=t.addHelpers,p=t.required;return u(r,function(r,t){var u=i&&i.hasOwnProperty(t),c=g(p)?!r.isOptional:p;o&&!u&&r.isOptional||(n[t]=f(r,{terse:o,obj:i&&i[t],required:c,addHelpers:a})),a&&e(n,t,u,r,c)}),n}function o(){return n.apply(void 0,arguments)}var i={};u(r,function(e,r){i[r]=f(e)}),n.__apiCheckData={strict:!1,optional:!1,type:"shape"};var a=b(function(e,n,o){var i=!t&&m.object(e,n,o);if(c(i))return i;var a=void 0;return o=o?o+(n?"/":""):"",n=n||"",u(r,function(r,t){return e.hasOwnProperty(t)||!r.isOptional?(a=r(e[t],t,""+o+n,e),!c(a)):void 0}),c(a)?a:void 0},{type:n,shortType:"shape"},e);return o.__apiCheckData=p(a.type.__apiCheckData),o.__apiCheckData.strict=!0,a.strict=b(function(e,t,n){var o=a(e,t,n);if(c(o))return o;var i=Object.keys(r),u=Object.keys(e).filter(function(e){return-1===i.indexOf(e)});return u.length?new Error(h(t,n)+" cannot have extra properties: "+d(u.join("`, `"))+".It is limited to "+d(i.join("`, `"))):void 0},{type:o,shortType:"strict shape"},e),a}function t(r,t,o){var i=d(t.join(", ")),a="if "+(r?"all of":"at least one of"),u="specified "+a+" these are not specified: "+i+" (otherwise it's optional)",p="requiredIfNot"+(r?".all":"")+"["+t.join(", ")+"}]",f=n(o,u,p);return b(function(e,n,i,a){var u=a&&a.hasOwnProperty(n),p=r?"every":"some",c=t[p](function(e){return a&&a.hasOwnProperty(e)});return c||u?u?o(e,n,i,a):void 0:y(n,i,f)},{type:f,notRequired:!0},e)}function n(e,r,t){function n(r){return r&&r["short"]?t:f(e)}return n.__apiCheckData={optional:!1,type:"ifNot",description:r},n}return r.ifNot=function(r,t){Array.isArray(r)||(r=[r]);var o=void 0;o=1===r.length?"specified only if "+r[0]+" is not specified":"specified only if none of the following are specified: ["+l(r,", ","and ")+"]";var i="ifNot["+r.join(", ")+"]",a=n(t,o,i);return b(function(e,n,o,i){var u=i&&i.hasOwnProperty(n),p=r.some(function(e){return i&&i.hasOwnProperty(e)});return u===p?y(n,o,a):u?t(e,n,o,i):void 0},{notRequired:!0,type:a,shortType:i},e)},r.onlyIf=function(r,t){r=s(r);var o=void 0;o=1===r.length?"specified only if "+r[0]+" is also specified":"specified only if all of the following are specified: ["+l(r,", ","and ")+"]";var i="onlyIf["+r.join(", ")+"]",a=n(t,o,i);return b(function(e,n,o,i){var u=r.every(function(e){return i.hasOwnProperty(e)});return u?t(e,n,o,i):y(n,o,a)},{type:a,shortType:i},e)},r.requiredIfNot=function(e,r){return Array.isArray(e)||(e=[e]),t(!1,e,r)},r.requiredIfNot.all=function(e,r){if(!Array.isArray(e))throw new Error("requiredIfNot.all must be passed an array");return t(!0,e,r)},r}function _(){var r="function arguments";return b(function(e,t,n){return Array.isArray(e)||c(m.object(e))||c(m.number(e.length))?y(t,n,r):void 0},{type:r},e)}function A(){return b(function(){},{type:"any"},e)}function T(){var r="null";return b(function(e,t,n){return null!==e?y(t,n,r):void 0},{type:r},e)}function w(r,t){var n="Range ("+r+" - "+t+")";return b(function(e,o,i){return"number"!=typeof e||r>e||e>t?y(o,i,n):void 0},{type:n},e)}function E(r){var t="lessThan["+r+"]";return b(function(e,n,o){return"number"!=typeof e||e>r?y(n,o,t):void 0},{type:t},e)}function D(r){var t="greaterThan["+r+"]";return b(function(e,n,o){return"number"!=typeof e||r>e?y(n,o,t):void 0},{type:t},e)}function N(){var r="empty object";return b(function(e,t,n){return"object"!==a(e)||null===e||Object.keys(e).length?y(t,n,r):void 0},{type:r},e)}return{array:r("Array"),bool:r("Boolean"),number:r("Number"),string:r("String"),func:t(),object:n(),emptyObject:N(),instanceOf:i,oneOf:v,oneOfType:O,arrayOf:k,objectOf:C,typeOrArrayOf:j,range:w,lessThan:E,greaterThan:D,shape:x(),args:_(),any:A(),"null":T()}}var o=t(1),i=t(2),a=i.typeOf,u=i.each,p=i.copy,f=i.getCheckerDisplay,c=i.isError,s=i.arrayify,l=i.list,y=i.getError,h=i.nAtL,d=i.t,v=i.checkerHelpers,g=i.undef,b=v.setupChecker,m=e.exports=n();e.exports.getCheckers=n}])});
//# sourceMappingURL=api-check.min.js.map;
/*!
* angular-formly JavaScript Library v7.2.3
*
* @license MIT (http://license.angular-formly.com)
*
* built with ♥ by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us>
* (ó ì_í)=óò=(ì_í ò)
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("angular"), require("api-check"));
	else if(typeof define === 'function' && define.amd)
		define(["angular", "api-check"], factory);
	else if(typeof exports === 'object')
		exports["ngFormly"] = factory(require("angular"), require("api-check"));
	else
		root["ngFormly"] = factory(root["angular"], root["apiCheck"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _indexCommon = __webpack_require__(1);

	var _indexCommon2 = _interopRequireDefault(_indexCommon);

	exports['default'] = _indexCommon2['default'];
	module.exports = exports['default'];

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _angularFix = __webpack_require__(2);

	var _angularFix2 = _interopRequireDefault(_angularFix);

	var _providersFormlyApiCheck = __webpack_require__(4);

	var _providersFormlyApiCheck2 = _interopRequireDefault(_providersFormlyApiCheck);

	var _otherDocsBaseUrl = __webpack_require__(6);

	var _otherDocsBaseUrl2 = _interopRequireDefault(_otherDocsBaseUrl);

	var _providersFormlyUsability = __webpack_require__(7);

	var _providersFormlyUsability2 = _interopRequireDefault(_providersFormlyUsability);

	var _providersFormlyConfig = __webpack_require__(8);

	var _providersFormlyConfig2 = _interopRequireDefault(_providersFormlyConfig);

	var _providersFormlyValidationMessages = __webpack_require__(10);

	var _providersFormlyValidationMessages2 = _interopRequireDefault(_providersFormlyValidationMessages);

	var _servicesFormlyUtil = __webpack_require__(11);

	var _servicesFormlyUtil2 = _interopRequireDefault(_servicesFormlyUtil);

	var _servicesFormlyWarn = __webpack_require__(12);

	var _servicesFormlyWarn2 = _interopRequireDefault(_servicesFormlyWarn);

	var _directivesFormlyCustomValidation = __webpack_require__(13);

	var _directivesFormlyCustomValidation2 = _interopRequireDefault(_directivesFormlyCustomValidation);

	var _directivesFormlyField = __webpack_require__(14);

	var _directivesFormlyField2 = _interopRequireDefault(_directivesFormlyField);

	var _directivesFormlyFocus = __webpack_require__(15);

	var _directivesFormlyFocus2 = _interopRequireDefault(_directivesFormlyFocus);

	var _directivesFormlyForm = __webpack_require__(16);

	var _directivesFormlyForm2 = _interopRequireDefault(_directivesFormlyForm);

	var _runFormlyNgModelAttrsManipulator = __webpack_require__(17);

	var _runFormlyNgModelAttrsManipulator2 = _interopRequireDefault(_runFormlyNgModelAttrsManipulator);

	var _runFormlyCustomTags = __webpack_require__(18);

	var _runFormlyCustomTags2 = _interopRequireDefault(_runFormlyCustomTags);

	var ngModuleName = 'formly';

	exports['default'] = ngModuleName;

	var ngModule = _angularFix2['default'].module(ngModuleName, []);

	ngModule.constant('formlyApiCheck', _providersFormlyApiCheck2['default']);
	ngModule.constant('formlyErrorAndWarningsUrlPrefix', _otherDocsBaseUrl2['default']);
	ngModule.constant('formlyVersion', ("7.2.3")); // <-- webpack variable

	ngModule.provider('formlyUsability', _providersFormlyUsability2['default']);
	ngModule.provider('formlyConfig', _providersFormlyConfig2['default']);

	ngModule.factory('formlyValidationMessages', _providersFormlyValidationMessages2['default']);
	ngModule.factory('formlyUtil', _servicesFormlyUtil2['default']);
	ngModule.factory('formlyWarn', _servicesFormlyWarn2['default']);

	ngModule.directive('formlyCustomValidation', _directivesFormlyCustomValidation2['default']);
	ngModule.directive('formlyField', _directivesFormlyField2['default']);
	ngModule.directive('formlyFocus', _directivesFormlyFocus2['default']);
	ngModule.directive('formlyForm', _directivesFormlyForm2['default']);

	ngModule.run(_runFormlyNgModelAttrsManipulator2['default']);
	ngModule.run(_runFormlyCustomTags2['default']);
	module.exports = exports['default'];

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// some versions of angular don't export the angular module properly,
	// so we get it from window in this case.
	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var angular = __webpack_require__(3);

	/* istanbul ignore next */
	if (!angular.version) {
	  angular = window.angular;
	}
	exports['default'] = angular;
	module.exports = exports['default'];

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _angularFix = __webpack_require__(2);

	var _angularFix2 = _interopRequireDefault(_angularFix);

	var _apiCheck = __webpack_require__(5);

	var _apiCheck2 = _interopRequireDefault(_apiCheck);

	var apiCheck = (0, _apiCheck2['default'])({
	  output: {
	    prefix: 'angular-formly:',
	    docsBaseUrl: __webpack_require__(6)
	  }
	});

	function shapeRequiredIfNot(otherProps, propChecker) {
	  if (!_angularFix2['default'].isArray(otherProps)) {
	    otherProps = [otherProps];
	  }
	  var type = 'specified if these are not specified: `' + otherProps.join(', ') + '` (otherwise it\'s optional)';

	  function shapeRequiredIfNotDefinition(prop, propName, location, obj) {
	    var propExists = obj && obj.hasOwnProperty(propName);
	    var otherPropsExist = otherProps.some(function (otherProp) {
	      return obj && obj.hasOwnProperty(otherProp);
	    });
	    if (!otherPropsExist && !propExists) {
	      return apiCheck.utils.getError(propName, location, type);
	    } else if (propExists) {
	      return propChecker(prop, propName, location, obj);
	    }
	  }

	  shapeRequiredIfNotDefinition.type = type;
	  return apiCheck.utils.checkerHelpers.setupChecker(shapeRequiredIfNotDefinition);
	}

	var formlyExpression = apiCheck.oneOfType([apiCheck.string, apiCheck.func]);
	var specifyWrapperType = apiCheck.typeOrArrayOf(apiCheck.string).nullable;

	var apiCheckProperty = apiCheck.func;

	var apiCheckInstanceProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.func.withProperties({
	  warn: apiCheck.func,
	  'throw': apiCheck.func,
	  shape: apiCheck.func
	}));

	var apiCheckFunctionProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.oneOf(['throw', 'warn']));

	var formlyWrapperType = apiCheck.shape({
	  name: shapeRequiredIfNot('types', apiCheck.string).optional,
	  template: apiCheck.shape.ifNot('templateUrl', apiCheck.string).optional,
	  templateUrl: apiCheck.shape.ifNot('template', apiCheck.string).optional,
	  types: apiCheck.typeOrArrayOf(apiCheck.string).optional,
	  overwriteOk: apiCheck.bool.optional,
	  apiCheck: apiCheckProperty.optional,
	  apiCheckInstance: apiCheckInstanceProperty.optional,
	  apiCheckFunction: apiCheckFunctionProperty.optional,
	  apiCheckOptions: apiCheck.object.optional
	}).strict;

	var expressionProperties = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({
	  expression: formlyExpression,
	  message: formlyExpression.optional
	}).strict]));

	var modelChecker = apiCheck.oneOfType([apiCheck.string, apiCheck.object]);

	var templateManipulators = apiCheck.shape({
	  preWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional,
	  postWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional
	}).strict.nullable;

	var validatorChecker = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({
	  expression: formlyExpression,
	  message: formlyExpression.optional
	}).strict]));

	var fieldOptionsApiShape = {
	  $$hashKey: apiCheck.any.optional,
	  type: apiCheck.shape.ifNot(['template', 'templateUrl'], apiCheck.string).optional,
	  template: apiCheck.shape.ifNot(['type', 'templateUrl'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,
	  templateUrl: apiCheck.shape.ifNot(['type', 'template'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,
	  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,
	  model: modelChecker.optional,
	  originalModel: modelChecker.optional,
	  className: apiCheck.string.optional,
	  id: apiCheck.string.optional,
	  name: apiCheck.string.optional,
	  expressionProperties: expressionProperties.optional,
	  extras: apiCheck.shape({
	    validateOnModelChange: apiCheck.bool.optional,
	    skipNgModelAttrsManipulator: apiCheck.oneOfType([apiCheck.string, apiCheck.bool]).optional
	  }).strict.optional,
	  data: apiCheck.object.optional,
	  templateOptions: apiCheck.object.optional,
	  wrapper: specifyWrapperType.optional,
	  modelOptions: apiCheck.shape({
	    updateOn: apiCheck.string.optional,
	    debounce: apiCheck.oneOfType([apiCheck.objectOf(apiCheck.number), apiCheck.number]).optional,
	    allowInvalid: apiCheck.bool.optional,
	    getterSetter: apiCheck.bool.optional,
	    timezone: apiCheck.string.optional
	  }).optional,
	  watcher: apiCheck.typeOrArrayOf(apiCheck.shape({
	    expression: formlyExpression.optional,
	    listener: formlyExpression
	  })).optional,
	  validators: validatorChecker.optional,
	  asyncValidators: validatorChecker.optional,
	  parsers: apiCheck.arrayOf(formlyExpression).optional,
	  formatters: apiCheck.arrayOf(formlyExpression).optional,
	  noFormControl: apiCheck.bool.optional,
	  hide: apiCheck.bool.optional,
	  hideExpression: formlyExpression.optional,
	  ngModelElAttrs: apiCheck.objectOf(apiCheck.string).optional,
	  ngModelAttrs: apiCheck.objectOf(apiCheck.shape({
	    statement: apiCheck.shape.ifNot(['value', 'attribute', 'bound', 'boolean'], apiCheck.any).optional,
	    value: apiCheck.shape.ifNot('statement', apiCheck.any).optional,
	    attribute: apiCheck.shape.ifNot('statement', apiCheck.any).optional,
	    bound: apiCheck.shape.ifNot('statement', apiCheck.any).optional,
	    boolean: apiCheck.shape.ifNot('statement', apiCheck.any).optional
	  }).strict).optional,
	  elementAttributes: apiCheck.objectOf(apiCheck.string).optional,
	  optionsTypes: apiCheck.typeOrArrayOf(apiCheck.string).optional,
	  link: apiCheck.func.optional,
	  controller: apiCheck.oneOfType([apiCheck.string, apiCheck.func, apiCheck.array]).optional,
	  validation: apiCheck.shape({
	    show: apiCheck.bool.nullable.optional,
	    messages: apiCheck.objectOf(formlyExpression).optional,
	    errorExistsAndShouldBeVisible: apiCheck.bool.optional
	  }).optional,
	  formControl: apiCheck.typeOrArrayOf(apiCheck.object).optional,
	  value: apiCheck.func.optional,
	  runExpressions: apiCheck.func.optional,
	  templateManipulators: templateManipulators.optional,
	  resetModel: apiCheck.func.optional,
	  updateInitialValue: apiCheck.func.optional,
	  initialValue: apiCheck.any.optional,
	  defaultValue: apiCheck.any.optional
	};

	var formlyFieldOptions = apiCheck.shape(fieldOptionsApiShape).strict;

	var formOptionsApi = apiCheck.shape({
	  formState: apiCheck.object.optional,
	  resetModel: apiCheck.func.optional,
	  updateInitialValue: apiCheck.func.optional,
	  removeChromeAutoComplete: apiCheck.bool.optional,
	  templateManipulators: templateManipulators.optional,
	  wrapper: specifyWrapperType.optional,
	  fieldTransform: apiCheck.oneOfType([apiCheck.func, apiCheck.array]).optional,
	  data: apiCheck.object.optional
	}).strict;

	var fieldGroup = apiCheck.shape({
	  $$hashKey: apiCheck.any.optional,
	  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,
	  // danger. Nested field groups wont get api-checked...
	  fieldGroup: apiCheck.arrayOf(apiCheck.oneOfType([formlyFieldOptions, apiCheck.object])),
	  className: apiCheck.string.optional,
	  options: formOptionsApi.optional,
	  hide: apiCheck.bool.optional,
	  hideExpression: formlyExpression.optional,
	  data: apiCheck.object.optional,
	  model: modelChecker.optional,
	  form: apiCheck.object.optional,
	  elementAttributes: apiCheck.objectOf(apiCheck.string).optional
	}).strict;

	var typeOptionsDefaultOptions = _angularFix2['default'].copy(fieldOptionsApiShape);
	typeOptionsDefaultOptions.key = apiCheck.string.optional;

	var formlyTypeOptions = apiCheck.shape({
	  name: apiCheck.string,
	  template: apiCheck.shape.ifNot('templateUrl', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,
	  templateUrl: apiCheck.shape.ifNot('template', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,
	  controller: apiCheck.oneOfType([apiCheck.func, apiCheck.string, apiCheck.array]).optional,
	  link: apiCheck.func.optional,
	  defaultOptions: apiCheck.oneOfType([apiCheck.func, apiCheck.shape(typeOptionsDefaultOptions)]).optional,
	  'extends': apiCheck.string.optional,
	  wrapper: specifyWrapperType.optional,
	  data: apiCheck.object.optional,
	  apiCheck: apiCheckProperty.optional,
	  apiCheckInstance: apiCheckInstanceProperty.optional,
	  apiCheckFunction: apiCheckFunctionProperty.optional,
	  apiCheckOptions: apiCheck.object.optional,
	  overwriteOk: apiCheck.bool.optional
	}).strict;

	_angularFix2['default'].extend(apiCheck, {
	  formlyTypeOptions: formlyTypeOptions, formlyFieldOptions: formlyFieldOptions, formlyExpression: formlyExpression, formlyWrapperType: formlyWrapperType, fieldGroup: fieldGroup, formOptionsApi: formOptionsApi
	});

	exports['default'] = apiCheck;
	module.exports = exports['default'];

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = "https://github.com/formly-js/angular-formly/blob/" + ("7.2.3") + "/other/ERRORS_AND_WARNINGS.md#";
	module.exports = exports["default"];

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _angularFix = __webpack_require__(2);

	var _angularFix2 = _interopRequireDefault(_angularFix);

	exports['default'] = formlyUsability;

	// @ngInject
	function formlyUsability(formlyApiCheck, formlyErrorAndWarningsUrlPrefix) {
	  var _this = this;

	  _angularFix2['default'].extend(this, {
	    getFormlyError: getFormlyError,
	    getFieldError: getFieldError,
	    checkWrapper: checkWrapper,
	    checkWrapperTemplate: checkWrapperTemplate,
	    getErrorMessage: getErrorMessage,
	    $get: function $get() {
	      return _this;
	    }
	  });

	  function getFieldError(errorInfoSlug, message, field) {
	    if (arguments.length < 3) {
	      field = message;
	      message = errorInfoSlug;
	      errorInfoSlug = null;
	    }
	    return new Error(getErrorMessage(errorInfoSlug, message) + (' Field definition: ' + _angularFix2['default'].toJson(field)));
	  }

	  function getFormlyError(errorInfoSlug, message) {
	    if (!message) {
	      message = errorInfoSlug;
	      errorInfoSlug = null;
	    }
	    return new Error(getErrorMessage(errorInfoSlug, message));
	  }

	  function getErrorMessage(errorInfoSlug, message) {
	    var url = '';
	    if (errorInfoSlug !== null) {
	      url = '' + formlyErrorAndWarningsUrlPrefix + errorInfoSlug;
	    }
	    return 'Formly Error: ' + message + '. ' + url;
	  }

	  function checkWrapper(wrapper) {
	    formlyApiCheck['throw'](formlyApiCheck.formlyWrapperType, wrapper, {
	      prefix: 'formlyConfig.setWrapper',
	      urlSuffix: 'setwrapper-validation-failed'
	    });
	  }

	  function checkWrapperTemplate(template, additionalInfo) {
	    var formlyTransclude = '<formly-transclude></formly-transclude>';
	    if (template.indexOf(formlyTransclude) === -1) {
	      throw getFormlyError('Template wrapper templates must use "' + formlyTransclude + '" somewhere in them. ' + ('This one does not have "<formly-transclude></formly-transclude>" in it: ' + template) + '\n' + ('Additional information: ' + JSON.stringify(additionalInfo)));
	    }
	  }
	}
	formlyUsability.$inject = ["formlyApiCheck", "formlyErrorAndWarningsUrlPrefix"];
	module.exports = exports['default'];

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	var _angularFix = __webpack_require__(2);

	var _angularFix2 = _interopRequireDefault(_angularFix);

	var _otherUtils = __webpack_require__(9);

	var _otherUtils2 = _interopRequireDefault(_otherUtils);

	exports['default'] = formlyConfig;

	// @ngInject
	function formlyConfig(formlyUsabilityProvider, formlyErrorAndWarningsUrlPrefix, formlyApiCheck) {
	  var _this2 = this;

	  var typeMap = {};
	  var templateWrappersMap = {};
	  var defaultWrapperName = 'default';
	  var _this = this;
	  var getError = formlyUsabilityProvider.getFormlyError;

	  _angularFix2['default'].extend(this, {
	    setType: setType,
	    getType: getType,
	    getTypeHeritage: getTypeHeritage,
	    setWrapper: setWrapper,
	    getWrapper: getWrapper,
	    getWrapperByType: getWrapperByType,
	    removeWrapperByName: removeWrapperByName,
	    removeWrappersForType: removeWrappersForType,
	    disableWarnings: false,
	    extras: {
	      disableNgModelAttrsManipulator: false,
	      fieldTransform: [],
	      ngModelAttrsManipulatorPreferUnbound: false,
	      removeChromeAutoComplete: false,
	      defaultHideDirective: 'ng-if',
	      getFieldId: null
	    },
	    templateManipulators: {
	      preWrapper: [],
	      postWrapper: []
	    },
	    $get: function $get() {
	      return _this2;
	    }
	  });

	  function setType(options) {
	    if (_angularFix2['default'].isArray(options)) {
	      var _ret = (function () {
	        var allTypes = [];
	        _angularFix2['default'].forEach(options, function (item) {
	          allTypes.push(setType(item));
	        });
	        return {
	          v: allTypes
	        };
	      })();

	      if (typeof _ret === 'object') return _ret.v;
	    } else if (_angularFix2['default'].isObject(options)) {
	      checkType(options);
	      if (options['extends']) {
	        extendTypeOptions(options);
	      }
	      typeMap[options.name] = options;
	      return typeMap[options.name];
	    } else {
	      throw getError('You must provide an object or array for setType. You provided: ' + JSON.stringify(arguments));
	    }
	  }

	  function checkType(options) {
	    formlyApiCheck['throw'](formlyApiCheck.formlyTypeOptions, options, {
	      prefix: 'formlyConfig.setType',
	      url: 'settype-validation-failed'
	    });
	    if (!options.overwriteOk) {
	      checkOverwrite(options.name, typeMap, options, 'types');
	    } else {
	      options.overwriteOk = undefined;
	    }
	  }

	  function extendTypeOptions(options) {
	    var extendsType = getType(options['extends'], true, options);
	    extendTypeControllerFunction(options, extendsType);
	    extendTypeLinkFunction(options, extendsType);
	    extendTypeDefaultOptions(options, extendsType);
	    _otherUtils2['default'].reverseDeepMerge(options, extendsType);
	    extendTemplate(options, extendsType);
	  }

	  function extendTemplate(options, extendsType) {
	    if (options.template && extendsType.templateUrl) {
	      delete options.templateUrl;
	    } else if (options.templateUrl && extendsType.template) {
	      delete options.template;
	    }
	  }

	  function extendTypeControllerFunction(options, extendsType) {
	    var extendsCtrl = extendsType.controller;
	    if (!_angularFix2['default'].isDefined(extendsCtrl)) {
	      return;
	    }
	    var optionsCtrl = options.controller;
	    if (_angularFix2['default'].isDefined(optionsCtrl)) {
	      options.controller = function ($scope, $controller) {
	        $controller(extendsCtrl, { $scope: $scope });
	        $controller(optionsCtrl, { $scope: $scope });
	      };
	      options.controller.$inject = ['$scope', '$controller'];
	    } else {
	      options.controller = extendsCtrl;
	    }
	  }

	  function extendTypeLinkFunction(options, extendsType) {
	    var extendsFn = extendsType.link;
	    if (!_angularFix2['default'].isDefined(extendsFn)) {
	      return;
	    }
	    var optionsFn = options.link;
	    if (_angularFix2['default'].isDefined(optionsFn)) {
	      options.link = function () {
	        extendsFn.apply(undefined, arguments);
	        optionsFn.apply(undefined, arguments);
	      };
	    } else {
	      options.link = extendsFn;
	    }
	  }

	  function extendTypeDefaultOptions(options, extendsType) {
	    var extendsDO = extendsType.defaultOptions;
	    if (!_angularFix2['default'].isDefined(extendsDO)) {
	      return;
	    }
	    var optionsDO = options.defaultOptions;
	    var optionsDOIsFn = _angularFix2['default'].isFunction(optionsDO);
	    var extendsDOIsFn = _angularFix2['default'].isFunction(extendsDO);
	    if (extendsDOIsFn) {
	      options.defaultOptions = function defaultOptions(opts, scope) {
	        var extendsDefaultOptions = extendsDO(opts, scope);
	        var mergedDefaultOptions = {};
	        _otherUtils2['default'].reverseDeepMerge(mergedDefaultOptions, opts, extendsDefaultOptions);
	        var extenderOptionsDefaultOptions = optionsDO;
	        if (optionsDOIsFn) {
	          extenderOptionsDefaultOptions = extenderOptionsDefaultOptions(mergedDefaultOptions, scope);
	        }
	        _otherUtils2['default'].reverseDeepMerge(extendsDefaultOptions, extenderOptionsDefaultOptions);
	        return extendsDefaultOptions;
	      };
	    } else if (optionsDOIsFn) {
	      options.defaultOptions = function defaultOptions(opts, scope) {
	        var newDefaultOptions = {};
	        _otherUtils2['default'].reverseDeepMerge(newDefaultOptions, opts, extendsDO);
	        return optionsDO(newDefaultOptions, scope);
	      };
	    }
	  }

	  function getType(name, throwError, errorContext) {
	    if (!name) {
	      return undefined;
	    }
	    var type = typeMap[name];
	    if (!type && throwError === true) {
	      throw getError('There is no type by the name of "' + name + '": ' + JSON.stringify(errorContext));
	    } else {
	      return type;
	    }
	  }

	  function getTypeHeritage(parent) {
	    var heritage = [];
	    var type = parent;
	    if (_angularFix2['default'].isString(type)) {
	      type = getType(parent);
	    }
	    parent = type['extends'];
	    while (parent) {
	      type = getType(parent);
	      heritage.push(type);
	      parent = type['extends'];
	    }
	    return heritage;
	  }

	  function setWrapper(_x, _x2) {
	    var _again = true;

	    _function: while (_again) {
	      var options = _x,
	          name = _x2;
	      _again = false;

	      if (_angularFix2['default'].isArray(options)) {
	        return options.map(function (wrapperOptions) {
	          return setWrapper(wrapperOptions);
	        });
	      } else if (_angularFix2['default'].isObject(options)) {
	        options.types = getOptionsTypes(options);
	        options.name = getOptionsName(options, name);
	        checkWrapperAPI(options);
	        templateWrappersMap[options.name] = options;
	        return options;
	      } else if (_angularFix2['default'].isString(options)) {
	        _x = {
	          template: options,
	          name: name
	        };
	        _x2 = undefined;
	        _again = true;
	        continue _function;
	      }
	    }
	  }

	  function getOptionsTypes(options) {
	    if (_angularFix2['default'].isString(options.types)) {
	      return [options.types];
	    }
	    if (!_angularFix2['default'].isDefined(options.types)) {
	      return [];
	    } else {
	      return options.types;
	    }
	  }

	  function getOptionsName(options, name) {
	    return options.name || name || options.types.join(' ') || defaultWrapperName;
	  }

	  function checkWrapperAPI(options) {
	    formlyUsabilityProvider.checkWrapper(options);
	    if (options.template) {
	      formlyUsabilityProvider.checkWrapperTemplate(options.template, options);
	    }
	    if (!options.overwriteOk) {
	      checkOverwrite(options.name, templateWrappersMap, options, 'templateWrappers');
	    } else {
	      delete options.overwriteOk;
	    }
	    checkWrapperTypes(options);
	  }

	  function checkWrapperTypes(options) {
	    var shouldThrow = !_angularFix2['default'].isArray(options.types) || !options.types.every(_angularFix2['default'].isString);
	    if (shouldThrow) {
	      throw getError('Attempted to create a template wrapper with types that is not a string or an array of strings');
	    }
	  }

	  function checkOverwrite(property, object, newValue, objectName) {
	    if (object.hasOwnProperty(property)) {
	      warn('overwriting-types-or-wrappers', ['Attempting to overwrite ' + property + ' on ' + objectName + ' which is currently', JSON.stringify(object[property]) + ' with ' + JSON.stringify(newValue), 'To supress this warning, specify the property "overwriteOk: true"'].join(' '));
	    }
	  }

	  function getWrapper(name) {
	    return templateWrappersMap[name || defaultWrapperName];
	  }

	  function getWrapperByType(type) {
	    /* eslint prefer-const:0 */
	    var wrappers = [];
	    for (var _name in templateWrappersMap) {
	      if (templateWrappersMap.hasOwnProperty(_name)) {
	        if (templateWrappersMap[_name].types && templateWrappersMap[_name].types.indexOf(type) !== -1) {
	          wrappers.push(templateWrappersMap[_name]);
	        }
	      }
	    }
	    return wrappers;
	  }

	  function removeWrapperByName(name) {
	    var wrapper = templateWrappersMap[name];
	    delete templateWrappersMap[name];
	    return wrapper;
	  }

	  function removeWrappersForType(type) {
	    var wrappers = getWrapperByType(type);
	    if (!wrappers) {
	      return undefined;
	    }
	    if (!_angularFix2['default'].isArray(wrappers)) {
	      return removeWrapperByName(wrappers.name);
	    } else {
	      wrappers.forEach(function (wrapper) {
	        return removeWrapperByName(wrapper.name);
	      });
	      return wrappers;
	    }
	  }

	  function warn() {
	    if (!_this.disableWarnings && console.warn) {
	      /* eslint no-console:0 */
	      var args = Array.prototype.slice.call(arguments);
	      var warnInfoSlug = args.shift();
	      args.unshift('Formly Warning:');
	      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);
	      console.warn.apply(console, _toConsumableArray(args));
	    }
	  }
	}
	formlyConfig.$inject = ["formlyUsabilityProvider", "formlyErrorAndWarningsUrlPrefix", "formlyApiCheck"];
	module.exports = exports['default'];

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _angularFix = __webpack_require__(2);

	var _angularFix2 = _interopRequireDefault(_angularFix);

	exports['default'] = {
	  formlyEval: formlyEval, getFieldId: getFieldId, reverseDeepMerge: reverseDeepMerge, findByNodeName: findByNodeName, arrayify: arrayify, extendFunction: extendFunction, extendArray: extendArray, startsWith: startsWith, contains: contains
	};

	function formlyEval(scope, expression, $modelValue, $viewValue, extraLocals) {
	  if (_angularFix2['default'].isFunction(expression)) {
	    return expression($viewValue, $modelValue, scope, extraLocals);
	  } else {
	    return scope.$eval(expression, _angularFix2['default'].extend({ $viewValue: $viewValue, $modelValue: $modelValue }, extraLocals));
	  }
	}

	function getFieldId(formId, options, index) {
	  if (options.id) {
	    return options.id;
	  }
	  var type = options.type;
	  if (!type && options.template) {
	    type = 'template';
	  } else if (!type && options.templateUrl) {
	    type = 'templateUrl';
	  }

	  return [formId, type, options.key, index].join('_');
	}

	function reverseDeepMerge(dest) {
	  _angularFix2['default'].forEach(arguments, function (src, index) {
	    if (!index) {
	      return;
	    }
	    _angularFix2['default'].forEach(src, function (val, prop) {
	      if (!_angularFix2['default'].isDefined(dest[prop])) {
	        dest[prop] = _angularFix2['default'].copy(val);
	      } else if (objAndSameType(dest[prop], val)) {
	        reverseDeepMerge(dest[prop], val);
	      }
	    });
	  });
	  return dest;
	}

	function objAndSameType(obj1, obj2) {
	  return _angularFix2['default'].isObject(obj1) && _angularFix2['default'].isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);
	}

	// recurse down a node tree to find a node with matching nodeName, for custom tags jQuery.find doesn't work in IE8
	function findByNodeName(el, nodeName) {
	  if (!el.prop) {
	    // not a jQuery or jqLite object -> wrap it
	    el = _angularFix2['default'].element(el);
	  }

	  if (el.prop('nodeName') === nodeName.toUpperCase()) {
	    return el;
	  }

	  var c = el.children();
	  for (var i = 0; c && i < c.length; i++) {
	    var node = findByNodeName(c[i], nodeName);
	    if (node) {
	      return node;
	    }
	  }
	}

	function arrayify(obj) {
	  if (obj && !_angularFix2['default'].isArray(obj)) {
	    obj = [obj];
	  } else if (!obj) {
	    obj = [];
	  }
	  return obj;
	}

	function extendFunction() {
	  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
	    fns[_key] = arguments[_key];
	  }

	  return function extendedFunction() {
	    var args = arguments;
	    fns.forEach(function (fn) {
	      return fn.apply(null, args);
	    });
	  };
	}

	function extendArray(primary, secondary, property) {
	  if (property) {
	    primary = primary[property];
	    secondary = secondary[property];
	  }
	  if (secondary && primary) {
	    _angularFix2['default'].forEach(secondary, function (item) {
	      if (primary.indexOf(item) === -1) {
	        primary.push(item);
	      }
	    });
	    return primary;
	  } else if (secondary) {
	    return secondary;
	  } else {
	    return primary;
	  }
	}

	function startsWith(str, search) {
	  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {
	    return str.length >= search.length && str.substring(0, search.length) === search;
	  } else {
	    return false;
	  }
	}

	function contains(str, search) {
	  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {
	    return str.length >= search.length && str.indexOf(search) !== -1;
	  } else {
	    return false;
	  }
	}
	module.exports = exports['default'];

/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = formlyValidationMessages;

	// @ngInject
	function formlyValidationMessages() {

	  var validationMessages = {
	    addTemplateOptionValueMessage: addTemplateOptionValueMessage,
	    addStringMessage: addStringMessage,
	    messages: {}
	  };

	  return validationMessages;

	  function addTemplateOptionValueMessage(name, prop, prefix, suffix, alternate) {
	    validationMessages.messages[name] = templateOptionValue(prop, prefix, suffix, alternate);
	  }

	  function addStringMessage(name, string) {
	    validationMessages.messages[name] = function () {
	      return string;
	    };
	  }

	  function templateOptionValue(prop, prefix, suffix, alternate) {
	    return function getValidationMessage(viewValue, modelValue, scope) {
	      if (scope.options.templateOptions[prop]) {
	        return prefix + " " + scope.options.templateOptions[prop] + " " + suffix;
	      } else {
	        return alternate;
	      }
	    };
	  }
	}
	module.exports = exports["default"];

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _otherUtils = __webpack_require__(9);

	var _otherUtils2 = _interopRequireDefault(_otherUtils);

	exports['default'] = formlyUtil;

	// @ngInject
	function formlyUtil() {
	  return _otherUtils2['default'];
	}
	module.exports = exports['default'];

/***/ },
/* 12 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	exports['default'] = formlyWarn;

	// @ngInject
	function formlyWarn(formlyConfig, formlyErrorAndWarningsUrlPrefix, $log) {
	  return function warn() {
	    if (!formlyConfig.disableWarnings) {
	      var args = Array.prototype.slice.call(arguments);
	      var warnInfoSlug = args.shift();
	      args.unshift('Formly Warning:');
	      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);
	      $log.warn.apply($log, _toConsumableArray(args));
	    }
	  };
	}
	formlyWarn.$inject = ["formlyConfig", "formlyErrorAndWarningsUrlPrefix", "$log"];
	module.exports = exports['default'];

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _angularFix = __webpack_require__(2);

	var _angularFix2 = _interopRequireDefault(_angularFix);

	exports['default'] = formlyCustomValidation;

	// @ngInject
	function formlyCustomValidation(formlyUtil) {
	  return {
	    restrict: 'A',
	    require: 'ngModel',
	    link: function formlyCustomValidationLink(scope, el, attrs, ctrl) {
	      var opts = scope.options;
	      opts.validation.messages = opts.validation.messages || {};
	      _angularFix2['default'].forEach(opts.validation.messages, function (message, key) {
	        opts.validation.messages[key] = function () {
	          return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);
	        };
	      });

	      var useNewValidatorsApi = ctrl.hasOwnProperty('$validators') && !attrs.hasOwnProperty('useParsers');
	      _angularFix2['default'].forEach(opts.validators, _angularFix2['default'].bind(null, addValidatorToPipeline, false));
	      _angularFix2['default'].forEach(opts.asyncValidators, _angularFix2['default'].bind(null, addValidatorToPipeline, true));

	      function addValidatorToPipeline(isAsync, validator, name) {
	        setupMessage(validator, name);
	        validator = _angularFix2['default'].isObject(validator) ? validator.expression : validator;
	        if (useNewValidatorsApi) {
	          setupWithValidators(validator, name, isAsync);
	        } else {
	          setupWithParsers(validator, name, isAsync);
	        }
	      }

	      function setupMessage(validator, name) {
	        var message = validator.message;
	        if (message) {
	          opts.validation.messages[name] = function () {
	            return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);
	          };
	        }
	      }

	      function setupWithValidators(validator, name, isAsync) {
	        var validatorCollection = isAsync ? '$asyncValidators' : '$validators';

	        ctrl[validatorCollection][name] = function evalValidity(modelValue, viewValue) {
	          return formlyUtil.formlyEval(scope, validator, modelValue, viewValue);
	        };
	      }

	      function setupWithParsers(validator, name, isAsync) {
	        var inFlightValidator = undefined;
	        ctrl.$parsers.unshift(function evalValidityOfParser(viewValue) {
	          var isValid = formlyUtil.formlyEval(scope, validator, ctrl.$modelValue, viewValue);
	          if (isAsync) {
	            ctrl.$pending = ctrl.$pending || {};
	            ctrl.$pending[name] = true;
	            inFlightValidator = isValid;
	            isValid.then(function () {
	              if (inFlightValidator === isValid) {
	                ctrl.$setValidity(name, true);
	              }
	            })['catch'](function () {
	              if (inFlightValidator === isValid) {
	                ctrl.$setValidity(name, false);
	              }
	            })['finally'](function () {
	              var $pending = ctrl.$pending || {};
	              if (Object.keys($pending).length === 1) {
	                delete ctrl.$pending;
	              } else {
	                delete ctrl.$pending[name];
	              }
	            });
	          } else {
	            ctrl.$setValidity(name, isValid);
	          }
	          return viewValue;
	        });
	      }
	    }
	  };
	}
	formlyCustomValidation.$inject = ["formlyUtil"];
	module.exports = exports['default'];

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	var _angularFix = __webpack_require__(2);

	var _angularFix2 = _interopRequireDefault(_angularFix);

	var _apiCheck = __webpack_require__(5);

	var _apiCheck2 = _interopRequireDefault(_apiCheck);

	exports['default'] = formlyField;

	/**
	 * @ngdoc directive
	 * @name formlyField
	 * @restrict AE
	 */
	// @ngInject
	function formlyField($http, $q, $compile, $templateCache, $interpolate, formlyConfig, formlyApiCheck, formlyUtil, formlyUsability, formlyWarn) {
	  var arrayify = formlyUtil.arrayify;

	  FormlyFieldController.$inject = ["$scope", "$timeout", "$parse", "$controller", "formlyValidationMessages"];
	  return {
	    restrict: 'AE',
	    transclude: true,
	    require: '?^formlyForm',
	    scope: {
	      options: '=',
	      model: '=',
	      originalModel: '=?',
	      formId: '@', // TODO remove formId in a breaking release
	      index: '=?',
	      fields: '=?',
	      formState: '=?',
	      formOptions: '=?',
	      form: '=?' // TODO require form in a breaking release
	    },
	    controller: FormlyFieldController,
	    link: fieldLink
	  };

	  // @ngInject
	  function FormlyFieldController($scope, $timeout, $parse, $controller, formlyValidationMessages) {
	    /* eslint max-statements:[2, 31] */
	    if ($scope.options.fieldGroup) {
	      setupFieldGroup();
	      return;
	    }

	    var fieldType = getFieldType($scope.options);
	    simplifyLife($scope.options);
	    mergeFieldOptionsWithTypeDefaults($scope.options, fieldType);
	    extendOptionsWithDefaults($scope.options, $scope.index);
	    checkApi($scope.options);
	    // set field id to link labels and fields

	    // initalization
	    setFieldIdAndName();
	    setDefaultValue();
	    setInitialValue();
	    runExpressions();
	    addValidationMessages($scope.options);
	    invokeControllers($scope, $scope.options, fieldType);

	    // function definitions
	    function runExpressions() {
	      // must run on next tick to make sure that the current value is correct.
	      return $timeout(function runExpressionsOnNextTick() {
	        var field = $scope.options;
	        var currentValue = valueGetterSetter();
	        _angularFix2['default'].forEach(field.expressionProperties, function runExpression(expression, prop) {
	          var setter = $parse(prop).assign;
	          var promise = $q.when(formlyUtil.formlyEval($scope, expression, currentValue, currentValue));
	          promise.then(function setFieldValue(value) {
	            setter(field, value);
	          });
	        });
	      }, 0, false);
	    }

	    function valueGetterSetter(newVal) {
	      if (!$scope.model || !$scope.options.key) {
	        return undefined;
	      }
	      if (_angularFix2['default'].isDefined(newVal)) {
	        $scope.model[$scope.options.key] = newVal;
	      }
	      return $scope.model[$scope.options.key];
	    }

	    function simplifyLife(options) {
	      // add a few empty objects (if they don't already exist) so you don't have to undefined check everywhere
	      formlyUtil.reverseDeepMerge(options, {
	        originalModel: options.model,
	        extras: {},
	        data: {},
	        templateOptions: {},
	        validation: {}
	      });
	      // create $scope.to so template authors can reference to instead of $scope.options.templateOptions
	      $scope.to = $scope.options.templateOptions;
	      $scope.formOptions = $scope.formOptions || {};
	    }

	    function setFieldIdAndName() {
	      if (_angularFix2['default'].isFunction(formlyConfig.extras.getFieldId)) {
	        $scope.id = formlyConfig.extras.getFieldId($scope.options, $scope.model, $scope);
	      } else {
	        var formName = $scope.form && $scope.form.$name || $scope.formId;
	        $scope.id = formlyUtil.getFieldId(formName, $scope.options, $scope.index);
	      }
	      $scope.options.id = $scope.id;
	      $scope.name = $scope.options.name || $scope.options.id;
	      $scope.options.name = $scope.name;
	    }

	    function setDefaultValue() {
	      if (_angularFix2['default'].isDefined($scope.options.defaultValue) && !_angularFix2['default'].isDefined($scope.model[$scope.options.key])) {
	        var setter = $parse($scope.options.key).assign;
	        setter($scope.model, $scope.options.defaultValue);
	      }
	    }

	    function setInitialValue() {
	      $scope.options.initialValue = $scope.model && $scope.model[$scope.options.key];
	    }

	    function mergeFieldOptionsWithTypeDefaults(options, type) {
	      if (type) {
	        mergeOptions(options, type.defaultOptions);
	      }
	      var properOrder = arrayify(options.optionsTypes).reverse(); // so the right things are overridden
	      _angularFix2['default'].forEach(properOrder, function (typeName) {
	        mergeOptions(options, formlyConfig.getType(typeName, true, options).defaultOptions);
	      });
	    }

	    function mergeOptions(options, extraOptions) {
	      if (extraOptions) {
	        if (_angularFix2['default'].isFunction(extraOptions)) {
	          extraOptions = extraOptions(options, $scope);
	        }
	        formlyUtil.reverseDeepMerge(options, extraOptions);
	      }
	    }

	    function extendOptionsWithDefaults(options, index) {
	      var key = options.key || index || 0;
	      _angularFix2['default'].extend(options, {
	        // attach the key in case the formly-field directive is used directly
	        key: key,
	        value: options.value || valueGetterSetter,
	        runExpressions: runExpressions,
	        resetModel: resetModel,
	        updateInitialValue: updateInitialValue
	      });
	    }

	    function resetModel() {
	      $scope.model[$scope.options.key] = $scope.options.initialValue;
	      if ($scope.options.formControl) {
	        if (_angularFix2['default'].isArray($scope.options.formControl)) {
	          _angularFix2['default'].forEach($scope.options.formControl, function (formControl) {
	            resetFormControl(formControl, true);
	          });
	        } else {
	          resetFormControl($scope.options.formControl);
	        }
	      }
	    }

	    function resetFormControl(formControl, isMultiNgModel) {
	      if (!isMultiNgModel) {
	        formControl.$setViewValue($scope.model[$scope.options.key]);
	      }

	      formControl.$render();
	      formControl.$setUntouched && formControl.$setUntouched();
	      formControl.$setPristine();

	      // To prevent breaking change requiring a digest to reset $viewModel
	      if (!$scope.$root.$$phase) {
	        $scope.$digest();
	      }
	    }

	    function updateInitialValue() {
	      $scope.options.initialValue = $scope.model[$scope.options.key];
	    }

	    function addValidationMessages(options) {
	      options.validation.messages = options.validation.messages || {};
	      _angularFix2['default'].forEach(formlyValidationMessages.messages, function createFunctionForMessage(expression, name) {
	        if (!options.validation.messages[name]) {
	          options.validation.messages[name] = function evaluateMessage(viewValue, modelValue, scope) {
	            return formlyUtil.formlyEval(scope, expression, modelValue, viewValue);
	          };
	        }
	      });
	    }

	    function invokeControllers(scope) {
	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	      var type = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	      _angularFix2['default'].forEach([type.controller, options.controller], function (controller) {
	        if (controller) {
	          $controller(controller, { $scope: scope });
	        }
	      });
	    }

	    function setupFieldGroup() {
	      $scope.options.options = $scope.options.options || {};
	      $scope.options.options.formState = $scope.formState;
	    }
	  }

	  // link function
	  function fieldLink(scope, el, attrs, formlyFormCtrl) {
	    if (scope.options.fieldGroup) {
	      setFieldGroupTemplate();
	      return;
	    }

	    // watch the field model (if exists) if there is no parent formly-form directive (that would watch it instead)
	    if (!formlyFormCtrl && scope.options.model) {
	      scope.$watch('options.model', function () {
	        return scope.options.runExpressions();
	      }, true);
	    }

	    addAttributes();
	    addClasses();

	    var type = getFieldType(scope.options);
	    var args = arguments;
	    var thusly = this;
	    var fieldCount = 0;
	    var fieldManipulators = getManipulators(scope.options, scope.formOptions);
	    getFieldTemplate(scope.options).then(runManipulators(fieldManipulators.preWrapper)).then(transcludeInWrappers(scope.options, scope.formOptions)).then(runManipulators(fieldManipulators.postWrapper)).then(setElementTemplate).then(watchFormControl).then(callLinkFunctions)['catch'](function (error) {
	      formlyWarn('there-was-a-problem-setting-the-template-for-this-field', 'There was a problem setting the template for this field ', scope.options, error);
	    });

	    function setFieldGroupTemplate() {
	      checkFieldGroupApi(scope.options);
	      //el.addClass('formly-field-group');
			el.addClass('row form-input-row');
	      var extraAttributes = '';
	      if (scope.options.elementAttributes) {
	        extraAttributes = Object.keys(scope.options.elementAttributes).map(function (key) {
	          return key + '="' + scope.options.elementAttributes[key] + '"';
	        }).join(' ');
	      }
	      var modelValue = 'model';
	      scope.options.form = scope.form;
	      if (scope.options.key) {
	        modelValue = 'model[\'' + scope.options.key + '\']';
	      }
	      setElementTemplate('\n          <formly-form model="' + modelValue + '"\n                       fields="options.fieldGroup"\n                       options="options.options"\n                       form="options.form"\n                       class="' + scope.options.className + '"\n                       ' + extraAttributes + '\n                       is-field-group>\n          </formly-form>\n        ');
	    }

	    function addAttributes() {
	      if (scope.options.elementAttributes) {
	        el.attr(scope.options.elementAttributes);
	      }
	    }

	    function addClasses() {
	      if (scope.options.className) {
	        el.addClass(scope.options.className);
	      }
	      if (scope.options.type) {
	        el.addClass('formly-field-' + scope.options.type);
	      }
	    }

	    function setElementTemplate(templateString) {
	      el.html(asHtml(templateString));
	      $compile(el.contents())(scope);
	      return templateString;
	    }

	    function watchFormControl(templateString) {
	      var stopWatchingShowError = _angularFix2['default'].noop;
	      if (scope.options.noFormControl) {
	        return;
	      }
	      var templateEl = _angularFix2['default'].element('<div>' + templateString + '</div>');
	      var ngModelNodes = templateEl[0].querySelectorAll('[ng-model],[data-ng-model]');

	      if (ngModelNodes.length) {
	        _angularFix2['default'].forEach(ngModelNodes, function (ngModelNode) {
	          fieldCount++;
	          watchFieldNameOrExistence(ngModelNode.getAttribute('name'));
	        });
	      }

	      function watchFieldNameOrExistence(name) {
	        var nameExpressionRegex = /\{\{(.*?)}}/;
	        var nameExpression = nameExpressionRegex.exec(name);
	        if (nameExpression) {
	          name = $interpolate(name)(scope);
	        }
	        watchFieldExistence(name);
	      }

	      function watchFieldExistence(name) {
	        scope.$watch('form["' + name + '"]', function formControlChange(formControl) {
	          if (formControl) {
	            if (fieldCount > 1) {
	              if (!scope.options.formControl) {
	                scope.options.formControl = [];
	              }
	              scope.options.formControl.push(formControl);
	            } else {
	              scope.options.formControl = formControl;
	            }
	            scope.fc = scope.options.formControl; // shortcut for template authors
	            stopWatchingShowError();
	            addShowMessagesWatcher();
	            addParsers();
	            addFormatters();
	          }
	        });
	      }

	      function addShowMessagesWatcher() {
	        stopWatchingShowError = scope.$watch(function watchShowValidationChange() {
	          var customExpression = formlyConfig.extras.errorExistsAndShouldBeVisibleExpression;
	          var options = scope.options;
	          var fc = scope.fc;

	          if (!fc.$invalid) {
	            return false;
	          } else if (typeof options.validation.show === 'boolean') {
	            return options.validation.show;
	          } else if (customExpression) {
	            return formlyUtil.formlyEval(scope, customExpression, fc.$modelValue, fc.$viewValue);
	          } else {
	            var noTouchedButDirty = _angularFix2['default'].isUndefined(fc.$touched) && fc.$dirty;
	            return scope.fc.$touched || noTouchedButDirty;
	          }
	        }, function onShowValidationChange(show) {
	          scope.options.validation.errorExistsAndShouldBeVisible = show;
	          scope.showError = show; // shortcut for template authors
	        });
	      }

	      function addParsers() {
	        setParsersOrFormatters('parsers');
	      }

	      function addFormatters() {
	        setParsersOrFormatters('formatters');
	        var ctrl = scope.fc;
	        var formWasPristine = scope.form.$pristine;
	        if (scope.options.formatters) {
	          (function () {
	            var value = ctrl.$modelValue;
	            ctrl.$formatters.forEach(function (formatter) {
	              value = formatter(value);
	            });

	            ctrl.$setViewValue(value);
	            ctrl.$render();
	            ctrl.$setPristine();
	            if (formWasPristine) {
	              scope.form.$setPristine();
	            }
	          })();
	        }
	      }

	      function setParsersOrFormatters(which) {
	        var originalThingProp = 'originalParser';
	        if (which === 'formatters') {
	          originalThingProp = 'originalFormatter';
	        }

	        // init with type's parsers
	        var things = getThingsFromType(type);

	        // get optionsTypes things
	        things = formlyUtil.extendArray(things, getThingsFromOptionsTypes(scope.options.optionsTypes));

	        // get field's things
	        things = formlyUtil.extendArray(things, scope.options[which]);

	        // convert things into formlyExpression things
	        _angularFix2['default'].forEach(things, function (thing, index) {
	          things[index] = getFormlyExpressionThing(thing);
	        });

	        var ngModelCtrls = scope.fc;
	        if (!_angularFix2['default'].isArray(ngModelCtrls)) {
	          ngModelCtrls = [ngModelCtrls];
	        }

	        _angularFix2['default'].forEach(ngModelCtrls, function (ngModelCtrl) {
	          var _ngModelCtrl;

	          ngModelCtrl['$' + which] = (_ngModelCtrl = ngModelCtrl['$' + which]).concat.apply(_ngModelCtrl, _toConsumableArray(things));
	        });

	        function getThingsFromType(theType) {
	          if (!theType) {
	            return [];
	          }
	          if (_angularFix2['default'].isString(theType)) {
	            theType = formlyConfig.getType(theType, true, scope.options);
	          }
	          var typeThings = [];

	          // get things from parent
	          if (theType['extends']) {
	            typeThings = formlyUtil.extendArray(typeThings, getThingsFromType(theType['extends']));
	          }

	          // get own type's things
	          typeThings = formlyUtil.extendArray(typeThings, getDefaultOptionsProperty(theType, which, []));

	          // get things from optionsTypes
	          typeThings = formlyUtil.extendArray(typeThings, getThingsFromOptionsTypes(getDefaultOptionsOptionsTypes(theType)));

	          return typeThings;
	        }

	        function getThingsFromOptionsTypes() {
	          var optionsTypes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

	          var optionsTypesThings = [];
	          _angularFix2['default'].forEach(_angularFix2['default'].copy(arrayify(optionsTypes)).reverse(), function (optionsTypeName) {
	            optionsTypesThings = formlyUtil.extendArray(optionsTypesThings, getThingsFromType(optionsTypeName));
	          });
	          return optionsTypesThings;
	        }

	        function getFormlyExpressionThing(thing) {
	          formlyExpressionParserOrFormatterFunction[originalThingProp] = thing;
	          return formlyExpressionParserOrFormatterFunction;

	          function formlyExpressionParserOrFormatterFunction($viewValue) {
	            var $modelValue = scope.options.value();
	            return formlyUtil.formlyEval(scope, thing, $modelValue, $viewValue);
	          }
	        }
	      }
	    }

	    function callLinkFunctions() {
	      if (type && type.link) {
	        type.link.apply(thusly, args);
	      }
	      if (scope.options.link) {
	        scope.options.link.apply(thusly, args);
	      }
	    }

	    function runManipulators(manipulators) {
	      return function runManipulatorsOnTemplate(templateToManipulate) {
	        var chain = $q.when(templateToManipulate);
	        _angularFix2['default'].forEach(manipulators, function (manipulator) {
	          chain = chain.then(function (template) {
	            return $q.when(manipulator(template, scope.options, scope)).then(function (newTemplate) {
	              return _angularFix2['default'].isString(newTemplate) ? newTemplate : asHtml(newTemplate);
	            });
	          });
	        });
	        return chain;
	      };
	    }
	  }

	  // sort-of stateless util functions
	  function asHtml(el) {
	    var wrapper = _angularFix2['default'].element('<a></a>');
	    return wrapper.append(el).html();
	  }

	  function getFieldType(options) {
	    return options.type && formlyConfig.getType(options.type);
	  }

	  function getManipulators(options, formOptions) {
	    var preWrapper = [];
	    var postWrapper = [];
	    addManipulators(options.templateManipulators);
	    addManipulators(formOptions.templateManipulators);
	    addManipulators(formlyConfig.templateManipulators);
	    return { preWrapper: preWrapper, postWrapper: postWrapper };

	    function addManipulators(manipulators) {
	      /* eslint-disable */ // it doesn't understand this :-(

	      var _ref = manipulators || {};

	      var _ref$preWrapper = _ref.preWrapper;
	      var pre = _ref$preWrapper === undefined ? [] : _ref$preWrapper;
	      var _ref$postWrapper = _ref.postWrapper;
	      var post = _ref$postWrapper === undefined ? [] : _ref$postWrapper;

	      preWrapper = preWrapper.concat(pre);
	      postWrapper = postWrapper.concat(post);
	      /* eslint-enable */
	    }
	  }

	  function getFieldTemplate(options) {
	    function fromOptionsOrType(key, fieldType) {
	      if (_angularFix2['default'].isDefined(options[key])) {
	        return options[key];
	      } else if (fieldType && _angularFix2['default'].isDefined(fieldType[key])) {
	        return fieldType[key];
	      }
	    }

	    var type = formlyConfig.getType(options.type, true, options);
	    var template = fromOptionsOrType('template', type);
	    var templateUrl = fromOptionsOrType('templateUrl', type);
	    if (_angularFix2['default'].isUndefined(template) && !templateUrl) {
	      throw formlyUsability.getFieldError('type-type-has-no-template', 'Type \'' + options.type + '\' has no template. On element:', options);
	    }

	    return getTemplate(templateUrl || template, _angularFix2['default'].isUndefined(template), options);
	  }

	  function getTemplate(template, isUrl, options) {
	    var templatePromise = undefined;
	    if (_angularFix2['default'].isFunction(template)) {
	      templatePromise = $q.when(template(options));
	    } else {
	      templatePromise = $q.when(template);
	    }

	    if (!isUrl) {
	      return templatePromise;
	    } else {
	      var _ret2 = (function () {
	        var httpOptions = { cache: $templateCache };
	        return {
	          v: templatePromise.then(function (url) {
	            return $http.get(url, httpOptions);
	          }).then(function (response) {
	            return response.data;
	          })['catch'](function handleErrorGettingATemplate(error) {
	            formlyWarn('problem-loading-template-for-templateurl', 'Problem loading template for ' + template, error);
	          })
	        };
	      })();

	      if (typeof _ret2 === 'object') return _ret2.v;
	    }
	  }

	  function transcludeInWrappers(options, formOptions) {
	    var wrapper = getWrapperOption(options, formOptions);

	    return function transcludeTemplate(template) {
	      if (!wrapper.length) {
	        return $q.when(template);
	      }

	      wrapper.forEach(function (aWrapper) {
	        formlyUsability.checkWrapper(aWrapper, options);
	        runApiCheck(aWrapper, options);
	      });
	      var promises = wrapper.map(function (w) {
	        return getTemplate(w.template || w.templateUrl, !w.template);
	      });
	      return $q.all(promises).then(function (wrappersTemplates) {
	        wrappersTemplates.forEach(function (wrapperTemplate, index) {
	          formlyUsability.checkWrapperTemplate(wrapperTemplate, wrapper[index]);
	        });
	        wrappersTemplates.reverse(); // wrapper 0 is wrapped in wrapper 1 and so on...
	        var totalWrapper = wrappersTemplates.shift();
	        wrappersTemplates.forEach(function (wrapperTemplate) {
	          totalWrapper = doTransclusion(totalWrapper, wrapperTemplate);
	        });
	        return doTransclusion(totalWrapper, template);
	      });
	    };
	  }

	  function doTransclusion(wrapper, template) {
	    var superWrapper = _angularFix2['default'].element('<a></a>'); // this allows people not have to have a single root in wrappers
	    superWrapper.append(wrapper);
	    var transcludeEl = superWrapper.find('formly-transclude');
	    if (!transcludeEl.length) {
	      // try it using our custom find function
	      transcludeEl = formlyUtil.findByNodeName(superWrapper, 'formly-transclude');
	    }
	    transcludeEl.replaceWith(template);
	    return superWrapper.html();
	  }

	  function getWrapperOption(options, formOptions) {
	    /* eslint complexity:[2, 6] */
	    var wrapper = options.wrapper;
	    // explicit null means no wrapper
	    if (wrapper === null) {
	      return [];
	    }

	    // nothing specified means use the default wrapper for the type
	    if (!wrapper) {
	      // get all wrappers that specify they apply to this type
	      wrapper = arrayify(formlyConfig.getWrapperByType(options.type));
	    } else {
	      wrapper = arrayify(wrapper).map(formlyConfig.getWrapper);
	    }

	    // get all wrappers for that the type specified that it uses.
	    var type = formlyConfig.getType(options.type, true, options);
	    if (type && type.wrapper) {
	      var typeWrappers = arrayify(type.wrapper).map(formlyConfig.getWrapper);
	      wrapper = wrapper.concat(typeWrappers);
	    }

	    // add form wrappers
	    if (formOptions.wrapper) {
	      var formWrappers = arrayify(formOptions.wrapper).map(formlyConfig.getWrapper);
	      wrapper = wrapper.concat(formWrappers);
	    }

	    // add the default wrapper last
	    var defaultWrapper = formlyConfig.getWrapper();
	    if (defaultWrapper) {
	      wrapper.push(defaultWrapper);
	    }
	    return wrapper;
	  }

	  function checkApi(options) {
	    formlyApiCheck['throw'](formlyApiCheck.formlyFieldOptions, options, {
	      prefix: 'formly-field directive',
	      url: 'formly-field-directive-validation-failed'
	    });
	    // validate with the type
	    var type = options.type && formlyConfig.getType(options.type);
	    if (type) {
	      runApiCheck(type, options, true);
	    }
	    if (options.expressionProperties && options.expressionProperties.hide) {
	      formlyWarn('dont-use-expressionproperties.hide-use-hideexpression-instead', 'You have specified `hide` in `expressionProperties`. Use `hideExpression` instead', options);
	    }
	  }

	  function checkFieldGroupApi(options) {
	    formlyApiCheck['throw'](formlyApiCheck.fieldGroup, options, {
	      prefix: 'formly-field directive',
	      url: 'formly-field-directive-validation-failed'
	    });
	  }

	  function runApiCheck(_ref2, options, forType) {
	    var apiCheck = _ref2.apiCheck;
	    var apiCheckInstance = _ref2.apiCheckInstance;
	    var apiCheckFunction = _ref2.apiCheckFunction;
	    var apiCheckOptions = _ref2.apiCheckOptions;

	    runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options);
	    if (forType && options.type) {
	      _angularFix2['default'].forEach(formlyConfig.getTypeHeritage(options.type), function (type) {
	        runApiCheckForType(type.apiCheck, type.apiCheckInstance, type.apiCheckFunction, type.apiCheckOptions, options);
	      });
	    }
	  }

	  function runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options) {
	    /* eslint complexity:[2, 9] */
	    if (!apiCheck) {
	      return;
	    }
	    var instance = apiCheckInstance || formlyConfig.extras.apiCheckInstance || formlyApiCheck;
	    if (instance.config.disabled || _apiCheck2['default'].globalConfig.disabled) {
	      return;
	    }
	    var fn = apiCheckFunction || 'warn';
	    // this is the new API
	    var checkerObjects = apiCheck(instance);
	    _angularFix2['default'].forEach(checkerObjects, function (shape, name) {
	      var checker = instance.shape(shape);
	      var checkOptions = _angularFix2['default'].extend({
	        prefix: 'formly-field type ' + options.type + ' for property ' + name,
	        url: formlyApiCheck.config.output.docsBaseUrl + 'formly-field-type-apicheck-failed'
	      }, apiCheckOptions);
	      instance[fn](checker, options[name], checkOptions);
	    });
	  }
	}
	formlyField.$inject = ["$http", "$q", "$compile", "$templateCache", "$interpolate", "formlyConfig", "formlyApiCheck", "formlyUtil", "formlyUsability", "formlyWarn"];

	// Stateless util functions
	function getDefaultOptionsOptionsTypes(type) {
	  return getDefaultOptionsProperty(type, 'optionsTypes', []);
	}

	function getDefaultOptionsProperty(type, prop, defaultValue) {
	  return type.defaultOptions && type.defaultOptions[prop] || defaultValue;
	}
	module.exports = exports['default'];

/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = formlyFocus;

	// @ngInject
	function formlyFocus($timeout, $document) {
	  return {
	    restrict: 'A',
	    link: function formlyFocusLink(scope, element, attrs) {
	      var previousEl = null;
	      var el = element[0];
	      var doc = $document[0];
	      attrs.$observe('formlyFocus', function respondToFocusExpressionChange(value) {
	        /* eslint no-bitwise:0 */ // I know what I'm doing. I promise...
	        if (value === 'true') {
	          $timeout(function setElementFocus() {
	            previousEl = doc.activeElement;
	            el.focus();
	          }, ~ ~attrs.focusWait);
	        } else if (value === 'false') {
	          if (doc.activeElement === el) {
	            el.blur();
	            if (attrs.hasOwnProperty('refocus') && previousEl) {
	              previousEl.focus();
	            }
	          }
	        }
	      });
	    }
	  };
	}
	formlyFocus.$inject = ["$timeout", "$document"];
	module.exports = exports['default'];

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var _slice = Array.prototype.slice;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	var _angularFix = __webpack_require__(2);

	var _angularFix2 = _interopRequireDefault(_angularFix);

	exports['default'] = formlyForm;

	/**
	 * @ngdoc directive
	 * @name formlyForm
	 * @restrict AE
	 */
	// @ngInject
	function formlyForm(formlyUsability, formlyWarn, $parse, formlyConfig, $interpolate) {
	  var currentFormId = 1;
	  FormlyFormController.$inject = ["$scope", "formlyApiCheck", "formlyUtil"];
	  return {
	    restrict: 'AE',
	    template: formlyFormGetTemplate,
	    replace: true,
	    transclude: true,
	    scope: {
	      fields: '=',
	      model: '=',
	      form: '=?',
	      options: '=?'
	    },
	    controller: FormlyFormController,
	    link: formlyFormLink
	  };

	  function formlyFormGetTemplate(el, attrs) {
	    var rootEl = getRootEl();
	    var fieldRootEl = getFieldRootEl();
	    var formId = 'formly_' + currentFormId++;
	    var parentFormAttributes = '';
	    if (attrs.hasOwnProperty('isFieldGroup') && el.parent().parent().hasClass('formly')) {
	      parentFormAttributes = copyAttributes(el.parent().parent()[0].attributes);
	    }
	    return '\n        <' + rootEl + ' class="formly"\n                 name="' + getFormName() + '"\n                 role="form" ' + parentFormAttributes + '>\n          <' + fieldRootEl + ' formly-field\n               ng-repeat="field in fields ' + getTrackBy() + '"\n               ' + getHideDirective() + '="!field.hide"\n               class="formly-field"\n               options="field"\n               model="field.model || model"\n               original-model="model"\n               fields="fields"\n               form="theFormlyForm"\n               form-id="' + getFormName() + '"\n               form-state="options.formState"\n               form-options="options"\n               index="$index">\n          </' + fieldRootEl + '>\n          <div ng-transclude class="' + getTranscludeClass() + '"></div>\n        </' + rootEl + '>\n      ';

	    function getRootEl() {
	      return attrs.rootEl || 'ng-form';
	    }

	    function getFieldRootEl() {
	      return attrs.fieldRootEl || 'div';
	    }

	    function getHideDirective() {
	      return attrs.hideDirective || formlyConfig.extras.defaultHideDirective || 'ng-if';
	    }

	    function getTrackBy() {
	      if (!attrs.trackBy) {
	        return '';
	      } else {
	        return 'track by ' + attrs.trackBy;
	      }
	    }

	    function getFormName() {
	      var formName = formId;
	      var bindName = attrs.bindName;
	      if (bindName) {
	        if (_angularFix2['default'].version.minor < 3) {
	          throw formlyUsability.getFormlyError('bind-name attribute on formly-form not allowed in < angular 1.3');
	        }
	        // we can do a one-time binding here because we know we're in 1.3.x territory
	        formName = $interpolate.startSymbol() + '::\'formly_\' + ' + bindName + $interpolate.endSymbol();
	      }
	      return formName;
	    }

	    function getTranscludeClass() {
	      return attrs.transcludeClass || '';
	    }

	    function copyAttributes(attributes) {
	      var excluded = ['model', 'form', 'fields', 'options', 'name', 'role', 'class', 'data-model', 'data-form', 'data-fields', 'data-options', 'data-name'];
	      var arrayAttrs = [];
	      _angularFix2['default'].forEach(attributes, function (_ref) {
	        var nodeName = _ref.nodeName;
	        var value = _ref.value;

	        if (nodeName !== 'undefined' && excluded.indexOf(nodeName) === -1) {
	          arrayAttrs.push(toKebabCase(nodeName) + '="' + value + '"');
	        }
	      });
	      return arrayAttrs.join(' ');
	    }
	  }

	  // @ngInject
	  function FormlyFormController($scope, formlyApiCheck, formlyUtil) {
	    setupOptions();
	    $scope.model = $scope.model || {};
	    setupFields();

	    // watch the model and evaluate watch expressions that depend on it.
	    $scope.$watch('model', onModelOrFormStateChange, true);
	    if ($scope.options.formState) {
	      $scope.$watch('options.formState', onModelOrFormStateChange, true);
	    }

	    function onModelOrFormStateChange() {
	      _angularFix2['default'].forEach($scope.fields, function runFieldExpressionProperties(field, index) {
	        var model = field.model || $scope.model;
	        var promise = field.runExpressions && field.runExpressions();
	        if (field.hideExpression) {
	          // can't use hide with expressionProperties reliably
	          var val = model[field.key];
	          field.hide = evalCloseToFormlyExpression(field.hideExpression, val, field, index);
	        }
	        if (field.extras && field.extras.validateOnModelChange && field.formControl) {
	          var validate = field.formControl.$validate;
	          if (promise) {
	            promise.then(validate);
	          } else {
	            validate();
	          }
	        }
	      });
	    }

	    function setupFields() {
	      $scope.fields = $scope.fields || [];

	      checkDeprecatedOptions($scope.options);

	      var fieldTransforms = $scope.options.fieldTransform || formlyConfig.extras.fieldTransform;

	      if (!_angularFix2['default'].isArray(fieldTransforms)) {
	        fieldTransforms = [fieldTransforms];
	      }

	      _angularFix2['default'].forEach(fieldTransforms, function transformFields(fieldTransform) {
	        if (fieldTransform) {
	          $scope.fields = fieldTransform($scope.fields, $scope.model, $scope.options, $scope.form);
	          if (!$scope.fields) {
	            throw formlyUsability.getFormlyError('fieldTransform must return an array of fields');
	          }
	        }
	      });

	      setupModels();

	      _angularFix2['default'].forEach($scope.fields, attachKey); // attaches a key based on the index if a key isn't specified
	      _angularFix2['default'].forEach($scope.fields, setupWatchers); // setup watchers for all fields
	    }

	    function checkDeprecatedOptions(options) {
	      if (formlyConfig.extras.fieldTransform && _angularFix2['default'].isFunction(formlyConfig.extras.fieldTransform)) {
	        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for formlyConfig.extras: ' + formlyConfig.extras.fieldTransform.name, formlyConfig.extras);
	      } else if (options.fieldTransform && _angularFix2['default'].isFunction(options.fieldTransform)) {
	        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for form', options);
	      }
	    }

	    function setupOptions() {
	      formlyApiCheck['throw']([formlyApiCheck.formOptionsApi.optional], [$scope.options], { prefix: 'formly-form options check' });
	      $scope.options = $scope.options || {};
	      $scope.options.formState = $scope.options.formState || {};

	      _angularFix2['default'].extend($scope.options, {
	        updateInitialValue: updateInitialValue,
	        resetModel: resetModel
	      });
	    }

	    function updateInitialValue() {
	      _angularFix2['default'].forEach($scope.fields, function (field) {
	        if (isFieldGroup(field) && field.options) {
	          field.options.updateInitialValue();
	        } else {
	          field.updateInitialValue();
	        }
	      });
	    }

	    function resetModel() {
	      _angularFix2['default'].forEach($scope.fields, function (field) {
	        if (isFieldGroup(field) && field.options) {
	          field.options.resetModel();
	        } else if (field.resetModel) {
	          field.resetModel();
	        }
	      });
	    }

	    function setupModels() {
	      // a set of field models that are already watched (the $scope.model will have its own watcher)
	      var watchedModels = [$scope.model];

	      if ($scope.options.formState) {
	        // $scope.options.formState will have its own watcher
	        watchedModels.push($scope.options.formState);
	      }

	      _angularFix2['default'].forEach($scope.fields, function (field) {
	        var isNewModel = initModel(field);

	        if (field.model && isNewModel && watchedModels.indexOf(field.model) === -1) {
	          $scope.$watch(function () {
	            return field.model;
	          }, onModelOrFormStateChange, true);
	          watchedModels.push(field.model);
	        }
	      });
	    }

	    function initModel(field) {
	      var isNewModel = true;

	      if (_angularFix2['default'].isString(field.model)) {
	        var expression = field.model;
	        var index = $scope.fields.indexOf(field);

	        isNewModel = !refrencesCurrentlyWatchedModel(expression);

	        field.model = evalCloseToFormlyExpression(expression, undefined, field, index);
	        if (!field.model) {
	          throw formlyUsability.getFieldError('field-model-must-be-initialized', 'Field model must be initialized. When specifying a model as a string for a field, the result of the' + ' expression must have been initialized ahead of time.', field);
	        }
	      }
	      return isNewModel;
	    }

	    function refrencesCurrentlyWatchedModel(expression) {
	      return ['model', 'formState'].some(function (item) {
	        return formlyUtil.startsWith(expression, item + '.') || formlyUtil.startsWith(expression, item + '[');
	      });
	    }

	    function attachKey(field, index) {
	      if (!isFieldGroup(field)) {
	        field.key = field.key || index || 0;
	      }
	    }

	    function setupWatchers(field, index) {
	      if (isFieldGroup(field) || !_angularFix2['default'].isDefined(field.watcher)) {
	        return;
	      }
	      var watchers = field.watcher;
	      if (!_angularFix2['default'].isArray(watchers)) {
	        watchers = [watchers];
	      }
	      _angularFix2['default'].forEach(watchers, function setupWatcher(watcher) {
	        if (!_angularFix2['default'].isDefined(watcher.listener)) {
	          throw formlyUsability.getFieldError('all-field-watchers-must-have-a-listener', 'All field watchers must have a listener', field);
	        }
	        var watchExpression = getWatchExpression(watcher, field, index);
	        var watchListener = getWatchListener(watcher, field, index);

	        var type = watcher.type || '$watch';
	        watcher.stopWatching = $scope[type](watchExpression, watchListener, watcher.watchDeep);
	      });
	    }

	    function getWatchExpression(watcher, field, index) {
	      var watchExpression = watcher.expression || 'model[\'' + field.key + '\']';
	      if (_angularFix2['default'].isFunction(watchExpression)) {
	        (function () {
	          // wrap the field's watch expression so we can call it with the field as the first arg
	          // and the stop function as the last arg as a helper
	          var originalExpression = watchExpression;
	          watchExpression = function formlyWatchExpression() {
	            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));
	            return originalExpression.apply(undefined, _toConsumableArray(args));
	          };
	          watchExpression.displayName = 'Formly Watch Expression for field for ' + field.key;
	        })();
	      }
	      return watchExpression;
	    }

	    function getWatchListener(watcher, field, index) {
	      var watchListener = watcher.listener;
	      if (_angularFix2['default'].isFunction(watchListener)) {
	        (function () {
	          // wrap the field's watch listener so we can call it with the field as the first arg
	          // and the stop function as the last arg as a helper
	          var originalListener = watchListener;
	          watchListener = function formlyWatchListener() {
	            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));
	            return originalListener.apply(undefined, _toConsumableArray(args));
	          };
	          watchListener.displayName = 'Formly Watch Listener for field for ' + field.key;
	        })();
	      }
	      return watchListener;
	    }

	    function modifyArgs(watcher, index) {
	      for (var _len = arguments.length, originalArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	        originalArgs[_key - 2] = arguments[_key];
	      }

	      return [$scope.fields[index]].concat(originalArgs, [watcher.stopWatching]);
	    }

	    function evalCloseToFormlyExpression(expression, val, field, index) {
	      var extraLocals = getFormlyFieldLikeLocals(field, index);
	      return formlyUtil.formlyEval($scope, expression, val, val, extraLocals);
	    }

	    function getFormlyFieldLikeLocals(field, index) {
	      // this makes it closer to what a regular formlyExpression would be
	      return {
	        options: field,
	        index: index,
	        formState: $scope.options.formState,
	        formId: $scope.formId
	      };
	    }
	  }

	  function formlyFormLink(scope, el, attrs) {
	    setFormController();
	    fixChromeAutocomplete();

	    function setFormController() {
	      var formId = attrs.name;
	      scope.formId = formId;
	      scope.theFormlyForm = scope[formId];
	      if (attrs.form) {
	        var getter = $parse(attrs.form);
	        var setter = getter.assign;
	        var parentForm = getter(scope.$parent);
	        if (parentForm) {
	          scope.theFormlyForm = parentForm;
	          if (scope[formId]) {
	            scope.theFormlyForm.$removeControl(scope[formId]);
	          }

	          // this next line is probably one of the more dangerous things that angular-formly does to improve the
	          // API for angular-formly forms. It ensures that the NgModelControllers inside of formly-form will be
	          // attached to the form that is passed to formly-form rather than the one that formly-form creates
	          // this is necessary because it's confusing to have a step between the form you pass in
	          // and the fields in that form. It also is because angular doesn't propagate properties like $submitted down
	          // to children forms :-( This line was added to solve this issue:
	          // https://github.com/formly-js/angular-formly/issues/287
	          // luckily, this is how the formController has been accessed by the NgModelController since angular 1.0.0
	          // so I expect it will remain this way for the life of angular 1.x
	          el.removeData('$formController');
	        } else {
	          setter(scope.$parent, scope[formId]);
	        }
	      }
	      if (!scope.theFormlyForm && !formlyConfig.disableWarnings) {
	        /* eslint no-console:0 */
	        formlyWarn('formly-form-has-no-formcontroller', 'Your formly-form does not have a `form` property. Many functions of the form (like validation) may not work', el, scope);
	      }
	    }

	    /*
	     * chrome autocomplete lameness
	     * see https://code.google.com/p/chromium/issues/detail?id=468153#c14
	     * ლ(ಠ益ಠლ)   (╯°□°)╯︵ ┻━┻    (◞‸◟；)
	     */
	    function fixChromeAutocomplete() {
	      var global = formlyConfig.extras.removeChromeAutoComplete === true;
	      var offInstance = scope.options && scope.options.removeChromeAutoComplete === false;
	      var onInstance = scope.options && scope.options.removeChromeAutoComplete === true;
	      if (global && !offInstance || onInstance) {
	        var input = document.createElement('input');
	        input.setAttribute('autocomplete', 'address-level4');
	        input.setAttribute('hidden', 'true');
	        el[0].appendChild(input);
	      }
	    }
	  }

	  // stateless util functions
	  function toKebabCase(string) {
	    if (string) {
	      return string.replace(/([A-Z])/g, function ($1) {
	        return '-' + $1.toLowerCase();
	      });
	    } else {
	      return '';
	    }
	  }

	  function isFieldGroup(field) {
	    return field && !!field.fieldGroup;
	  }
	}
	formlyForm.$inject = ["formlyUsability", "formlyWarn", "$parse", "formlyConfig", "$interpolate"];
	module.exports = exports['default'];

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _angularFix = __webpack_require__(2);

	var _angularFix2 = _interopRequireDefault(_angularFix);

	var _otherUtils = __webpack_require__(9);

	exports['default'] = addFormlyNgModelAttrsManipulator;

	// @ngInject
	function addFormlyNgModelAttrsManipulator(formlyConfig, $interpolate) {
	  if (formlyConfig.extras.disableNgModelAttrsManipulator) {
	    return;
	  }
	  formlyConfig.templateManipulators.preWrapper.push(ngModelAttrsManipulator);

	  function ngModelAttrsManipulator(template, options, scope) {
	    var node = document.createElement('div');
	    var skip = options.extras && options.extras.skipNgModelAttrsManipulator;
	    if (skip === true) {
	      return template;
	    }
	    node.innerHTML = template;

	    var modelNodes = getNgModelNodes(node, skip);
	    if (!modelNodes || !modelNodes.length) {
	      return template;
	    }

	    addIfNotPresent(modelNodes, 'id', scope.id);
	    addIfNotPresent(modelNodes, 'name', scope.name || scope.id);

	    addValidation();
	    alterNgModelAttr();
	    addModelOptions();
	    addTemplateOptionsAttrs();
	    addNgModelElAttrs();

	    return node.innerHTML;

	    function addValidation() {
	      if (_angularFix2['default'].isDefined(options.validators) || _angularFix2['default'].isDefined(options.validation.messages)) {
	        addIfNotPresent(modelNodes, 'formly-custom-validation', '');
	      }
	    }

	    function alterNgModelAttr() {
	      if (isPropertyAccessor(options.key)) {
	        addRegardlessOfPresence(modelNodes, 'ng-model', 'model.' + options.key);
	      }
	    }

	    function addModelOptions() {
	      if (_angularFix2['default'].isDefined(options.modelOptions)) {
	        addIfNotPresent(modelNodes, 'ng-model-options', 'options.modelOptions');
	        if (options.modelOptions.getterSetter) {
	          addRegardlessOfPresence(modelNodes, 'ng-model', 'options.value');
	        }
	      }
	    }

	    function addTemplateOptionsAttrs() {
	      if (!options.templateOptions && !options.expressionProperties) {
	        // no need to run these if there are no templateOptions or expressionProperties
	        return;
	      }
	      var to = options.templateOptions || {};
	      var ep = options.expressionProperties || {};

	      var ngModelAttributes = getBuiltInAttributes();

	      // extend with the user's specifications winning
	      _angularFix2['default'].extend(ngModelAttributes, options.ngModelAttrs);

	      // Feel free to make this more simple :-)
	      _angularFix2['default'].forEach(ngModelAttributes, function (val, name) {
	        /* eslint complexity:[2, 14] */
	        var attrVal = undefined,
	            attrName = undefined;
	        var ref = 'options.templateOptions[\'' + name + '\']';
	        var toVal = to[name];
	        var epVal = getEpValue(ep, name);

	        var inTo = _angularFix2['default'].isDefined(toVal);
	        var inEp = _angularFix2['default'].isDefined(epVal);
	        if (val.value) {
	          // I realize this looks backwards, but it's right, trust me...
	          attrName = val.value;
	          attrVal = name;
	        } else if (val.statement && inTo) {
	          attrName = val.statement;
	          if (_angularFix2['default'].isString(to[name])) {
	            attrVal = '$eval(' + ref + ')';
	          } else if (_angularFix2['default'].isFunction(to[name])) {
	            attrVal = ref + '(model[options.key], options, this, $event)';
	          } else {
	            throw new Error('options.templateOptions.' + name + ' must be a string or function: ' + JSON.stringify(options));
	          }
	        } else if (val.bound && inEp) {
	          attrName = val.bound;
	          attrVal = ref;
	        } else if ((val.attribute || val.boolean) && inEp) {
	          attrName = val.attribute || val.boolean;
	          attrVal = '' + $interpolate.startSymbol() + ref + $interpolate.endSymbol();
	        } else if (val.attribute && inTo) {
	          attrName = val.attribute;
	          attrVal = toVal;
	        } else if (val.boolean) {
	          if (inTo && !inEp && toVal) {
	            attrName = val.boolean;
	            attrVal = true;
	          } else {
	            /* eslint no-empty:0 */
	            // empty to illustrate that a boolean will not be added via val.bound
	            // if you want it added via val.bound, then put it in expressionProperties
	          }
	        } else if (val.bound && inTo) {
	            attrName = val.bound;
	            attrVal = ref;
	          }

	        if (_angularFix2['default'].isDefined(attrName) && _angularFix2['default'].isDefined(attrVal)) {
	          addIfNotPresent(modelNodes, attrName, attrVal);
	        }
	      });
	    }

	    function addNgModelElAttrs() {
	      _angularFix2['default'].forEach(options.ngModelElAttrs, function (val, name) {
	        addRegardlessOfPresence(modelNodes, name, val);
	      });
	    }
	  }

	  // Utility functions
	  function getNgModelNodes(node, skip) {
	    var selectorNot = _angularFix2['default'].isString(skip) ? ':not(' + skip + ')' : '';
	    var skipNot = ':not([formly-skip-ng-model-attrs-manipulator])';
	    var query = '[ng-model]' + selectorNot + skipNot + ', [data-ng-model]' + selectorNot + skipNot;
	    try {
	      return node.querySelectorAll(query);
	    } catch (e) {
	      //this code is needed for IE8, as it does not support the CSS3 ':not' selector
	      //it should be removed when IE8 support is dropped
	      return getNgModelNodesFallback(node, skip);
	    }
	  }

	  function getNgModelNodesFallback(node, skip) {
	    var allNgModelNodes = node.querySelectorAll('[ng-model], [data-ng-model]');
	    var matchingNgModelNodes = [];

	    //make sure this array is compatible with NodeList type by adding an 'item' function
	    matchingNgModelNodes.item = function (i) {
	      return this[i];
	    };

	    for (var i = 0; i < allNgModelNodes.length; i++) {
	      var ngModelNode = allNgModelNodes[i];
	      if (!ngModelNode.hasAttribute('formly-skip-ng-model-attrs-manipulator') && !(_angularFix2['default'].isString(skip) && nodeMatches(ngModelNode, skip))) {
	        matchingNgModelNodes.push(ngModelNode);
	      }
	    }

	    return matchingNgModelNodes;
	  }

	  function nodeMatches(node, selector) {
	    var div = document.createElement('div');
	    div.innerHTML = node.outerHTML;
	    return div.querySelector(selector);
	  }

	  function getBuiltInAttributes() {
	    var ngModelAttributes = {
	      focus: {
	        attribute: 'formly-focus'
	      }
	    };
	    var boundOnly = [];
	    var bothBooleanAndBound = ['required', 'disabled'];
	    var bothAttributeAndBound = ['pattern', 'minlength'];
	    var statementOnly = ['change', 'keydown', 'keyup', 'keypress', 'click', 'focus', 'blur'];
	    var attributeOnly = ['placeholder', 'min', 'max', 'tabindex', 'type'];
	    if (formlyConfig.extras.ngModelAttrsManipulatorPreferUnbound) {
	      bothAttributeAndBound.push('maxlength');
	    } else {
	      boundOnly.push('maxlength');
	    }

	    _angularFix2['default'].forEach(boundOnly, function (item) {
	      ngModelAttributes[item] = { bound: 'ng-' + item };
	    });

	    _angularFix2['default'].forEach(bothBooleanAndBound, function (item) {
	      ngModelAttributes[item] = { boolean: item, bound: 'ng-' + item };
	    });

	    _angularFix2['default'].forEach(bothAttributeAndBound, function (item) {
	      ngModelAttributes[item] = { attribute: item, bound: 'ng-' + item };
	    });

	    _angularFix2['default'].forEach(statementOnly, function (item) {
	      var propName = 'on' + item.substr(0, 1).toUpperCase() + item.substr(1);
	      ngModelAttributes[propName] = { statement: 'ng-' + item };
	    });

	    _angularFix2['default'].forEach(attributeOnly, function (item) {
	      ngModelAttributes[item] = { attribute: item };
	    });
	    return ngModelAttributes;
	  }

	  function getEpValue(ep, name) {
	    return ep['templateOptions.' + name] || ep['templateOptions[\'' + name + '\']'] || ep['templateOptions["' + name + '"]'];
	  }

	  function addIfNotPresent(nodes, attr, val) {
	    _angularFix2['default'].forEach(nodes, function (node) {
	      if (!node.getAttribute(attr)) {
	        node.setAttribute(attr, val);
	      }
	    });
	  }

	  function addRegardlessOfPresence(nodes, attr, val) {
	    _angularFix2['default'].forEach(nodes, function (node) {
	      node.setAttribute(attr, val);
	    });
	  }

	  function isPropertyAccessor(key) {
	    return (0, _otherUtils.contains)(key, '.') || (0, _otherUtils.contains)(key, '[') && (0, _otherUtils.contains)(key, ']');
	  }
	}
	addFormlyNgModelAttrsManipulator.$inject = ["formlyConfig", "$interpolate"];
	module.exports = exports['default'];

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _angularFix = __webpack_require__(2);

	var _angularFix2 = _interopRequireDefault(_angularFix);

	exports['default'] = addCustomTags;

	// @ngInject
	function addCustomTags($document) {
	  if ($document && $document.get) {
	    (function () {
	      // IE8 check ->
	      // http://stackoverflow.com/questions/10964966/detect-ie-version-prior-to-v9-in-javascript/10965203#10965203
	      var document = $document.get(0);
	      var div = document.createElement('div');
	      div.innerHTML = '<!--[if lt IE 9]><i></i><![endif]-->';
	      var isIeLessThan9 = div.getElementsByTagName('i').length === 1;

	      if (isIeLessThan9) {
	        // add the custom elements that we need for formly
	        var customElements = ['formly-field', 'formly-form', 'formly-custom-validation', 'formly-focus', 'formly-transpose'];
	        _angularFix2['default'].forEach(customElements, function (el) {
	          document.createElement(el);
	        });
	      }
	    })();
	  }
	}
	addCustomTags.$inject = ["$document"];
	module.exports = exports['default'];

/***/ }
/******/ ])
});
;;
/*! 10.1.9 */
!function(){function a(a,b){window.XMLHttpRequest.prototype[a]=b(window.XMLHttpRequest.prototype[a])}function b(a,b,c){try{Object.defineProperty(a,b,{get:c})}catch(d){}}if(window.FileAPI||(window.FileAPI={}),!window.XMLHttpRequest)throw"AJAX is not supported. XMLHttpRequest is not defined.";if(FileAPI.shouldLoad=!window.FormData||FileAPI.forceLoad,FileAPI.shouldLoad){var c=function(a){if(!a.__listeners){a.upload||(a.upload={}),a.__listeners=[];var b=a.upload.addEventListener;a.upload.addEventListener=function(c,d){a.__listeners[c]=d,b&&b.apply(this,arguments)}}};a("open",function(a){return function(b,d,e){c(this),this.__url=d;try{a.apply(this,[b,d,e])}catch(f){f.message.indexOf("Access is denied")>-1&&(this.__origError=f,a.apply(this,[b,"_fix_for_ie_crossdomain__",e]))}}}),a("getResponseHeader",function(a){return function(b){return this.__fileApiXHR&&this.__fileApiXHR.getResponseHeader?this.__fileApiXHR.getResponseHeader(b):null==a?null:a.apply(this,[b])}}),a("getAllResponseHeaders",function(a){return function(){return this.__fileApiXHR&&this.__fileApiXHR.getAllResponseHeaders?this.__fileApiXHR.getAllResponseHeaders():null==a?null:a.apply(this)}}),a("abort",function(a){return function(){return this.__fileApiXHR&&this.__fileApiXHR.abort?this.__fileApiXHR.abort():null==a?null:a.apply(this)}}),a("setRequestHeader",function(a){return function(b,d){if("__setXHR_"===b){c(this);var e=d(this);e instanceof Function&&e(this)}else this.__requestHeaders=this.__requestHeaders||{},this.__requestHeaders[b]=d,a.apply(this,arguments)}}),a("send",function(a){return function(){var c=this;if(arguments[0]&&arguments[0].__isFileAPIShim){var d=arguments[0],e={url:c.__url,jsonp:!1,cache:!0,complete:function(a,d){a&&angular.isString(a)&&-1!==a.indexOf("#2174")&&(a=null),c.__completed=!0,!a&&c.__listeners.load&&c.__listeners.load({type:"load",loaded:c.__loaded,total:c.__total,target:c,lengthComputable:!0}),!a&&c.__listeners.loadend&&c.__listeners.loadend({type:"loadend",loaded:c.__loaded,total:c.__total,target:c,lengthComputable:!0}),"abort"===a&&c.__listeners.abort&&c.__listeners.abort({type:"abort",loaded:c.__loaded,total:c.__total,target:c,lengthComputable:!0}),void 0!==d.status&&b(c,"status",function(){return 0===d.status&&a&&"abort"!==a?500:d.status}),void 0!==d.statusText&&b(c,"statusText",function(){return d.statusText}),b(c,"readyState",function(){return 4}),void 0!==d.response&&b(c,"response",function(){return d.response});var e=d.responseText||(a&&0===d.status&&"abort"!==a?a:void 0);b(c,"responseText",function(){return e}),b(c,"response",function(){return e}),a&&b(c,"err",function(){return a}),c.__fileApiXHR=d,c.onreadystatechange&&c.onreadystatechange(),c.onload&&c.onload()},progress:function(a){if(a.target=c,c.__listeners.progress&&c.__listeners.progress(a),c.__total=a.total,c.__loaded=a.loaded,a.total===a.loaded){var b=this;setTimeout(function(){c.__completed||(c.getAllResponseHeaders=function(){},b.complete(null,{status:204,statusText:"No Content"}))},FileAPI.noContentTimeout||1e4)}},headers:c.__requestHeaders};e.data={},e.files={};for(var f=0;f<d.data.length;f++){var g=d.data[f];null!=g.val&&null!=g.val.name&&null!=g.val.size&&null!=g.val.type?e.files[g.key]=g.val:e.data[g.key]=g.val}setTimeout(function(){if(!FileAPI.hasFlash)throw'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"';c.__fileApiXHR=FileAPI.upload(e)},1)}else{if(this.__origError)throw this.__origError;a.apply(c,arguments)}}}),window.XMLHttpRequest.__isFileAPIShim=!0,window.FormData=FormData=function(){return{append:function(a,b,c){b.__isFileAPIBlobShim&&(b=b.data[0]),this.data.push({key:a,val:b,name:c})},data:[],__isFileAPIShim:!0}},window.Blob=Blob=function(a){return{data:a,__isFileAPIBlobShim:!0}}}}(),function(){function a(a){return"input"===a[0].tagName.toLowerCase()&&a.attr("type")&&"file"===a.attr("type").toLowerCase()}function b(){try{var a=new ActiveXObject("ShockwaveFlash.ShockwaveFlash");if(a)return!0}catch(b){if(void 0!==navigator.mimeTypes["application/x-shockwave-flash"])return!0}return!1}function c(a){var b=0,c=0;if(window.jQuery)return jQuery(a).offset();if(a.offsetParent)do b+=a.offsetLeft-a.scrollLeft,c+=a.offsetTop-a.scrollTop,a=a.offsetParent;while(a);return{left:b,top:c}}if(FileAPI.shouldLoad){if(FileAPI.hasFlash=b(),FileAPI.forceLoad&&(FileAPI.html5=!1),!FileAPI.upload){var d,e,f,g,h,i=document.createElement("script"),j=document.getElementsByTagName("script");if(window.FileAPI.jsUrl)d=window.FileAPI.jsUrl;else if(window.FileAPI.jsPath)e=window.FileAPI.jsPath;else for(f=0;f<j.length;f++)if(h=j[f].src,g=h.search(/\/ng\-file\-upload[\-a-zA-z0-9\.]*\.js/),g>-1){e=h.substring(0,g+1);break}null==FileAPI.staticPath&&(FileAPI.staticPath=e),i.setAttribute("src",d||e+"FileAPI.js"),document.getElementsByTagName("head")[0].appendChild(i)}FileAPI.ngfFixIE=function(d,e,f){if(!b())throw'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"';var g=function(){d.attr("disabled")?e&&e.removeClass("js-fileapi-wrapper"):(e.attr("__ngf_flash_")||(e.unbind("change"),e.unbind("click"),e.bind("change",function(a){h.apply(this,[a]),f.apply(this,[a])}),e.attr("__ngf_flash_","true")),e.addClass("js-fileapi-wrapper"),a(d)||e.css("position","absolute").css("top",c(d[0]).top+"px").css("left",c(d[0]).left+"px").css("width",d[0].offsetWidth+"px").css("height",d[0].offsetHeight+"px").css("filter","alpha(opacity=0)").css("display",d.css("display")).css("overflow","hidden").css("z-index","900000").css("visibility","visible"))};d.bind("mouseenter",g);var h=function(a){for(var b=FileAPI.getFiles(a),c=0;c<b.length;c++)void 0===b[c].size&&(b[c].size=0),void 0===b[c].name&&(b[c].name="file"),void 0===b[c].type&&(b[c].type="undefined");a.target||(a.target={}),a.target.files=b,a.target.files!==b&&(a.__files_=b),(a.__files_||a.target.files).item=function(b){return(a.__files_||a.target.files)[b]||null}}},FileAPI.disableFileInput=function(a,b){b?a.removeClass("js-fileapi-wrapper"):a.addClass("js-fileapi-wrapper")}}}(),window.FileReader||(window.FileReader=function(){var a=this,b=!1;this.listeners={},this.addEventListener=function(b,c){a.listeners[b]=a.listeners[b]||[],a.listeners[b].push(c)},this.removeEventListener=function(b,c){a.listeners[b]&&a.listeners[b].splice(a.listeners[b].indexOf(c),1)},this.dispatchEvent=function(b){var c=a.listeners[b.type];if(c)for(var d=0;d<c.length;d++)c[d].call(a,b)},this.onabort=this.onerror=this.onload=this.onloadstart=this.onloadend=this.onprogress=null;var c=function(b,c){var d={type:b,target:a,loaded:c.loaded,total:c.total,error:c.error};return null!=c.result&&(d.target.result=c.result),d},d=function(d){b||(b=!0,a.onloadstart&&a.onloadstart(c("loadstart",d)));var e;"load"===d.type?(a.onloadend&&a.onloadend(c("loadend",d)),e=c("load",d),a.onload&&a.onload(e),a.dispatchEvent(e)):"progress"===d.type?(e=c("progress",d),a.onprogress&&a.onprogress(e),a.dispatchEvent(e)):(e=c("error",d),a.onerror&&a.onerror(e),a.dispatchEvent(e))};this.readAsDataURL=function(a){FileAPI.readAsDataURL(a,d)},this.readAsText=function(a){FileAPI.readAsText(a,d)}});;
/*! 10.1.9 */
!window.XMLHttpRequest||window.FileAPI&&FileAPI.shouldLoad||(window.XMLHttpRequest.prototype.setRequestHeader=function(a){return function(b,c){if("__setXHR_"===b){var d=c(this);d instanceof Function&&d(this)}else a.apply(this,arguments)}}(window.XMLHttpRequest.prototype.setRequestHeader));var ngFileUpload=angular.module("ngFileUpload",[]);ngFileUpload.version="10.1.9",ngFileUpload.service("UploadBase",["$http","$q","$timeout",function(a,b,c){function d(d){function e(a){j.notify&&j.notify(a),k.progressFunc&&c(function(){k.progressFunc(a)})}function h(a){return null!=d._start&&g?{loaded:a.loaded+d._start,total:d._file.size,type:a.type,config:d,lengthComputable:!0,target:a.target}:a}function i(){a(d).then(function(a){g&&d._chunkSize&&!d._finished?(e({loaded:d._end,total:d._file.size,config:d,type:"progress"}),f.upload(d,!0)):(d._finished&&delete d._finished,j.resolve(a))},function(a){j.reject(a)},function(a){j.notify(a)})}d.method=d.method||"POST",d.headers=d.headers||{};var j=d._deferred=d._deferred||b.defer(),k=j.promise;return d.disableProgress||(d.headers.__setXHR_=function(){return function(a){a&&a instanceof XMLHttpRequest&&(d.__XHR=a,d.xhrFn&&d.xhrFn(a),a.upload.addEventListener("progress",function(a){a.config=d,e(h(a))},!1),a.upload.addEventListener("load",function(a){a.lengthComputable&&(a.config=d,e(h(a)))},!1))}}),g?d._chunkSize&&d._end&&!d._finished?(d._start=d._end,d._end+=d._chunkSize,i()):d.resumeSizeUrl?a.get(d.resumeSizeUrl).then(function(a){d._start=d.resumeSizeResponseReader?d.resumeSizeResponseReader(a.data):parseInt((null==a.data.size?a.data:a.data.size).toString()),d._chunkSize&&(d._end=d._start+d._chunkSize),i()},function(a){throw a}):d.resumeSize?d.resumeSize().then(function(a){d._start=a,i()},function(a){throw a}):i():i(),k.success=function(a){return k.then(function(b){a(b.data,b.status,b.headers,d)}),k},k.error=function(a){return k.then(null,function(b){a(b.data,b.status,b.headers,d)}),k},k.progress=function(a){return k.progressFunc=a,k.then(null,null,function(b){a(b)}),k},k.abort=k.pause=function(){return d.__XHR&&c(function(){d.__XHR.abort()}),k},k.xhr=function(a){return d.xhrFn=function(b){return function(){b&&b.apply(k,arguments),a.apply(k,arguments)}}(d.xhrFn),k},k}function e(a){var b={};for(var c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);return b}var f=this;this.isResumeSupported=function(){return window.Blob&&window.Blob instanceof Function&&(new window.Blob).slice};var g=this.isResumeSupported();this.rename=function(a,b){return a.ngfName=b,a},this.jsonBlob=function(a){null==a||angular.isString(a)||(a=JSON.stringify(a));var b=new window.Blob([a],{type:"application/json"});return b._ngfBlob=!0,b},this.json=function(a){return angular.toJson(a)},this.upload=function(a,b){function c(a){return null!=a&&(a instanceof window.Blob||a.flashId&&a.name&&a.size)}function h(b,c){if(b._ngfBlob)return b;if(a._file=a._file||b,null!=a._start&&g){a._end&&a._end>=b.size&&(a._finished=!0,a._end=b.size);var d=b.slice(a._start,a._end||b.size);return d.name=b.name,d.ngfName=b.ngfName,a._chunkSize&&(c.append("_chunkSize",a._end-a._start),c.append("_chunkNumber",Math.floor(a._start/a._chunkSize)),c.append("_totalSize",a._file.size)),d}return b}function i(b,d,e){if(void 0!==d)if(angular.isDate(d)&&(d=d.toISOString()),angular.isString(d))b.append(e,d);else if(c(d)){var f=h(d,b),g=e.split(",");g[1]&&(f.ngfName=g[1].replace(/^\s+|\s+$/g,""),e=g[0]),a._fileKey=a._fileKey||e,b.append(e,f,f.ngfName||f.name)}else if(angular.isObject(d)){if(d.$$ngfCircularDetection)throw"ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: "+e;d.$$ngfCircularDetection=!0;try{for(var j in d)if(d.hasOwnProperty(j)&&"$$ngfCircularDetection"!==j){var k=null==a.objectKey?"[i]":a.objectKey;d.length&&parseInt(j)>-1&&(k=null==a.arrayKey?k:a.arrayKey),i(b,d[j],e+k.replace(/[ik]/g,j))}}finally{delete d.$$ngfCircularDetection}}else b.append(e,d)}function j(){a._chunkSize=f.translateScalars(a.resumeChunkSize),a._chunkSize=a._chunkSize?parseInt(a._chunkSize.toString()):null,a.headers=a.headers||{},a.headers["Content-Type"]=void 0,a.transformRequest=a.transformRequest?angular.isArray(a.transformRequest)?a.transformRequest:[a.transformRequest]:[],a.transformRequest.push(function(b){var c,d=new window.FormData;b=b||a.fields||{},a.file&&(b.file=a.file);for(c in b)if(b.hasOwnProperty(c)){var e=b[c];a.formDataAppender?a.formDataAppender(d,c,e):i(d,e,c)}return d})}return b||(a=e(a)),a._isDigested||(a._isDigested=!0,j()),d(a)},this.http=function(b){return b=e(b),b.transformRequest=b.transformRequest||function(b){return window.ArrayBuffer&&b instanceof window.ArrayBuffer||b instanceof window.Blob?b:a.defaults.transformRequest[0].apply(this,arguments)},b._chunkSize=f.translateScalars(b.resumeChunkSize),b._chunkSize=b._chunkSize?parseInt(b._chunkSize.toString()):null,d(b)},this.translateScalars=function(a){if(angular.isString(a)){if(a.search(/kb/i)===a.length-2)return parseFloat(1e3*a.substring(0,a.length-2));if(a.search(/mb/i)===a.length-2)return parseFloat(1e6*a.substring(0,a.length-2));if(a.search(/gb/i)===a.length-2)return parseFloat(1e9*a.substring(0,a.length-2));if(a.search(/b/i)===a.length-1)return parseFloat(a.substring(0,a.length-1));if(a.search(/s/i)===a.length-1)return parseFloat(a.substring(0,a.length-1));if(a.search(/m/i)===a.length-1)return parseFloat(60*a.substring(0,a.length-1));if(a.search(/h/i)===a.length-1)return parseFloat(3600*a.substring(0,a.length-1))}return a},this.setDefaults=function(a){this.defaults=a||{}},this.defaults={},this.version=ngFileUpload.version}]),ngFileUpload.service("Upload",["$parse","$timeout","$compile","$q","UploadExif",function(a,b,c,d,e){function f(a,b,c){var e=[i.emptyPromise()];return angular.forEach(a,function(d,f){0===d.type.indexOf("image/jpeg")&&i.attrGetter("ngfFixOrientation",b,c,{$file:d})&&e.push(i.happyPromise(i.applyExifRotation(d),d).then(function(b){a.splice(f,1,b)}))}),d.all(e)}function g(a,b,c){var e=i.attrGetter("ngfResize",b,c);if(!e||!i.isResizeSupported()||!a.length)return i.emptyPromise();var f=[i.emptyPromise()];return angular.forEach(a,function(b,c){if(0===b.type.indexOf("image")){if(e.pattern&&!i.validatePattern(b,e.pattern))return;var d=i.resize(b,e.width,e.height,e.quality,e.type,e.ratio,e.centerCrop);f.push(d),d.then(function(b){a.splice(c,1,b)},function(a){b.$error="resize",b.$errorParam=(a?(a.message?a.message:a)+": ":"")+(b&&b.name)})}}),d.all(f)}function h(a,b,c,d){var e=[],f=i.attrGetter("ngfKeep",c,d);if(f){var g=!1;if("distinct"===f||i.attrGetter("ngfKeepDistinct",c,d)===!0){var h=b.length;if(a)for(var j=0;j<a.length;j++){for(var k=0;h>k;k++)if(a[j].name===b[k].name){e.push(a[j]);break}k===h&&(b.push(a[j]),g=!0)}a=b}else a=b.concat(a||[])}return{files:a,dupFiles:e,keep:f}}var i=e;return i.getAttrWithDefaults=function(a,b){if(null!=a[b])return a[b];var c=i.defaults[b];return null==c?c:angular.isString(c)?c:JSON.stringify(c)},i.attrGetter=function(b,c,d,e){var f=this.getAttrWithDefaults(c,b);if(!d)return f;try{return e?a(f)(d,e):a(f)(d)}catch(g){if(b.search(/min|max|pattern/i))return f;throw g}},i.shouldUpdateOn=function(a,b,c){var d=i.attrGetter("ngModelOptions",b,c);return d&&d.updateOn?d.updateOn.split(" ").indexOf(a)>-1:!0},i.emptyPromise=function(){var a=d.defer(),c=arguments;return b(function(){a.resolve.apply(a,c)}),a.promise},i.happyPromise=function(a,c){var e=d.defer();return a.then(function(a){e.resolve(a)},function(a){b(function(){throw a}),e.resolve(c)}),e.promise},i.updateModel=function(c,d,e,j,k,l,m){function n(f,g,h,k,m){var n=f&&f.length?f[0]:null;c&&(i.applyModelValidation(c,f),c.$ngfModelChange=!0,c.$setViewValue(m?n:f)),j&&a(j)(e,{$files:f,$file:n,$newFiles:h,$duplicateFiles:k,$invalidFiles:g,$event:l});var o=i.attrGetter("ngfModelInvalid",d);o&&b(function(){a(o).assign(e,g)}),b(function(){})}var o=k,p=c&&c.$modelValue&&(angular.isArray(c.$modelValue)?c.$modelValue:[c.$modelValue]);p=(p||d.$$ngfPrevFiles||[]).slice(0);var q=h(k,p,d,e);k=q.files;var r=q.dupFiles,s=!i.attrGetter("ngfMultiple",d,e)&&!i.attrGetter("multiple",d)&&!q.keep;if(d.$$ngfPrevFiles=k,!q.keep||o&&o.length){i.attrGetter("ngfBeforeModelChange",d,e,{$files:k,$file:k&&k.length?k[0]:null,$duplicateFiles:r,$event:l}),i.validate(o,c,d,e).then(function(){if(m)n(k,[],o,r,s);else{var a=i.attrGetter("ngModelOptions",d,e);if(!a||!a.allowInvalid){var c=[],h=[];angular.forEach(k,function(a){a.$error?h.push(a):c.push(a)}),k=c}var j=i.emptyPromise(k);i.attrGetter("ngfFixOrientation",d,e)&&i.isExifSupported()&&(j=f(k,d,e)),j.then(function(){g(k,d,e).then(function(){b(function(){n(k,h,o,r,s)},a&&a.debounce?a.debounce.change||a.debounce:0)},function(a){throw"Could not resize files "+a})})}});for(var t=p.length;t--;){var u=p[t];window.URL&&u.blobUrl&&(URL.revokeObjectURL(u.blobUrl),delete u.blobUrl)}}},i}]),ngFileUpload.directive("ngfSelect",["$parse","$timeout","$compile","Upload",function(a,b,c,d){function e(a){var b=a.match(/Android[^\d]*(\d+)\.(\d+)/);if(b&&b.length>2){var c=d.defaults.androidFixMinorVersion||4;return parseInt(b[1])<4||parseInt(b[1])===c&&parseInt(b[2])<c}return-1===a.indexOf("Chrome")&&/.*Windows.*Safari.*/.test(a)}function f(a,b,c,d,f,h,i,j){function k(){return"input"===b[0].tagName.toLowerCase()&&c.type&&"file"===c.type.toLowerCase()}function l(){return t("ngfChange")||t("ngfSelect")}function m(b){if(j.shouldUpdateOn("change",c,a)){for(var e=b.__files_||b.target&&b.target.files,f=[],g=0;g<e.length;g++)f.push(e[g]);j.updateModel(d,c,a,l(),f.length?f:null,b)}}function n(a){if(b!==a)for(var c=0;c<b[0].attributes.length;c++){var d=b[0].attributes[c];"type"!==d.name&&"class"!==d.name&&"style"!==d.name&&((null==d.value||""===d.value)&&("required"===d.name&&(d.value="required"),"multiple"===d.name&&(d.value="multiple")),a.attr(d.name,"id"===d.name?"ngf-"+d.value:d.value))}}function o(){if(k())return b;var a=angular.element('<input type="file">');n(a);var c=angular.element("<label>upload</label>");return c.css("visibility","hidden").css("position","absolute").css("overflow","hidden").css("width","0px").css("height","0px").css("border","none").css("margin","0px").css("padding","0px").attr("tabindex","-1"),g.push({el:b,ref:c}),document.body.appendChild(c.append(a)[0]),a}function p(c){if(b.attr("disabled")||t("ngfSelectDisabled",a))return!1;var d=q(c);if(null!=d)return d;r(c);try{k()||document.body.contains(w[0])||(g.push({el:b,ref:w.parent()}),document.body.appendChild(w[0].parent()),w.bind("change",m))}catch(f){}return e(navigator.userAgent)?setTimeout(function(){w[0].click()},0):w[0].click(),!1}function q(a){var b=a.changedTouches||a.originalEvent&&a.originalEvent.changedTouches;if("touchstart"===a.type)return v=b?b[0].clientY:0,!0;if(a.stopPropagation(),a.preventDefault(),"touchend"===a.type){var c=b?b[0].clientY:0;if(Math.abs(c-v)>20)return!1}}function r(b){j.shouldUpdateOn("click",c,a)&&w.val()&&(w.val(null),j.updateModel(d,c,a,l(),null,b,!0))}function s(a){if(w&&!w.attr("__ngf_ie10_Fix_")){if(!w[0].parentNode)return void(w=null);a.preventDefault(),a.stopPropagation(),w.unbind("click");var b=w.clone();return w.replaceWith(b),w=b,w.attr("__ngf_ie10_Fix_","true"),w.bind("change",m),w.bind("click",s),w[0].click(),!1}w.removeAttr("__ngf_ie10_Fix_")}var t=function(a,b){return j.attrGetter(a,c,b)};j.registerModelChangeValidator(d,c,a);var u=[];u.push(a.$watch(t("ngfMultiple"),function(){w.attr("multiple",t("ngfMultiple",a))})),u.push(a.$watch(t("ngfCapture"),function(){w.attr("capture",t("ngfCapture",a))})),u.push(a.$watch(t("ngfAccept"),function(){w.attr("accept",t("ngfAccept",a))})),c.$observe("accept",function(){w.attr("accept",t("accept"))}),u.push(function(){c.$$observers&&delete c.$$observers.accept});var v=0,w=b;k()||(w=o()),w.bind("change",m),k()?b.bind("click",r):b.bind("click touchstart touchend",p),-1!==navigator.appVersion.indexOf("MSIE 10")&&w.bind("click",s),d&&d.$formatters.push(function(a){return(null==a||0===a.length)&&w.val()&&w.val(null),a}),a.$on("$destroy",function(){k()||w.parent().remove(),angular.forEach(u,function(a){a()})}),h(function(){for(var a=0;a<g.length;a++){var b=g[a];document.body.contains(b.el[0])||(g.splice(a,1),b.ref.remove())}}),window.FileAPI&&window.FileAPI.ngfFixIE&&window.FileAPI.ngfFixIE(b,w,m)}var g=[];return{restrict:"AEC",require:"?ngModel",link:function(e,g,h,i){f(e,g,h,i,a,b,c,d)}}}]),function(){function a(a){return"img"===a.tagName.toLowerCase()?"image":"audio"===a.tagName.toLowerCase()?"audio":"video"===a.tagName.toLowerCase()?"video":/./}function b(b,c,d,e,f,g,h,i){function j(a){var g=b.attrGetter("ngfNoObjectUrl",f,d);b.dataUrl(a,g)["finally"](function(){c(function(){var b=(g?a.$ngfDataUrl:a.$ngfBlobUrl)||a.$ngfDataUrl;i?e.css("background-image","url('"+(b||"")+"')"):e.attr("src",b),b?e.removeClass("ng-hide"):e.addClass("ng-hide")})})}c(function(){var c=d.$watch(f[g],function(c){var d=h;if("ngfThumbnail"===g&&(d||(d={width:e[0].clientWidth,height:e[0].clientHeight}),0===d.width&&window.getComputedStyle)){var f=getComputedStyle(e[0]);d={width:parseInt(f.width.slice(0,-2)),height:parseInt(f.height.slice(0,-2))}}return angular.isString(c)?(e.removeClass("ng-hide"),i?e.css("background-image","url('"+c+"')"):e.attr("src",c)):void(!c||!c.type||0!==c.type.search(a(e[0]))||i&&0!==c.type.indexOf("image")?e.addClass("ng-hide"):d&&b.isResizeSupported()?b.resize(c,d.width,d.height,d.quality).then(function(a){j(a)},function(a){throw a}):j(c))});d.$on("$destroy",function(){c()})})}ngFileUpload.service("UploadDataUrl",["UploadBase","$timeout","$q",function(a,b,c){var d=a;return d.base64DataUrl=function(a){if(angular.isArray(a)){var b=c.defer(),e=0;return angular.forEach(a,function(c){d.dataUrl(c,!0)["finally"](function(){if(e++,e===a.length){var c=[];angular.forEach(a,function(a){c.push(a.$ngfDataUrl)}),b.resolve(c,a)}})}),b.promise}return d.dataUrl(a,!0)},d.dataUrl=function(a,e){if(!a)return d.emptyPromise(a,a);if(e&&null!=a.$ngfDataUrl||!e&&null!=a.$ngfBlobUrl)return d.emptyPromise(e?a.$ngfDataUrl:a.$ngfBlobUrl,a);var f=e?a.$$ngfDataUrlPromise:a.$$ngfBlobUrlPromise;if(f)return f;var g=c.defer();return b(function(){if(window.FileReader&&a&&(!window.FileAPI||-1===navigator.userAgent.indexOf("MSIE 8")||a.size<2e4)&&(!window.FileAPI||-1===navigator.userAgent.indexOf("MSIE 9")||a.size<4e6)){var c=window.URL||window.webkitURL;if(c&&c.createObjectURL&&!e){var d;try{d=c.createObjectURL(a)}catch(f){return void b(function(){a.$ngfBlobUrl="",g.reject()})}b(function(){a.$ngfBlobUrl=d,d&&g.resolve(d,a)})}else{var h=new FileReader;h.onload=function(c){b(function(){a.$ngfDataUrl=c.target.result,g.resolve(c.target.result,a)})},h.onerror=function(){b(function(){a.$ngfDataUrl="",g.reject()})},h.readAsDataURL(a)}}else b(function(){a[e?"dataUrl":"blobUrl"]="",g.reject()})}),f=e?a.$$ngfDataUrlPromise=g.promise:a.$$ngfBlobUrlPromise=g.promise,f["finally"](function(){delete a[e?"$$ngfDataUrlPromise":"$$ngfBlobUrlPromise"]}),f},d}]),ngFileUpload.directive("ngfSrc",["Upload","$timeout",function(a,c){return{restrict:"AE",link:function(d,e,f){b(a,c,d,e,f,"ngfSrc",a.attrGetter("ngfResize",f,d),!1)}}}]),ngFileUpload.directive("ngfBackground",["Upload","$timeout",function(a,c){return{restrict:"AE",link:function(d,e,f){b(a,c,d,e,f,"ngfBackground",a.attrGetter("ngfResize",f,d),!0)}}}]),ngFileUpload.directive("ngfThumbnail",["Upload","$timeout",function(a,c){return{restrict:"AE",link:function(d,e,f){var g=a.attrGetter("ngfSize",f,d);b(a,c,d,e,f,"ngfThumbnail",g,a.attrGetter("ngfAsBackground",f,d))}}}]),ngFileUpload.config(["$compileProvider",function(a){a.imgSrcSanitizationWhitelist&&a.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|local|file|data|blob):/),a.aHrefSanitizationWhitelist&&a.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|local|file|data|blob):/)}]),ngFileUpload.filter("ngfDataUrl",["UploadDataUrl","$sce",function(a,b){return function(c,d,e){if(angular.isString(c))return b.trustAsResourceUrl(c);var f=c&&((d?c.$ngfDataUrl:c.$ngfBlobUrl)||c.$ngfDataUrl);return c&&!f?(!c.$ngfDataUrlFilterInProgress&&angular.isObject(c)&&(c.$ngfDataUrlFilterInProgress=!0,a.dataUrl(c,d)),""):(c&&delete c.$ngfDataUrlFilterInProgress,(c&&f?e?b.trustAsResourceUrl(f):f:c)||"")}}])}(),ngFileUpload.service("UploadValidate",["UploadDataUrl","$q","$timeout",function(a,b,c){function d(a){var b="",c=[];if(a.length>2&&"/"===a[0]&&"/"===a[a.length-1])b=a.substring(1,a.length-1);else{var e=a.split(",");if(e.length>1)for(var f=0;f<e.length;f++){var g=d(e[f]);g.regexp?(b+="("+g.regexp+")",f<e.length-1&&(b+="|")):c=c.concat(g.excludes)}else 0===a.indexOf("!")?c.push("^((?!"+d(a.substring(1)).regexp+").)*$"):(0===a.indexOf(".")&&(a="*"+a),b="^"+a.replace(new RegExp("[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]","g"),"\\$&")+"$",b=b.replace(/\\\*/g,".*").replace(/\\\?/g,"."))}return{regexp:b,excludes:c}}function e(a,b){null==b||a.$dirty||(a.$setDirty?a.$setDirty():a.$dirty=!0)}var f=a;return f.validatePattern=function(a,b){if(!b)return!0;var c=d(b),e=!0;if(c.regexp&&c.regexp.length){var f=new RegExp(c.regexp,"i");e=null!=a.type&&f.test(a.type)||null!=a.name&&f.test(a.name)}for(var g=c.excludes.length;g--;){var h=new RegExp(c.excludes[g],"i");e=e&&(null==a.type||h.test(a.type))&&(null==a.name||h.test(a.name))}return e},f.ratioToFloat=function(a){var b=a.toString(),c=b.search(/[x:]/i);return b=c>-1?parseFloat(b.substring(0,c))/parseFloat(b.substring(c+1)):parseFloat(b)},f.registerModelChangeValidator=function(a,b,c){a&&a.$formatters.push(function(d){a.$ngfModelChange?a.$ngfModelChange=!1:f.validate(d,a,b,c,function(){f.applyModelValidation(a,d)})})},f.applyModelValidation=function(a,b){e(a,b),angular.forEach(a.$ngfValidations,function(b){a.$setValidity(b.name,b.valid)})},f.validate=function(a,c,d,e){function g(b,d,e){if(a){for(var f="ngf"+b[0].toUpperCase()+b.substr(1),g=a.length,h=null;g--;){var j=a[g];if(j){var k=i(f,{$file:j});null==k&&(k=d(i("ngfValidate")||{}),h=null==h?!0:h),null!=k&&(e(j,k)||(j.$error=b,j.$errorParam=k,a.splice(g,1),h=!1))}}null!==h&&c.$ngfValidations.push({name:b,valid:h})}}function h(d,e,g,h,j){var k=[f.emptyPromise()];if(a){var l="ngf"+d[0].toUpperCase()+d.substr(1);return a=void 0===a.length?[a]:a,angular.forEach(a,function(a){var c=b.defer();if(k.push(c.promise),g&&(null==a.type||0!==a.type.search(g)))return void c.resolve();var f=i(l,{$file:a})||e(i("ngfValidate",{$file:a})||{});f?h(a,f).then(function(b){j(b,f)?c.resolve():(a.$error=d,a.$errorParam=f,c.reject())},function(){i("ngfValidateForce",{$file:a})?(a.$error=d,a.$errorParam=f,c.reject()):c.resolve()}):c.resolve()}),b.all(k).then(function(){c.$ngfValidations.push({name:d,valid:!0})},function(){c.$ngfValidations.push({name:d,valid:!1})})}}c=c||{},c.$ngfValidations=c.$ngfValidations||[],angular.forEach(c.$ngfValidations,function(a){a.valid=!0});var i=function(a,b){return f.attrGetter(a,d,e,b)};if(null==a||0===a.length)return f.emptyPromise(c);a=void 0===a.length?[a]:a.slice(0),g("pattern",function(a){return a.pattern},f.validatePattern),g("minSize",function(a){return a.size&&a.size.min},function(a,b){return a.size>=f.translateScalars(b)}),g("maxSize",function(a){return a.size&&a.size.max},function(a,b){return a.size<=f.translateScalars(b)});var j=0;if(g("maxTotalSize",function(a){return a.maxTotalSize&&a.maxTotalSize},function(b,c){return j+=b.size,j>f.translateScalars(c)?(a.splice(0,a.length),!1):!0}),g("validateFn",function(){return null},function(a,b){return b===!0||null===b||""===b}),!a.length)return f.emptyPromise(c,c.$ngfValidations);var k=b.defer(),l=[];return l.push(f.happyPromise(h("maxHeight",function(a){return a.height&&a.height.max},/image/,this.imageDimensions,function(a,b){return a.height<=b}))),l.push(f.happyPromise(h("minHeight",function(a){return a.height&&a.height.min},/image/,this.imageDimensions,function(a,b){return a.height>=b}))),l.push(f.happyPromise(h("maxWidth",function(a){return a.width&&a.width.max},/image/,this.imageDimensions,function(a,b){return a.width<=b}))),l.push(f.happyPromise(h("minWidth",function(a){return a.width&&a.width.min},/image/,this.imageDimensions,function(a,b){return a.width>=b}))),l.push(f.happyPromise(h("ratio",function(a){return a.ratio},/image/,this.imageDimensions,function(a,b){for(var c=b.toString().split(","),d=!1,e=0;e<c.length;e++)Math.abs(a.width/a.height-f.ratioToFloat(c[e]))<1e-4&&(d=!0);return d}))),l.push(f.happyPromise(h("maxRatio",function(a){return a.ratio},/image/,this.imageDimensions,function(a,b){return a.width/a.height-f.ratioToFloat(b)<1e-4}))),l.push(f.happyPromise(h("minRatio",function(a){return a.ratio},/image/,this.imageDimensions,function(a,b){return a.width/a.height-f.ratioToFloat(b)>-1e-4}))),l.push(f.happyPromise(h("maxDuration",function(a){return a.duration&&a.duration.max},/audio|video/,this.mediaDuration,function(a,b){return a<=f.translateScalars(b)}))),l.push(f.happyPromise(h("minDuration",function(a){return a.duration&&a.duration.min},/audio|video/,this.mediaDuration,function(a,b){return a>=f.translateScalars(b)}))),l.push(f.happyPromise(h("validateAsyncFn",function(){return null},null,function(a,b){return b},function(a){return a===!0||null===a||""===a}))),b.all(l).then(function(){k.resolve(c,c.$ngfValidations)})},f.imageDimensions=function(a){if(a.$ngfWidth&&a.$ngfHeight){var d=b.defer();return c(function(){d.resolve({width:a.$ngfWidth,height:a.$ngfHeight})}),d.promise}if(a.$ngfDimensionPromise)return a.$ngfDimensionPromise;var e=b.defer();return c(function(){return 0!==a.type.indexOf("image")?void e.reject("not image"):void f.dataUrl(a).then(function(b){function d(){var b=h[0].clientWidth,c=h[0].clientHeight;h.remove(),a.$ngfWidth=b,a.$ngfHeight=c,e.resolve({width:b,height:c})}function f(){h.remove(),e.reject("load error")}function g(){c(function(){h[0].parentNode&&(h[0].clientWidth?d():i>10?f():g())},1e3)}var h=angular.element("<img>").attr("src",b).css("visibility","hidden").css("position","fixed");h.on("load",d),h.on("error",f);var i=0;g(),angular.element(document.getElementsByTagName("body")[0]).append(h)},function(){e.reject("load error")})}),a.$ngfDimensionPromise=e.promise,a.$ngfDimensionPromise["finally"](function(){delete a.$ngfDimensionPromise}),a.$ngfDimensionPromise},f.mediaDuration=function(a){if(a.$ngfDuration){var d=b.defer();return c(function(){d.resolve(a.$ngfDuration)}),d.promise}if(a.$ngfDurationPromise)return a.$ngfDurationPromise;var e=b.defer();return c(function(){return 0!==a.type.indexOf("audio")&&0!==a.type.indexOf("video")?void e.reject("not media"):void f.dataUrl(a).then(function(b){function d(){var b=h[0].duration;a.$ngfDuration=b,h.remove(),e.resolve(b)}function f(){h.remove(),e.reject("load error")}function g(){c(function(){h[0].parentNode&&(h[0].duration?d():i>10?f():g())},1e3)}var h=angular.element(0===a.type.indexOf("audio")?"<audio>":"<video>").attr("src",b).css("visibility","none").css("position","fixed");h.on("loadedmetadata",d),h.on("error",f);var i=0;g(),angular.element(document.body).append(h)},function(){e.reject("load error")})}),a.$ngfDurationPromise=e.promise,a.$ngfDurationPromise["finally"](function(){delete a.$ngfDurationPromise}),a.$ngfDurationPromise},f}]),ngFileUpload.service("UploadResize",["UploadValidate","$q",function(a,b){var c=a,d=function(a,b,c,d,e){var f=e?Math.max(c/a,d/b):Math.min(c/a,d/b);return{width:a*f,height:b*f,marginX:a*f-c,marginY:b*f-d}},e=function(a,e,f,g,h,i,j){var k=b.defer(),l=document.createElement("canvas"),m=document.createElement("img");return m.onload=function(){try{if(i){var a=c.ratioToFloat(i),b=m.width/m.height;a>b?(e=m.width,f=e/a):(f=m.height,e=f*a)}e||(e=m.width),f||(f=m.height);var n=d(m.width,m.height,e,f,j);l.width=Math.min(n.width,e),l.height=Math.min(n.height,f);var o=l.getContext("2d");o.drawImage(m,Math.min(0,-n.marginX/2),Math.min(0,-n.marginY/2),n.width,n.height),k.resolve(l.toDataURL(h||"image/WebP",g||1))}catch(p){k.reject(p)}},m.onerror=function(){k.reject()},m.src=a,k.promise};return c.dataUrltoBlob=function(a,b){for(var c=a.split(","),d=c[0].match(/:(.*?);/)[1],e=atob(c[1]),f=e.length,g=new Uint8Array(f);f--;)g[f]=e.charCodeAt(f);var h=new window.Blob([g],{type:d});return h.name=b,h},c.isResizeSupported=function(){var a=document.createElement("canvas");return window.atob&&a.getContext&&a.getContext("2d")},c.isResizeSupported()&&Object.defineProperty(window.Blob.prototype,"name",{get:function(){return this.$ngfName},set:function(a){this.$ngfName=a},configurable:!0}),c.resize=function(a,d,f,g,h,i,j){if(0!==a.type.indexOf("image"))return c.emptyPromise(a);var k=b.defer();return c.dataUrl(a,!0).then(function(b){e(b,d,f,g,h||a.type,i,j).then(function(b){k.resolve(c.dataUrltoBlob(b,a.name))},function(){k.reject()})},function(){k.reject()}),k.promise},c}]),function(){function a(a,c,d,e,f,g,h,i,j,k){function l(){return c.attr("disabled")||q("ngfDropDisabled",a)}function m(b,c){var f=[];b.replace(/<(img src|img [^>]* src) *=\"([^\"]*)\"/gi,function(a,b,c){f.push(c)});var g=[],h=[];f.length&&(angular.forEach(f,function(a){g.push(j({url:a,method:"get",responseType:"arraybuffer"}).then(function(a){var b=new Uint8Array(a.data),c=a.headers("content-type")||"image/WebP",d=new window.Blob([b],{type:c});h.push(d)}))}),k.all(g).then(function(){i.updateModel(e,d,a,q("ngfChange")||q("ngfDrop"),h,c)}))}function n(a,b,c,d){var e=q("ngfDragOverClass",a,{$event:c}),f="dragover";if(angular.isString(e))f=e;else if(e&&(e.delay&&(u=e.delay),e.accept||e.reject)){var g=c.dataTransfer.items;if(null!=g&&g.length)for(var h=e.pattern||q("ngfPattern",a,{$event:c}),j=g.length;j--;){if(!i.validatePattern(g[j],h)){f=e.reject;break}f=e.accept}else f=e.accept}d(f)}function o(a,b,c,d){function e(a,b,c){if(null!=b)if(b.isDirectory){var d=(c||"")+b.name;a.push({name:b.name,type:"directory",path:d});var f=b.createReader(),g=[];i++;var h=function(){f.readEntries(function(d){try{if(d.length)g=g.concat(Array.prototype.slice.call(d||[],0)),h();else{for(var f=0;f<g.length;f++)e(a,g[f],(c?c:"")+b.name+"/");i--}}catch(j){i--,console.error(j)}},function(){i--})};h()}else i++,b.file(function(b){try{i--,b.path=(c?c:"")+b.name,a.push(b)}catch(d){i--,console.error(d)}},function(){i--})}var f=[],i=0,j=a.dataTransfer.items;if(j&&j.length>0&&"file"!==h.protocol())for(var k=0;k<j.length;k++){if(j[k].webkitGetAsEntry&&j[k].webkitGetAsEntry()&&j[k].webkitGetAsEntry().isDirectory){var l=j[k].webkitGetAsEntry();if(l.isDirectory&&!c)continue;null!=l&&e(f,l)}else{var m=j[k].getAsFile();null!=m&&f.push(m)}if(!d&&f.length>0)break}else{var n=a.dataTransfer.files;if(null!=n)for(var o=0;o<n.length;o++){var p=n.item(o);if((p.type||p.size>0)&&f.push(p),!d&&f.length>0)break}}var q=0;!function r(a){g(function(){if(i)10*q++<2e4&&r(10);else{if(!d&&f.length>1){for(k=0;"directory"===f[k].type;)k++;f=[f[k]]}b(f)}},a||0)}()}var p=b(),q=function(a,b,c){return i.attrGetter(a,d,b,c)};if(q("dropAvailable")&&g(function(){a[q("dropAvailable")]?a[q("dropAvailable")].value=p:a[q("dropAvailable")]=p}),!p)return void(q("ngfHideOnDropNotAvailable",a)===!0&&c.css("display","none"));null==q("ngfSelect")&&i.registerModelChangeValidator(e,d,a);var r,s=null,t=f(q("ngfStopPropagation")),u=1;c[0].addEventListener("dragover",function(b){if(!l()){if(b.preventDefault(),t(a)&&b.stopPropagation(),navigator.userAgent.indexOf("Chrome")>-1){var e=b.dataTransfer.effectAllowed;b.dataTransfer.dropEffect="move"===e||"linkMove"===e?"move":"copy"}g.cancel(s),r||(r="C",n(a,d,b,function(d){r=d,c.addClass(r),q("ngfDrag",a,{$isDragging:!0,$class:r,$event:b})}))}},!1),c[0].addEventListener("dragenter",function(b){l()||(b.preventDefault(),t(a)&&b.stopPropagation())},!1),c[0].addEventListener("dragleave",function(b){l()||(b.preventDefault(),t(a)&&b.stopPropagation(),s=g(function(){r&&c.removeClass(r),r=null,q("ngfDrag",a,{$isDragging:!1,$event:b})},u||100))},!1),c[0].addEventListener("drop",function(b){if(!l()&&i.shouldUpdateOn("drop",d,a)){b.preventDefault(),t(a)&&b.stopPropagation(),r&&c.removeClass(r),r=null;var f;try{f=b.dataTransfer&&b.dataTransfer.getData&&b.dataTransfer.getData("text/html")}catch(g){}i.shouldUpdateOn("dropUrl",d,a)&&f?m(f,b):o(b,function(c){i.updateModel(e,d,a,q("ngfChange")||q("ngfDrop"),c,b)},q("ngfAllowDir",a)!==!1,q("multiple")||q("ngfMultiple",a))}},!1),c[0].addEventListener("paste",function(b){if(navigator.userAgent.toLowerCase().indexOf("firefox")>-1&&b.preventDefault(),!l()&&i.shouldUpdateOn("paste",d,a)){var c=[],f=b.clipboardData||b.originalEvent.clipboardData;if(f&&f.items)for(var g=0;g<f.items.length;g++)-1!==f.items[g].type.indexOf("image")&&c.push(f.items[g].getAsFile());if(c.length)i.updateModel(e,d,a,q("ngfChange")||q("ngfDrop"),c,b);else{var h;try{h=f&&f.getData&&f.getData("text/html")}catch(j){}i.shouldUpdateOn("pasteUrl",d,a)&&h&&m(h,b)}}},!1),navigator.userAgent.toLowerCase().indexOf("firefox")>-1&&q("ngfEnableFirefoxPaste",a)&&(c.attr("contenteditable",!0),c.on("keypress",function(a){a.metaKey||a.ctrlKey||a.preventDefault()}))}function b(){var a=document.createElement("div");return"draggable"in a&&"ondrop"in a&&!/Edge\/12./i.test(navigator.userAgent)}ngFileUpload.directive("ngfDrop",["$parse","$timeout","$location","Upload","$http","$q",function(b,c,d,e,f,g){return{restrict:"AEC",require:"?ngModel",link:function(h,i,j,k){a(h,i,j,k,b,c,d,e,f,g)}}}]),ngFileUpload.directive("ngfNoFileDrop",function(){return function(a,c){b()&&c.css("display","none")}}),ngFileUpload.directive("ngfDropAvailable",["$parse","$timeout","Upload",function(a,c,d){return function(e,f,g){if(b()){var h=a(d.attrGetter("ngfDropAvailable",g));c(function(){h(e),h.assign&&h.assign(e,!0)})}}}])}(),ngFileUpload.service("UploadExif",["UploadResize","$q",function(a,b){function c(a){var b=new DataView(a);if(255!==b.getUint8(0)||216!==b.getUint8(1))return"Not a valid JPEG";for(var c,d=2,e=a.byteLength;e>d;){if(255!==b.getUint8(d))return"Not a valid marker at offset "+d+", found: "+b.getUint8(d);if(c=b.getUint8(d+1),225===c)return g(b,d+4,b.getUint16(d+2)-2);d+=2+b.getUint16(d+2)}}function d(a,b,c,d){var f,g,h=a.getUint16(c,!d);for(g=0;h>g;g++){f=c+12*g+2;var i=a.getUint16(f,!d);if(274===i)return e(a,f,b,d)}return null}function e(a,b,c,d){var e,f,g,h=a.getUint32(b+4,!d),i=a.getUint32(b+8,!d)+c;if(1===h)return a.getUint16(b+8,!d);for(e=h>2?i:b+8,f=[],g=0;h>g;g++)f[g]=a.getUint16(e+2*g,!d);return f}function f(a,b,c){for(var d="",e=b;b+c>e;e++)d+=String.fromCharCode(a.getUint8(e));return d}function g(a,b){if("Exif"!==f(a,b,4))return"Not valid EXIF data! "+f(a,b,4);var c,e=b+6;if(18761===a.getUint16(e))c=!1;else{if(19789!==a.getUint16(e))return"Not valid TIFF data! (no 0x4949 or 0x4D4D)";c=!0}if(42!==a.getUint16(e+2,!c))return"Not valid TIFF data! (no 0x002A)";var g=a.getUint32(e+4,!c);return 8>g?a.getUint32(e+4,!c):d(a,e,e+g,c)}function h(a,b,c,d){switch(b){case 2:return a.transform(-1,0,0,1,c,0);case 3:return a.transform(-1,0,0,-1,c,d);case 4:return a.transform(1,0,0,-1,0,d);case 5:return a.transform(0,1,1,0,0,0);case 6:return a.transform(0,1,-1,0,d,0);case 7:return a.transform(0,-1,-1,0,d,c);case 8:return a.transform(0,-1,1,0,0,c)}}var i=a;return i.isExifSupported=function(){return window.FileReader&&(new FileReader).readAsArrayBuffer&&i.isResizeSupported()},i.orientation=function(a){if(null!=a.$ngfOrientation)return i.emptyPromise(a.$ngfOrientation);var d=b.defer(),e=new FileReader;return e.onload=function(b){var e;try{e=c(b.target.result)}catch(b){return void d.reject(b)}angular.isString(e)?d.resolve(1):(a.$ngfOrientation=e,d.resolve(e))},e.onerror=function(a){d.reject(a)},e.readAsArrayBuffer(a),d.promise},i.applyExifRotation=function(a){if(0!==a.type.indexOf("image/jpeg"))return i.emptyPromise(a);var c=b.defer();return i.orientation(a).then(function(b){(!b||2>b||b>8)&&c.resolve(a),i.dataUrl(a,!0).then(function(d){var e=document.createElement("canvas"),f=document.createElement("img");f.onload=function(){try{e.width=b>4?f.height:f.width,e.height=b>4?f.width:f.height;var d=e.getContext("2d");h(d,b,f.width,f.height),d.drawImage(f,0,0);var g=e.toDataURL(a.type||"image/WebP",1),j=i.dataUrltoBlob(g,a.name);c.resolve(j)}catch(k){c.reject(k)}},f.onerror=function(){c.reject()},f.src=d;

},function(a){c.reject(a)})},function(a){c.reject(a)}),c.promise},i}]);;
/**
 * @license MIT
 */
(function(window, document, undefined) {'use strict';
  // ie10+
  var ie10plus = window.navigator.msPointerEnabled;
  /**
   * Flow.js is a library providing multiple simultaneous, stable and
   * resumable uploads via the HTML5 File API.
   * @param [opts]
   * @param {number} [opts.chunkSize]
   * @param {bool} [opts.forceChunkSize]
   * @param {number} [opts.simultaneousUploads]
   * @param {bool} [opts.singleFile]
   * @param {string} [opts.fileParameterName]
   * @param {number} [opts.progressCallbacksInterval]
   * @param {number} [opts.speedSmoothingFactor]
   * @param {Object|Function} [opts.query]
   * @param {Object|Function} [opts.headers]
   * @param {bool} [opts.withCredentials]
   * @param {Function} [opts.preprocess]
   * @param {string} [opts.method]
   * @param {string|Function} [opts.testMethod]
   * @param {string|Function} [opts.uploadMethod]
   * @param {bool} [opts.prioritizeFirstAndLastChunk]
   * @param {bool} [opts.allowDuplicateUploads]
   * @param {string|Function} [opts.target]
   * @param {number} [opts.maxChunkRetries]
   * @param {number} [opts.chunkRetryInterval]
   * @param {Array.<number>} [opts.permanentErrors]
   * @param {Array.<number>} [opts.successStatuses]
   * @param {Function} [opts.initFileFn]
   * @param {Function} [opts.readFileFn]
   * @param {Function} [opts.generateUniqueIdentifier]
   * @constructor
   */
  function Flow(opts) {
    /**
     * Supported by browser?
     * @type {boolean}
     */
    this.support = (
        typeof File !== 'undefined' &&
        typeof Blob !== 'undefined' &&
        typeof FileList !== 'undefined' &&
        (
          !!Blob.prototype.slice || !!Blob.prototype.webkitSlice || !!Blob.prototype.mozSlice ||
          false
        ) // slicing files support
    );

    if (!this.support) {
      return ;
    }

    /**
     * Check if directory upload is supported
     * @type {boolean}
     */
    this.supportDirectory = /Chrome/.test(window.navigator.userAgent);

    /**
     * List of FlowFile objects
     * @type {Array.<FlowFile>}
     */
    this.files = [];

    /**
     * Default options for flow.js
     * @type {Object}
     */
    this.defaults = {
      chunkSize: 1024 * 1024,
      forceChunkSize: false,
      simultaneousUploads: 3,
      singleFile: false,
      fileParameterName: 'file',
      progressCallbacksInterval: 500,
      speedSmoothingFactor: 0.1,
      query: {},
      headers: {},
      withCredentials: false,
      preprocess: null,
      method: 'multipart',
      testMethod: 'GET',
      uploadMethod: 'POST',
      prioritizeFirstAndLastChunk: false,
      allowDuplicateUploads: false,
      target: '/',
      testChunks: true,
      generateUniqueIdentifier: null,
      maxChunkRetries: 0,
      chunkRetryInterval: null,
      permanentErrors: [404, 415, 500, 501],
      successStatuses: [200, 201, 202],
      onDropStopPropagation: false,
      initFileFn: null,
      readFileFn: webAPIFileRead
    };
    
    /**
     * Current options
     * @type {Object}
     */
    this.opts = {};

    /**
     * List of events:
     *  key stands for event name
     *  value array list of callbacks
     * @type {}
     */
    this.events = {};

    var $ = this;

    /**
     * On drop event
     * @function
     * @param {MouseEvent} event
     */
    this.onDrop = function (event) {
      if ($.opts.onDropStopPropagation) {
        event.stopPropagation();
      }
      event.preventDefault();
      var dataTransfer = event.dataTransfer;
      if (dataTransfer.items && dataTransfer.items[0] &&
        dataTransfer.items[0].webkitGetAsEntry) {
        $.webkitReadDataTransfer(event);
      } else {
        $.addFiles(dataTransfer.files, event);
      }
    };

    /**
     * Prevent default
     * @function
     * @param {MouseEvent} event
     */
    this.preventEvent = function (event) {
      event.preventDefault();
    };


    /**
     * Current options
     * @type {Object}
     */
    this.opts = Flow.extend({}, this.defaults, opts || {});

  }

  Flow.prototype = {
    /**
     * Set a callback for an event, possible events:
     * fileSuccess(file), fileProgress(file), fileAdded(file, event),
     * fileRetry(file), fileError(file, message), complete(),
     * progress(), error(message, file), pause()
     * @function
     * @param {string} event
     * @param {Function} callback
     */
    on: function (event, callback) {
      event = event.toLowerCase();
      if (!this.events.hasOwnProperty(event)) {
        this.events[event] = [];
      }
      this.events[event].push(callback);
    },

    /**
     * Remove event callback
     * @function
     * @param {string} [event] removes all events if not specified
     * @param {Function} [fn] removes all callbacks of event if not specified
     */
    off: function (event, fn) {
      if (event !== undefined) {
        event = event.toLowerCase();
        if (fn !== undefined) {
          if (this.events.hasOwnProperty(event)) {
            arrayRemove(this.events[event], fn);
          }
        } else {
          delete this.events[event];
        }
      } else {
        this.events = {};
      }
    },

    /**
     * Fire an event
     * @function
     * @param {string} event event name
     * @param {...} args arguments of a callback
     * @return {bool} value is false if at least one of the event handlers which handled this event
     * returned false. Otherwise it returns true.
     */
    fire: function (event, args) {
      // `arguments` is an object, not array, in FF, so:
      args = Array.prototype.slice.call(arguments);
      event = event.toLowerCase();
      var preventDefault = false;
      if (this.events.hasOwnProperty(event)) {
        each(this.events[event], function (callback) {
          preventDefault = callback.apply(this, args.slice(1)) === false || preventDefault;
        }, this);
      }
      if (event != 'catchall') {
        args.unshift('catchAll');
        preventDefault = this.fire.apply(this, args) === false || preventDefault;
      }
      return !preventDefault;
    },

    /**
     * Read webkit dataTransfer object
     * @param event
     */
    webkitReadDataTransfer: function (event) {
      var $ = this;
      var queue = event.dataTransfer.items.length;
      var files = [];
      each(event.dataTransfer.items, function (item) {
        var entry = item.webkitGetAsEntry();
        if (!entry) {
          decrement();
          return ;
        }
        if (entry.isFile) {
          // due to a bug in Chrome's File System API impl - #149735
          fileReadSuccess(item.getAsFile(), entry.fullPath);
        } else {
          readDirectory(entry.createReader());
        }
      });
      function readDirectory(reader) {
        reader.readEntries(function (entries) {
          if (entries.length) {
            queue += entries.length;
            each(entries, function(entry) {
              if (entry.isFile) {
                var fullPath = entry.fullPath;
                entry.file(function (file) {
                  fileReadSuccess(file, fullPath);
                }, readError);
              } else if (entry.isDirectory) {
                readDirectory(entry.createReader());
              }
            });
            readDirectory(reader);
          } else {
            decrement();
          }
        }, readError);
      }
      function fileReadSuccess(file, fullPath) {
        // relative path should not start with "/"
        file.relativePath = fullPath.substring(1);
        files.push(file);
        decrement();
      }
      function readError(fileError) {
        throw fileError;
      }
      function decrement() {
        if (--queue == 0) {
          $.addFiles(files, event);
        }
      }
    },

    /**
     * Generate unique identifier for a file
     * @function
     * @param {FlowFile} file
     * @returns {string}
     */
    generateUniqueIdentifier: function (file) {
      var custom = this.opts.generateUniqueIdentifier;
      if (typeof custom === 'function') {
        return custom(file);
      }
      // Some confusion in different versions of Firefox
      var relativePath = file.relativePath || file.webkitRelativePath || file.fileName || file.name;
      return file.size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, '');
    },

    /**
     * Upload next chunk from the queue
     * @function
     * @returns {boolean}
     * @private
     */
    uploadNextChunk: function (preventEvents) {
      // In some cases (such as videos) it's really handy to upload the first
      // and last chunk of a file quickly; this let's the server check the file's
      // metadata and determine if there's even a point in continuing.
      var found = false;
      if (this.opts.prioritizeFirstAndLastChunk) {
        each(this.files, function (file) {
          if (!file.paused && file.chunks.length &&
            file.chunks[0].status() === 'pending') {
            file.chunks[0].send();
            found = true;
            return false;
          }
          if (!file.paused && file.chunks.length > 1 &&
            file.chunks[file.chunks.length - 1].status() === 'pending') {
            file.chunks[file.chunks.length - 1].send();
            found = true;
            return false;
          }
        });
        if (found) {
          return found;
        }
      }

      // Now, simply look for the next, best thing to upload
      each(this.files, function (file) {
        if (!file.paused) {
          each(file.chunks, function (chunk) {
            if (chunk.status() === 'pending') {
              chunk.send();
              found = true;
              return false;
            }
          });
        }
        if (found) {
          return false;
        }
      });
      if (found) {
        return true;
      }

      // The are no more outstanding chunks to upload, check is everything is done
      var outstanding = false;
      each(this.files, function (file) {
        if (!file.isComplete()) {
          outstanding = true;
          return false;
        }
      });
      if (!outstanding && !preventEvents) {
        // All chunks have been uploaded, complete
        async(function () {
          this.fire('complete');
        }, this);
      }
      return false;
    },


    /**
     * Assign a browse action to one or more DOM nodes.
     * @function
     * @param {Element|Array.<Element>} domNodes
     * @param {boolean} isDirectory Pass in true to allow directories to
     * @param {boolean} singleFile prevent multi file upload
     * @param {Object} attributes set custom attributes:
     *  http://www.w3.org/TR/html-markup/input.file.html#input.file-attributes
     *  eg: accept: 'image/*'
     * be selected (Chrome only).
     */
    assignBrowse: function (domNodes, isDirectory, singleFile, attributes) {
      if (typeof domNodes.length === 'undefined') {
        domNodes = [domNodes];
      }

      each(domNodes, function (domNode) {
        var input;
        if (domNode.tagName === 'INPUT' && domNode.type === 'file') {
          input = domNode;
        } else {
          input = document.createElement('input');
          input.setAttribute('type', 'file');
          // display:none - not working in opera 12
          extend(input.style, {
            visibility: 'hidden',
            position: 'absolute',
            width: '1px',
            height: '1px'
          });
          // for opera 12 browser, input must be assigned to a document
          domNode.appendChild(input);
          // https://developer.mozilla.org/en/using_files_from_web_applications)
          // event listener is executed two times
          // first one - original mouse click event
          // second - input.click(), input is inside domNode
          domNode.addEventListener('click', function() {
            input.click();
          }, false);
        }
        if (!this.opts.singleFile && !singleFile) {
          input.setAttribute('multiple', 'multiple');
        }
        if (isDirectory) {
          input.setAttribute('webkitdirectory', 'webkitdirectory');
        }
        each(attributes, function (value, key) {
          input.setAttribute(key, value);
        });
        // When new files are added, simply append them to the overall list
        var $ = this;
        input.addEventListener('change', function (e) {
       	  if (e.target.value) {
            $.addFiles(e.target.files, e);
            e.target.value = '';
       	  }
        }, false);
      }, this);
    },

    /**
     * Assign one or more DOM nodes as a drop target.
     * @function
     * @param {Element|Array.<Element>} domNodes
     */
    assignDrop: function (domNodes) {
      if (typeof domNodes.length === 'undefined') {
        domNodes = [domNodes];
      }
      each(domNodes, function (domNode) {
        domNode.addEventListener('dragover', this.preventEvent, false);
        domNode.addEventListener('dragenter', this.preventEvent, false);
        domNode.addEventListener('drop', this.onDrop, false);
      }, this);
    },

    /**
     * Un-assign drop event from DOM nodes
     * @function
     * @param domNodes
     */
    unAssignDrop: function (domNodes) {
      if (typeof domNodes.length === 'undefined') {
        domNodes = [domNodes];
      }
      each(domNodes, function (domNode) {
        domNode.removeEventListener('dragover', this.preventEvent);
        domNode.removeEventListener('dragenter', this.preventEvent);
        domNode.removeEventListener('drop', this.onDrop);
      }, this);
    },

    /**
     * Returns a boolean indicating whether or not the instance is currently
     * uploading anything.
     * @function
     * @returns {boolean}
     */
    isUploading: function () {
      var uploading = false;
      each(this.files, function (file) {
        if (file.isUploading()) {
          uploading = true;
          return false;
        }
      });
      return uploading;
    },

    /**
     * should upload next chunk
     * @function
     * @returns {boolean|number}
     */
    _shouldUploadNext: function () {
      var num = 0;
      var should = true;
      var simultaneousUploads = this.opts.simultaneousUploads;
      each(this.files, function (file) {
        each(file.chunks, function(chunk) {
          if (chunk.status() === 'uploading') {
            num++;
            if (num >= simultaneousUploads) {
              should = false;
              return false;
            }
          }
        });
      });
      // if should is true then return uploading chunks's length
      return should && num;
    },

    /**
     * Start or resume uploading.
     * @function
     */
    upload: function () {
      // Make sure we don't start too many uploads at once
      var ret = this._shouldUploadNext();
      if (ret === false) {
        return;
      }
      // Kick off the queue
      this.fire('uploadStart');
      var started = false;
      for (var num = 1; num <= this.opts.simultaneousUploads - ret; num++) {
        started = this.uploadNextChunk(true) || started;
      }
      if (!started) {
        async(function () {
          this.fire('complete');
        }, this);
      }
    },

    /**
     * Resume uploading.
     * @function
     */
    resume: function () {
      each(this.files, function (file) {
        file.resume();
      });
    },

    /**
     * Pause uploading.
     * @function
     */
    pause: function () {
      each(this.files, function (file) {
        file.pause();
      });
    },

    /**
     * Cancel upload of all FlowFile objects and remove them from the list.
     * @function
     */
    cancel: function () {
      for (var i = this.files.length - 1; i >= 0; i--) {
        this.files[i].cancel();
      }
    },

    /**
     * Returns a number between 0 and 1 indicating the current upload progress
     * of all files.
     * @function
     * @returns {number}
     */
    progress: function () {
      var totalDone = 0;
      var totalSize = 0;
      // Resume all chunks currently being uploaded
      each(this.files, function (file) {
        totalDone += file.progress() * file.size;
        totalSize += file.size;
      });
      return totalSize > 0 ? totalDone / totalSize : 0;
    },

    /**
     * Add a HTML5 File object to the list of files.
     * @function
     * @param {File} file
     * @param {Event} [event] event is optional
     */
    addFile: function (file, event) {
      this.addFiles([file], event);
    },

    /**
     * Add a HTML5 File object to the list of files.
     * @function
     * @param {FileList|Array} fileList
     * @param {Event} [event] event is optional
     */
    addFiles: function (fileList, event) {
      var files = [];
      each(fileList, function (file) {
        // https://github.com/flowjs/flow.js/issues/55
        if ((!ie10plus || ie10plus && file.size > 0) && !(file.size % 4096 === 0 && (file.name === '.' || file.fileName === '.')) &&
          (this.opts.allowDuplicateUploads || !this.getFromUniqueIdentifier(this.generateUniqueIdentifier(file)))) {
          var f = new FlowFile(this, file);
          if (this.fire('fileAdded', f, event)) {
            files.push(f);
          }
        }
      }, this);
      if (this.fire('filesAdded', files, event)) {
        each(files, function (file) {
          if (this.opts.singleFile && this.files.length > 0) {
            this.removeFile(this.files[0]);
          }
          this.files.push(file);
        }, this);
      }
      this.fire('filesSubmitted', files, event);
    },


    /**
     * Cancel upload of a specific FlowFile object from the list.
     * @function
     * @param {FlowFile} file
     */
    removeFile: function (file) {
      for (var i = this.files.length - 1; i >= 0; i--) {
        if (this.files[i] === file) {
          this.files.splice(i, 1);
          file.abort();
        }
      }
    },

    /**
     * Look up a FlowFile object by its unique identifier.
     * @function
     * @param {string} uniqueIdentifier
     * @returns {boolean|FlowFile} false if file was not found
     */
    getFromUniqueIdentifier: function (uniqueIdentifier) {
      var ret = false;
      each(this.files, function (file) {
        if (file.uniqueIdentifier === uniqueIdentifier) {
          ret = file;
        }
      });
      return ret;
    },

    /**
     * Returns the total size of all files in bytes.
     * @function
     * @returns {number}
     */
    getSize: function () {
      var totalSize = 0;
      each(this.files, function (file) {
        totalSize += file.size;
      });
      return totalSize;
    },

    /**
     * Returns the total size uploaded of all files in bytes.
     * @function
     * @returns {number}
     */
    sizeUploaded: function () {
      var size = 0;
      each(this.files, function (file) {
        size += file.sizeUploaded();
      });
      return size;
    },

    /**
     * Returns remaining time to upload all files in seconds. Accuracy is based on average speed.
     * If speed is zero, time remaining will be equal to positive infinity `Number.POSITIVE_INFINITY`
     * @function
     * @returns {number}
     */
    timeRemaining: function () {
      var sizeDelta = 0;
      var averageSpeed = 0;
      each(this.files, function (file) {
        if (!file.paused && !file.error) {
          sizeDelta += file.size - file.sizeUploaded();
          averageSpeed += file.averageSpeed;
        }
      });
      if (sizeDelta && !averageSpeed) {
        return Number.POSITIVE_INFINITY;
      }
      if (!sizeDelta && !averageSpeed) {
        return 0;
      }
      return Math.floor(sizeDelta / averageSpeed);
    }
  };






  /**
   * FlowFile class
   * @name FlowFile
   * @param {Flow} flowObj
   * @param {File} file
   * @constructor
   */
  function FlowFile(flowObj, file) {

    /**
     * Reference to parent Flow instance
     * @type {Flow}
     */
    this.flowObj = flowObj;
    
    /**
     * Used to store the bytes read
     * @type {Blob|string}
     */
    this.bytes = null;

    /**
     * Reference to file
     * @type {File}
     */
    this.file = file;

    /**
     * File name. Some confusion in different versions of Firefox
     * @type {string}
     */
    this.name = file.fileName || file.name;

    /**
     * File size
     * @type {number}
     */
    this.size = file.size;

    /**
     * Relative file path
     * @type {string}
     */
    this.relativePath = file.relativePath || file.webkitRelativePath || this.name;

    /**
     * File unique identifier
     * @type {string}
     */
    this.uniqueIdentifier = flowObj.generateUniqueIdentifier(file);

    /**
     * List of chunks
     * @type {Array.<FlowChunk>}
     */
    this.chunks = [];

    /**
     * Indicated if file is paused
     * @type {boolean}
     */
    this.paused = false;

    /**
     * Indicated if file has encountered an error
     * @type {boolean}
     */
    this.error = false;

    /**
     * Average upload speed
     * @type {number}
     */
    this.averageSpeed = 0;

    /**
     * Current upload speed
     * @type {number}
     */
    this.currentSpeed = 0;

    /**
     * Date then progress was called last time
     * @type {number}
     * @private
     */
    this._lastProgressCallback = Date.now();

    /**
     * Previously uploaded file size
     * @type {number}
     * @private
     */
    this._prevUploadedSize = 0;

    /**
     * Holds previous progress
     * @type {number}
     * @private
     */
    this._prevProgress = 0;

    this.bootstrap();
  }

  FlowFile.prototype = {
    /**
     * Update speed parameters
     * @link http://stackoverflow.com/questions/2779600/how-to-estimate-download-time-remaining-accurately
     * @function
     */
    measureSpeed: function () {
      var timeSpan = Date.now() - this._lastProgressCallback;
      if (!timeSpan) {
        return ;
      }
      var smoothingFactor = this.flowObj.opts.speedSmoothingFactor;
      var uploaded = this.sizeUploaded();
      // Prevent negative upload speed after file upload resume
      this.currentSpeed = Math.max((uploaded - this._prevUploadedSize) / timeSpan * 1000, 0);
      this.averageSpeed = smoothingFactor * this.currentSpeed + (1 - smoothingFactor) * this.averageSpeed;
      this._prevUploadedSize = uploaded;
    },

    /**
     * For internal usage only.
     * Callback when something happens within the chunk.
     * @function
     * @param {FlowChunk} chunk
     * @param {string} event can be 'progress', 'success', 'error' or 'retry'
     * @param {string} [message]
     */
    chunkEvent: function (chunk, event, message) {
      switch (event) {
        case 'progress':
          if (Date.now() - this._lastProgressCallback <
            this.flowObj.opts.progressCallbacksInterval) {
            break;
          }
          this.measureSpeed();
          this.flowObj.fire('fileProgress', this, chunk);
          this.flowObj.fire('progress');
          this._lastProgressCallback = Date.now();
          break;
        case 'error':
          this.error = true;
          this.abort(true);
          this.flowObj.fire('fileError', this, message, chunk);
          this.flowObj.fire('error', message, this, chunk);
          break;
        case 'success':
          if (this.error) {
            return;
          }
          this.measureSpeed();
          this.flowObj.fire('fileProgress', this, chunk);
          this.flowObj.fire('progress');
          this._lastProgressCallback = Date.now();
          if (this.isComplete()) {
            this.currentSpeed = 0;
            this.averageSpeed = 0;
            this.flowObj.fire('fileSuccess', this, message, chunk);
          }
          break;
        case 'retry':
          this.flowObj.fire('fileRetry', this, chunk);
          break;
      }
    },

    /**
     * Pause file upload
     * @function
     */
    pause: function() {
      this.paused = true;
      this.abort();
    },

    /**
     * Resume file upload
     * @function
     */
    resume: function() {
      this.paused = false;
      this.flowObj.upload();
    },

    /**
     * Abort current upload
     * @function
     */
    abort: function (reset) {
      this.currentSpeed = 0;
      this.averageSpeed = 0;
      var chunks = this.chunks;
      if (reset) {
        this.chunks = [];
      }
      each(chunks, function (c) {
        if (c.status() === 'uploading') {
          c.abort();
          this.flowObj.uploadNextChunk();
        }
      }, this);
    },

    /**
     * Cancel current upload and remove from a list
     * @function
     */
    cancel: function () {
      this.flowObj.removeFile(this);
    },

    /**
     * Retry aborted file upload
     * @function
     */
    retry: function () {
      this.bootstrap();
      this.flowObj.upload();
    },

    /**
     * Clear current chunks and slice file again
     * @function
     */
    bootstrap: function () {
      if (typeof this.flowObj.opts.initFileFn === "function") {
        this.flowObj.opts.initFileFn(this);
      }

      this.abort(true);
      this.error = false;
      // Rebuild stack of chunks from file
      this._prevProgress = 0;
      var round = this.flowObj.opts.forceChunkSize ? Math.ceil : Math.floor;
      var chunks = Math.max(
        round(this.size / this.flowObj.opts.chunkSize), 1
      );
      for (var offset = 0; offset < chunks; offset++) {
        this.chunks.push(
          new FlowChunk(this.flowObj, this, offset)
        );
      }
    },

    /**
     * Get current upload progress status
     * @function
     * @returns {number} from 0 to 1
     */
    progress: function () {
      if (this.error) {
        return 1;
      }
      if (this.chunks.length === 1) {
        this._prevProgress = Math.max(this._prevProgress, this.chunks[0].progress());
        return this._prevProgress;
      }
      // Sum up progress across everything
      var bytesLoaded = 0;
      each(this.chunks, function (c) {
        // get chunk progress relative to entire file
        bytesLoaded += c.progress() * (c.endByte - c.startByte);
      });
      var percent = bytesLoaded / this.size;
      // We don't want to lose percentages when an upload is paused
      this._prevProgress = Math.max(this._prevProgress, percent > 0.9999 ? 1 : percent);
      return this._prevProgress;
    },

    /**
     * Indicates if file is being uploaded at the moment
     * @function
     * @returns {boolean}
     */
    isUploading: function () {
      var uploading = false;
      each(this.chunks, function (chunk) {
        if (chunk.status() === 'uploading') {
          uploading = true;
          return false;
        }
      });
      return uploading;
    },

    /**
     * Indicates if file is has finished uploading and received a response
     * @function
     * @returns {boolean}
     */
    isComplete: function () {
      var outstanding = false;
      each(this.chunks, function (chunk) {
        var status = chunk.status();
        if (status === 'pending' || status === 'uploading' || status === 'reading' || chunk.preprocessState === 1 || chunk.readState === 1) {
          outstanding = true;
          return false;
        }
      });
      return !outstanding;
    },

    /**
     * Count total size uploaded
     * @function
     * @returns {number}
     */
    sizeUploaded: function () {
      var size = 0;
      each(this.chunks, function (chunk) {
        size += chunk.sizeUploaded();
      });
      return size;
    },

    /**
     * Returns remaining time to finish upload file in seconds. Accuracy is based on average speed.
     * If speed is zero, time remaining will be equal to positive infinity `Number.POSITIVE_INFINITY`
     * @function
     * @returns {number}
     */
    timeRemaining: function () {
      if (this.paused || this.error) {
        return 0;
      }
      var delta = this.size - this.sizeUploaded();
      if (delta && !this.averageSpeed) {
        return Number.POSITIVE_INFINITY;
      }
      if (!delta && !this.averageSpeed) {
        return 0;
      }
      return Math.floor(delta / this.averageSpeed);
    },

    /**
     * Get file type
     * @function
     * @returns {string}
     */
    getType: function () {
      return this.file.type && this.file.type.split('/')[1];
    },

    /**
     * Get file extension
     * @function
     * @returns {string}
     */
    getExtension: function () {
      return this.name.substr((~-this.name.lastIndexOf(".") >>> 0) + 2).toLowerCase();
    }
  };

  /**
   * Default read function using the webAPI
   *
   * @function webAPIFileRead(fileObj, fileType, startByte, endByte, chunk)
   *
   */
  function webAPIFileRead(fileObj, startByte, endByte, fileType, chunk) {
    var function_name = 'slice';

    if (fileObj.file.slice)
      function_name =  'slice';
    else if (fileObj.file.mozSlice)
      function_name = 'mozSlice';
    else if (fileObj.file.webkitSlice)
      function_name = 'webkitSlice';

    chunk.readFinished(fileObj.file[function_name](startByte, endByte, fileType));
  }


  /**
   * Class for storing a single chunk
   * @name FlowChunk
   * @param {Flow} flowObj
   * @param {FlowFile} fileObj
   * @param {number} offset
   * @constructor
   */
  function FlowChunk(flowObj, fileObj, offset) {

    /**
     * Reference to parent flow object
     * @type {Flow}
     */
    this.flowObj = flowObj;

    /**
     * Reference to parent FlowFile object
     * @type {FlowFile}
     */
    this.fileObj = fileObj;

    /**
     * File offset
     * @type {number}
     */
    this.offset = offset;

    /**
     * Indicates if chunk existence was checked on the server
     * @type {boolean}
     */
    this.tested = false;

    /**
     * Number of retries performed
     * @type {number}
     */
    this.retries = 0;

    /**
     * Pending retry
     * @type {boolean}
     */
    this.pendingRetry = false;

    /**
     * Preprocess state
     * @type {number} 0 = unprocessed, 1 = processing, 2 = finished
     */
    this.preprocessState = 0;

    /**
     * Read state
     * @type {number} 0 = not read, 1 = reading, 2 = finished
     */
    this.readState = 0;


    /**
     * Bytes transferred from total request size
     * @type {number}
     */
    this.loaded = 0;

    /**
     * Total request size
     * @type {number}
     */
    this.total = 0;

    /**
     * Size of a chunk
     * @type {number}
     */
    this.chunkSize = this.flowObj.opts.chunkSize;

    /**
     * Chunk start byte in a file
     * @type {number}
     */
    this.startByte = this.offset * this.chunkSize;

    /**
      * Compute the endbyte in a file
      *
      */
    this.computeEndByte = function() {
      var endByte = Math.min(this.fileObj.size, (this.offset + 1) * this.chunkSize);
      if (this.fileObj.size - endByte < this.chunkSize && !this.flowObj.opts.forceChunkSize) {
        // The last chunk will be bigger than the chunk size,
        // but less than 2 * this.chunkSize
        endByte = this.fileObj.size;
      }
      return endByte;
    }

    /**
     * Chunk end byte in a file
     * @type {number}
     */
    this.endByte = this.computeEndByte();

    /**
     * XMLHttpRequest
     * @type {XMLHttpRequest}
     */
    this.xhr = null;

    var $ = this;

    /**
     * Send chunk event
     * @param event
     * @param {...} args arguments of a callback
     */
    this.event = function (event, args) {
      args = Array.prototype.slice.call(arguments);
      args.unshift($);
      $.fileObj.chunkEvent.apply($.fileObj, args);
    };
    /**
     * Catch progress event
     * @param {ProgressEvent} event
     */
    this.progressHandler = function(event) {
      if (event.lengthComputable) {
        $.loaded = event.loaded ;
        $.total = event.total;
      }
      $.event('progress', event);
    };

    /**
     * Catch test event
     * @param {Event} event
     */
    this.testHandler = function(event) {
      var status = $.status(true);
      if (status === 'error') {
        $.event(status, $.message());
        $.flowObj.uploadNextChunk();
      } else if (status === 'success') {
        $.tested = true;
        $.event(status, $.message());
        $.flowObj.uploadNextChunk();
      } else if (!$.fileObj.paused) {
        // Error might be caused by file pause method
        // Chunks does not exist on the server side
        $.tested = true;
        $.send();
      }
    };

    /**
     * Upload has stopped
     * @param {Event} event
     */
    this.doneHandler = function(event) {
      var status = $.status();
      if (status === 'success' || status === 'error') {
        delete this.data;
        $.event(status, $.message());
        $.flowObj.uploadNextChunk();
      } else {
        $.event('retry', $.message());
        $.pendingRetry = true;
        $.abort();
        $.retries++;
        var retryInterval = $.flowObj.opts.chunkRetryInterval;
        if (retryInterval !== null) {
          setTimeout(function () {
            $.send();
          }, retryInterval);
        } else {
          $.send();
        }
      }
    };
  }

  FlowChunk.prototype = {
    /**
     * Get params for a request
     * @function
     */
    getParams: function () {
      return {
        flowChunkNumber: this.offset + 1,
        flowChunkSize: this.flowObj.opts.chunkSize,
        flowCurrentChunkSize: this.endByte - this.startByte,
        flowTotalSize: this.fileObj.size,
        flowIdentifier: this.fileObj.uniqueIdentifier,
        flowFilename: this.fileObj.name,
        flowRelativePath: this.fileObj.relativePath,
        flowTotalChunks: this.fileObj.chunks.length
      };
    },

    /**
     * Get target option with query params
     * @function
     * @param params
     * @returns {string}
     */
    getTarget: function(target, params){
      if(target.indexOf('?') < 0) {
        target += '?';
      } else {
        target += '&';
      }
      return target + params.join('&');
    },

    /**
     * Makes a GET request without any data to see if the chunk has already
     * been uploaded in a previous session
     * @function
     */
    test: function () {
      // Set up request and listen for event
      this.xhr = new XMLHttpRequest();
      this.xhr.addEventListener("load", this.testHandler, false);
      this.xhr.addEventListener("error", this.testHandler, false);
      var testMethod = evalOpts(this.flowObj.opts.testMethod, this.fileObj, this);
      var data = this.prepareXhrRequest(testMethod, true);
      this.xhr.send(data);
    },

    /**
     * Finish preprocess state
     * @function
     */
    preprocessFinished: function () {
      // Re-compute the endByte after the preprocess function to allow an
      // implementer of preprocess to set the fileObj size
      this.endByte = this.computeEndByte();

      this.preprocessState = 2;
      this.send();
    },

    /**
     * Finish read state
     * @function
     */
    readFinished: function (bytes) {
      this.readState = 2;
      this.bytes = bytes;
      this.send();
    },


    /**
     * Uploads the actual data in a POST call
     * @function
     */
    send: function () {
      var preprocess = this.flowObj.opts.preprocess;
      var read = this.flowObj.opts.readFileFn;
      if (typeof preprocess === 'function') {
        switch (this.preprocessState) {
          case 0:
            this.preprocessState = 1;
            preprocess(this);
            return;
          case 1:
            return;
        }
      }
      switch (this.readState) {
        case 0:
          this.readState = 1;
          read(this.fileObj, this.startByte, this.endByte, this.fileType, this);
          return;
        case 1:
          return;
      }
      if (this.flowObj.opts.testChunks && !this.tested) {
        this.test();
        return;
      }

      this.loaded = 0;
      this.total = 0;
      this.pendingRetry = false;

      // Set up request and listen for event
      this.xhr = new XMLHttpRequest();
      this.xhr.upload.addEventListener('progress', this.progressHandler, false);
      this.xhr.addEventListener("load", this.doneHandler, false);
      this.xhr.addEventListener("error", this.doneHandler, false);

      var uploadMethod = evalOpts(this.flowObj.opts.uploadMethod, this.fileObj, this);
      var data = this.prepareXhrRequest(uploadMethod, false, this.flowObj.opts.method, this.bytes);
      this.xhr.send(data);
    },

    /**
     * Abort current xhr request
     * @function
     */
    abort: function () {
      // Abort and reset
      var xhr = this.xhr;
      this.xhr = null;
      if (xhr) {
        xhr.abort();
      }
    },

    /**
     * Retrieve current chunk upload status
     * @function
     * @returns {string} 'pending', 'uploading', 'success', 'error'
     */
    status: function (isTest) {
      if (this.readState === 1) {
        return 'reading';
      } else if (this.pendingRetry || this.preprocessState === 1) {
        // if pending retry then that's effectively the same as actively uploading,
        // there might just be a slight delay before the retry starts
        return 'uploading';
      } else if (!this.xhr) {
        return 'pending';
      } else if (this.xhr.readyState < 4) {
        // Status is really 'OPENED', 'HEADERS_RECEIVED'
        // or 'LOADING' - meaning that stuff is happening
        return 'uploading';
      } else {
        if (this.flowObj.opts.successStatuses.indexOf(this.xhr.status) > -1) {
          // HTTP 200, perfect
		      // HTTP 202 Accepted - The request has been accepted for processing, but the processing has not been completed.
          return 'success';
        } else if (this.flowObj.opts.permanentErrors.indexOf(this.xhr.status) > -1 ||
            !isTest && this.retries >= this.flowObj.opts.maxChunkRetries) {
          // HTTP 415/500/501, permanent error
          return 'error';
        } else {
          // this should never happen, but we'll reset and queue a retry
          // a likely case for this would be 503 service unavailable
          this.abort();
          return 'pending';
        }
      }
    },

    /**
     * Get response from xhr request
     * @function
     * @returns {String}
     */
    message: function () {
      return this.xhr ? this.xhr.responseText : '';
    },

    /**
     * Get upload progress
     * @function
     * @returns {number}
     */
    progress: function () {
      if (this.pendingRetry) {
        return 0;
      }
      var s = this.status();
      if (s === 'success' || s === 'error') {
        return 1;
      } else if (s === 'pending') {
        return 0;
      } else {
        return this.total > 0 ? this.loaded / this.total : 0;
      }
    },

    /**
     * Count total size uploaded
     * @function
     * @returns {number}
     */
    sizeUploaded: function () {
      var size = this.endByte - this.startByte;
      // can't return only chunk.loaded value, because it is bigger than chunk size
      if (this.status() !== 'success') {
        size = this.progress() * size;
      }
      return size;
    },

    /**
     * Prepare Xhr request. Set query, headers and data
     * @param {string} method GET or POST
     * @param {bool} isTest is this a test request
     * @param {string} [paramsMethod] octet or form
     * @param {Blob} [blob] to send
     * @returns {FormData|Blob|Null} data to send
     */
    prepareXhrRequest: function(method, isTest, paramsMethod, blob) {
      // Add data from the query options
      var query = evalOpts(this.flowObj.opts.query, this.fileObj, this, isTest);
      query = extend(query, this.getParams());

      var target = evalOpts(this.flowObj.opts.target, this.fileObj, this, isTest);
      var data = null;
      if (method === 'GET' || paramsMethod === 'octet') {
        // Add data from the query options
        var params = [];
        each(query, function (v, k) {
          params.push([encodeURIComponent(k), encodeURIComponent(v)].join('='));
        });
        target = this.getTarget(target, params);
        data = blob || null;
      } else {
        // Add data from the query options
        data = new FormData();
        each(query, function (v, k) {
          data.append(k, v);
        });
        data.append(this.flowObj.opts.fileParameterName, blob, this.fileObj.file.name);
      }

      this.xhr.open(method, target, true);
      this.xhr.withCredentials = this.flowObj.opts.withCredentials;

      // Add data from header options
      each(evalOpts(this.flowObj.opts.headers, this.fileObj, this, isTest), function (v, k) {
        this.xhr.setRequestHeader(k, v);
      }, this);

      return data;
    }
  };

  /**
   * Remove value from array
   * @param array
   * @param value
   */
  function arrayRemove(array, value) {
    var index = array.indexOf(value);
    if (index > -1) {
      array.splice(index, 1);
    }
  }

  /**
   * If option is a function, evaluate it with given params
   * @param {*} data
   * @param {...} args arguments of a callback
   * @returns {*}
   */
  function evalOpts(data, args) {
    if (typeof data === "function") {
      // `arguments` is an object, not array, in FF, so:
      args = Array.prototype.slice.call(arguments);
      data = data.apply(null, args.slice(1));
    }
    return data;
  }
  Flow.evalOpts = evalOpts;

  /**
   * Execute function asynchronously
   * @param fn
   * @param context
   */
  function async(fn, context) {
    setTimeout(fn.bind(context), 0);
  }

  /**
   * Extends the destination object `dst` by copying all of the properties from
   * the `src` object(s) to `dst`. You can specify multiple `src` objects.
   * @function
   * @param {Object} dst Destination object.
   * @param {...Object} src Source object(s).
   * @returns {Object} Reference to `dst`.
   */
  function extend(dst, src) {
    each(arguments, function(obj) {
      if (obj !== dst) {
        each(obj, function(value, key){
          dst[key] = value;
        });
      }
    });
    return dst;
  }
  Flow.extend = extend;

  /**
   * Iterate each element of an object
   * @function
   * @param {Array|Object} obj object or an array to iterate
   * @param {Function} callback first argument is a value and second is a key.
   * @param {Object=} context Object to become context (`this`) for the iterator function.
   */
  function each(obj, callback, context) {
    if (!obj) {
      return ;
    }
    var key;
    // Is Array?
    // Array.isArray won't work, not only arrays can be iterated by index https://github.com/flowjs/ng-flow/issues/236#
    if (typeof(obj.length) !== 'undefined') {
      for (key = 0; key < obj.length; key++) {
        if (callback.call(context, obj[key], key) === false) {
          return ;
        }
      }
    } else {
      for (key in obj) {
        if (obj.hasOwnProperty(key) && callback.call(context, obj[key], key) === false) {
          return ;
        }
      }
    }
  }
  Flow.each = each;

  /**
   * FlowFile constructor
   * @type {FlowFile}
   */
  Flow.FlowFile = FlowFile;

  /**
   * FlowFile constructor
   * @type {FlowChunk}
   */
  Flow.FlowChunk = FlowChunk;

  /**
   * Library version
   * @type {string}
   */
  Flow.version = '2.10.1';

  if ( typeof module === "object" && module && typeof module.exports === "object" ) {
    // Expose Flow as module.exports in loaders that implement the Node
    // module pattern (including browserify). Do not create the global, since
    // the user will be storing it themselves locally, and globals are frowned
    // upon in the Node module world.
    module.exports = Flow;
  } else {
    // Otherwise expose Flow to the global object as usual
    window.Flow = Flow;

    // Register as a named AMD module, since Flow can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase flow is used because AMD module names are
    // derived from file names, and Flow is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of Flow, it will work.
    if ( typeof define === "function" && define.amd ) {
      define( "flow", [], function () { return Flow; } );
    }
  }
})(window, document);

/**
 * @description
 * var app = angular.module('App', ['flow.provider'], function(flowFactoryProvider){
 *    flowFactoryProvider.defaults = {target: '/'};
 * });
 * @name flowFactoryProvider
 */
angular.module('flow.provider', [])
.provider('flowFactory', function() {
  'use strict';
  /**
   * Define the default properties for flow.js
   * @name flowFactoryProvider.defaults
   * @type {Object}
   */
  this.defaults = {};

  /**
   * Flow, MaybeFlow or NotFlow
   * @name flowFactoryProvider.factory
   * @type {function}
   * @return {Flow}
   */
  this.factory = function (options) {
    return new Flow(options);
  };

  /**
   * Define the default events
   * @name flowFactoryProvider.events
   * @type {Array}
   * @private
   */
  this.events = [];

  /**
   * Add default events
   * @name flowFactoryProvider.on
   * @function
   * @param {string} event
   * @param {Function} callback
   */
  this.on = function (event, callback) {
    this.events.push([event, callback]);
  };

  this.$get = function() {
    var fn = this.factory;
    var defaults = this.defaults;
    var events = this.events;
    return {
      'create': function(opts) {
        // combine default options with global options and options
        var flow = fn(angular.extend({}, defaults, opts));
        angular.forEach(events, function (event) {
          flow.on(event[0], event[1]);
        });
        return flow;
      }
    };
  };
});
angular.module('flow.init', ['flow.provider'])
  .controller('flowCtrl', ['$scope', '$attrs', '$parse', 'flowFactory',
  function ($scope, $attrs, $parse, flowFactory) {

    var options = angular.extend({}, $scope.$eval($attrs.flowInit));

    // use existing flow object or create a new one
    var flow  = $scope.$eval($attrs.flowObject) || flowFactory.create(options);

    var catchAllHandler = function(eventName){
      var args = Array.prototype.slice.call(arguments);
      args.shift();
      var event = $scope.$broadcast.apply($scope, ['flow::' + eventName, flow].concat(args));
      if ({
        'progress':1, 'filesSubmitted':1, 'fileSuccess': 1, 'fileError': 1, 'complete': 1
      }[eventName]) {
        $scope.$apply();
      }
      if (event.defaultPrevented) {
        return false;
      }
    };

    flow.on('catchAll', catchAllHandler);
    $scope.$on('$destroy', function(){
        flow.off('catchAll', catchAllHandler);
    });

    $scope.$flow = flow;

    if ($attrs.hasOwnProperty('flowName')) {
      $parse($attrs.flowName).assign($scope, flow);
      $scope.$on('$destroy', function () {
        $parse($attrs.flowName).assign($scope);
      });
    }
  }])
  .directive('flowInit', [function() {
    return {
      scope: true,
      controller: 'flowCtrl'
    };
  }]);
angular.module('flow.btn', ['flow.init'])
.directive('flowBtn', [function() {
  return {
    'restrict': 'EA',
    'scope': false,
    'require': '^flowInit',
    'link': function(scope, element, attrs) {
      var isDirectory = attrs.hasOwnProperty('flowDirectory');
      var isSingleFile = attrs.hasOwnProperty('flowSingleFile');
      var inputAttrs = attrs.hasOwnProperty('flowAttrs') && scope.$eval(attrs.flowAttrs);
      scope.$flow.assignBrowse(element, isDirectory, isSingleFile, inputAttrs);
    }
  };
}]);
angular.module('flow.dragEvents', ['flow.init'])
/**
 * @name flowPreventDrop
 * Prevent loading files then dropped on element
 */
  .directive('flowPreventDrop', function() {
    return {
      'scope': false,
      'link': function(scope, element, attrs) {
        element.bind('drop dragover', function (event) {
          event.preventDefault();
        });
      }
    };
  })
/**
 * @name flowDragEnter
 * executes `flowDragEnter` and `flowDragLeave` events
 */
  .directive('flowDragEnter', ['$timeout', function($timeout) {
    return {
      'scope': false,
      'link': function(scope, element, attrs) {
        var promise;
        var enter = false;
        element.bind('dragover', function (event) {
          if (!isFileDrag(event)) {
            return ;
          }
          if (!enter) {
            scope.$apply(attrs.flowDragEnter);
            enter = true;
          }
          $timeout.cancel(promise);
          event.preventDefault();
        });
        element.bind('dragleave drop', function (event) {
          $timeout.cancel(promise);
          promise = $timeout(function () {
            scope.$eval(attrs.flowDragLeave);
            promise = null;
            enter = false;
          }, 100);
        });
        function isFileDrag(dragEvent) {
          var fileDrag = false;
          var dataTransfer = dragEvent.dataTransfer || dragEvent.originalEvent.dataTransfer;
          angular.forEach(dataTransfer && dataTransfer.types, function(val) {
            if (val === 'Files') {
              fileDrag = true;
            }
          });
          return fileDrag;
        }
      }
    };
  }]);

angular.module('flow.drop', ['flow.init'])
.directive('flowDrop', function() {
  return {
    'scope': false,
    'require': '^flowInit',
    'link': function(scope, element, attrs) {
      if (attrs.flowDropEnabled) {
        scope.$watch(attrs.flowDropEnabled, function (value) {
          if (value) {
            assignDrop();
          } else {
            unAssignDrop();
          }
        });
      } else {
        assignDrop();
      }
      function assignDrop() {
        scope.$flow.assignDrop(element);
      }
      function unAssignDrop() {
        scope.$flow.unAssignDrop(element);
      }
    }
  };
});

!function (angular) {'use strict';
  var module = angular.module('flow.events', ['flow.init']);
  var events = {
    fileSuccess: ['$file', '$message'],
    fileProgress: ['$file'],
    fileAdded: ['$file', '$event'],
    filesAdded: ['$files', '$event'],
    filesSubmitted: ['$files', '$event'],
    fileRetry: ['$file'],
    fileError: ['$file', '$message'],
    uploadStart: [],
    complete: [],
    progress: [],
    error: ['$message', '$file']
  };

  angular.forEach(events, function (eventArgs, eventName) {
    var name = 'flow' + capitaliseFirstLetter(eventName);
    if (name == 'flowUploadStart') {
      name = 'flowUploadStarted';// event alias
    }
    module.directive(name, [function() {
      return {
        require: '^flowInit',
        controller: ['$scope', '$attrs', function ($scope, $attrs) {
          $scope.$on('flow::' + eventName, function () {
            var funcArgs = Array.prototype.slice.call(arguments);
            var event = funcArgs.shift();// remove angular event
            // remove flow object and ignore event if it is from parent directive
            if ($scope.$flow !== funcArgs.shift()) {
              return ;
            }
            var args = {};
            angular.forEach(eventArgs, function(value, key) {
              args[value] = funcArgs[key];
            });
            if ($scope.$eval($attrs[name], args) === false) {
              event.preventDefault();
            }
          });
        }]
      };
    }]);
  });

  function capitaliseFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
}(angular);
angular.module('flow.img', ['flow.init'])
.directive('flowImg', [function() {
  return {
    'scope': false,
    'require': '^flowInit',
    'link': function(scope, element, attrs) {
      var file = attrs.flowImg;
      scope.$watch(file, function (file) {
        if (!file) {
          return ;
        }
        var fileReader = new FileReader();
        fileReader.readAsDataURL(file.file);
        fileReader.onload = function (event) {
          scope.$apply(function () {
            attrs.$set('src', event.target.result);
          });
        };
      });
    }
  };
}]);
angular.module('flow.transfers', ['flow.init'])
.directive('flowTransfers', [function() {
  return {
    'scope': true,
    'require': '^flowInit',
    'link': function(scope) {
      scope.transfers = scope.$flow.files;
    }
  };
}]);
angular.module('flow', ['flow.provider', 'flow.init', 'flow.events', 'flow.btn',
  'flow.drop', 'flow.transfers', 'flow.img', 'flow.dragEvents']);;
/*! ngImgCrop v0.3.2 License: MIT */!function(){"use strict";var e=angular.module("ngImgCrop",[]);e.factory("cropAreaCircle",["cropArea",function(e){var t=function(){e.apply(this,arguments),this._boxResizeBaseSize=20,this._boxResizeNormalRatio=.9,this._boxResizeHoverRatio=1.2,this._iconMoveNormalRatio=.9,this._iconMoveHoverRatio=1.2,this._boxResizeNormalSize=this._boxResizeBaseSize*this._boxResizeNormalRatio,this._boxResizeHoverSize=this._boxResizeBaseSize*this._boxResizeHoverRatio,this._posDragStartX=0,this._posDragStartY=0,this._posResizeStartX=0,this._posResizeStartY=0,this._posResizeStartSize=0,this._boxResizeIsHover=!1,this._areaIsHover=!1,this._boxResizeIsDragging=!1,this._areaIsDragging=!1};return t.prototype=new e,t.prototype._calcCirclePerimeterCoords=function(e){var t=this._size/2,i=e*(Math.PI/180),r=this._x+t*Math.cos(i),s=this._y+t*Math.sin(i);return[r,s]},t.prototype._calcResizeIconCenterCoords=function(){return this._calcCirclePerimeterCoords(-45)},t.prototype._isCoordWithinArea=function(e){return Math.sqrt((e[0]-this._x)*(e[0]-this._x)+(e[1]-this._y)*(e[1]-this._y))<this._size/2},t.prototype._isCoordWithinBoxResize=function(e){var t=this._calcResizeIconCenterCoords(),i=this._boxResizeHoverSize/2;return e[0]>t[0]-i&&e[0]<t[0]+i&&e[1]>t[1]-i&&e[1]<t[1]+i},t.prototype._drawArea=function(e,t,i){e.arc(t[0],t[1],i/2,0,2*Math.PI)},t.prototype.draw=function(){e.prototype.draw.apply(this,arguments),this._cropCanvas.drawIconMove([this._x,this._y],this._areaIsHover?this._iconMoveHoverRatio:this._iconMoveNormalRatio),this._cropCanvas.drawIconResizeBoxNESW(this._calcResizeIconCenterCoords(),this._boxResizeBaseSize,this._boxResizeIsHover?this._boxResizeHoverRatio:this._boxResizeNormalRatio)},t.prototype.processMouseMove=function(e,t){var i="default",r=!1;if(this._boxResizeIsHover=!1,this._areaIsHover=!1,this._areaIsDragging)this._x=e-this._posDragStartX,this._y=t-this._posDragStartY,this._areaIsHover=!0,i="move",r=!0,this._events.trigger("area-move");else if(this._boxResizeIsDragging){i="nesw-resize";var s,o,a;o=e-this._posResizeStartX,a=this._posResizeStartY-t,s=o>a?this._posResizeStartSize+2*a:this._posResizeStartSize+2*o,this._size=Math.max(this._minSize,s),this._boxResizeIsHover=!0,r=!0,this._events.trigger("area-resize")}else this._isCoordWithinBoxResize([e,t])?(i="nesw-resize",this._areaIsHover=!1,this._boxResizeIsHover=!0,r=!0):this._isCoordWithinArea([e,t])&&(i="move",this._areaIsHover=!0,r=!0);return this._dontDragOutside(),angular.element(this._ctx.canvas).css({cursor:i}),r},t.prototype.processMouseDown=function(e,t){this._isCoordWithinBoxResize([e,t])?(this._areaIsDragging=!1,this._areaIsHover=!1,this._boxResizeIsDragging=!0,this._boxResizeIsHover=!0,this._posResizeStartX=e,this._posResizeStartY=t,this._posResizeStartSize=this._size,this._events.trigger("area-resize-start")):this._isCoordWithinArea([e,t])&&(this._areaIsDragging=!0,this._areaIsHover=!0,this._boxResizeIsDragging=!1,this._boxResizeIsHover=!1,this._posDragStartX=e-this._x,this._posDragStartY=t-this._y,this._events.trigger("area-move-start"))},t.prototype.processMouseUp=function(){this._areaIsDragging&&(this._areaIsDragging=!1,this._events.trigger("area-move-end")),this._boxResizeIsDragging&&(this._boxResizeIsDragging=!1,this._events.trigger("area-resize-end")),this._areaIsHover=!1,this._boxResizeIsHover=!1,this._posDragStartX=0,this._posDragStartY=0},t}]),e.factory("cropAreaSquare",["cropArea",function(e){var t=function(){e.apply(this,arguments),this._resizeCtrlBaseRadius=10,this._resizeCtrlNormalRatio=.75,this._resizeCtrlHoverRatio=1,this._iconMoveNormalRatio=.9,this._iconMoveHoverRatio=1.2,this._resizeCtrlNormalRadius=this._resizeCtrlBaseRadius*this._resizeCtrlNormalRatio,this._resizeCtrlHoverRadius=this._resizeCtrlBaseRadius*this._resizeCtrlHoverRatio,this._posDragStartX=0,this._posDragStartY=0,this._posResizeStartX=0,this._posResizeStartY=0,this._posResizeStartSize=0,this._resizeCtrlIsHover=-1,this._areaIsHover=!1,this._resizeCtrlIsDragging=-1,this._areaIsDragging=!1};return t.prototype=new e,t.prototype._calcSquareCorners=function(){var e=this._size/2;return[[this._x-e,this._y-e],[this._x+e,this._y-e],[this._x-e,this._y+e],[this._x+e,this._y+e]]},t.prototype._calcSquareDimensions=function(){var e=this._size/2;return{left:this._x-e,top:this._y-e,right:this._x+e,bottom:this._y+e}},t.prototype._isCoordWithinArea=function(e){var t=this._calcSquareDimensions();return e[0]>=t.left&&e[0]<=t.right&&e[1]>=t.top&&e[1]<=t.bottom},t.prototype._isCoordWithinResizeCtrl=function(e){for(var t=this._calcSquareCorners(),i=-1,r=0,s=t.length;s>r;r++){var o=t[r];if(e[0]>o[0]-this._resizeCtrlHoverRadius&&e[0]<o[0]+this._resizeCtrlHoverRadius&&e[1]>o[1]-this._resizeCtrlHoverRadius&&e[1]<o[1]+this._resizeCtrlHoverRadius){i=r;break}}return i},t.prototype._drawArea=function(e,t,i){var r=i/2;e.rect(t[0]-r,t[1]-r,i,i)},t.prototype.draw=function(){e.prototype.draw.apply(this,arguments),this._cropCanvas.drawIconMove([this._x,this._y],this._areaIsHover?this._iconMoveHoverRatio:this._iconMoveNormalRatio);for(var t=this._calcSquareCorners(),i=0,r=t.length;r>i;i++){var s=t[i];this._cropCanvas.drawIconResizeCircle(s,this._resizeCtrlBaseRadius,this._resizeCtrlIsHover===i?this._resizeCtrlHoverRatio:this._resizeCtrlNormalRatio)}},t.prototype.processMouseMove=function(e,t){var i="default",r=!1;if(this._resizeCtrlIsHover=-1,this._areaIsHover=!1,this._areaIsDragging)this._x=e-this._posDragStartX,this._y=t-this._posDragStartY,this._areaIsHover=!0,i="move",r=!0,this._events.trigger("area-move");else if(this._resizeCtrlIsDragging>-1){var s,o;switch(this._resizeCtrlIsDragging){case 0:s=-1,o=-1,i="nwse-resize";break;case 1:s=1,o=-1,i="nesw-resize";break;case 2:s=-1,o=1,i="nesw-resize";break;case 3:s=1,o=1,i="nwse-resize"}var a,n=(e-this._posResizeStartX)*s,h=(t-this._posResizeStartY)*o;a=n>h?this._posResizeStartSize+h:this._posResizeStartSize+n;var c=this._size;this._size=Math.max(this._minSize,a);var l=(this._size-c)/2;this._x+=l*s,this._y+=l*o,this._resizeCtrlIsHover=this._resizeCtrlIsDragging,r=!0,this._events.trigger("area-resize")}else{var u=this._isCoordWithinResizeCtrl([e,t]);if(u>-1){switch(u){case 0:i="nwse-resize";break;case 1:i="nesw-resize";break;case 2:i="nesw-resize";break;case 3:i="nwse-resize"}this._areaIsHover=!1,this._resizeCtrlIsHover=u,r=!0}else this._isCoordWithinArea([e,t])&&(i="move",this._areaIsHover=!0,r=!0)}return this._dontDragOutside(),angular.element(this._ctx.canvas).css({cursor:i}),r},t.prototype.processMouseDown=function(e,t){var i=this._isCoordWithinResizeCtrl([e,t]);i>-1?(this._areaIsDragging=!1,this._areaIsHover=!1,this._resizeCtrlIsDragging=i,this._resizeCtrlIsHover=i,this._posResizeStartX=e,this._posResizeStartY=t,this._posResizeStartSize=this._size,this._events.trigger("area-resize-start")):this._isCoordWithinArea([e,t])&&(this._areaIsDragging=!0,this._areaIsHover=!0,this._resizeCtrlIsDragging=-1,this._resizeCtrlIsHover=-1,this._posDragStartX=e-this._x,this._posDragStartY=t-this._y,this._events.trigger("area-move-start"))},t.prototype.processMouseUp=function(){this._areaIsDragging&&(this._areaIsDragging=!1,this._events.trigger("area-move-end")),this._resizeCtrlIsDragging>-1&&(this._resizeCtrlIsDragging=-1,this._events.trigger("area-resize-end")),this._areaIsHover=!1,this._resizeCtrlIsHover=-1,this._posDragStartX=0,this._posDragStartY=0},t}]),e.factory("cropArea",["cropCanvas",function(e){var t=function(t,i){this._ctx=t,this._events=i,this._minSize=80,this._cropCanvas=new e(t),this._image=new Image,this._x=0,this._y=0,this._size=200};return t.prototype.getImage=function(){return this._image},t.prototype.setImage=function(e){this._image=e},t.prototype.getX=function(){return this._x},t.prototype.setX=function(e){this._x=e,this._dontDragOutside()},t.prototype.getY=function(){return this._y},t.prototype.setY=function(e){this._y=e,this._dontDragOutside()},t.prototype.getSize=function(){return this._size},t.prototype.setSize=function(e){this._size=Math.max(this._minSize,e),this._dontDragOutside()},t.prototype.getMinSize=function(){return this._minSize},t.prototype.setMinSize=function(e){this._minSize=e,this._size=Math.max(this._minSize,this._size),this._dontDragOutside()},t.prototype._dontDragOutside=function(){var e=this._ctx.canvas.height,t=this._ctx.canvas.width;this._size>t&&(this._size=t),this._size>e&&(this._size=e),this._x<this._size/2&&(this._x=this._size/2),this._x>t-this._size/2&&(this._x=t-this._size/2),this._y<this._size/2&&(this._y=this._size/2),this._y>e-this._size/2&&(this._y=e-this._size/2)},t.prototype._drawArea=function(){},t.prototype.draw=function(){this._cropCanvas.drawCropArea(this._image,[this._x,this._y],this._size,this._drawArea)},t.prototype.processMouseMove=function(){},t.prototype.processMouseDown=function(){},t.prototype.processMouseUp=function(){},t}]),e.factory("cropCanvas",[function(){var e=[[-.5,-2],[-3,-4.5],[-.5,-7],[-7,-7],[-7,-.5],[-4.5,-3],[-2,-.5]],t=[[.5,-2],[3,-4.5],[.5,-7],[7,-7],[7,-.5],[4.5,-3],[2,-.5]],i=[[-.5,2],[-3,4.5],[-.5,7],[-7,7],[-7,.5],[-4.5,3],[-2,.5]],r=[[.5,2],[3,4.5],[.5,7],[7,7],[7,.5],[4.5,3],[2,.5]],s=[[-1.5,-2.5],[-1.5,-6],[-5,-6],[0,-11],[5,-6],[1.5,-6],[1.5,-2.5]],o=[[-2.5,-1.5],[-6,-1.5],[-6,-5],[-11,0],[-6,5],[-6,1.5],[-2.5,1.5]],a=[[-1.5,2.5],[-1.5,6],[-5,6],[0,11],[5,6],[1.5,6],[1.5,2.5]],n=[[2.5,-1.5],[6,-1.5],[6,-5],[11,0],[6,5],[6,1.5],[2.5,1.5]],h={areaOutline:"#fff",resizeBoxStroke:"#fff",resizeBoxFill:"#444",resizeBoxArrowFill:"#fff",resizeCircleStroke:"#fff",resizeCircleFill:"#444",moveIconFill:"#fff"};return function(c){var l=function(e,t,i){return[i*e[0]+t[0],i*e[1]+t[1]]},u=function(e,t,i,r){c.save(),c.fillStyle=t,c.beginPath();var s,o=l(e[0],i,r);c.moveTo(o[0],o[1]);for(var a in e)a>0&&(s=l(e[a],i,r),c.lineTo(s[0],s[1]));c.lineTo(o[0],o[1]),c.fill(),c.closePath(),c.restore()};this.drawIconMove=function(e,t){u(s,h.moveIconFill,e,t),u(o,h.moveIconFill,e,t),u(a,h.moveIconFill,e,t),u(n,h.moveIconFill,e,t)},this.drawIconResizeCircle=function(e,t,i){var r=t*i;c.save(),c.strokeStyle=h.resizeCircleStroke,c.lineWidth=2,c.fillStyle=h.resizeCircleFill,c.beginPath(),c.arc(e[0],e[1],r,0,2*Math.PI),c.fill(),c.stroke(),c.closePath(),c.restore()},this.drawIconResizeBoxBase=function(e,t,i){var r=t*i;c.save(),c.strokeStyle=h.resizeBoxStroke,c.lineWidth=2,c.fillStyle=h.resizeBoxFill,c.fillRect(e[0]-r/2,e[1]-r/2,r,r),c.strokeRect(e[0]-r/2,e[1]-r/2,r,r),c.restore()},this.drawIconResizeBoxNESW=function(e,r,s){this.drawIconResizeBoxBase(e,r,s),u(t,h.resizeBoxArrowFill,e,s),u(i,h.resizeBoxArrowFill,e,s)},this.drawIconResizeBoxNWSE=function(t,i,s){this.drawIconResizeBoxBase(t,i,s),u(e,h.resizeBoxArrowFill,t,s),u(r,h.resizeBoxArrowFill,t,s)},this.drawCropArea=function(e,t,i,r){var s=e.width/c.canvas.width,o=e.height/c.canvas.height,a=t[0]-i/2,n=t[1]-i/2;c.save(),c.strokeStyle=h.areaOutline,c.lineWidth=2,c.beginPath(),r(c,t,i),c.stroke(),c.clip(),i>0&&c.drawImage(e,a*s,n*o,i*s,i*o,a,n,i,i),c.beginPath(),r(c,t,i),c.stroke(),c.clip(),c.restore()}}}]),e.service("cropEXIF",[function(){function e(e){return!!e.exifdata}function t(e,t){t=t||e.match(/^data\:([^\;]+)\;base64,/im)[1]||"",e=e.replace(/^data\:([^\;]+)\;base64,/gim,"");for(var i=atob(e),r=i.length,s=new ArrayBuffer(r),o=new Uint8Array(s),a=0;r>a;a++)o[a]=i.charCodeAt(a);return s}function i(e,t){var i=new XMLHttpRequest;i.open("GET",e,!0),i.responseType="blob",i.onload=function(){(200==this.status||0===this.status)&&t(this.response)},i.send()}function r(e,r){function a(t){var i=s(t),a=o(t);e.exifdata=i||{},e.iptcdata=a||{},r&&r.call(e)}if(e.src)if(/^data\:/i.test(e.src)){var n=t(e.src);a(n)}else if(/^blob\:/i.test(e.src)){var h=new FileReader;h.onload=function(e){a(e.target.result)},i(e.src,function(e){h.readAsArrayBuffer(e)})}else{var c=new XMLHttpRequest;c.onload=function(){if(200!=this.status&&0!==this.status)throw"Could not load image";a(c.response),c=null},c.open("GET",e.src,!0),c.responseType="arraybuffer",c.send(null)}else if(window.FileReader&&(e instanceof window.Blob||e instanceof window.File)){var h=new FileReader;h.onload=function(e){u&&console.log("Got file of length "+e.target.result.byteLength),a(e.target.result)},h.readAsArrayBuffer(e)}}function s(e){var t=new DataView(e);if(u&&console.log("Got file of length "+e.byteLength),255!=t.getUint8(0)||216!=t.getUint8(1))return u&&console.log("Not a valid JPEG"),!1;for(var i,r=2,s=e.byteLength;s>r;){if(255!=t.getUint8(r))return u&&console.log("Not a valid marker at offset "+r+", found: "+t.getUint8(r)),!1;if(i=t.getUint8(r+1),u&&console.log(i),225==i)return u&&console.log("Found 0xFFE1 marker"),l(t,r+4,t.getUint16(r+2)-2);r+=2+t.getUint16(r+2)}}function o(e){var t=new DataView(e);if(u&&console.log("Got file of length "+e.byteLength),255!=t.getUint8(0)||216!=t.getUint8(1))return u&&console.log("Not a valid JPEG"),!1;for(var i=2,r=e.byteLength,s=function(e,t){return 56===e.getUint8(t)&&66===e.getUint8(t+1)&&73===e.getUint8(t+2)&&77===e.getUint8(t+3)&&4===e.getUint8(t+4)&&4===e.getUint8(t+5)};r>i;){if(s(t,i)){var o=t.getUint8(i+7);o%2!==0&&(o+=1),0===o&&(o=4);var n=i+8+o,h=t.getUint16(i+6+o);return a(e,n,h)}i++}}function a(e,t,i){for(var r,s,o,a,n,h=new DataView(e),l={},u=t;t+i>u;)28===h.getUint8(u)&&2===h.getUint8(u+1)&&(a=h.getUint8(u+2),a in _&&(o=h.getInt16(u+3),n=o+5,s=_[a],r=c(h,u+5,o),l.hasOwnProperty(s)?l[s]instanceof Array?l[s].push(r):l[s]=[l[s],r]:l[s]=r)),u++;return l}function n(e,t,i,r,s){var o,a,n,c=e.getUint16(i,!s),l={};for(n=0;c>n;n++)o=i+12*n+2,a=r[e.getUint16(o,!s)],!a&&u&&console.log("Unknown tag: "+e.getUint16(o,!s)),l[a]=h(e,o,t,i,s);return l}function h(e,t,i,r,s){var o,a,n,h,l,u,g=e.getUint16(t+2,!s),d=e.getUint32(t+4,!s),f=e.getUint32(t+8,!s)+i;switch(g){case 1:case 7:if(1==d)return e.getUint8(t+8,!s);for(o=d>4?f:t+8,a=[],h=0;d>h;h++)a[h]=e.getUint8(o+h);return a;case 2:return o=d>4?f:t+8,c(e,o,d-1);case 3:if(1==d)return e.getUint16(t+8,!s);for(o=d>2?f:t+8,a=[],h=0;d>h;h++)a[h]=e.getUint16(o+2*h,!s);return a;case 4:if(1==d)return e.getUint32(t+8,!s);for(a=[],h=0;d>h;h++)a[h]=e.getUint32(f+4*h,!s);return a;case 5:if(1==d)return l=e.getUint32(f,!s),u=e.getUint32(f+4,!s),n=new Number(l/u),n.numerator=l,n.denominator=u,n;for(a=[],h=0;d>h;h++)l=e.getUint32(f+8*h,!s),u=e.getUint32(f+4+8*h,!s),a[h]=new Number(l/u),a[h].numerator=l,a[h].denominator=u;return a;case 9:if(1==d)return e.getInt32(t+8,!s);for(a=[],h=0;d>h;h++)a[h]=e.getInt32(f+4*h,!s);return a;case 10:if(1==d)return e.getInt32(f,!s)/e.getInt32(f+4,!s);for(a=[],h=0;d>h;h++)a[h]=e.getInt32(f+8*h,!s)/e.getInt32(f+4+8*h,!s);return a}}function c(e,t,i){for(var r="",s=t;t+i>s;s++)r+=String.fromCharCode(e.getUint8(s));return r}function l(e,t){if("Exif"!=c(e,t,4))return u&&console.log("Not valid EXIF data! "+c(e,t,4)),!1;var i,r,s,o,a,h=t+6;if(18761==e.getUint16(h))i=!1;else{if(19789!=e.getUint16(h))return u&&console.log("Not valid TIFF data! (no 0x4949 or 0x4D4D)"),!1;i=!0}if(42!=e.getUint16(h+2,!i))return u&&console.log("Not valid TIFF data! (no 0x002A)"),!1;var l=e.getUint32(h+4,!i);if(8>l)return u&&console.log("Not valid TIFF data! (First offset less than 8)",e.getUint32(h+4,!i)),!1;if(r=n(e,h,h+l,d,i),r.ExifIFDPointer){o=n(e,h,h+r.ExifIFDPointer,g,i);for(s in o){switch(s){case"LightSource":case"Flash":case"MeteringMode":case"ExposureProgram":case"SensingMethod":case"SceneCaptureType":case"SceneType":case"CustomRendered":case"WhiteBalance":case"GainControl":case"Contrast":case"Saturation":case"Sharpness":case"SubjectDistanceRange":case"FileSource":o[s]=p[s][o[s]];break;case"ExifVersion":case"FlashpixVersion":o[s]=String.fromCharCode(o[s][0],o[s][1],o[s][2],o[s][3]);break;case"ComponentsConfiguration":o[s]=p.Components[o[s][0]]+p.Components[o[s][1]]+p.Components[o[s][2]]+p.Components[o[s][3]]}r[s]=o[s]}}if(r.GPSInfoIFDPointer){a=n(e,h,h+r.GPSInfoIFDPointer,f,i);for(s in a){switch(s){case"GPSVersionID":a[s]=a[s][0]+"."+a[s][1]+"."+a[s][2]+"."+a[s][3]}r[s]=a[s]}}return r}var u=!1,g=this.Tags={36864:"ExifVersion",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37500:"MakerNote",37510:"UserComment",40964:"RelatedSoundFile",36867:"DateTimeOriginal",36868:"DateTimeDigitized",37520:"SubsecTime",37521:"SubsecTimeOriginal",37522:"SubsecTimeDigitized",33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"ISOSpeedRatings",34856:"OECF",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBias",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37396:"SubjectArea",37386:"FocalLength",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRation",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",40965:"InteroperabilityIFDPointer",42016:"ImageUniqueID"},d=this.TiffTags={256:"ImageWidth",257:"ImageHeight",34665:"ExifIFDPointer",34853:"GPSInfoIFDPointer",40965:"InteroperabilityIFDPointer",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",274:"Orientation",277:"SamplesPerPixel",284:"PlanarConfiguration",530:"YCbCrSubSampling",531:"YCbCrPositioning",282:"XResolution",283:"YResolution",296:"ResolutionUnit",273:"StripOffsets",278:"RowsPerStrip",279:"StripByteCounts",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",301:"TransferFunction",318:"WhitePoint",319:"PrimaryChromaticities",529:"YCbCrCoefficients",532:"ReferenceBlackWhite",306:"DateTime",270:"ImageDescription",271:"Make",272:"Model",305:"Software",315:"Artist",33432:"Copyright"},f=this.GPSTags={0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential"},p=this.StringValues={ExposureProgram:{0:"Not defined",1:"Manual",2:"Normal program",3:"Aperture priority",4:"Shutter priority",5:"Creative program",6:"Action program",7:"Portrait mode",8:"Landscape mode"},MeteringMode:{0:"Unknown",1:"Average",2:"CenterWeightedAverage",3:"Spot",4:"MultiSpot",5:"Pattern",6:"Partial",255:"Other"},LightSource:{0:"Unknown",1:"Daylight",2:"Fluorescent",3:"Tungsten (incandescent light)",4:"Flash",9:"Fine weather",10:"Cloudy weather",11:"Shade",12:"Daylight fluorescent (D 5700 - 7100K)",13:"Day white fluorescent (N 4600 - 5400K)",14:"Cool white fluorescent (W 3900 - 4500K)",15:"White fluorescent (WW 3200 - 3700K)",17:"Standard light A",18:"Standard light B",19:"Standard light C",20:"D55",21:"D65",22:"D75",23:"D50",24:"ISO studio tungsten",255:"Other"},Flash:{0:"Flash did not fire",1:"Flash fired",5:"Strobe return light not detected",7:"Strobe return light detected",9:"Flash fired, compulsory flash mode",13:"Flash fired, compulsory flash mode, return light not detected",15:"Flash fired, compulsory flash mode, return light detected",16:"Flash did not fire, compulsory flash mode",24:"Flash did not fire, auto mode",25:"Flash fired, auto mode",29:"Flash fired, auto mode, return light not detected",31:"Flash fired, auto mode, return light detected",32:"No flash function",65:"Flash fired, red-eye reduction mode",69:"Flash fired, red-eye reduction mode, return light not detected",71:"Flash fired, red-eye reduction mode, return light detected",73:"Flash fired, compulsory flash mode, red-eye reduction mode",77:"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",79:"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",89:"Flash fired, auto mode, red-eye reduction mode",93:"Flash fired, auto mode, return light not detected, red-eye reduction mode",95:"Flash fired, auto mode, return light detected, red-eye reduction mode"},SensingMethod:{1:"Not defined",2:"One-chip color area sensor",3:"Two-chip color area sensor",4:"Three-chip color area sensor",5:"Color sequential area sensor",7:"Trilinear sensor",8:"Color sequential linear sensor"},SceneCaptureType:{0:"Standard",1:"Landscape",2:"Portrait",3:"Night scene"},SceneType:{1:"Directly photographed"},CustomRendered:{0:"Normal process",1:"Custom process"},WhiteBalance:{0:"Auto white balance",1:"Manual white balance"},GainControl:{0:"None",1:"Low gain up",2:"High gain up",3:"Low gain down",4:"High gain down"},Contrast:{0:"Normal",1:"Soft",2:"Hard"},Saturation:{0:"Normal",1:"Low saturation",2:"High saturation"},Sharpness:{0:"Normal",1:"Soft",2:"Hard"},SubjectDistanceRange:{0:"Unknown",1:"Macro",2:"Close view",3:"Distant view"},FileSource:{3:"DSC"},Components:{0:"",1:"Y",2:"Cb",3:"Cr",4:"R",5:"G",6:"B"}},_={120:"caption",110:"credit",25:"keywords",55:"dateCreated",80:"byline",85:"bylineTitle",122:"captionWriter",105:"headline",116:"copyright",15:"category"};this.getData=function(t,i){return(t instanceof Image||t instanceof HTMLImageElement)&&!t.complete?!1:(e(t)?i&&i.call(t):r(t,i),!0)},this.getTag=function(t,i){return e(t)?t.exifdata[i]:void 0},this.getAllTags=function(t){if(!e(t))return{};var i,r=t.exifdata,s={};for(i in r)r.hasOwnProperty(i)&&(s[i]=r[i]);return s},this.pretty=function(t){if(!e(t))return"";var i,r=t.exifdata,s="";for(i in r)r.hasOwnProperty(i)&&(s+="object"==typeof r[i]?r[i]instanceof Number?i+" : "+r[i]+" ["+r[i].numerator+"/"+r[i].denominator+"]\r\n":i+" : ["+r[i].length+" values]\r\n":i+" : "+r[i]+"\r\n");return s},this.readFromBinaryFile=function(e){return s(e)}}]),e.factory("cropHost",["$document","cropAreaCircle","cropAreaSquare","cropEXIF",function(e,t,i,r){var s=function(e){var t=e.getBoundingClientRect(),i=document.body,r=document.documentElement,s=window.pageYOffset||r.scrollTop||i.scrollTop,o=window.pageXOffset||r.scrollLeft||i.scrollLeft,a=r.clientTop||i.clientTop||0,n=r.clientLeft||i.clientLeft||0,h=t.top+s-a,c=t.left+o-n;return{top:Math.round(h),left:Math.round(c)}};return function(o,a,n){function h(){c.clearRect(0,0,c.canvas.width,c.canvas.height),null!==l&&(c.drawImage(l,0,0,c.canvas.width,c.canvas.height),c.save(),c.fillStyle="rgba(0, 0, 0, 0.65)",c.fillRect(0,0,c.canvas.width,c.canvas.height),c.restore(),u.draw())}var c=null,l=null,u=null,g=[100,100],d=[300,300],f=200,p="image/png",_=null,m=function(){if(null!==l){u.setImage(l);var e=[l.width,l.height],t=l.width/l.height,i=e;i[0]>d[0]?(i[0]=d[0],i[1]=i[0]/t):i[0]<g[0]&&(i[0]=g[0],i[1]=i[0]/t),i[1]>d[1]?(i[1]=d[1],i[0]=i[1]*t):i[1]<g[1]&&(i[1]=g[1],i[0]=i[1]*t),o.prop("width",i[0]).prop("height",i[1]).css({"margin-left":-i[0]/2+"px","margin-top":-i[1]/2+"px"}),u.setX(c.canvas.width/2),u.setY(c.canvas.height/2),u.setSize(Math.min(200,c.canvas.width/2,c.canvas.height/2))}else o.prop("width",0).prop("height",0).css({"margin-top":0});h()},v=function(e){return angular.isDefined(e.changedTouches)?e.changedTouches:e.originalEvent.changedTouches},S=function(e){if(null!==l){var t,i,r=s(c.canvas);"touchmove"===e.type?(t=v(e)[0].pageX,i=v(e)[0].pageY):(t=e.pageX,i=e.pageY),u.processMouseMove(t-r.left,i-r.top),h()}},z=function(e){if(e.preventDefault(),e.stopPropagation(),null!==l){var t,i,r=s(c.canvas);"touchstart"===e.type?(t=v(e)[0].pageX,i=v(e)[0].pageY):(t=e.pageX,i=e.pageY),u.processMouseDown(t-r.left,i-r.top),h()}},I=function(e){if(null!==l){var t,i,r=s(c.canvas);"touchend"===e.type?(t=v(e)[0].pageX,i=v(e)[0].pageY):(t=e.pageX,i=e.pageY),u.processMouseUp(t-r.left,i-r.top),h()}};this.getResultImageDataURI=function(){var e,t;return t=angular.element("<canvas></canvas>")[0],e=t.getContext("2d"),t.width=f,t.height=f,null!==l&&e.drawImage(l,(u.getX()-u.getSize()/2)*(l.width/c.canvas.width),(u.getY()-u.getSize()/2)*(l.height/c.canvas.height),u.getSize()*(l.width/c.canvas.width),u.getSize()*(l.height/c.canvas.height),0,0,f,f),null!==_?t.toDataURL(p,_):t.toDataURL(p)},this.setNewImageSource=function(e){if(l=null,m(),n.trigger("image-updated"),e){var t=new Image;"http"===e.substring(0,4).toLowerCase()&&(t.crossOrigin="anonymous"),t.onload=function(){n.trigger("load-done"),r.getData(t,function(){var e=r.getTag(t,"Orientation");if([3,6,8].indexOf(e)>-1){var i=document.createElement("canvas"),s=i.getContext("2d"),o=t.width,a=t.height,h=0,c=0,u=0;switch(e){case 3:h=-t.width,c=-t.height,u=180;break;case 6:o=t.height,a=t.width,c=-t.height,u=90;break;case 8:o=t.height,a=t.width,h=-t.width,u=270}i.width=o,i.height=a,s.rotate(u*Math.PI/180),s.drawImage(t,h,c),l=new Image,l.src=i.toDataURL("image/png")}else l=t;m(),n.trigger("image-updated")})},t.onerror=function(){n.trigger("load-error")},n.trigger("load-start"),t.src=e}},this.setMaxDimensions=function(e,t){if(d=[e,t],null!==l){var i=c.canvas.width,r=c.canvas.height,s=[l.width,l.height],a=l.width/l.height,n=s;n[0]>d[0]?(n[0]=d[0],n[1]=n[0]/a):n[0]<g[0]&&(n[0]=g[0],n[1]=n[0]/a),n[1]>d[1]?(n[1]=d[1],n[0]=n[1]*a):n[1]<g[1]&&(n[1]=g[1],n[0]=n[1]*a),o.prop("width",n[0]).prop("height",n[1]).css({"margin-left":-n[0]/2+"px","margin-top":-n[1]/2+"px"});var f=c.canvas.width/i,p=c.canvas.height/r,_=Math.min(f,p);u.setX(u.getX()*f),u.setY(u.getY()*p),u.setSize(u.getSize()*_)}else o.prop("width",0).prop("height",0).css({"margin-top":0});h()},this.setAreaMinSize=function(e){e=parseInt(e,10),isNaN(e)||(u.setMinSize(e),h())},this.setResultImageSize=function(e){e=parseInt(e,10),isNaN(e)||(f=e)},this.setResultImageFormat=function(e){p=e},this.setResultImageQuality=function(e){e=parseFloat(e),!isNaN(e)&&e>=0&&1>=e&&(_=e)},this.setAreaType=function(e){var r=u.getSize(),s=u.getMinSize(),o=u.getX(),a=u.getY(),g=t;"square"===e&&(g=i),u=new g(c,n),u.setMinSize(s),u.setSize(r),u.setX(o),u.setY(a),null!==l&&u.setImage(l),h()},c=o[0].getContext("2d"),u=new t(c,n),e.on("mousemove",S),o.on("mousedown",z),e.on("mouseup",I),e.on("touchmove",S),o.on("touchstart",z),e.on("touchend",I),this.destroy=function(){e.off("mousemove",S),o.off("mousedown",z),e.off("mouseup",S),e.off("touchmove",S),o.off("touchstart",z),e.off("touchend",S),o.remove()}}}]),e.factory("cropPubSub",[function(){return function(){var e={};this.on=function(t,i){return t.split(" ").forEach(function(t){e[t]||(e[t]=[]),e[t].push(i)}),this},this.trigger=function(t,i){return angular.forEach(e[t],function(e){e.call(null,i)}),this}}}]),e.directive("imgCrop",["$timeout","cropHost","cropPubSub",function(e,t,i){return{restrict:"E",scope:{image:"=",resultImage:"=",changeOnFly:"=",areaType:"@",areaMinSize:"=",resultImageSize:"=",resultImageFormat:"@",resultImageQuality:"=",onChange:"&",onLoadBegin:"&",onLoadDone:"&",onLoadError:"&"},template:"<canvas></canvas>",controller:["$scope",function(e){e.events=new i}],link:function(i,r){var s,o=i.events,a=new t(r.find("canvas"),{},o),n=function(e){var t=a.getResultImageDataURI();s!==t&&(s=t,angular.isDefined(e.resultImage)&&(e.resultImage=t),e.onChange({$dataURI:e.resultImage}))},h=function(t){return function(){e(function(){i.$apply(function(e){t(e)})})}};o.on("load-start",h(function(e){e.onLoadBegin({})})).on("load-done",h(function(e){e.onLoadDone({})})).on("load-error",h(function(e){e.onLoadError({})})).on("area-move area-resize",h(function(e){e.changeOnFly&&n(e)})).on("area-move-end area-resize-end image-updated",h(function(e){n(e)})),i.$watch("image",function(){a.setNewImageSource(i.image)}),i.$watch("areaType",function(){a.setAreaType(i.areaType),n(i)}),i.$watch("areaMinSize",function(){a.setAreaMinSize(i.areaMinSize),n(i)}),i.$watch("resultImageSize",function(){a.setResultImageSize(i.resultImageSize),n(i)}),i.$watch("resultImageFormat",function(){a.setResultImageFormat(i.resultImageFormat),n(i)}),i.$watch("resultImageQuality",function(){a.setResultImageQuality(i.resultImageQuality),n(i)}),i.$watch(function(){return[r[0].clientWidth,r[0].clientHeight]},function(e){a.setMaxDimensions(e[0],e[1]),n(i)},!0),i.$on("$destroy",function(){a.destroy()})}}}])}();;
/*! ngImgCropExtended v0.6.2 License: MIT */!function(){var e=angular.module("ngImgCrop",[]);e.factory("cropAreaCircle",["cropArea",function(e){var t=function(){e.apply(this,arguments),this._boxResizeBaseSize=25,this._boxResizeNormalRatio=1,this._boxResizeHoverRatio=1.2,this._iconMoveNormalRatio=.9,this._iconMoveHoverRatio=1.2,this._boxResizeNormalSize=this._boxResizeBaseSize*this._boxResizeNormalRatio,this._boxResizeHoverSize=this._boxResizeBaseSize*this._boxResizeHoverRatio,this._posDragStartX=0,this._posDragStartY=0,this._posResizeStartX=0,this._posResizeStartY=0,this._posResizeStartSize=0,this._boxResizeIsHover=!1,this._areaIsHover=!1,this._boxResizeIsDragging=!1,this._areaIsDragging=!1};return t.prototype=new e,t.prototype.getType=function(){return"circle"},t.prototype._calcCirclePerimeterCoords=function(e){var t=this._size.w/2,i=e*(Math.PI/180),r=this.getCenterPoint().x+t*Math.cos(i),n=this.getCenterPoint().y+t*Math.sin(i);return[r,n]},t.prototype._calcResizeIconCenterCoords=function(){return this._calcCirclePerimeterCoords(-45)},t.prototype._isCoordWithinArea=function(e){return Math.sqrt((e[0]-this.getCenterPoint().x)*(e[0]-this.getCenterPoint().x)+(e[1]-this.getCenterPoint().y)*(e[1]-this.getCenterPoint().y))<this._size.w/2},t.prototype._isCoordWithinBoxResize=function(e){var t=this._calcResizeIconCenterCoords(),i=this._boxResizeHoverSize/2;return e[0]>t[0]-i&&e[0]<t[0]+i&&e[1]>t[1]-i&&e[1]<t[1]+i},t.prototype._drawArea=function(e,t,i){e.arc(t.x,t.y,i.w/2,0,2*Math.PI)},t.prototype.draw=function(){e.prototype.draw.apply(this,arguments);var t=this.getCenterPoint();this._cropCanvas.drawIconMove([t.x,t.y],this._areaIsHover?this._iconMoveHoverRatio:this._iconMoveNormalRatio),this._cropCanvas.drawIconResizeBoxNESW(this._calcResizeIconCenterCoords(),this._boxResizeBaseSize,this._boxResizeIsHover?this._boxResizeHoverRatio:this._boxResizeNormalRatio)},t.prototype.processMouseMove=function(e,t){var i="default",r=!1;if(this._boxResizeIsHover=!1,this._areaIsHover=!1,this._areaIsDragging)this.setCenterPointOnMove({x:e-this._posDragStartX,y:t-this._posDragStartY}),this._areaIsHover=!0,i="move",r=!0,this._events.trigger("area-move");else if(this._boxResizeIsDragging){i="nesw-resize";var n,o,a;o=e-this._posResizeStartX,a=this._posResizeStartY-t,n=o>a?this._posResizeStartSize.w+2*a:this._posResizeStartSize.w+2*o;var s=(this.getCenterPoint(),{}),h={};s.x=this.getCenterPoint().x-.5*n,h.x=this.getCenterPoint().x+.5*n,s.y=this.getCenterPoint().y-.5*n,h.y=this.getCenterPoint().y+.5*n,this.CircleOnMove(s,h),this._boxResizeIsHover=!0,r=!0,this._events.trigger("area-resize")}else this._isCoordWithinBoxResize([e,t])?(i="nesw-resize",this._areaIsHover=!1,this._boxResizeIsHover=!0,r=!0):this._isCoordWithinArea([e,t])&&(i="move",this._areaIsHover=!0,r=!0);return angular.element(this._ctx.canvas).css({cursor:i}),r},t.prototype.processMouseDown=function(e,t){if(this._isCoordWithinBoxResize([e,t]))this._areaIsDragging=!1,this._areaIsHover=!1,this._boxResizeIsDragging=!0,this._boxResizeIsHover=!0,this._posResizeStartX=e,this._posResizeStartY=t,this._posResizeStartSize=this._size,this._events.trigger("area-resize-start");else if(this._isCoordWithinArea([e,t])){this._areaIsDragging=!0,this._areaIsHover=!0,this._boxResizeIsDragging=!1,this._boxResizeIsHover=!1;var i=this.getCenterPoint();this._posDragStartX=e-i.x,this._posDragStartY=t-i.y,this._events.trigger("area-move-start")}},t.prototype.processMouseUp=function(){this._areaIsDragging&&(this._areaIsDragging=!1,this._events.trigger("area-move-end")),this._boxResizeIsDragging&&(this._boxResizeIsDragging=!1,this._events.trigger("area-resize-end")),this._areaIsHover=!1,this._boxResizeIsHover=!1,this._posDragStartX=0,this._posDragStartY=0},t}]),e.factory("cropAreaRectangle",["cropArea",function(e){var t=function(){e.apply(this,arguments),this._resizeCtrlBaseRadius=15,this._resizeCtrlNormalRatio=.6,this._resizeCtrlHoverRatio=.7,this._iconMoveNormalRatio=.9,this._iconMoveHoverRatio=1.2,this._resizeCtrlNormalRadius=this._resizeCtrlBaseRadius*this._resizeCtrlNormalRatio,this._resizeCtrlHoverRadius=this._resizeCtrlBaseRadius*this._resizeCtrlHoverRatio,this._posDragStartX=0,this._posDragStartY=0,this._posResizeStartX=0,this._posResizeStartY=0,this._posResizeStartSize={w:0,h:0},this._resizeCtrlIsHover=-1,this._areaIsHover=!1,this._resizeCtrlIsDragging=-1,this._areaIsDragging=!1};return t.prototype=new e,t.prototype.getType=function(){return"rectangle"},t.prototype._calcRectangleCorners=function(){var e=this.getSize(),t=this.getSouthEastBound();return[[e.x,e.y],[t.x,e.y],[e.x,t.y],[t.x,t.y]]},t.prototype._calcRectangleDimensions=function(){var e=this.getSize(),t=this.getSouthEastBound();return{left:e.x,top:e.y,right:t.x,bottom:t.y}},t.prototype._isCoordWithinArea=function(e){var t=this._calcRectangleDimensions();return e[0]>=t.left&&e[0]<=t.right&&e[1]>=t.top&&e[1]<=t.bottom},t.prototype._isCoordWithinResizeCtrl=function(e){for(var t=this._calcRectangleCorners(),i=-1,r=0,n=t.length;n>r;r++){var o=t[r];if(e[0]>o[0]-this._resizeCtrlHoverRadius&&e[0]<o[0]+this._resizeCtrlHoverRadius&&e[1]>o[1]-this._resizeCtrlHoverRadius&&e[1]<o[1]+this._resizeCtrlHoverRadius){i=r;break}}return i},t.prototype._drawArea=function(e,t,i){e.rect(i.x,i.y,i.w,i.h)},t.prototype.draw=function(){e.prototype.draw.apply(this,arguments);var t=this.getCenterPoint();this._cropCanvas.drawIconMove([t.x,t.y],this._areaIsHover?this._iconMoveHoverRatio:this._iconMoveNormalRatio);for(var i=this._calcRectangleCorners(),r=0,n=i.length;n>r;r++){var o=i[r];this._cropCanvas.drawIconResizeBoxBase(o,this._resizeCtrlBaseRadius,this._resizeCtrlIsHover===r?this._resizeCtrlHoverRatio:this._resizeCtrlNormalRatio)}},t.prototype.processMouseMove=function(e,t){var i="default",r=!1;if(this._resizeCtrlIsHover=-1,this._areaIsHover=!1,this._areaIsDragging)this.setCenterPointOnMove({x:e-this._posDragStartX,y:t-this._posDragStartY}),this._areaIsHover=!0,i="move",r=!0,this._events.trigger("area-move");else if(this._resizeCtrlIsDragging>-1){var n=this.getSize(),o=this.getSouthEastBound(),a=e;switch(this._resizeCtrlIsDragging){case 0:this._aspect&&(a=o.x-(o.y-t)*this._aspect),this.setSizeByCorners({x:a,y:t},{x:o.x,y:o.y}),i="nwse-resize";break;case 1:this._aspect&&(a=n.x+(o.y-t)*this._aspect),this.setSizeByCorners({x:n.x,y:t},{x:a,y:o.y}),i="nesw-resize";break;case 2:this._aspect&&(a=o.x-(t-n.y)*this._aspect),this.setSizeByCorners({x:a,y:n.y},{x:o.x,y:t}),i="nesw-resize";break;case 3:this._aspect&&(a=n.x+(t-n.y)*this._aspect),this.setSizeByCorners({x:n.x,y:n.y},{x:a,y:t}),i="nwse-resize"}this._resizeCtrlIsHover=this._resizeCtrlIsDragging,r=!0,this._events.trigger("area-resize")}else{var s=this._isCoordWithinResizeCtrl([e,t]);if(s>-1){switch(s){case 0:i="nwse-resize";break;case 1:i="nesw-resize";break;case 2:i="nesw-resize";break;case 3:i="nwse-resize"}this._areaIsHover=!1,this._resizeCtrlIsHover=s,r=!0}else this._isCoordWithinArea([e,t])&&(i="move",this._areaIsHover=!0,r=!0)}return angular.element(this._ctx.canvas).css({cursor:i}),r},t.prototype.processMouseDown=function(e,t){var i=this._isCoordWithinResizeCtrl([e,t]);if(i>-1)this._areaIsDragging=!1,this._areaIsHover=!1,this._resizeCtrlIsDragging=i,this._resizeCtrlIsHover=i,this._posResizeStartX=e,this._posResizeStartY=t,this._posResizeStartSize=this._size,this._events.trigger("area-resize-start");else if(this._isCoordWithinArea([e,t])){this._areaIsDragging=!0,this._areaIsHover=!0,this._resizeCtrlIsDragging=-1,this._resizeCtrlIsHover=-1;var r=this.getCenterPoint();this._posDragStartX=e-r.x,this._posDragStartY=t-r.y,this._events.trigger("area-move-start")}},t.prototype.processMouseUp=function(){this._areaIsDragging&&(this._areaIsDragging=!1,this._events.trigger("area-move-end")),this._resizeCtrlIsDragging>-1&&(this._resizeCtrlIsDragging=-1,this._events.trigger("area-resize-end")),this._areaIsHover=!1,this._resizeCtrlIsHover=-1,this._posDragStartX=0,this._posDragStartY=0},t}]),e.factory("cropAreaSquare",["cropArea",function(e){var t=function(){e.apply(this,arguments),this._resizeCtrlBaseRadius=15,this._resizeCtrlNormalRatio=.6,this._resizeCtrlHoverRatio=.7,this._iconMoveNormalRatio=.9,this._iconMoveHoverRatio=1.2,this._resizeCtrlNormalRadius=this._resizeCtrlBaseRadius*this._resizeCtrlNormalRatio,this._resizeCtrlHoverRadius=this._resizeCtrlBaseRadius*this._resizeCtrlHoverRatio,this._posDragStartX=0,this._posDragStartY=0,this._posResizeStartX=0,this._posResizeStartY=0,this._posResizeStartSize=0,this._resizeCtrlIsHover=-1,this._areaIsHover=!1,this._resizeCtrlIsDragging=-1,this._areaIsDragging=!1};return t.prototype=new e,t.prototype.getType=function(){return"square"},t.prototype._calcSquareCorners=function(){var e=this.getSize(),t=this.getSouthEastBound();return[[e.x,e.y],[t.x,e.y],[e.x,t.y],[t.x,t.y]]},t.prototype._calcSquareDimensions=function(){var e=this.getSize(),t=this.getSouthEastBound();return{left:e.x,top:e.y,right:t.x,bottom:t.y}},t.prototype._isCoordWithinArea=function(e){var t=this._calcSquareDimensions();return e[0]>=t.left&&e[0]<=t.right&&e[1]>=t.top&&e[1]<=t.bottom},t.prototype._isCoordWithinResizeCtrl=function(e){for(var t=this._calcSquareCorners(),i=-1,r=0,n=t.length;n>r;r++){var o=t[r];if(e[0]>o[0]-this._resizeCtrlHoverRadius&&e[0]<o[0]+this._resizeCtrlHoverRadius&&e[1]>o[1]-this._resizeCtrlHoverRadius&&e[1]<o[1]+this._resizeCtrlHoverRadius){i=r;break}}return i},t.prototype._drawArea=function(e,t,i){e.rect(i.x,i.y,i.w,i.h)},t.prototype.draw=function(){e.prototype.draw.apply(this,arguments);var t=this.getCenterPoint();this._cropCanvas.drawIconMove([t.x,t.y],this._areaIsHover?this._iconMoveHoverRatio:this._iconMoveNormalRatio);for(var i=this._calcSquareCorners(),r=0,n=i.length;n>r;r++){var o=i[r];this._cropCanvas.drawIconResizeBoxBase(o,this._resizeCtrlBaseRadius,this._resizeCtrlIsHover===r?this._resizeCtrlHoverRatio:this._resizeCtrlNormalRatio)}},t.prototype._clampPoint=function(e,t){var i=this._ctx.canvas.width;return 0>e&&(t-=Math.abs(e),e=0),0>t&&(e-=Math.abs(t),t=0),e>i&&(t-=i-e,e=i),t>i&&(e-=i-t,t=i),{x:e,y:t}},t.prototype.processMouseMove=function(e,t){var i="default",r=!1;if(this._resizeCtrlIsHover=-1,this._areaIsHover=!1,this._areaIsDragging)this.setCenterPointOnMove({x:e-this._posDragStartX,y:t-this._posDragStartY}),this._areaIsHover=!0,i="move",r=!0,this._events.trigger("area-move");else if(this._resizeCtrlIsDragging>-1){var n,o;switch(this._resizeCtrlIsDragging){case 0:n=-1,o=-1,i="nwse-resize";break;case 1:n=1,o=-1,i="nesw-resize";break;case 2:n=-1,o=1,i="nesw-resize";break;case 3:n=1,o=1,i="nwse-resize"}var a,s=(e-this._posResizeStartX)*n,h=(t-this._posResizeStartY)*o;a=s>h?this._posResizeStartSize.w+h:this._posResizeStartSize.w+s;var c=Math.max(this._minSize.w,a),u={},l={},g={},d={},f=this.getSize(),p=this.getSouthEastBound();switch(this._resizeCtrlIsDragging){case 0:u.x=p.x-c,u.y=p.y-c,u=this._clampPoint(u.x,u.y),this.setSizeByCorners(u,{x:p.x,y:p.y}),i="nwse-resize";break;case 1:d.x=f.x+c,d.y=p.y-c,d=this._clampPoint(d.x,d.y),this.setSizeByCorners({x:f.x,y:d.y},{x:d.x,y:p.y}),i="nesw-resize";break;case 2:g.x=p.x-c,g.y=f.y+c,g=this._clampPoint(g.x,g.y),this.setSizeByCorners({x:g.x,y:f.y},{x:p.x,y:g.y}),i="nesw-resize";break;case 3:l.x=f.x+c,l.y=f.y+c,l=this._clampPoint(l.x,l.y),this.setSizeByCorners({x:f.x,y:f.y},l),i="nwse-resize"}this._resizeCtrlIsHover=this._resizeCtrlIsDragging,r=!0,this._events.trigger("area-resize")}else{var v=this._isCoordWithinResizeCtrl([e,t]);if(v>-1){switch(v){case 0:i="nwse-resize";break;case 1:i="nesw-resize";break;case 2:i="nesw-resize";break;case 3:i="nwse-resize"}this._areaIsHover=!1,this._resizeCtrlIsHover=v,r=!0}else this._isCoordWithinArea([e,t])&&(i="move",this._areaIsHover=!0,r=!0)}return angular.element(this._ctx.canvas).css({cursor:i}),r},t.prototype.processMouseDown=function(e,t){var i=this._isCoordWithinResizeCtrl([e,t]);if(i>-1)this._areaIsDragging=!1,this._areaIsHover=!1,this._resizeCtrlIsDragging=i,this._resizeCtrlIsHover=i,this._posResizeStartX=e,this._posResizeStartY=t,this._posResizeStartSize=this._size,this._events.trigger("area-resize-start");else if(this._isCoordWithinArea([e,t])){this._areaIsDragging=!0,this._areaIsHover=!0,this._resizeCtrlIsDragging=-1,this._resizeCtrlIsHover=-1;var r=this.getCenterPoint();this._posDragStartX=e-r.x,this._posDragStartY=t-r.y,this._events.trigger("area-move-start")}},t.prototype.processMouseUp=function(){this._areaIsDragging&&(this._areaIsDragging=!1,this._events.trigger("area-move-end")),this._resizeCtrlIsDragging>-1&&(this._resizeCtrlIsDragging=-1,this._events.trigger("area-resize-end")),this._areaIsHover=!1,this._resizeCtrlIsHover=-1,this._posDragStartX=0,this._posDragStartY=0},t}]),e.factory("cropArea",["cropCanvas",function(e){var t=function(t,i){this._ctx=t,this._events=i,this._minSize={x:0,y:0,w:80,h:80},this._initSize=void 0,this._initCoords=void 0,this._allowCropResizeOnCorners=!1,this._forceAspectRatio=!1,this._aspect=null,this._cropCanvas=new e(t),this._image=new Image,this._size={x:0,y:0,w:150,h:150}};return t.prototype.setAllowCropResizeOnCorners=function(e){this._allowCropResizeOnCorners=e},t.prototype.getImage=function(){return this._image},t.prototype.setImage=function(e){this._image=e},t.prototype.setForceAspectRatio=function(e){this._forceAspectRatio=e},t.prototype.setAspect=function(e){this._aspect=e},t.prototype.getAspect=function(){return this._aspect},t.prototype.getCanvasSize=function(){return{w:this._ctx.canvas.width,h:this._ctx.canvas.height}},t.prototype.getSize=function(){return this._size},t.prototype.setSize=function(e){e=this._processSize(e),this._size=this._preventBoundaryCollision(e)},t.prototype.setSizeOnMove=function(e){e=this._processSize(e),this._size=this._allowCropResizeOnCorners?this._preventBoundaryCollision(e):this._allowMouseOutsideCanvas(e)},t.prototype.CircleOnMove=function(e,t){var i={x:e.x,y:e.y,w:t.x-e.x,h:t.y-e.y},r=this._ctx.canvas.height,n=this._ctx.canvas.width;(i.w>n||i.h>r)&&(r>n?(i.w=n,i.h=n):(i.w=r,i.h=r)),i.x+i.w>n&&(i.x=n-i.w),i.y+i.h>r&&(i.y=r-i.h),i.x<0&&(i.x=0),i.y<0&&(i.y=0),this._minSize.w>i.w&&(i.w=this._minSize.w,i.x=this._size.x),this._minSize.h>i.h&&(i.h=this._minSize.h,i.y=this._size.y),this._size=i},t.prototype.setSizeByCorners=function(e,t){var i={x:e.x,y:e.y,w:t.x-e.x,h:t.y-e.y};this.setSize(i)},t.prototype.getSouthEastBound=function(){return this._southEastBound(this.getSize())},t.prototype.setMinSize=function(e){this._minSize=this._processSize(e),this.setSize(this._minSize)},t.prototype.getMinSize=function(){return this._minSize},t.prototype.getCenterPoint=function(){var e=this.getSize();return{x:e.x+e.w/2,y:e.y+e.h/2}},t.prototype.setCenterPoint=function(e){var t=this.getSize();this.setSize({x:e.x-t.w/2,y:e.y-t.h/2,w:t.w,h:t.h})},t.prototype.setCenterPointOnMove=function(e){var t=this.getSize();this.setSizeOnMove({x:e.x-t.w/2,y:e.y-t.h/2,w:t.w,h:t.h})},t.prototype.setInitSize=function(e){this._initSize=this._processSize(e),this.setSize(this._initSize)},t.prototype.getInitSize=function(){return this._initSize},t.prototype.setInitCoords=function(e){e.h=this.getSize().h,e.w=this.getSize().w,this._initCoords=this._processSize(e),this.setSize(this._initCoords)},t.prototype.getInitCoords=function(){return this._initCoords},t.prototype.getType=function(){return"circle"},t.prototype._allowMouseOutsideCanvas=function(e){var t=this._ctx.canvas.height,i=this._ctx.canvas.width,r={w:e.w,h:e.h};return r.x=e.x<0?0:e.x+e.w>i?i-e.w:e.x,r.y=e.y<0?0:e.y+e.h>t?t-e.h:e.y,r},t.prototype._preventBoundaryCollision=function(e){var t=this._ctx.canvas.height,i=this._ctx.canvas.width,r={x:e.x,y:e.y},n=this._southEastBound(e);r.x<0&&(r.x=0),r.y<0&&(r.y=0),n.x>i&&(n.x=i),n.y>t&&(n.y=t);var o=this._forceAspectRatio?e.w:n.x-r.x,a=this._forceAspectRatio?e.h:n.y-r.y;a>t&&(a=t),this._aspect&&(o=a*this._aspect,r.x+o>i&&(o=i-r.x,a=o/this._aspect,this._minSize.w>o&&(o=this._minSize.w),this._minSize.h>a&&(a=this._minSize.h),r.x=i-o),r.y+a>t&&(r.y=t-a)),this._forceAspectRatio&&(o=a,r.x+o>i&&(o=i-r.x,o<this._minSize.w&&(o=this._minSize.w),a=o));var s={x:r.x,y:r.y,w:o,h:a};return s.w<this._minSize.w&&!this._forceAspectRatio&&(s.w=this._minSize.w,n=this._southEastBound(s),n.x>i&&(n.x=i,r.x=Math.max(n.x-i,n.x-this._minSize.w),s={x:r.x,y:r.y,w:n.x-r.x,h:n.y-r.y})),s.h<this._minSize.h&&!this._forceAspectRatio&&(s.h=this._minSize.h,n=this._southEastBound(s),n.y>t&&(n.y=t,r.y=Math.max(n.y-t,n.y-this._minSize.h),s={x:r.x,y:r.y,w:n.x-r.x,h:n.y-r.y})),this._forceAspectRatio&&(n=this._southEastBound(s),n.y>t&&(s.y=t-s.h),n.x>i&&(s.x=i-s.w)),s},t.prototype._dontDragOutside=function(){var e=this._ctx.canvas.height,t=this._ctx.canvas.width;this._width>t&&(this._width=t),this._height>e&&(this._height=e),this._x<this._width/2&&(this._x=this._width/2),this._x>t-this._width/2&&(this._x=t-this._width/2),this._y<this._height/2&&(this._y=this._height/2),this._y>e-this._height/2&&(this._y=e-this._height/2)},t.prototype._drawArea=function(){},t.prototype._processSize=function(e){"number"==typeof e&&(e={w:e,h:e});var t=e.w;return this._aspect&&(t=e.h*this._aspect),{x:"undefined"==typeof e.x?this.getSize().x:e.x,y:"undefined"==typeof e.y?this.getSize().y:e.y,w:t||this._minSize.w,h:e.h||this._minSize.h}},t.prototype._southEastBound=function(e){return{x:e.x+e.w,y:e.y+e.h}},t.prototype.draw=function(){this._cropCanvas.drawCropArea(this._image,this.getCenterPoint(),this._size,this._drawArea)},t.prototype.processMouseMove=function(){},t.prototype.processMouseDown=function(){},t.prototype.processMouseUp=function(){},t}]),e.factory("cropCanvas",[function(){var e=[[-.5,-2],[-3,-4.5],[-.5,-7],[-7,-7],[-7,-.5],[-4.5,-3],[-2,-.5]],t=[[.5,-2],[3,-4.5],[.5,-7],[7,-7],[7,-.5],[4.5,-3],[2,-.5]],i=[[-.5,2],[-3,4.5],[-.5,7],[-7,7],[-7,.5],[-4.5,3],[-2,.5]],r=[[.5,2],[3,4.5],[.5,7],[7,7],[7,.5],[4.5,3],[2,.5]],n=[[-1.5,-2.5],[-1.5,-6],[-5,-6],[0,-11],[5,-6],[1.5,-6],[1.5,-2.5]],o=[[-2.5,-1.5],[-6,-1.5],[-6,-5],[-11,0],[-6,5],[-6,1.5],[-2.5,1.5]],a=[[-1.5,2.5],[-1.5,6],[-5,6],[0,11],[5,6],[1.5,6],[1.5,2.5]],s=[[2.5,-1.5],[6,-1.5],[6,-5],[11,0],[6,5],[6,1.5],[2.5,1.5]],h={areaOutline:"#fff",resizeBoxStroke:"#bababa",resizeBoxFill:"#444",resizeBoxArrowFill:"#fff",resizeCircleStroke:"#bababa",resizeCircleFill:"#444",moveIconFill:"#fff"},c={strokeWidth:1};return function(u){var l=function(e,t,i){return[i*e[0]+t[0],i*e[1]+t[1]]},g=function(e,t,i,r){u.save(),u.fillStyle=t,u.beginPath();var n,o=l(e[0],i,r);u.moveTo(o[0],o[1]);for(var a in e)a>0&&(n=l(e[a],i,r),u.lineTo(n[0],n[1]));u.lineTo(o[0],o[1]),u.fill(),u.closePath(),u.restore()};this.drawIconMove=function(e,t){g(n,h.moveIconFill,e,t),g(o,h.moveIconFill,e,t),g(a,h.moveIconFill,e,t),g(s,h.moveIconFill,e,t)},this.drawIconResizeCircle=function(e,t,i){var r=t*i;u.save(),u.strokeStyle=h.resizeCircleStroke,u.lineWidth=c.strokeWidth,u.fillStyle=h.resizeCircleFill,u.beginPath(),u.arc(e[0],e[1],r,0,2*Math.PI),u.fill(),u.stroke(),u.closePath(),u.restore()},this.drawIconResizeBoxBase=function(e,t,i){var r=t*i;u.save(),u.strokeStyle=h.resizeBoxStroke,u.lineWidth=c.strokeWidth,u.fillStyle=h.resizeBoxFill,u.fillRect(e[0]-r/2,e[1]-r/2,r,r),u.strokeRect(e[0]-r/2,e[1]-r/2,r,r),u.restore()},this.drawIconResizeBoxNESW=function(e,r,n){this.drawIconResizeBoxBase(e,r,n),g(t,h.resizeBoxArrowFill,e,n),g(i,h.resizeBoxArrowFill,e,n)},this.drawIconResizeBoxNWSE=function(t,i,n){this.drawIconResizeBoxBase(t,i,n),g(e,h.resizeBoxArrowFill,t,n),g(r,h.resizeBoxArrowFill,t,n)},this.drawCropArea=function(e,t,i,r){var n=Math.abs(e.width/u.canvas.width),o=Math.abs(e.height/u.canvas.height),a=Math.abs(t.x-i.w/2),s=Math.abs(t.y-i.h/2);u.save(),u.strokeStyle=h.areaOutline,u.lineWidth=c.strokeWidth,u.setLineDash([5,5]),u.beginPath(),r(u,t,i),u.stroke(),u.clip(),i.w>0&&u.drawImage(e,a*n,s*o,Math.abs(i.w*n),Math.abs(i.h*o),a,s,Math.abs(i.w),Math.abs(i.h)),u.beginPath(),r(u,t,i),u.stroke(),u.clip(),u.restore()}}}]),e.service("cropEXIF",[function(){function e(e){return!!e.exifdata}function t(e,t){t=t||e.match(/^data\:([^\;]+)\;base64,/im)[1]||"",e=e.replace(/^data\:([^\;]+)\;base64,/gim,"");for(var i=atob(e),r=i.length,n=new ArrayBuffer(r),o=new Uint8Array(n),a=0;r>a;a++)o[a]=i.charCodeAt(a);return n}function i(e,t){var i=new XMLHttpRequest;i.open("GET",e,!0),i.responseType="blob",i.onload=function(){(200===this.status||0===this.status)&&t(this.response)},i.send()}function r(e,r){function a(t){var i=n(t),a=o(t);e.exifdata=i||{},e.iptcdata=a||{},r&&r.call(e)}var s=new FileReader;if(e.src){if(/^data\:/i.test(e.src)){var h=t(e.src);a(h)}else/^blob\:/i.test(e.src)&&(s.onload=function(e){a(e.target.result)},i(e.src,function(e){s.readAsArrayBuffer(e)}));var c=new XMLHttpRequest;c.onload=function(){if(200!==this.status&&0!==this.status)throw"Could not load image";a(c.response),c=null},c.responseType="arraybuffer",c.open("GET",e.src,!0);try{c.send(null)}catch(u){}}else window.FileReader&&(e instanceof window.Blob||e instanceof window.File)&&(s.onload=function(e){l&&console.log("Got file of length "+e.target.result.byteLength),a(e.target.result)},s.readAsArrayBuffer(e))}function n(e){var t=new DataView(e);if(l&&console.log("Got file of length "+e.byteLength),255!==t.getUint8(0)||216!==t.getUint8(1))return l&&console.log("Not a valid JPEG"),!1;for(var i,r=2,n=e.byteLength;n>r;){if(255!==t.getUint8(r))return l&&console.log("Not a valid marker at offset "+r+", found: "+t.getUint8(r)),!1;if(i=t.getUint8(r+1),l&&console.log(i),225===i)return l&&console.log("Found 0xFFE1 marker"),u(t,r+4,t.getUint16(r+2)-2);r+=2+t.getUint16(r+2)}}function o(e){var t=new DataView(e);if(l&&console.log("Got file of length "+e.byteLength),255!==t.getUint8(0)||216!==t.getUint8(1))return l&&console.log("Not a valid JPEG"),!1;for(var i=2,r=e.byteLength,n=function(e,t){return 56===e.getUint8(t)&&66===e.getUint8(t+1)&&73===e.getUint8(t+2)&&77===e.getUint8(t+3)&&4===e.getUint8(t+4)&&4===e.getUint8(t+5)};r>i;){if(n(t,i)){var o=t.getUint8(i+7);o%2!==0&&(o+=1),0===o&&(o=4);var s=i+8+o,h=t.getUint16(i+6+o);return a(e,s,h)}i++}}function a(e,t,i){for(var r,n,o,a,s,h=new DataView(e),u={},l=t;t+i>l;)28===h.getUint8(l)&&2===h.getUint8(l+1)&&(a=h.getUint8(l+2),a in v&&(o=h.getInt16(l+3),s=o+5,n=v[a],r=c(h,l+5,o),u.hasOwnProperty(n)?u[n]instanceof Array?u[n].push(r):u[n]=[u[n],r]:u[n]=r)),l++;return u}function s(e,t,i,r,n){var o,a,s,c=e.getUint16(i,!n),u={};for(s=0;c>s;s++)o=i+12*s+2,a=r[e.getUint16(o,!n)],!a&&l&&console.log("Unknown tag: "+e.getUint16(o,!n)),u[a]=h(e,o,t,i,n);return u}function h(e,t,i,r,n){var o,a,s,h,u,l,g=e.getUint16(t+2,!n),d=e.getUint32(t+4,!n),f=e.getUint32(t+8,!n)+i;switch(g){case 1:case 7:if(1===d)return e.getUint8(t+8,!n);for(o=d>4?f:t+8,a=[],h=0;d>h;h++)a[h]=e.getUint8(o+h);return a;case 2:return o=d>4?f:t+8,c(e,o,d-1);case 3:if(1===d)return e.getUint16(t+8,!n);for(o=d>2?f:t+8,a=[],h=0;d>h;h++)a[h]=e.getUint16(o+2*h,!n);return a;case 4:if(1===d)return e.getUint32(t+8,!n);for(a=[],h=0;d>h;h++)a[h]=e.getUint32(f+4*h,!n);return a;case 5:if(1===d)return u=e.getUint32(f,!n),l=e.getUint32(f+4,!n),s=u/l,s.numerator=u,s.denominator=l,s;for(a=[],h=0;d>h;h++)u=e.getUint32(f+8*h,!n),l=e.getUint32(f+4+8*h,!n),a[h]=u/l,a[h].numerator=u,a[h].denominator=l;return a;case 9:if(1===d)return e.getInt32(t+8,!n);for(a=[],h=0;d>h;h++)a[h]=e.getInt32(f+4*h,!n);return a;case 10:if(1===d)return e.getInt32(f,!n)/e.getInt32(f+4,!n);for(a=[],h=0;d>h;h++)a[h]=e.getInt32(f+8*h,!n)/e.getInt32(f+4+8*h,!n);return a}}function c(e,t,i){for(var r="",n=t;t+i>n;n++)r+=String.fromCharCode(e.getUint8(n));return r}function u(e,t){if("Exif"!==c(e,t,4))return l&&console.log("Not valid EXIF data! "+c(e,t,4)),!1;var i,r,n,o,a,h=t+6;if(18761===e.getUint16(h))i=!1;else{if(19789!==e.getUint16(h))return l&&console.log("Not valid TIFF data! (no 0x4949 or 0x4D4D)"),!1;i=!0}if(42!==e.getUint16(h+2,!i))return l&&console.log("Not valid TIFF data! (no 0x002A)"),!1;var u=e.getUint32(h+4,!i);if(8>u)return l&&console.log("Not valid TIFF data! (First offset less than 8)",e.getUint32(h+4,!i)),!1;if(r=s(e,h,h+u,d,i),r.ExifIFDPointer){o=s(e,h,h+r.ExifIFDPointer,g,i);for(n in o){switch(n){case"LightSource":case"Flash":case"MeteringMode":case"ExposureProgram":case"SensingMethod":case"SceneCaptureType":case"SceneType":case"CustomRendered":case"WhiteBalance":case"GainControl":case"Contrast":case"Saturation":case"Sharpness":case"SubjectDistanceRange":case"FileSource":o[n]=p[n][o[n]];break;case"ExifVersion":case"FlashpixVersion":o[n]=String.fromCharCode(o[n][0],o[n][1],o[n][2],o[n][3]);break;case"ComponentsConfiguration":o[n]=p.Components[o[n][0]]+p.Components[o[n][1]]+p.Components[o[n][2]]+p.Components[o[n][3]]}r[n]=o[n]}}if(r.GPSInfoIFDPointer){a=s(e,h,h+r.GPSInfoIFDPointer,f,i);for(n in a){switch(n){case"GPSVersionID":a[n]=a[n][0]+"."+a[n][1]+"."+a[n][2]+"."+a[n][3]}r[n]=a[n]}}return r}var l=!1,g=this.Tags={36864:"ExifVersion",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37500:"MakerNote",37510:"UserComment",40964:"RelatedSoundFile",36867:"DateTimeOriginal",36868:"DateTimeDigitized",37520:"SubsecTime",37521:"SubsecTimeOriginal",37522:"SubsecTimeDigitized",33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"ISOSpeedRatings",34856:"OECF",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBias",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37396:"SubjectArea",37386:"FocalLength",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRation",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",40965:"InteroperabilityIFDPointer",42016:"ImageUniqueID"},d=this.TiffTags={256:"ImageWidth",257:"ImageHeight",34665:"ExifIFDPointer",34853:"GPSInfoIFDPointer",40965:"InteroperabilityIFDPointer",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",274:"Orientation",277:"SamplesPerPixel",284:"PlanarConfiguration",530:"YCbCrSubSampling",531:"YCbCrPositioning",282:"XResolution",283:"YResolution",296:"ResolutionUnit",273:"StripOffsets",278:"RowsPerStrip",279:"StripByteCounts",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",301:"TransferFunction",318:"WhitePoint",319:"PrimaryChromaticities",529:"YCbCrCoefficients",532:"ReferenceBlackWhite",306:"DateTime",270:"ImageDescription",271:"Make",272:"Model",305:"Software",315:"Artist",33432:"Copyright"},f=this.GPSTags={0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential"},p=this.StringValues={ExposureProgram:{0:"Not defined",1:"Manual",2:"Normal program",3:"Aperture priority",4:"Shutter priority",5:"Creative program",6:"Action program",7:"Portrait mode",8:"Landscape mode"},MeteringMode:{0:"Unknown",1:"Average",2:"CenterWeightedAverage",3:"Spot",4:"MultiSpot",5:"Pattern",6:"Partial",255:"Other"},LightSource:{0:"Unknown",1:"Daylight",2:"Fluorescent",3:"Tungsten (incandescent light)",4:"Flash",9:"Fine weather",10:"Cloudy weather",11:"Shade",12:"Daylight fluorescent (D 5700 - 7100K)",13:"Day white fluorescent (N 4600 - 5400K)",14:"Cool white fluorescent (W 3900 - 4500K)",15:"White fluorescent (WW 3200 - 3700K)",17:"Standard light A",18:"Standard light B",19:"Standard light C",20:"D55",21:"D65",22:"D75",23:"D50",24:"ISO studio tungsten",255:"Other"},Flash:{0:"Flash did not fire",1:"Flash fired",5:"Strobe return light not detected",7:"Strobe return light detected",9:"Flash fired, compulsory flash mode",13:"Flash fired, compulsory flash mode, return light not detected",15:"Flash fired, compulsory flash mode, return light detected",16:"Flash did not fire, compulsory flash mode",24:"Flash did not fire, auto mode",25:"Flash fired, auto mode",29:"Flash fired, auto mode, return light not detected",31:"Flash fired, auto mode, return light detected",32:"No flash function",65:"Flash fired, red-eye reduction mode",69:"Flash fired, red-eye reduction mode, return light not detected",71:"Flash fired, red-eye reduction mode, return light detected",73:"Flash fired, compulsory flash mode, red-eye reduction mode",77:"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",79:"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",89:"Flash fired, auto mode, red-eye reduction mode",93:"Flash fired, auto mode, return light not detected, red-eye reduction mode",95:"Flash fired, auto mode, return light detected, red-eye reduction mode"},SensingMethod:{1:"Not defined",2:"One-chip color area sensor",3:"Two-chip color area sensor",4:"Three-chip color area sensor",5:"Color sequential area sensor",7:"Trilinear sensor",8:"Color sequential linear sensor"},SceneCaptureType:{0:"Standard",1:"Landscape",2:"Portrait",3:"Night scene"},SceneType:{1:"Directly photographed"},CustomRendered:{0:"Normal process",1:"Custom process"},WhiteBalance:{0:"Auto white balance",1:"Manual white balance"},GainControl:{0:"None",1:"Low gain up",2:"High gain up",3:"Low gain down",4:"High gain down"},Contrast:{0:"Normal",1:"Soft",2:"Hard"},Saturation:{0:"Normal",1:"Low saturation",2:"High saturation"},Sharpness:{0:"Normal",1:"Soft",2:"Hard"},SubjectDistanceRange:{0:"Unknown",1:"Macro",2:"Close view",3:"Distant view"},FileSource:{3:"DSC"},Components:{0:"",1:"Y",2:"Cb",3:"Cr",4:"R",5:"G",6:"B"}},v={120:"caption",110:"credit",25:"keywords",55:"dateCreated",80:"byline",85:"bylineTitle",122:"captionWriter",105:"headline",116:"copyright",15:"category"};this.getData=function(t,i){return(t instanceof Image||t instanceof HTMLImageElement)&&!t.complete?!1:(e(t)?i&&i.call(t):r(t,i),!0)},this.getTag=function(t,i){return e(t)?t.exifdata[i]:void 0},this.getAllTags=function(t){if(!e(t))return{};var i,r=t.exifdata,n={};for(i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);return n},this.pretty=function(t){if(!e(t))return"";var i,r=t.exifdata,n="";for(i in r)r.hasOwnProperty(i)&&(n+="object"==typeof r[i]?r[i]instanceof Number?i+" : "+r[i]+" ["+r[i].numerator+"/"+r[i].denominator+"]\r\n":i+" : ["+r[i].length+" values]\r\n":i+" : "+r[i]+"\r\n");return n},this.readFromBinaryFile=function(e){return n(e)}}]),e.factory("cropHost",["$document","$q","cropAreaCircle","cropAreaSquare","cropAreaRectangle","cropEXIF",function(e,t,i,r,n,o){var a=function(e){var t=e.getBoundingClientRect(),i=document.body,r=document.documentElement,n=window.pageYOffset||r.scrollTop||i.scrollTop,o=window.pageXOffset||r.scrollLeft||i.scrollLeft,a=r.clientTop||i.clientTop||0,s=r.clientLeft||i.clientLeft||0,h=t.top+n-a,c=t.left+o-s;return{top:Math.round(h),left:Math.round(c)}};return function(s,h,c){function u(){l.clearRect(0,0,l.canvas.width,l.canvas.height),null!==g&&(l.drawImage(g,0,0,l.canvas.width,l.canvas.height),l.save(),l.fillStyle="rgba(0, 0, 0, 0.65)",l.fillRect(0,0,l.canvas.width,l.canvas.height),l.restore(),d.draw())}var l=null,g=null,d=null,f=null,p=null,v=this,m=[100,100],w=[300,300],y=null,S=[],_={w:200,h:200},C=null,z="image/png",I=null,x=!1;this.setInitMax=function(e){f=e},this.setAllowCropResizeOnCorners=function(e){d.setAllowCropResizeOnCorners(e)};var R=function(){if(null!==g){d.setImage(g);var e=[g.width,g.height],t=g.width/g.height,i=e;i[0]>w[0]?(i[0]=w[0],i[1]=i[0]/t):i[0]<m[0]&&(i[0]=m[0],i[1]=i[0]/t),"fixed-height"===y&&i[1]>w[1]?(i[1]=w[1],i[0]=i[1]*t):i[1]<m[1]&&(i[1]=m[1],i[0]=i[1]*t),s.prop("width",i[0]).prop("height",i[1]),"fixed-height"===y&&s.css({"margin-left":-i[0]/2+"px","margin-top":-i[1]/2+"px"});
var r=l.canvas.width,n=l.canvas.height,o=v.getAreaType();if("circle"===o||"square"===o)r>n&&(r=n),n=r;else if("rectangle"===o&&p){var a=d.getAspect();r/n>a?r=a*n:n=a*r}if(f?d.setSize({w:r,h:n}):void 0!==d.getInitSize()?d.setSize({w:Math.min(d.getInitSize().w,r/2),h:Math.min(d.getInitSize().h,n/2)}):d.setSize({w:Math.min(200,r/2),h:Math.min(200,n/2)}),d.getInitCoords())if(v.areaInitIsRelativeToImage){var h=g.width/i[0];d.setSize({w:d.getInitSize().w/h,h:d.getInitSize().h/h,x:d.getInitCoords().x/h,y:d.getInitCoords().y/h})}else d.setSize({w:d.getSize().w,h:d.getSize().h,x:d.getInitCoords().x,y:d.getInitCoords().y});else d.setCenterPoint({x:l.canvas.width/2,y:l.canvas.height/2})}else s.prop("width",0).prop("height",0).css({"margin-top":0});u()},b=function(e){return angular.isDefined(e.changedTouches)?e.changedTouches:e.originalEvent.changedTouches},D=function(e){if(null!==g){var t,i,r=a(l.canvas);"touchmove"===e.type?(t=b(e)[0].pageX,i=b(e)[0].pageY):(t=e.pageX,i=e.pageY),d.processMouseMove(t-r.left,i-r.top),u()}},P=function(e){if(e.preventDefault(),e.stopPropagation(),null!==g){var t,i,r=a(l.canvas);"touchstart"===e.type?(t=b(e)[0].pageX,i=b(e)[0].pageY):(t=e.pageX,i=e.pageY),d.processMouseDown(t-r.left,i-r.top),u()}},M=function(e){if(null!==g){var t,i,r=a(l.canvas);"touchend"===e.type?(t=b(e)[0].pageX,i=b(e)[0].pageY):(t=e.pageX,i=e.pageY),d.processMouseUp(t-r.left,i-r.top),u()}},F=function(e){var t,i,r=e,n=d.getCenterPoint(),o={dataURI:null,imageData:null};if(i=angular.element("<canvas></canvas>")[0],t=i.getContext("2d"),i.width=r.w,i.height=r.h,null!==g){var a=(n.x-d.getSize().w/2)*(g.width/l.canvas.width),s=(n.y-d.getSize().h/2)*(g.height/l.canvas.height),h=d.getSize().w*(g.width/l.canvas.width),c=d.getSize().h*(g.height/l.canvas.height);if(x)t.drawImage(g,a,s,h,c,0,0,r.w,r.h);else{var u,f,p=h/c;p>1?(f=r.w,u=f/p):(u=r.h,f=u*p),t.drawImage(g,a,s,h,c,0,0,Math.round(f),Math.round(u))}o.dataURI=null!==I?i.toDataURL(z,I):i.toDataURL(z)}return o};this.getResultImage=function(){if(0===S.length)return F(this.getResultImageSize());for(var e=[],t=0;t<S.length;t++)e.push({dataURI:F(S[t]).dataURI,w:S[t].w,h:S[t].h});return e},this.getResultImageDataBlob=function(){var e,i,r=d.getCenterPoint(),n=this.getResultImageSize(),o=t.defer();if(i=angular.element("<canvas></canvas>")[0],e=i.getContext("2d"),i.width=n.w,i.height=n.h,null!==g){var a=(r.x-d.getSize().w/2)*(g.width/l.canvas.width),s=(r.y-d.getSize().h/2)*(g.height/l.canvas.height),h=d.getSize().w*(g.width/l.canvas.width),c=d.getSize().h*(g.height/l.canvas.height);if(x)e.drawImage(g,a,s,h,c,0,0,n.w,n.h);else{var u,f,p=h/c;p>1?(f=n.w,u=f/p):(u=n.h,f=u*p),e.drawImage(g,a,s,h,c,0,0,Math.round(f),Math.round(u))}}return null!==I?i.toBlob(function(e){o.resolve(e)},z,I):i.toBlob(function(e){o.resolve(e)},z),o.promise},this.getAreaCoords=function(){return d.getSize()},this.getArea=function(){return d},this.setNewImageSource=function(e){if(g=null,R(),e){var t=new Image;t.onload=function(){c.trigger("load-done"),o.getData(t,function(){var e=o.getTag(t,"Orientation");if([3,6,8].indexOf(e)>-1){var i=document.createElement("canvas"),r=i.getContext("2d"),n=t.width,a=t.height,s=0,h=0,u=0,l=0,d=0;switch(l=n,d=a,e){case 3:s=-t.width,h=-t.height,u=180;break;case 6:n=t.height,a=t.width,h=-t.height,l=a,d=n,u=90;break;case 8:n=t.height,a=t.width,s=-t.width,l=a,d=n,u=270}var f=1e3;if(n>f||a>f){var p=0;n>f?(p=f/n,n=f,a=p*a):a>f&&(p=f/a,a=f,n=p*n),h=p*h,s=p*s,l=p*l,d=p*d}i.width=n,i.height=a,r.rotate(u*Math.PI/180),r.drawImage(t,s,h,l,d),g=new Image,g.onload=function(){R(),c.trigger("image-updated")},g.src=i.toDataURL(z)}else g=t,c.trigger("image-updated");R()})},t.onerror=function(){c.trigger("load-error")},c.trigger("load-start"),e instanceof window.Blob?t.src=URL.createObjectURL(e):(("http"===e.substring(0,4).toLowerCase()||"//"===e.substring(0,2))&&(t.crossOrigin="anonymous"),t.src=e)}},this.setMaxDimensions=function(e,t){if(w=[e,t],null!==g){var i=l.canvas.width,r=l.canvas.height,n=[g.width,g.height],o=g.width/g.height,a=n;a[0]>w[0]?(a[0]=w[0],a[1]=a[0]/o):a[0]<m[0]&&(a[0]=m[0],a[1]=a[0]/o),"fixed-height"===y&&a[1]>w[1]?(a[1]=w[1],a[0]=a[1]*o):a[1]<m[1]&&(a[1]=m[1],a[0]=a[1]*o),s.prop("width",a[0]).prop("height",a[1]),"fixed-height"===y&&s.css({"margin-left":-a[0]/2+"px","margin-top":-a[1]/2+"px"});var h=l.canvas.width/i,c=l.canvas.height/r,f=Math.min(h,c),p=d.getCenterPoint();d.setSize({w:d.getSize().w*f,h:d.getSize().h*f}),d.setCenterPoint({x:p.x*h,y:p.y*c})}else s.prop("width",0).prop("height",0).css({"margin-top":0});u()},this.setAreaMinSize=function(e){angular.isUndefined(e)||(e="number"==typeof e||"string"==typeof e?{w:parseInt(parseInt(e),10),h:parseInt(parseInt(e),10)}:{w:parseInt(e.w,10),h:parseInt(e.h,10)},isNaN(e.w)||isNaN(e.h)||(d.setMinSize(e),u()))},this.setAreaMinRelativeSize=function(e){if(null!==g&&!angular.isUndefined(e)){var t=d.getCanvasSize();"number"==typeof e||"string"==typeof e?(C={w:e,h:e},e={w:t.w/(g.width/parseInt(parseInt(e),10)),h:t.h/(g.height/parseInt(parseInt(e),10))}):(C=e,e={w:t.w/(g.width/parseInt(parseInt(e.w),10)),h:t.h/(g.height/parseInt(parseInt(e.h),10))}),isNaN(e.w)||isNaN(e.h)||(d.setMinSize(e),u())}},this.setAreaInitSize=function(e){angular.isUndefined(e)||(e="number"==typeof e||"string"==typeof e?{w:parseInt(parseInt(e),10),h:parseInt(parseInt(e),10)}:{w:parseInt(e.w,10),h:parseInt(e.h,10)},isNaN(e.w)||isNaN(e.h)||(d.setInitSize(e),u()))},this.setAreaInitCoords=function(e){angular.isUndefined(e)||(e={x:parseInt(e.x,10),y:parseInt(e.y,10)},isNaN(e.x)||isNaN(e.y)||(d.setInitCoords(e),u()))},this.setMaxCanvasDimensions=function(e){if(!angular.isUndefined(e)){var t=[];t="number"==typeof e||"string"==typeof e?[parseInt(parseInt(e),10),parseInt(parseInt(e),10)]:[parseInt(e.w,10),parseInt(e.h,10)],!isNaN(t[0])&&t[0]>0&&t[0]>m[0]&&!isNaN(t[1])&&t[1]>0&&t[1]>m[1]&&(w=t)}},this.setMinCanvasDimensions=function(e){if(!angular.isUndefined(e)){var t=[];t="number"==typeof e||"string"==typeof e?[parseInt(parseInt(e),10),parseInt(parseInt(e),10)]:[parseInt(e.w,10),parseInt(e.h,10)],!isNaN(t[0])&&t[0]>=0&&!isNaN(t[1])&&t[1]>=0&&(m=t)}},this.setScalemode=function(e){y=e},this.getScalemode=function(){return y},this.getResultImageSize=function(){if("selection"===_)return d.getSize();if("max"===_){var e=1;g&&l&&l.canvas&&(e=g.width/l.canvas.width);var t={w:e*d.getSize().w,h:e*d.getSize().h};return C&&(t.w<C.w&&(t.w=C.w),t.h<C.h&&(t.h=C.h)),t}return _},this.setResultImageSize=function(e){if(angular.isArray(e))return S=e.slice(),e={w:parseInt(e[0].w,10),h:parseInt(e[0].h,10)},void 0;if(!angular.isUndefined(e)){if(angular.isString(e))return _=e,void 0;angular.isNumber(e)&&(e=parseInt(e,10),e={w:e,h:e}),e={w:parseInt(e.w,10),h:parseInt(e.h,10)},isNaN(e.w)||isNaN(e.h)||(_=e,u())}},this.setResultImageFormat=function(e){z=e},this.setResultImageQuality=function(e){e=parseFloat(e),!isNaN(e)&&e>=0&&1>=e&&(I=e)},this.getAreaType=function(){return d.getType()},this.setAreaType=function(e){var t=d.getCenterPoint(),o=d.getSize(),a=d.getMinSize(),s=t.x,h=t.y,f=i;"square"===e?f=r:"rectangle"===e&&(f=n),d=new f(l,c),d.setMinSize(a),d.setSize(o),"square"===e||"circle"===e?(x=!0,d.setForceAspectRatio(!0)):(x=!1,d.setForceAspectRatio(!1)),d.setCenterPoint({x:s,y:h}),null!==g&&d.setImage(g),u()},this.getDominantColor=function(e){var i=new Image,r=new ColorThief,n=null,o=t.defer();return i.src=e,i.onload=function(){n=r.getColor(i),o.resolve(n)},o.promise},this.getPalette=function(e){var i=new Image,r=new ColorThief,n=null,o=t.defer();return i.src=e,i.onload=function(){n=r.getPalette(i,colorPaletteLength),o.resolve(n)},o.promise},this.setPaletteColorLength=function(e){colorPaletteLength=e},this.setAspect=function(e){p=!0,d.setAspect(e);var t=d.getMinSize();t.w=t.h*e,d.setMinSize(t);var i=d.getSize();i.w=i.h*e,d.setSize(i)},l=s[0].getContext("2d"),d=new i(l,c),e.on("mousemove",D),s.on("mousedown",P),e.on("mouseup",M),e.on("touchmove",D),s.on("touchstart",P),e.on("touchend",M),this.destroy=function(){e.off("mousemove",D),s.off("mousedown",P),e.off("mouseup",M),e.off("touchmove",D),s.off("touchstart",P),e.off("touchend",M),s.remove()}}}]),e.factory("cropPubSub",[function(){return function(){var e={};this.on=function(t,i){return t.split(" ").forEach(function(t){e[t]||(e[t]=[]),e[t].push(i)}),this},this.trigger=function(t,i){return angular.forEach(e[t],function(e){e.call(null,i)}),this}}}]),e.directive("imgCrop",["$timeout","cropHost","cropPubSub",function(e,t,i){return{restrict:"E",scope:{image:"=",resultImage:"=",resultArrayImage:"=?",resultBlob:"=?",urlBlob:"=?",chargement:"=?",cropject:"=?",maxCanvasDimensions:"=?",minCanvasDimensions:"=?",canvasScalemode:"@?",changeOnFly:"=?",liveView:"=?",initMaxArea:"=?",areaCoords:"=?",areaType:"@",areaMinSize:"=?",areaInitSize:"=?",areaInitCoords:"=?",areaInitIsRelativeToImage:"=?",areaMinRelativeSize:"=?",resultImageSize:"=?",resultImageFormat:"=?",resultImageQuality:"=?",aspectRatio:"=?",allowCropResizeOnCorners:"=?",dominantColor:"=?",paletteColor:"=?",paletteColorLength:"=?",onChange:"&",onLoadBegin:"&",onLoadDone:"&",onLoadError:"&"},template:"<canvas></canvas>",controller:["$scope",function(e){e.events=new i}],link:function(i,r){console.warn("This plugin is deprecated in the name of ui-cropper. You can find it under https://github.com/CrackerakiUA/ui-cropper"),i.liveView&&"boolean"==typeof i.liveView.block?i.liveView.render=function(e){s(i,!0,e)}:i.liveView={block:!1};var n=i.events,o=new t(r.find("canvas"),{},n);i.canvasScalemode?o.setScalemode(i.canvasScalemode):o.setScalemode("fixed-height"),r.addClass(o.getScalemode());var a,s=function(e,t,i){if(""!==e.image&&(!e.liveView.block||t)){var r,n=o.getResultImage();angular.isArray(n)?(r=n[0].dataURI,e.resultArrayImage=n):r=n.dataURI;var s=window.URL||window.webkitURL;a!==r&&(a=r,e.resultImage=r,e.liveView.callback&&e.liveView.callback(r),i&&i(r),o.getResultImageDataBlob().then(function(t){e.resultBlob=t,e.urlBlob=s.createObjectURL(t)}),e.resultImage&&(o.getDominantColor(e.resultImage).then(function(t){e.dominantColor=t}),o.getPalette(e.resultImage).then(function(t){e.paletteColor=t})),h(e),e.onChange({$dataURI:e.resultImage}))}},h=function(e){e.areaCoords=o.getAreaCoords()},c=function(e){var t=o.getAreaCoords(),i={x:o.getArea().getImage().width/o.getArea().getCanvasSize().w+50,y:o.getArea().getImage().height/o.getArea().getCanvasSize().h+50};e.cropject={canvasSize:o.getArea().getCanvasSize(),areaCoords:t,cropWidth:t.w,cropHeight:t.h,cropTop:t.y,cropLeft:t.x,cropImageWidth:Math.round(t.w*i.x),cropImageHeight:Math.round(t.h*i.y),cropImageTop:Math.round(t.y*i.y),cropImageLeft:Math.round(t.x*i.x)}},u=function(t){return function(){e(function(){i.$apply(function(e){t(e)})})}},l=function(){var e=window.navigator.userLanguage||window.navigator.language;switch(e){case"nl":case"nl_NL":return"Aan het laden";case"fr":case"fr-FR":return"Chargement";case"es":case"es-ES":return"Cargando";case"ca":case"ca-ES":return"Càrrega";case"de":case"de-DE":return"Laden";default:return"Loading"}};i.chargement||(i.chargement=l());var g=function(){r.append('<div class="loading"><span>'+i.chargement+"...</span></div>")};n.on("load-start",u(function(e){e.onLoadBegin({})})).on("load-done",u(function(e){var t=r.children();angular.forEach(t,function(e){angular.element(e).hasClass("loading")&&angular.element(e).remove()}),c(e),e.onLoadDone({})})).on("load-error",u(function(e){e.onLoadError({})})).on("area-move area-resize",u(function(e){e.changeOnFly&&s(e),c(e)})).on("image-updated",u(function(e){o.setAreaMinRelativeSize(e.areaMinRelativeSize)})).on("area-move-end area-resize-end image-updated",u(function(e){s(e),c(e)})),i.$watch("image",function(t){t&&g(),i.timeout&&e.cancel(i.timeout),i.timeout=e(function(){i.timeout=null,o.setInitMax(i.initMaxArea),o.setNewImageSource(i.image)},100)}),i.$watch("areaType",function(){o.setAreaType(i.areaType),s(i)}),i.$watch("areaMinSize",function(){o.setAreaMinSize(i.areaMinSize),s(i)}),i.$watch("areaMinRelativeSize",function(){""!==i.image&&(o.setAreaMinRelativeSize(i.areaMinRelativeSize),s(i))}),i.$watch("areaInitSize",function(){o.setAreaInitSize(i.areaInitSize),s(i)}),i.$watch("areaInitCoords",function(){o.setAreaInitCoords(i.areaInitCoords),o.areaInitIsRelativeToImage=i.areaInitIsRelativeToImage,s(i)}),i.$watch("maxCanvasDimensions",function(){o.setMaxCanvasDimensions(i.maxCanvasDimensions)}),i.$watch("minCanvasDimensions",function(){o.setMinCanvasDimensions(i.minCanvasDimensions)}),i.$watch("resultImageFormat",function(){o.setResultImageFormat(i.resultImageFormat),s(i)}),i.$watch("resultImageQuality",function(){o.setResultImageQuality(i.resultImageQuality),s(i)}),i.$watch("resultImageSize",function(){o.setResultImageSize(i.resultImageSize),s(i)}),i.$watch("paletteColorLength",function(){o.setPaletteColorLength(i.paletteColorLength)}),i.$watch("aspectRatio",function(){"string"==typeof i.aspectRatio&&""!==i.aspectRatio&&(i.aspectRatio=parseInt(i.aspectRatio)),i.aspectRatio&&o.setAspect(i.aspectRatio)}),i.$watch("allowCropResizeOnCorners",function(){i.allowCropResizeOnCorners&&o.setAllowCropResizeOnCorners(i.allowCropResizeOnCorners)}),i.$watch(function(){return"fixed-height"===o.getScalemode()?[r[0].clientWidth,r[0].clientHeight]:"full-width"===o.getScalemode()?r[0].clientWidth:void 0},function(e){"fixed-height"===o.getScalemode()&&e[0]>0&&e[1]>0&&(o.setMaxDimensions(e[0],e[1]),s(i)),"full-width"===o.getScalemode()&&e>0&&o.setMaxDimensions(e)},!0),i.$on("$destroy",function(){o.destroy()})}}}])}(),function(e){"use strict";var t,i=e.Uint8Array,r=e.HTMLCanvasElement,n=r&&r.prototype,o=/\s*;\s*base64\s*(?:;|$)/i,a="toDataURL",s=function(e){for(var r,n,o,a=e.length,s=new i(a/4*3|0),h=0,c=0,u=[0,0],l=0,g=0;a--;)n=e.charCodeAt(h++),r=t[n-43],255!==r&&r!==o&&(u[1]=u[0],u[0]=n,g=g<<6|r,l++,4===l&&(s[c++]=g>>>16,61!==u[1]&&(s[c++]=g>>>8),61!==u[0]&&(s[c++]=g),l=0));return s};i&&(t=new i([62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,0,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51])),r&&!n.toBlob&&(n.toBlob=function(e,t){if(t||(t="image/png"),this.mozGetAsFile)return e(this.mozGetAsFile("canvas",t)),void 0;if(this.msToBlob&&/^\s*image\/png\s*(?:$|;)/i.test(t))return e(this.msToBlob()),void 0;var r,n=Array.prototype.slice.call(arguments,1),h=this[a].apply(this,n),c=h.indexOf(","),u=h.substring(c+1),l=o.test(h.substring(0,c));Blob.fake?(r=new Blob,r.encoding=l?"base64":"URI",r.data=u,r.size=u.length):i&&(r=l?new Blob([s(u)],{type:t}):new Blob([decodeURIComponent(u)],{type:t})),"undefined"!=typeof e&&e(r)},n.toBlobHD=n.toDataURLHD?function(){a="toDataURLHD";var e=this.toBlob();return a="toDataURL",e}:n.toBlob)}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||this.content||this),function(){var e=function(e){this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),document.body.appendChild(this.canvas),this.width=this.canvas.width=e.width,this.height=this.canvas.height=e.height,this.context.drawImage(e,0,0,this.width,this.height)};e.prototype.clear=function(){this.context.clearRect(0,0,this.width,this.height)},e.prototype.update=function(e){this.context.putImageData(e,0,0)},e.prototype.getPixelCount=function(){return this.width*this.height},e.prototype.getImageData=function(){return this.context.getImageData(0,0,this.width,this.height)},e.prototype.removeCanvas=function(){this.canvas.parentNode.removeChild(this.canvas)};var t=function(){};if(t.prototype.getColor=function(e,t){var i=this.getPalette(e,5,t),r=i[0];return r},t.prototype.getPalette=function(t,i,n){"undefined"==typeof i&&(i=10),("undefined"==typeof n||1>n)&&(n=10);for(var o,a,s,h,c,u=new e(t),l=u.getImageData(),g=l.data,d=u.getPixelCount(),f=[],p=0;d>p;p+=n)o=4*p,a=g[o+0],s=g[o+1],h=g[o+2],c=g[o+3],c>=125&&(a>250&&s>250&&h>250||f.push([a,s,h]));var v=r.quantize(f,i),m=v?v.palette():null;return u.removeCanvas(),m},!i)var i={map:function(e,t){var i={};return t?e.map(function(e,r){return i.index=r,t.call(i,e)}):e.slice()},naturalOrder:function(e,t){return t>e?-1:e>t?1:0},sum:function(e,t){var i={};return e.reduce(t?function(e,r,n){return i.index=n,e+t.call(i,r)}:function(e,t){return e+t},0)},max:function(e,t){return Math.max.apply(null,t?i.map(e,t):e)}};var r=function(){function e(e,t,i){return(e<<2*c)+(t<<c)+i}function t(e){function t(){i.sort(e),r=!0}var i=[],r=!1;return{push:function(e){i.push(e),r=!1},peek:function(e){return r||t(),void 0===e&&(e=i.length-1),i[e]},pop:function(){return r||t(),i.pop()},size:function(){return i.length},map:function(e){return i.map(e)},debug:function(){return r||t(),i}}}function r(e,t,i,r,n,o,a){var s=this;s.r1=e,s.r2=t,s.g1=i,s.g2=r,s.b1=n,s.b2=o,s.histo=a}function n(){this.vboxes=new t(function(e,t){return i.naturalOrder(e.vbox.count()*e.vbox.volume(),t.vbox.count()*t.vbox.volume())})}function o(t){var i,r,n,o,a=1<<3*c,s=new Array(a);return t.forEach(function(t){r=t[0]>>u,n=t[1]>>u,o=t[2]>>u,i=e(r,n,o),s[i]=(s[i]||0)+1}),s}function a(e,t){var i,n,o,a=1e6,s=0,h=1e6,c=0,l=1e6,g=0;return e.forEach(function(e){i=e[0]>>u,n=e[1]>>u,o=e[2]>>u,a>i?a=i:i>s&&(s=i),h>n?h=n:n>c&&(c=n),l>o?l=o:o>g&&(g=o)}),new r(a,s,h,c,l,g,t)}function s(t,r){function n(e){var t,i,n,o,a,s=e+"1",h=e+"2",u=0;for(c=r[s];c<=r[h];c++)if(p[c]>f/2){for(n=r.copy(),o=r.copy(),t=c-r[s],i=r[h]-c,a=i>=t?Math.min(r[h]-1,~~(c+i/2)):Math.max(r[s],~~(c-1-t/2));!p[a];)a++;for(u=v[a];!u&&p[a-1];)u=v[--a];return n[h]=a,o[s]=n[h]+1,[n,o]}}if(r.count()){var o=r.r2-r.r1+1,a=r.g2-r.g1+1,s=r.b2-r.b1+1,h=i.max([o,a,s]);if(1==r.count())return[r.copy()];var c,u,l,g,d,f=0,p=[],v=[];if(h==o)for(c=r.r1;c<=r.r2;c++){for(g=0,u=r.g1;u<=r.g2;u++)for(l=r.b1;l<=r.b2;l++)d=e(c,u,l),g+=t[d]||0;f+=g,p[c]=f}else if(h==a)for(c=r.g1;c<=r.g2;c++){for(g=0,u=r.r1;u<=r.r2;u++)for(l=r.b1;l<=r.b2;l++)d=e(u,c,l),g+=t[d]||0;f+=g,p[c]=f}else for(c=r.b1;c<=r.b2;c++){for(g=0,u=r.r1;u<=r.r2;u++)for(l=r.g1;l<=r.g2;l++)d=e(u,l,c),g+=t[d]||0;f+=g,p[c]=f}return p.forEach(function(e,t){v[t]=f-e}),h==o?n("r"):h==a?n("g"):n("b")}}function h(e,r){function h(e,t){for(var i,r=1,n=0;l>n;)if(i=e.pop(),i.count()){var o=s(c,i),a=o[0],h=o[1];if(!a)return;if(e.push(a),h&&(e.push(h),r++),r>=t)return;if(n++>l)return}else e.push(i),n++}if(!e.length||2>r||r>256)return!1;var c=o(e),u=0;c.forEach(function(){u++});var d=a(e,c),f=new t(function(e,t){return i.naturalOrder(e.count(),t.count())});f.push(d),h(f,g*r);for(var p=new t(function(e,t){return i.naturalOrder(e.count()*e.volume(),t.count()*t.volume())});f.size();)p.push(f.pop());h(p,r-p.size());for(var v=new n;p.size();)v.push(p.pop());return v}var c=5,u=8-c,l=1e3,g=.75;return r.prototype={volume:function(e){var t=this;return(!t._volume||e)&&(t._volume=(t.r2-t.r1+1)*(t.g2-t.g1+1)*(t.b2-t.b1+1)),t._volume},count:function(t){var i=this,r=i.histo;if(!i._count_set||t){var n,o,a,s=0;for(n=i.r1;n<=i.r2;n++)for(o=i.g1;o<=i.g2;o++)for(a=i.b1;a<=i.b2;a++)index=e(n,o,a),s+=r[index]||0;i._count=s,i._count_set=!0}return i._count},copy:function(){var e=this;return new r(e.r1,e.r2,e.g1,e.g2,e.b1,e.b2,e.histo)},avg:function(t){var i=this,r=i.histo;if(!i._avg||t){var n,o,a,s,h,u=0,l=1<<8-c,g=0,d=0,f=0;for(o=i.r1;o<=i.r2;o++)for(a=i.g1;a<=i.g2;a++)for(s=i.b1;s<=i.b2;s++)h=e(o,a,s),n=r[h]||0,u+=n,g+=n*(o+.5)*l,d+=n*(a+.5)*l,f+=n*(s+.5)*l;i._avg=u?[~~(g/u),~~(d/u),~~(f/u)]:[~~(l*(i.r1+i.r2+1)/2),~~(l*(i.g1+i.g2+1)/2),~~(l*(i.b1+i.b2+1)/2)]}return i._avg},contains:function(e){var t=this,i=e[0]>>u;return gval=e[1]>>u,bval=e[2]>>u,i>=t.r1&&i<=t.r2&&gval>=t.g1&&gval<=t.g2&&bval>=t.b1&&bval<=t.b2}},n.prototype={push:function(e){this.vboxes.push({vbox:e,color:e.avg()})},palette:function(){return this.vboxes.map(function(e){return e.color})},size:function(){return this.vboxes.size()},map:function(e){for(var t=this.vboxes,i=0;i<t.size();i++)if(t.peek(i).vbox.contains(e))return t.peek(i).color;return this.nearest(e)},nearest:function(e){for(var t,i,r,n=this.vboxes,o=0;o<n.size();o++)i=Math.sqrt(Math.pow(e[0]-n.peek(o).color[0],2)+Math.pow(e[1]-n.peek(o).color[1],2)+Math.pow(e[2]-n.peek(o).color[2],2)),(t>i||void 0===t)&&(t=i,r=n.peek(o).color);return r},forcebw:function(){var e=this.vboxes;e.sort(function(e,t){return i.naturalOrder(i.sum(e.color),i.sum(t.color))});var t=e[0].color;t[0]<5&&t[1]<5&&t[2]<5&&(e[0].color=[0,0,0]);var r=e.length-1,n=e[r].color;n[0]>251&&n[1]>251&&n[2]>251&&(e[r].color=[255,255,255])}},{quantize:h}}();"function"==typeof define&&define.amd?define([],function(){return t}):"object"==typeof exports?module.exports=t:this.ColorThief=t}.call(this),function(){function e(e){return!!e.exifdata}function t(e,t){t=t||e.match(/^data\:([^\;]+)\;base64,/im)[1]||"",e=e.replace(/^data\:([^\;]+)\;base64,/gim,"");for(var i=atob(e),r=i.length,n=new ArrayBuffer(r),o=new Uint8Array(n),a=0;r>a;a++)o[a]=i.charCodeAt(a);return n}function i(e,t){var i=new XMLHttpRequest;i.open("GET",e,!0),i.responseType="blob",i.onload=function(){(200==this.status||0===this.status)&&t(this.response)},i.send()}function r(e,r){function n(t){var i=o(t),n=a(t);e.exifdata=i||{},e.iptcdata=n||{},r&&r.call(e)}if(e.src)if(/^data\:/i.test(e.src)){var s=t(e.src);n(s)}else if(/^blob\:/i.test(e.src)){var h=new FileReader;h.onload=function(e){n(e.target.result)},i(e.src,function(e){h.readAsArrayBuffer(e)})}else{var c=new XMLHttpRequest;c.onload=function(){if(200!=this.status&&0!==this.status)throw"Could not load image";n(c.response),c=null},c.open("GET",e.src,!0),c.responseType="arraybuffer",c.send(null)}else if(window.FileReader&&(e instanceof window.Blob||e instanceof window.File)){var h=new FileReader;h.onload=function(e){g&&console.log("Got file of length "+e.target.result.byteLength),n(e.target.result)},h.readAsArrayBuffer(e)}}function o(e){var t=new DataView(e);if(g&&console.log("Got file of length "+e.byteLength),255!=t.getUint8(0)||216!=t.getUint8(1))return g&&console.log("Not a valid JPEG"),!1;for(var i,r=2,n=e.byteLength;n>r;){if(255!=t.getUint8(r))return g&&console.log("Not a valid marker at offset "+r+", found: "+t.getUint8(r)),!1;if(i=t.getUint8(r+1),g&&console.log(i),225==i)return g&&console.log("Found 0xFFE1 marker"),l(t,r+4,t.getUint16(r+2)-2);r+=2+t.getUint16(r+2)}}function a(e){var t=new DataView(e);if(g&&console.log("Got file of length "+e.byteLength),255!=t.getUint8(0)||216!=t.getUint8(1))return g&&console.log("Not a valid JPEG"),!1;for(var i=2,r=e.byteLength,n=function(e,t){return 56===e.getUint8(t)&&66===e.getUint8(t+1)&&73===e.getUint8(t+2)&&77===e.getUint8(t+3)&&4===e.getUint8(t+4)&&4===e.getUint8(t+5)};r>i;){if(n(t,i)){var o=t.getUint8(i+7);o%2!==0&&(o+=1),0===o&&(o=4);var a=i+8+o,h=t.getUint16(i+6+o);return s(e,a,h)}i++}}function s(e,t,i){for(var r,n,o,a,s,h=new DataView(e),c={},l=t;t+i>l;)28===h.getUint8(l)&&2===h.getUint8(l+1)&&(a=h.getUint8(l+2),a in y&&(o=h.getInt16(l+3),s=o+5,n=y[a],r=u(h,l+5,o),c.hasOwnProperty(n)?c[n]instanceof Array?c[n].push(r):c[n]=[c[n],r]:c[n]=r)),l++;return c}function h(e,t,i,r,n){var o,a,s,h=e.getUint16(i,!n),u={};for(s=0;h>s;s++)o=i+12*s+2,a=r[e.getUint16(o,!n)],!a&&g&&console.log("Unknown tag: "+e.getUint16(o,!n)),u[a]=c(e,o,t,i,n);return u}function c(e,t,i,r,n){var o,a,s,h,c,l,g=e.getUint16(t+2,!n),d=e.getUint32(t+4,!n),f=e.getUint32(t+8,!n)+i;switch(g){case 1:case 7:if(1==d)return e.getUint8(t+8,!n);for(o=d>4?f:t+8,a=[],h=0;d>h;h++)a[h]=e.getUint8(o+h);return a;case 2:return o=d>4?f:t+8,u(e,o,d-1);case 3:if(1==d)return e.getUint16(t+8,!n);for(o=d>2?f:t+8,a=[],h=0;d>h;h++)a[h]=e.getUint16(o+2*h,!n);return a;case 4:if(1==d)return e.getUint32(t+8,!n);for(a=[],h=0;d>h;h++)a[h]=e.getUint32(f+4*h,!n);return a;case 5:if(1==d)return c=e.getUint32(f,!n),l=e.getUint32(f+4,!n),s=new Number(c/l),s.numerator=c,s.denominator=l,s;for(a=[],h=0;d>h;h++)c=e.getUint32(f+8*h,!n),l=e.getUint32(f+4+8*h,!n),a[h]=new Number(c/l),a[h].numerator=c,a[h].denominator=l;return a;case 9:if(1==d)return e.getInt32(t+8,!n);for(a=[],h=0;d>h;h++)a[h]=e.getInt32(f+4*h,!n);return a;case 10:if(1==d)return e.getInt32(f,!n)/e.getInt32(f+4,!n);for(a=[],h=0;d>h;h++)a[h]=e.getInt32(f+8*h,!n)/e.getInt32(f+4+8*h,!n);return a}}function u(e,t,i){var r="";for(n=t;t+i>n;n++)r+=String.fromCharCode(e.getUint8(n));return r}function l(e,t){if("Exif"!=u(e,t,4))return g&&console.log("Not valid EXIF data! "+u(e,t,4)),!1;var i,r,n,o,a,s=t+6;if(18761==e.getUint16(s))i=!1;else{if(19789!=e.getUint16(s))return g&&console.log("Not valid TIFF data! (no 0x4949 or 0x4D4D)"),!1;i=!0}if(42!=e.getUint16(s+2,!i))return g&&console.log("Not valid TIFF data! (no 0x002A)"),!1;var c=e.getUint32(s+4,!i);if(8>c)return g&&console.log("Not valid TIFF data! (First offset less than 8)",e.getUint32(s+4,!i)),!1;if(r=h(e,s,s+c,v,i),r.ExifIFDPointer){o=h(e,s,s+r.ExifIFDPointer,p,i);for(n in o){switch(n){case"LightSource":case"Flash":case"MeteringMode":case"ExposureProgram":case"SensingMethod":case"SceneCaptureType":case"SceneType":case"CustomRendered":case"WhiteBalance":case"GainControl":case"Contrast":case"Saturation":case"Sharpness":case"SubjectDistanceRange":case"FileSource":o[n]=w[n][o[n]];break;case"ExifVersion":case"FlashpixVersion":o[n]=String.fromCharCode(o[n][0],o[n][1],o[n][2],o[n][3]);break;case"ComponentsConfiguration":o[n]=w.Components[o[n][0]]+w.Components[o[n][1]]+w.Components[o[n][2]]+w.Components[o[n][3]]}r[n]=o[n]}}if(r.GPSInfoIFDPointer){a=h(e,s,s+r.GPSInfoIFDPointer,m,i);for(n in a){switch(n){case"GPSVersionID":a[n]=a[n][0]+"."+a[n][1]+"."+a[n][2]+"."+a[n][3]}r[n]=a[n]}}return r}var g=!1,d=this,f=function(e){return e instanceof f?e:this instanceof f?(this.EXIFwrapped=e,void 0):new f(e)};"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=f),exports.EXIF=f):d.EXIF=f;var p=f.Tags={36864:"ExifVersion",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37500:"MakerNote",37510:"UserComment",40964:"RelatedSoundFile",36867:"DateTimeOriginal",36868:"DateTimeDigitized",37520:"SubsecTime",37521:"SubsecTimeOriginal",37522:"SubsecTimeDigitized",33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"ISOSpeedRatings",34856:"OECF",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBias",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37396:"SubjectArea",37386:"FocalLength",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRation",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",40965:"InteroperabilityIFDPointer",42016:"ImageUniqueID"},v=f.TiffTags={256:"ImageWidth",257:"ImageHeight",34665:"ExifIFDPointer",34853:"GPSInfoIFDPointer",40965:"InteroperabilityIFDPointer",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",274:"Orientation",277:"SamplesPerPixel",284:"PlanarConfiguration",530:"YCbCrSubSampling",531:"YCbCrPositioning",282:"XResolution",283:"YResolution",296:"ResolutionUnit",273:"StripOffsets",278:"RowsPerStrip",279:"StripByteCounts",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",301:"TransferFunction",318:"WhitePoint",319:"PrimaryChromaticities",529:"YCbCrCoefficients",532:"ReferenceBlackWhite",306:"DateTime",270:"ImageDescription",271:"Make",272:"Model",305:"Software",315:"Artist",33432:"Copyright"},m=f.GPSTags={0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential"},w=f.StringValues={ExposureProgram:{0:"Not defined",1:"Manual",2:"Normal program",3:"Aperture priority",4:"Shutter priority",5:"Creative program",6:"Action program",7:"Portrait mode",8:"Landscape mode"},MeteringMode:{0:"Unknown",1:"Average",2:"CenterWeightedAverage",3:"Spot",4:"MultiSpot",5:"Pattern",6:"Partial",255:"Other"},LightSource:{0:"Unknown",1:"Daylight",2:"Fluorescent",3:"Tungsten (incandescent light)",4:"Flash",9:"Fine weather",10:"Cloudy weather",11:"Shade",12:"Daylight fluorescent (D 5700 - 7100K)",13:"Day white fluorescent (N 4600 - 5400K)",14:"Cool white fluorescent (W 3900 - 4500K)",15:"White fluorescent (WW 3200 - 3700K)",17:"Standard light A",18:"Standard light B",19:"Standard light C",20:"D55",21:"D65",22:"D75",23:"D50",24:"ISO studio tungsten",255:"Other"},Flash:{0:"Flash did not fire",1:"Flash fired",5:"Strobe return light not detected",7:"Strobe return light detected",9:"Flash fired, compulsory flash mode",13:"Flash fired, compulsory flash mode, return light not detected",15:"Flash fired, compulsory flash mode, return light detected",16:"Flash did not fire, compulsory flash mode",24:"Flash did not fire, auto mode",25:"Flash fired, auto mode",29:"Flash fired, auto mode, return light not detected",31:"Flash fired, auto mode, return light detected",32:"No flash function",65:"Flash fired, red-eye reduction mode",69:"Flash fired, red-eye reduction mode, return light not detected",71:"Flash fired, red-eye reduction mode, return light detected",73:"Flash fired, compulsory flash mode, red-eye reduction mode",77:"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",79:"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",89:"Flash fired, auto mode, red-eye reduction mode",93:"Flash fired, auto mode, return light not detected, red-eye reduction mode",95:"Flash fired, auto mode, return light detected, red-eye reduction mode"},SensingMethod:{1:"Not defined",2:"One-chip color area sensor",3:"Two-chip color area sensor",4:"Three-chip color area sensor",5:"Color sequential area sensor",7:"Trilinear sensor",8:"Color sequential linear sensor"},SceneCaptureType:{0:"Standard",1:"Landscape",2:"Portrait",3:"Night scene"},SceneType:{1:"Directly photographed"},CustomRendered:{0:"Normal process",1:"Custom process"},WhiteBalance:{0:"Auto white balance",1:"Manual white balance"},GainControl:{0:"None",1:"Low gain up",2:"High gain up",3:"Low gain down",4:"High gain down"},Contrast:{0:"Normal",1:"Soft",2:"Hard"},Saturation:{0:"Normal",1:"Low saturation",2:"High saturation"},Sharpness:{0:"Normal",1:"Soft",2:"Hard"},SubjectDistanceRange:{0:"Unknown",1:"Macro",2:"Close view",3:"Distant view"},FileSource:{3:"DSC"},Components:{0:"",1:"Y",2:"Cb",3:"Cr",4:"R",5:"G",6:"B"}},y={120:"caption",110:"credit",25:"keywords",55:"dateCreated",80:"byline",85:"bylineTitle",122:"captionWriter",105:"headline",116:"copyright",15:"category"};f.getData=function(t,i){return(t instanceof Image||t instanceof HTMLImageElement)&&!t.complete?!1:(e(t)?i&&i.call(t):r(t,i),!0)},f.getTag=function(t,i){return e(t)?t.exifdata[i]:void 0},f.getAllTags=function(t){if(!e(t))return{};var i,r=t.exifdata,n={};for(i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);return n},f.pretty=function(t){if(!e(t))return"";var i,r=t.exifdata,n="";for(i in r)r.hasOwnProperty(i)&&(n+="object"==typeof r[i]?r[i]instanceof Number?i+" : "+r[i]+" ["+r[i].numerator+"/"+r[i].denominator+"]\r\n":i+" : ["+r[i].length+" values]\r\n":i+" : "+r[i]+"\r\n");return n},f.readFromBinaryFile=function(e){return o(e)},"function"==typeof define&&define.amd&&define("exif-js",[],function(){return f})}.call(this),function(){function e(e){var t=e.naturalWidth,i=e.naturalHeight;
if(t*i>1048576){var r=document.createElement("canvas");r.width=r.height=1;var n=r.getContext("2d");return n.drawImage(e,-t+1,0),0===n.getImageData(0,0,1,1).data[3]}return!1}function t(e,t,i){var r=document.createElement("canvas");r.width=1,r.height=i;var n=r.getContext("2d");n.drawImage(e,0,0);for(var o=n.getImageData(0,0,1,i).data,a=0,s=i,h=i;h>a;){var c=o[4*(h-1)+3];0===c?s=h:a=h,h=s+a>>1}var u=h/i;return 0===u?1:u}function i(e,t,i){var n=document.createElement("canvas");return r(e,n,t,i),n.toDataURL("image/jpeg",t.quality||.8)}function r(i,r,o,a){var s=i.naturalWidth,h=i.naturalHeight;if(s+h!==!1){var c=o.width,u=o.height,l=r.getContext("2d");l.save(),n(r,l,c,u,o.orientation);var g=e(i);g&&(s/=2,h/=2);var d=1024,f=document.createElement("canvas");f.width=f.height=d;for(var p=f.getContext("2d"),v=a?t(i,s,h):1,m=Math.ceil(d*c/s),w=Math.ceil(d*u/h/v),y=0,S=0;h>y;){for(var _=0,C=0;s>_;)p.clearRect(0,0,d,d),p.drawImage(i,-_,-y),l.drawImage(f,0,0,d,d,C,S,m,w),_+=d,C+=m;y+=d,S+=w}l.restore(),f=p=null}}function n(e,t,i,r,n){switch(n){case 5:case 6:case 7:case 8:e.width=r,e.height=i;break;default:e.width=i,e.height=r}switch(n){case 2:t.translate(i,0),t.scale(-1,1);break;case 3:t.translate(i,r),t.rotate(Math.PI);break;case 4:t.translate(0,r),t.scale(1,-1);break;case 5:t.rotate(.5*Math.PI),t.scale(1,-1);break;case 6:t.rotate(.5*Math.PI),t.translate(0,-r);break;case 7:t.rotate(.5*Math.PI),t.translate(i,-r),t.scale(-1,1);break;case 8:t.rotate(-.5*Math.PI),t.translate(-i,0)}}function o(e){if(window.Blob&&e instanceof Blob){if(!a)throw Error("No createObjectURL function found to create blob url");var t=new Image;t.src=a.createObjectURL(e),this.blob=e,e=t}if(!e.naturalWidth&&!e.naturalHeight){var i=this;e.onload=e.onerror=function(){var e=i.imageLoadListeners;if(e){i.imageLoadListeners=null;for(var t=0,r=e.length;r>t;t++)e[t]()}},this.imageLoadListeners=[]}this.srcImage=e}var a=window.URL&&window.URL.createObjectURL?window.URL:window.webkitURL&&window.webkitURL.createObjectURL?window.webkitURL:null;o.prototype.render=function(e,t,n){if(this.imageLoadListeners){var o=this;return this.imageLoadListeners.push(function(){o.render(e,t,n)}),void 0}t=t||{};var s=this.srcImage.naturalWidth,h=this.srcImage.naturalHeight,c=t.width,u=t.height,l=t.maxWidth,g=t.maxHeight,d=!this.blob||"image/jpeg"===this.blob.type;c&&!u?u=h*c/s<<0:u&&!c?c=s*u/h<<0:(c=s,u=h),l&&c>l&&(c=l,u=h*c/s<<0),g&&u>g&&(u=g,c=s*u/h<<0);var f={width:c,height:u};for(var p in t)f[p]=t[p];var v=e.tagName.toLowerCase();"img"===v?e.src=i(this.srcImage,f,d):"canvas"===v&&r(this.srcImage,e,f,d),"function"==typeof this.onrender&&this.onrender(e),n&&n(),this.blob&&(this.blob=null,a.revokeObjectURL(this.srcImage.src))},"function"==typeof define&&define.amd?define([],function(){return o}):"object"==typeof exports?module.exports=o:this.MegaPixImage=o}();;
/*!
 * angular-spectrum-colorpicker v1.4.2
 * https://github.com/Jimdo/angular-spectrum-colorpicker
 *
 * Angular directive for a colorpicker, that bases on http://bgrins.github.io/spectrum/
 * Idea from http://jsfiddle.net/g/LAJCa/
 *
 * Copyright 2015, Jimdo GmbH
 * Released under the MIT license
 */
(function(angular, undefined) {
  'use strict';

  // src/js/helper.module.js
  var angularSpectrumColorpicker = angular.module('angularSpectrumColorpicker', []);

  // src/js/spectrumColorpicker.directive.js
  (function(undefined) {
    'use strict';
    angularSpectrumColorpicker.directive('spectrumColorpicker', function() {
      return {
        restrict: 'EA',
        require: 'ngModel',
        scope: {
          fallbackValue: '=',
          disabled: '=?',
          format: '=?',
          options: '=?',
          triggerId: '@?',
  		  palette : '=?',
          onChange: '&?',
          onShow: '&?',
          onHide: '&?',
          onMove: '&?',

          onBeforeShow: '&?',
  
  	    onChangeOptions: '=?',
  	    onShowOptions: '=?',
  	    onHideOptions: '=?',
  	    onMoveOptions: '=?'
        },
        replace: true,
        templateUrl: 'directive.html',
        link: function($scope, $element, attrs, $ngModel) {
  
          var $input = $element.find('input');
  
          function formatColor(tiny) {
            var formatted = tiny;
            if (formatted) {
              formatted = tiny.toString($scope.format);
            }
            return formatted;
          }
  
          function callOnChange(color) {
            if (angular.isFunction($scope.onChange)) {
              $scope.onChange({color: color});
            }
          }
  
          function setViewValue(color) {
            var value = $scope.fallbackValue;
  
            if (color) {
              value = formatColor(color);
            } else if (angular.isUndefined($scope.fallbackValue)) {
              value = color;
            }
  
            $ngModel.$setViewValue(value);
            callOnChange(value);
          }
  
          var onChange = function(color) {
            $scope.$evalAsync(function() {
              setViewValue(color);
            });
          };
          var onToggle = function() {
            $input.spectrum('toggle');
            return false;
          };
  
  
          var baseOpts = {
            color: $ngModel.$viewValue
          };
  
          var localOpts = {};
  
              angular.forEach({
                  'change': 'onChange',
                  'move': 'onMove',
                  'hide': 'onHide',
                  'show': 'onShow',
              },
              function (eventHandlerName, eventName) {
                  var spectrumEventHandlerOptions = $scope[eventHandlerName + 'Options'];
                  localOpts[eventName] = function (color) {
                      if (!spectrumEventHandlerOptions || spectrumEventHandlerOptions.update) {
                          onChange(color);
                      }
                      // we don't do this for change, because we expose the current
                      // value actively through the model
                      if (eventHandlerName !== 'change' && angular.isFunction($scope[eventHandlerName])) {
                          return $scope[eventHandlerName]({ color: formatColor(color) });
                      } else {
                          return null;
                      }
                 };
            });
  
          if (angular.isFunction($scope.onBeforeShow)) {
            localOpts.beforeShow = function(color) {
              return $scope.onBeforeShow({color: formatColor(color)});
            };
          }
  
  		if ($scope.palette) {
            localOpts.palette = $scope.palette;
          }
  
          var options = angular.extend({}, baseOpts, $scope.options, localOpts);
  
          if ($scope.triggerId) {
            angular.element(document.body).on('click', '#' + $scope.triggerId, onToggle);
          }
  
          $ngModel.$render = function() {
            $input.spectrum('set', $ngModel.$viewValue || '');
            callOnChange($ngModel.$viewValue);
          };
  
          if (options.color) {
            $input.spectrum('set', options.color || '');
            setViewValue(options.color);
          }
  
  		$input.spectrum(options);
  
          $scope.$on('$destroy', function() {
            if ($scope.triggerId) {
              angular.element(document.body).off('click', '#' + $scope.triggerId, onToggle);
            }
          });
  		$element.on('$destroy', function(){
  			$input.spectrum('destroy');
  		});
  
          if(angular.isDefined(options.disabled)) {
            $scope.disabled = !!options.disabled;
          }
  
          $scope.$watch('disabled', function (newDisabled) {
            $input.spectrum(newDisabled ? 'disable' : 'enable');
          });
  
  		$scope.$watch('palette', function (palette) {
  		  $input.spectrum('option', 'palette', palette);
  		});
        }
      };
    });
  })();

  // .tmp/all-partials.js
  angular.module('angularSpectrumColorpicker').run(['$templateCache', function($templateCache) {
    'use strict';
  
    $templateCache.put('directive.html',
      "<span><input class=\"input-small\"></span>"
    );
  
  }]);
})(window.angular);
;
(function (root, factory) {
    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['angular'], factory);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = factory(require('angular'));
    } else {
        root.angularClipboard = factory(root.angular);
  }
}(this, function (angular) {

return angular.module('angular-clipboard', [])
    .factory('clipboard', ['$document', '$window', function ($document, $window) {
        function createNode(text, context) {
            var node = $document[0].createElement('textarea');
            node.style.position = 'absolute';
            node.textContent = text;
            node.style.left = '-10000px';
            node.style.top = ($window.pageYOffset || $document[0].documentElement.scrollTop) + 'px';
            return node;
        }

        function copyNode(node) {
            try {
                // Set inline style to override css styles
                $document[0].body.style.webkitUserSelect = 'initial';

                var selection = $document[0].getSelection();
                selection.removeAllRanges();
                node.select();

                if(!$document[0].execCommand('copy')) {
                    throw('failure copy');
                }
                selection.removeAllRanges();
            } finally {
                // Reset inline style
                $document[0].body.style.webkitUserSelect = '';
            }
        }

        function copyText(text, context) {
            var node = createNode(text, context);
            $document[0].body.appendChild(node);
            copyNode(node);
            $document[0].body.removeChild(node);
        }

        return {
            copyText: copyText,
            supported: 'queryCommandSupported' in $document[0] && $document[0].queryCommandSupported('copy')
        };
    }])
    .directive('clipboard', ['clipboard', function (clipboard) {
        return {
            restrict: 'A',
            scope: {
                onCopied: '&',
                onError: '&',
                text: '=',
                supported: '=?'
            },
            link: function (scope, element) {
                scope.supported = clipboard.supported;

                element.on('click', function (event) {
                    try {
                        clipboard.copyText(scope.text, element[0]);
                        if (angular.isFunction(scope.onCopied)) {
                            scope.$evalAsync(scope.onCopied());
                        }
                    } catch (err) {
                        if (angular.isFunction(scope.onError)) {
                            scope.$evalAsync(scope.onError({err: err}));
                        }
                    }
                });
            }
        };
    }]);

}));
;
/*! angularjs-slider - v6.2.3 - 
 (c) Rafal Zajac <rzajac@gmail.com>, Valentin Hervieu <valentin@hervieu.me>, Jussi Saarivirta <jusasi@gmail.com>, Angelin Sirbu <angelin.sirbu@gmail.com> - 
 https://github.com/angular-slider/angularjs-slider - 
 2017-07-08 */
/*jslint unparam: true */
/*global angular: false, console: false, define, module */
(function(root, factory) {
  'use strict';
  /* istanbul ignore next */
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['angular'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    // to support bundler like browserify
    var angularObj = angular || require('angular');
    if ((!angularObj || !angularObj.module) && typeof angular != 'undefined') {
      angularObj = angular;
    }
    module.exports = factory(angularObj);
  } else {
    // Browser globals (root is window)
    factory(root.angular);
  }

}(this, function(angular) {
  'use strict';
  var module = angular.module('rzModule', [])

  .factory('RzSliderOptions', function() {
    var defaultOptions = {
      floor: 0,
      ceil: null, //defaults to rz-slider-model
      step: 1,
      precision: 0,
      minRange: null,
      maxRange: null,
      pushRange: false,
      minLimit: null,
      maxLimit: null,
      id: null,
      translate: null,
      getLegend: null,
      stepsArray: null,
      bindIndexForStepsArray: false,
      draggableRange: false,
      draggableRangeOnly: false,
      showSelectionBar: false,
      showSelectionBarEnd: false,
      showSelectionBarFromValue: null,
      hidePointerLabels: false,
      hideLimitLabels: false,
      autoHideLimitLabels: true,
      readOnly: false,
      disabled: false,
      interval: 350,
      showTicks: false,
      showTicksValues: false,
      ticksArray: null,
      ticksTooltip: null,
      ticksValuesTooltip: null,
      vertical: false,
      getSelectionBarColor: null,
      getTickColor: null,
      getPointerColor: null,
      keyboardSupport: true,
      scale: 1,
      enforceStep: true,
      enforceRange: false,
      noSwitching: false,
      onlyBindHandles: false,
      onStart: null,
      onChange: null,
      onEnd: null,
      rightToLeft: false,
      boundPointerLabels: true,
      mergeRangeLabelsIfSame: false,
      customTemplateScope: null,
      logScale: false,
      customValueToPosition: null,
      customPositionToValue: null,
      selectionBarGradient: null,
      ariaLabel: null,
      ariaLabelledBy: null,
      ariaLabelHigh: null,
      ariaLabelledByHigh: null
    };
    var globalOptions = {};

    var factory = {};
    /**
     * `options({})` allows global configuration of all sliders in the
     * application.
     *
     *   var app = angular.module( 'App', ['rzModule'], function( RzSliderOptions ) {
     *     // show ticks for all sliders
     *     RzSliderOptions.options( { showTicks: true } );
     *   });
     */
    factory.options = function(value) {
      angular.extend(globalOptions, value);
    };

    factory.getOptions = function(options) {
      return angular.extend({}, defaultOptions, globalOptions, options);
    };

    return factory;
  })

  .factory('rzThrottle', ['$timeout', function($timeout) {
    /**
     * rzThrottle
     *
     * Taken from underscore project
     *
     * @param {Function} func
     * @param {number} wait
     * @param {ThrottleOptions} options
     * @returns {Function}
     */
    return function(func, wait, options) {
      'use strict';
      /* istanbul ignore next */
      var getTime = (Date.now || function() {
        return new Date().getTime();
      });
      var context, args, result;
      var timeout = null;
      var previous = 0;
      options = options || {};
      var later = function() {
        previous = getTime();
        timeout = null;
        result = func.apply(context, args);
        context = args = null;
      };
      return function() {
        var now = getTime();
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0) {
          $timeout.cancel(timeout);
          timeout = null;
          previous = now;
          result = func.apply(context, args);
          context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = $timeout(later, remaining);
        }
        return result;
      };
    }
  }])

  .factory('RzSlider', ['$timeout', '$document', '$window', '$compile', 'RzSliderOptions', 'rzThrottle', function($timeout, $document, $window, $compile, RzSliderOptions, rzThrottle) {
    'use strict';

    /**
     * Slider
     *
     * @param {ngScope} scope            The AngularJS scope
     * @param {Element} sliderElem The slider directive element wrapped in jqLite
     * @constructor
     */
    var Slider = function(scope, sliderElem) {
      /**
       * The slider's scope
       *
       * @type {ngScope}
       */
      this.scope = scope;

      /**
       * The slider inner low value (linked to rzSliderModel)
       * @type {number}
       */
      this.lowValue = 0;

      /**
       * The slider inner high value (linked to rzSliderHigh)
       * @type {number}
       */
      this.highValue = 0;

      /**
       * Slider element wrapped in jqLite
       *
       * @type {jqLite}
       */
      this.sliderElem = sliderElem;

      /**
       * Slider type
       *
       * @type {boolean} Set to true for range slider
       */
      this.range = this.scope.rzSliderModel !== undefined && this.scope.rzSliderHigh !== undefined;

      /**
       * Values recorded when first dragging the bar
       *
       * @type {Object}
       */
      this.dragging = {
        active: false,
        value: 0,
        difference: 0,
        position: 0,
        lowLimit: 0,
        highLimit: 0
      };

      /**
       * property that handle position (defaults to left for horizontal)
       * @type {string}
       */
      this.positionProperty = 'left';

      /**
       * property that handle dimension (defaults to width for horizontal)
       * @type {string}
       */
      this.dimensionProperty = 'width';

      /**
       * Half of the width or height of the slider handles
       *
       * @type {number}
       */
      this.handleHalfDim = 0;

      /**
       * Maximum position the slider handle can have
       *
       * @type {number}
       */
      this.maxPos = 0;

      /**
       * Precision
       *
       * @type {number}
       */
      this.precision = 0;

      /**
       * Step
       *
       * @type {number}
       */
      this.step = 1;

      /**
       * The name of the handle we are currently tracking
       *
       * @type {string}
       */
      this.tracking = '';

      /**
       * Minimum value (floor) of the model
       *
       * @type {number}
       */
      this.minValue = 0;

      /**
       * Maximum value (ceiling) of the model
       *
       * @type {number}
       */
      this.maxValue = 0;


      /**
       * The delta between min and max value
       *
       * @type {number}
       */
      this.valueRange = 0;


      /**
       * If showTicks/showTicksValues options are number.
       * In this case, ticks values should be displayed below the slider.
       * @type {boolean}
       */
      this.intermediateTicks = false;

      /**
       * Set to true if init method already executed
       *
       * @type {boolean}
       */
      this.initHasRun = false;

      /**
       * Used to call onStart on the first keydown event
       *
       * @type {boolean}
       */
      this.firstKeyDown = false;

      /**
       * Internal flag to prevent watchers to be called when the sliders value are modified internally.
       * @type {boolean}
       */
      this.internalChange = false;

      /**
       * Internal flag to keep track of the visibility of combo label
       * @type {boolean}
       */
      this.cmbLabelShown = false;

      /**
       * Internal variable to keep track of the focus element
       */
      this.currentFocusElement = null;

      // Slider DOM elements wrapped in jqLite
      this.fullBar = null; // The whole slider bar
      this.selBar = null; // Highlight between two handles
      this.minH = null; // Left slider handle
      this.maxH = null; // Right slider handle
      this.flrLab = null; // Floor label
      this.ceilLab = null; // Ceiling label
      this.minLab = null; // Label above the low value
      this.maxLab = null; // Label above the high value
      this.cmbLab = null; // Combined label
      this.ticks = null; // The ticks

      // Initialize slider
      this.init();
    };

    // Add instance methods
    Slider.prototype = {

      /**
       * Initialize slider
       *
       * @returns {undefined}
       */
      init: function() {
        var thrLow, thrHigh,
          self = this;

        var calcDimFn = function() {
          self.calcViewDimensions();
        };

        this.applyOptions();
        this.syncLowValue();
        if (this.range)
          this.syncHighValue();
        this.initElemHandles();
        this.manageElementsStyle();
        this.setDisabledState();
        this.calcViewDimensions();
        this.setMinAndMax();
        this.addAccessibility();
        this.updateCeilLab();
        this.updateFloorLab();
        this.initHandles();
        this.manageEventsBindings();

        // Recalculate slider view dimensions
        this.scope.$on('reCalcViewDimensions', calcDimFn);

        // Recalculate stuff if view port dimensions have changed
        angular.element($window).on('resize', calcDimFn);

        this.initHasRun = true;

        // Watch for changes to the model
        thrLow = rzThrottle(function() {
          self.onLowHandleChange();
        }, self.options.interval);

        thrHigh = rzThrottle(function() {
          self.onHighHandleChange();
        }, self.options.interval);

        this.scope.$on('rzSliderForceRender', function() {
          self.resetLabelsValue();
          thrLow();
          if (self.range) {
            thrHigh();
          }
          self.resetSlider();
        });

        // Watchers (order is important because in case of simultaneous change,
        // watchers will be called in the same order)
        this.scope.$watch('rzSliderOptions()', function(newValue, oldValue) {
          if (newValue === oldValue)
            return;
          self.applyOptions(); // need to be called before synchronizing the values
          self.syncLowValue();
          if (self.range)
            self.syncHighValue();
          self.resetSlider();
        }, true);

        this.scope.$watch('rzSliderModel', function(newValue, oldValue) {
          if (self.internalChange)
            return;
          if (newValue === oldValue)
            return;
          thrLow();
        });

        this.scope.$watch('rzSliderHigh', function(newValue, oldValue) {
          if (self.internalChange)
            return;
          if (newValue === oldValue)
            return;
          if (newValue != null)
            thrHigh();
          if (self.range && newValue == null || !self.range && newValue != null) {
            self.applyOptions();
            self.resetSlider();
          }
        });

        this.scope.$on('$destroy', function() {
          self.unbindEvents();
          angular.element($window).off('resize', calcDimFn);
          self.currentFocusElement = null;
        });
      },

      findStepIndex: function(modelValue) {
        var index = 0;
        for (var i = 0; i < this.options.stepsArray.length; i++) {
          var step = this.options.stepsArray[i];
          if (step === modelValue) {
            index = i;
            break;
          }
          else if (angular.isDate(step)) {
            if (step.getTime() === modelValue.getTime()) {
              index = i;
              break;
            }
          }
          else if (angular.isObject(step)) {
            if (angular.isDate(step.value) && step.value.getTime() === modelValue.getTime() || step.value === modelValue) {
              index = i;
              break;
            }
          }
        }
        return index;
      },

      syncLowValue: function() {
        if (this.options.stepsArray) {
          if (!this.options.bindIndexForStepsArray)
            this.lowValue = this.findStepIndex(this.scope.rzSliderModel);
          else
            this.lowValue = this.scope.rzSliderModel
        }
        else
          this.lowValue = this.scope.rzSliderModel;
      },

      syncHighValue: function() {
        if (this.options.stepsArray) {
          if (!this.options.bindIndexForStepsArray)
            this.highValue = this.findStepIndex(this.scope.rzSliderHigh);
          else
            this.highValue = this.scope.rzSliderHigh
        }
        else
          this.highValue = this.scope.rzSliderHigh;
      },

      getStepValue: function(sliderValue) {
        var step = this.options.stepsArray[sliderValue];
        if (angular.isDate(step))
          return step;
        if (angular.isObject(step))
          return step.value;
        return step;
      },

      applyLowValue: function() {
        if (this.options.stepsArray) {
          if (!this.options.bindIndexForStepsArray)
            this.scope.rzSliderModel = this.getStepValue(this.lowValue);
          else
            this.scope.rzSliderModel = this.lowValue
        }
        else
          this.scope.rzSliderModel = this.lowValue;
      },

      applyHighValue: function() {
        if (this.options.stepsArray) {
          if (!this.options.bindIndexForStepsArray)
            this.scope.rzSliderHigh = this.getStepValue(this.highValue);
          else
            this.scope.rzSliderHigh = this.highValue
        }
        else
          this.scope.rzSliderHigh = this.highValue;
      },

      /*
       * Reflow the slider when the low handle changes (called with throttle)
       */
      onLowHandleChange: function() {
        this.syncLowValue();
        if (this.range)
          this.syncHighValue();
        this.setMinAndMax();
        this.updateLowHandle(this.valueToPosition(this.lowValue));
        this.updateSelectionBar();
        this.updateTicksScale();
        this.updateAriaAttributes();
        if (this.range) {
          this.updateCmbLabel();
        }
      },

      /*
       * Reflow the slider when the high handle changes (called with throttle)
       */
      onHighHandleChange: function() {
        this.syncLowValue();
        this.syncHighValue();
        this.setMinAndMax();
        this.updateHighHandle(this.valueToPosition(this.highValue));
        this.updateSelectionBar();
        this.updateTicksScale();
        this.updateCmbLabel();
        this.updateAriaAttributes();
      },

      /**
       * Read the user options and apply them to the slider model
       */
      applyOptions: function() {
        var sliderOptions;
        if (this.scope.rzSliderOptions)
          sliderOptions = this.scope.rzSliderOptions();
        else
          sliderOptions = {};

        this.options = RzSliderOptions.getOptions(sliderOptions);

        if (this.options.step <= 0)
          this.options.step = 1;

        this.range = this.scope.rzSliderModel !== undefined && this.scope.rzSliderHigh !== undefined;
        this.options.draggableRange = this.range && this.options.draggableRange;
        this.options.draggableRangeOnly = this.range && this.options.draggableRangeOnly;
        if (this.options.draggableRangeOnly) {
          this.options.draggableRange = true;
        }

        this.options.showTicks = this.options.showTicks || this.options.showTicksValues || !!this.options.ticksArray;
        this.scope.showTicks = this.options.showTicks; //scope is used in the template
        if (angular.isNumber(this.options.showTicks) || this.options.ticksArray)
          this.intermediateTicks = true;

        this.options.showSelectionBar = this.options.showSelectionBar || this.options.showSelectionBarEnd
          || this.options.showSelectionBarFromValue !== null;

        if (this.options.stepsArray) {
          this.parseStepsArray();
        } else {
          if (this.options.translate)
            this.customTrFn = this.options.translate;
          else
            this.customTrFn = function(value) {
              return String(value);
            };

          this.getLegend = this.options.getLegend;
        }

        if (this.options.vertical) {
          this.positionProperty = 'bottom';
          this.dimensionProperty = 'height';
        }

        if (this.options.customTemplateScope)
          this.scope.custom = this.options.customTemplateScope;
      },

      parseStepsArray: function() {
        this.options.floor = 0;
        this.options.ceil = this.options.stepsArray.length - 1;
        this.options.step = 1;

        if (this.options.translate) {
          this.customTrFn = this.options.translate;
        }
        else {
          this.customTrFn = function(modelValue) {
            if (this.options.bindIndexForStepsArray)
              return this.getStepValue(modelValue);
            return modelValue;
          };
        }

        this.getLegend = function(index) {
          var step = this.options.stepsArray[index];
          if (angular.isObject(step))
            return step.legend;
          return null;
        };
      },

      /**
       * Resets slider
       *
       * @returns {undefined}
       */
      resetSlider: function() {
        this.manageElementsStyle();
        this.addAccessibility();
        this.setMinAndMax();
        this.updateCeilLab();
        this.updateFloorLab();
        this.unbindEvents();
        this.manageEventsBindings();
        this.setDisabledState();
        this.calcViewDimensions();
        this.refocusPointerIfNeeded();
      },

      refocusPointerIfNeeded: function() {
        if (this.currentFocusElement) {
          this.onPointerFocus(this.currentFocusElement.pointer, this.currentFocusElement.ref);
          this.focusElement(this.currentFocusElement.pointer)
        }
      },

      /**
       * Set the slider children to variables for easy access
       *
       * Run only once during initialization
       *
       * @returns {undefined}
       */
      initElemHandles: function() {
        // Assign all slider elements to object properties for easy access
        angular.forEach(this.sliderElem.children(), function(elem, index) {
          var jElem = angular.element(elem);

          switch (index) {
            case 0:
              this.fullBar = jElem;
              break;
            case 1:
              this.selBar = jElem;
              break;
            case 2:
              this.minH = jElem;
              break;
            case 3:
              this.maxH = jElem;
              break;
            case 4:
              this.flrLab = jElem;
              break;
            case 5:
              this.ceilLab = jElem;
              break;
            case 6:
              this.minLab = jElem;
              break;
            case 7:
              this.maxLab = jElem;
              break;
            case 8:
              this.cmbLab = jElem;
              break;
            case 9:
              this.ticks = jElem;
              break;
          }

        }, this);

        // Initialize position cache properties
        this.selBar.rzsp = 0;
        this.minH.rzsp = 0;
        this.maxH.rzsp = 0;
        this.flrLab.rzsp = 0;
        this.ceilLab.rzsp = 0;
        this.minLab.rzsp = 0;
        this.maxLab.rzsp = 0;
        this.cmbLab.rzsp = 0;
      },

      /**
       * Update each elements style based on options
       */
      manageElementsStyle: function() {

        if (!this.range)
          this.maxH.css('display', 'none');
        else
          this.maxH.css('display', '');


        this.alwaysHide(this.flrLab, this.options.showTicksValues || this.options.hideLimitLabels);
        this.alwaysHide(this.ceilLab, this.options.showTicksValues || this.options.hideLimitLabels);

        var hideLabelsForTicks = this.options.showTicksValues && !this.intermediateTicks;
        this.alwaysHide(this.minLab, hideLabelsForTicks || this.options.hidePointerLabels);
        this.alwaysHide(this.maxLab, hideLabelsForTicks || !this.range || this.options.hidePointerLabels);
        this.alwaysHide(this.cmbLab, hideLabelsForTicks || !this.range || this.options.hidePointerLabels);
        this.alwaysHide(this.selBar, !this.range && !this.options.showSelectionBar);

        if (this.options.vertical)
          this.sliderElem.addClass('rz-vertical');

        if (this.options.draggableRange)
          this.selBar.addClass('rz-draggable');
        else
          this.selBar.removeClass('rz-draggable');

        if (this.intermediateTicks && this.options.showTicksValues)
          this.ticks.addClass('rz-ticks-values-under');
      },

      alwaysHide: function(el, hide) {
        el.rzAlwaysHide = hide;
        if (hide)
          this.hideEl(el);
        else
          this.showEl(el)
      },

      /**
       * Manage the events bindings based on readOnly and disabled options
       *
       * @returns {undefined}
       */
      manageEventsBindings: function() {
        if (this.options.disabled || this.options.readOnly)
          this.unbindEvents();
        else
          this.bindEvents();
      },

      /**
       * Set the disabled state based on rzSliderDisabled
       *
       * @returns {undefined}
       */
      setDisabledState: function() {
        if (this.options.disabled) {
          this.sliderElem.attr('disabled', 'disabled');
        } else {
          this.sliderElem.attr('disabled', null);
        }
      },

      /**
       * Reset label values
       *
       * @return {undefined}
       */
      resetLabelsValue: function() {
        this.minLab.rzsv = undefined;
        this.maxLab.rzsv = undefined;
      },

      /**
       * Initialize slider handles positions and labels
       *
       * Run only once during initialization and every time view port changes size
       *
       * @returns {undefined}
       */
      initHandles: function() {
        this.updateLowHandle(this.valueToPosition(this.lowValue));

        /*
         the order here is important since the selection bar should be
         updated after the high handle but before the combined label
         */
        if (this.range)
          this.updateHighHandle(this.valueToPosition(this.highValue));
        this.updateSelectionBar();
        if (this.range)
          this.updateCmbLabel();

        this.updateTicksScale();
      },

      /**
       * Translate value to human readable format
       *
       * @param {number|string} value
       * @param {jqLite} label
       * @param {String} which
       * @param {boolean} [useCustomTr]
       * @returns {undefined}
       */
      translateFn: function(value, label, which, useCustomTr) {
        useCustomTr = useCustomTr === undefined ? true : useCustomTr;

        var valStr = '',
          getDimension = false,
          noLabelInjection = label.hasClass('no-label-injection');

        if (useCustomTr) {
          if (this.options.stepsArray && !this.options.bindIndexForStepsArray)
            value = this.getStepValue(value);
          valStr = String(this.customTrFn(value, this.options.id, which));
        }
        else {
          valStr = String(value)
        }

        if (label.rzsv === undefined || label.rzsv.length !== valStr.length || (label.rzsv.length > 0 && label.rzsd === 0)) {
          getDimension = true;
          label.rzsv = valStr;
        }

        if (!noLabelInjection) {
          label.html(valStr);
        }
        ;

        this.scope[which + 'Label'] = valStr;

        // Update width only when length of the label have changed
        if (getDimension) {
          this.getDimension(label);
        }
      },

      /**
       * Set maximum and minimum values for the slider and ensure the model and high
       * value match these limits
       * @returns {undefined}
       */
      setMinAndMax: function() {

        this.step = +this.options.step;
        this.precision = +this.options.precision;

        this.minValue = this.options.floor;
        if (this.options.logScale && this.minValue === 0)
          throw Error("Can't use floor=0 with logarithmic scale");

        if (this.options.enforceStep) {
          this.lowValue = this.roundStep(this.lowValue);
          if (this.range)
            this.highValue = this.roundStep(this.highValue);
        }

        if (this.options.ceil != null)
          this.maxValue = this.options.ceil;
        else
          this.maxValue = this.options.ceil = this.range ? this.highValue : this.lowValue;

        if (this.options.enforceRange) {
          this.lowValue = this.sanitizeValue(this.lowValue);
          if (this.range)
            this.highValue = this.sanitizeValue(this.highValue);
        }

        this.applyLowValue();
        if (this.range)
          this.applyHighValue();

        this.valueRange = this.maxValue - this.minValue;
      },

      /**
       * Adds accessibility attributes
       *
       * Run only once during initialization
       *
       * @returns {undefined}
       */
      addAccessibility: function() {
        this.minH.attr('role', 'slider');
        this.updateAriaAttributes();
        if (this.options.keyboardSupport && !(this.options.readOnly || this.options.disabled))
          this.minH.attr('tabindex', '0');
        else
          this.minH.attr('tabindex', '');
        if (this.options.vertical)
          this.minH.attr('aria-orientation', 'vertical');
        if (this.options.ariaLabel)
          this.minH.attr('aria-label', this.options.ariaLabel);
        else if (this.options.ariaLabelledBy)
          this.minH.attr('aria-labelledby', this.options.ariaLabelledBy);

        if (this.range) {
          this.maxH.attr('role', 'slider');
          if (this.options.keyboardSupport && !(this.options.readOnly || this.options.disabled))
            this.maxH.attr('tabindex', '0');
          else
            this.maxH.attr('tabindex', '');
          if (this.options.vertical)
            this.maxH.attr('aria-orientation', 'vertical');
          if (this.options.ariaLabelHigh)
            this.maxH.attr('aria-label', this.options.ariaLabelHigh);
          else if (this.options.ariaLabelledByHigh)
            this.maxH.attr('aria-labelledby', this.options.ariaLabelledByHigh);
        }
      },

      /**
       * Updates aria attributes according to current values
       */
      updateAriaAttributes: function() {
        this.minH.attr({
          'aria-valuenow': this.scope.rzSliderModel,
          'aria-valuetext': this.customTrFn(this.scope.rzSliderModel, this.options.id, 'model'),
          'aria-valuemin': this.minValue,
          'aria-valuemax': this.maxValue
        });
        if (this.range) {
          this.maxH.attr({
            'aria-valuenow': this.scope.rzSliderHigh,
            'aria-valuetext': this.customTrFn(this.scope.rzSliderHigh, this.options.id, 'high'),
            'aria-valuemin': this.minValue,
            'aria-valuemax': this.maxValue
          });
        }
      },

      /**
       * Calculate dimensions that are dependent on view port size
       *
       * Run once during initialization and every time view port changes size.
       *
       * @returns {undefined}
       */
      calcViewDimensions: function() {
        var handleWidth = this.getDimension(this.minH);

        this.handleHalfDim = handleWidth / 2;
        this.barDimension = this.getDimension(this.fullBar);

        this.maxPos = this.barDimension - handleWidth;

        this.getDimension(this.sliderElem);
        this.sliderElem.rzsp = this.sliderElem[0].getBoundingClientRect()[this.positionProperty];

        if (this.initHasRun) {
          this.updateFloorLab();
          this.updateCeilLab();
          this.initHandles();
          var self = this;
          $timeout(function() {
            self.updateTicksScale();
          });
        }
      },

      /**
       * Update the ticks position
       *
       * @returns {undefined}
       */
      updateTicksScale: function() {
        if (!this.options.showTicks) return;

        var ticksArray = this.options.ticksArray || this.getTicksArray(),
          translate = this.options.vertical ? 'translateY' : 'translateX',
          self = this;

        if (this.options.rightToLeft)
          ticksArray.reverse();

        this.scope.ticks = ticksArray.map(function(value) {
          var position = self.valueToPosition(value);

          if (self.options.vertical)
            position = self.maxPos - position;

          var translation = translate + '(' + Math.round(position) + 'px)';
          var tick = {
            selected: self.isTickSelected(value),
            style: {
              '-webkit-transform': translation,
              '-moz-transform': translation,
              '-o-transform': translation,
              '-ms-transform': translation,
              'transform': translation
            }
          };
          if (tick.selected && self.options.getSelectionBarColor) {
            tick.style['background-color'] = self.getSelectionBarColor();
          }
          if (!tick.selected && self.options.getTickColor) {
            tick.style['background-color'] = self.getTickColor(value);
          }
          if (self.options.ticksTooltip) {
            tick.tooltip = self.options.ticksTooltip(value);
            tick.tooltipPlacement = self.options.vertical ? 'right' : 'top';
          }
          if (self.options.showTicksValues) {
            tick.value = self.getDisplayValue(value, 'tick-value');
            if (self.options.ticksValuesTooltip) {
              tick.valueTooltip = self.options.ticksValuesTooltip(value);
              tick.valueTooltipPlacement = self.options.vertical ? 'right' : 'top';
            }
          }
          if (self.getLegend) {
            var legend = self.getLegend(value, self.options.id);
            if (legend)
              tick.legend = legend;
          }
          return tick;
        });
      },

      getTicksArray: function() {
        var step = this.step,
          ticksArray = [];
        if (this.intermediateTicks)
          step = this.options.showTicks;
        for (var value = this.minValue; value <= this.maxValue; value += step) {
          ticksArray.push(value);
        }
        return ticksArray;
      },

      isTickSelected: function(value) {
        if (!this.range) {
          if (this.options.showSelectionBarFromValue !== null) {
            var center = this.options.showSelectionBarFromValue;
            if (this.lowValue > center && value >= center && value <= this.lowValue)
              return true;
            else if (this.lowValue < center && value <= center && value >= this.lowValue)
              return true;
          }
          else if (this.options.showSelectionBarEnd) {
            if (value >= this.lowValue)
              return true;
          }
          else if (this.options.showSelectionBar && value <= this.lowValue)
            return true;
        }
        if (this.range && value >= this.lowValue && value <= this.highValue)
          return true;
        return false;
      },

      /**
       * Update position of the floor label
       *
       * @returns {undefined}
       */
      updateFloorLab: function() {
        this.translateFn(this.minValue, this.flrLab, 'floor');
        this.getDimension(this.flrLab);
        var position = this.options.rightToLeft ? this.barDimension - this.flrLab.rzsd : 0;
        this.setPosition(this.flrLab, position);
      },

      /**
       * Update position of the ceiling label
       *
       * @returns {undefined}
       */
      updateCeilLab: function() {
        this.translateFn(this.maxValue, this.ceilLab, 'ceil');
        this.getDimension(this.ceilLab);
        var position = this.options.rightToLeft ? 0 : this.barDimension - this.ceilLab.rzsd;
        this.setPosition(this.ceilLab, position);
      },

      /**
       * Update slider handles and label positions
       *
       * @param {string} which
       * @param {number} newPos
       */
      updateHandles: function(which, newPos) {
        if (which === 'lowValue')
          this.updateLowHandle(newPos);
        else
          this.updateHighHandle(newPos);

        this.updateSelectionBar();
        this.updateTicksScale();
        if (this.range)
          this.updateCmbLabel();
      },

      /**
       * Helper function to work out the position for handle labels depending on RTL or not
       *
       * @param {string} labelName maxLab or minLab
       * @param newPos
       *
       * @returns {number}
       */
      getHandleLabelPos: function(labelName, newPos) {
        var labelRzsd = this[labelName].rzsd,
          nearHandlePos = newPos - labelRzsd / 2 + this.handleHalfDim,
          endOfBarPos = this.barDimension - labelRzsd;

        if (!this.options.boundPointerLabels)
          return nearHandlePos;

        if (this.options.rightToLeft && labelName === 'minLab' || !this.options.rightToLeft && labelName === 'maxLab') {
          return Math.min(nearHandlePos, endOfBarPos);
        } else {
          return Math.min(Math.max(nearHandlePos, 0), endOfBarPos);
        }
      },

      /**
       * Update low slider handle position and label
       *
       * @param {number} newPos
       * @returns {undefined}
       */
      updateLowHandle: function(newPos) {
        this.setPosition(this.minH, newPos);
        this.translateFn(this.lowValue, this.minLab, 'model');
        this.setPosition(this.minLab, this.getHandleLabelPos('minLab', newPos));

        if (this.options.getPointerColor) {
          var pointercolor = this.getPointerColor('min');
          this.scope.minPointerStyle = {
            backgroundColor: pointercolor
          };
        }

        if (this.options.autoHideLimitLabels) {
          this.shFloorCeil();
        }
      },

      /**
       * Update high slider handle position and label
       *
       * @param {number} newPos
       * @returns {undefined}
       */
      updateHighHandle: function(newPos) {
        this.setPosition(this.maxH, newPos);
        this.translateFn(this.highValue, this.maxLab, 'high');
        this.setPosition(this.maxLab, this.getHandleLabelPos('maxLab', newPos));

        if (this.options.getPointerColor) {
          var pointercolor = this.getPointerColor('max');
          this.scope.maxPointerStyle = {
            backgroundColor: pointercolor
          };
        }
        if (this.options.autoHideLimitLabels) {
          this.shFloorCeil();
        }

      },

      /**
       * Show/hide floor/ceiling label
       *
       * @returns {undefined}
       */
      shFloorCeil: function() {
        // Show based only on hideLimitLabels if pointer labels are hidden
        if (this.options.hidePointerLabels) {
          return;
        }
        var flHidden = false,
          clHidden = false,
          isMinLabAtFloor = this.isLabelBelowFloorLab(this.minLab),
          isMinLabAtCeil = this.isLabelAboveCeilLab(this.minLab),
          isMaxLabAtCeil = this.isLabelAboveCeilLab(this.maxLab),
          isCmbLabAtFloor = this.isLabelBelowFloorLab(this.cmbLab),
          isCmbLabAtCeil = this.isLabelAboveCeilLab(this.cmbLab);

        if (isMinLabAtFloor) {
          flHidden = true;
          this.hideEl(this.flrLab);
        } else {
          flHidden = false;
          this.showEl(this.flrLab);
        }

        if (isMinLabAtCeil) {
          clHidden = true;
          this.hideEl(this.ceilLab);
        } else {
          clHidden = false;
          this.showEl(this.ceilLab);
        }

        if (this.range) {
          var hideCeil = this.cmbLabelShown ? isCmbLabAtCeil : isMaxLabAtCeil;
          var hideFloor = this.cmbLabelShown ? isCmbLabAtFloor : isMinLabAtFloor;

          if (hideCeil) {
            this.hideEl(this.ceilLab);
          } else if (!clHidden) {
            this.showEl(this.ceilLab);
          }

          // Hide or show floor label
          if (hideFloor) {
            this.hideEl(this.flrLab);
          } else if (!flHidden) {
            this.showEl(this.flrLab);
          }
        }
      },

      isLabelBelowFloorLab: function(label) {
        var isRTL = this.options.rightToLeft,
          pos = label.rzsp,
          dim = label.rzsd,
          floorPos = this.flrLab.rzsp,
          floorDim = this.flrLab.rzsd;
        return isRTL ?
          pos + dim >= floorPos - 2 :
          pos <= floorPos + floorDim + 2;
      },

      isLabelAboveCeilLab: function(label) {
        var isRTL = this.options.rightToLeft,
          pos = label.rzsp,
          dim = label.rzsd,
          ceilPos = this.ceilLab.rzsp,
          ceilDim = this.ceilLab.rzsd;
        return isRTL ?
          pos <= ceilPos + ceilDim + 2 :
          pos + dim >= ceilPos - 2;
      },

      /**
       * Update slider selection bar, combined label and range label
       *
       * @returns {undefined}
       */
      updateSelectionBar: function() {
        var position = 0,
          dimension = 0,
          isSelectionBarFromRight = this.options.rightToLeft ? !this.options.showSelectionBarEnd : this.options.showSelectionBarEnd,
          positionForRange = this.options.rightToLeft ? this.maxH.rzsp + this.handleHalfDim : this.minH.rzsp + this.handleHalfDim;

        if (this.range) {
          dimension = Math.abs(this.maxH.rzsp - this.minH.rzsp);
          position = positionForRange;
        }
        else {
          if (this.options.showSelectionBarFromValue !== null) {
            var center = this.options.showSelectionBarFromValue,
              centerPosition = this.valueToPosition(center),
              isModelGreaterThanCenter = this.options.rightToLeft ? this.lowValue <= center : this.lowValue > center;
            if (isModelGreaterThanCenter) {
              dimension = this.minH.rzsp - centerPosition;
              position = centerPosition + this.handleHalfDim;
            }
            else {
              dimension = centerPosition - this.minH.rzsp;
              position = this.minH.rzsp + this.handleHalfDim;
            }
          }
          else if (isSelectionBarFromRight) {
            dimension = Math.abs(this.maxPos - this.minH.rzsp) + this.handleHalfDim;
            position = this.minH.rzsp + this.handleHalfDim;
          } else {
            dimension = this.minH.rzsp + this.handleHalfDim;
            position = 0;
          }
        }
        this.setDimension(this.selBar, dimension);
        this.setPosition(this.selBar, position);
        if (this.options.getSelectionBarColor) {
          var color = this.getSelectionBarColor();
          this.scope.barStyle = {
            backgroundColor: color
          };
        } else if (this.options.selectionBarGradient) {
          var offset = this.options.showSelectionBarFromValue !== null ? this.valueToPosition(this.options.showSelectionBarFromValue) : 0,
            reversed = offset - position > 0 ^ isSelectionBarFromRight,
            direction = this.options.vertical ? (reversed ? 'bottom' : 'top') : (reversed ? 'left' : 'right');
          this.scope.barStyle = {
            backgroundImage: 'linear-gradient(to ' + direction + ', ' + this.options.selectionBarGradient.from + ' 0%,' + this.options.selectionBarGradient.to + ' 100%)'
          };
          if (this.options.vertical) {
            this.scope.barStyle.backgroundPosition = 'center ' + (offset + dimension + position + (reversed ? -this.handleHalfDim : 0)) + 'px';
            this.scope.barStyle.backgroundSize = '100% ' + (this.barDimension - this.handleHalfDim) + 'px';
          } else {
            this.scope.barStyle.backgroundPosition = (offset - position + (reversed ? this.handleHalfDim : 0)) + 'px center';
            this.scope.barStyle.backgroundSize = (this.barDimension - this.handleHalfDim) + 'px 100%';
          }
        }
      },

      /**
       * Wrapper around the getSelectionBarColor of the user to pass to
       * correct parameters
       */
      getSelectionBarColor: function() {
        if (this.range)
          return this.options.getSelectionBarColor(this.scope.rzSliderModel, this.scope.rzSliderHigh);
        return this.options.getSelectionBarColor(this.scope.rzSliderModel);
      },

      /**
       * Wrapper around the getPointerColor of the user to pass to
       * correct parameters
       */
      getPointerColor: function(pointerType) {
        if (pointerType === 'max') {
          return this.options.getPointerColor(this.scope.rzSliderHigh, pointerType);
        }
        return this.options.getPointerColor(this.scope.rzSliderModel, pointerType);
      },

      /**
       * Wrapper around the getTickColor of the user to pass to
       * correct parameters
       */
      getTickColor: function(value) {
        return this.options.getTickColor(value);
      },

      /**
       * Update combined label position and value
       *
       * @returns {undefined}
       */
      updateCmbLabel: function() {
        var isLabelOverlap = null;
        if (this.options.rightToLeft) {
          isLabelOverlap = this.minLab.rzsp - this.minLab.rzsd - 10 <= this.maxLab.rzsp;
        } else {
          isLabelOverlap = this.minLab.rzsp + this.minLab.rzsd + 10 >= this.maxLab.rzsp;
        }

        if (isLabelOverlap) {
          var lowTr = this.getDisplayValue(this.lowValue, 'model'),
            highTr = this.getDisplayValue(this.highValue, 'high'),
            labelVal = '';
          if (this.options.mergeRangeLabelsIfSame && lowTr === highTr) {
            labelVal = lowTr;
          } else {
            labelVal = this.options.rightToLeft ? highTr + ' - ' + lowTr : lowTr + ' - ' + highTr;
          }

          this.translateFn(labelVal, this.cmbLab, 'cmb', false);
          var pos = this.options.boundPointerLabels ? Math.min(
            Math.max(
              this.selBar.rzsp + this.selBar.rzsd / 2 - this.cmbLab.rzsd / 2,
              0
            ),
            this.barDimension - this.cmbLab.rzsd
          ) : this.selBar.rzsp + this.selBar.rzsd / 2 - this.cmbLab.rzsd / 2;

          this.setPosition(this.cmbLab, pos);
          this.cmbLabelShown = true;
          this.hideEl(this.minLab);
          this.hideEl(this.maxLab);
          this.showEl(this.cmbLab);
        } else {
          this.cmbLabelShown = false;
          this.updateHighHandle(this.valueToPosition(this.highValue));
          this.updateLowHandle(this.valueToPosition(this.lowValue));
          this.showEl(this.maxLab);
          this.showEl(this.minLab);
          this.hideEl(this.cmbLab);
        }
        if (this.options.autoHideLimitLabels) {
          this.shFloorCeil();
        }
      },

      /**
       * Return the translated value if a translate function is provided else the original value
       * @param value
       * @param which if it's min or max handle
       * @returns {*}
       */
      getDisplayValue: function(value, which) {
        if (this.options.stepsArray && !this.options.bindIndexForStepsArray) {
          value = this.getStepValue(value);
        }
        return this.customTrFn(value, this.options.id, which);
      },

      /**
       * Round value to step and precision based on minValue
       *
       * @param {number} value
       * @param {number} customStep a custom step to override the defined step
       * @returns {number}
       */
      roundStep: function(value, customStep) {
        var step = customStep ? customStep : this.step,
          steppedDifference = parseFloat((value - this.minValue) / step).toPrecision(12);
        steppedDifference = Math.round(+steppedDifference) * step;
        var newValue = (this.minValue + steppedDifference).toFixed(this.precision);
        return +newValue;
      },

      /**
       * Hide element
       *
       * @param element
       * @returns {jqLite} The jqLite wrapped DOM element
       */
      hideEl: function(element) {
        return element.css({
          visibility: 'hidden'
        });
      },

      /**
       * Show element
       *
       * @param element The jqLite wrapped DOM element
       * @returns {jqLite} The jqLite
       */
      showEl: function(element) {
        if (!!element.rzAlwaysHide) {
          return element;
        }

        return element.css({
          visibility: 'visible'
        });
      },

      /**
       * Set element left/top position depending on whether slider is horizontal or vertical
       *
       * @param {jqLite} elem The jqLite wrapped DOM element
       * @param {number} pos
       * @returns {number}
       */
      setPosition: function(elem, pos) {
        elem.rzsp = pos;
        var css = {};
        css[this.positionProperty] = Math.round(pos) + 'px';
        elem.css(css);
        return pos;
      },

      /**
       * Get element width/height depending on whether slider is horizontal or vertical
       *
       * @param {jqLite} elem The jqLite wrapped DOM element
       * @returns {number}
       */
      getDimension: function(elem) {
        var val = elem[0].getBoundingClientRect();
        if (this.options.vertical)
          elem.rzsd = (val.bottom - val.top) * this.options.scale;
        else
          elem.rzsd = (val.right - val.left) * this.options.scale;
        return elem.rzsd;
      },

      /**
       * Set element width/height depending on whether slider is horizontal or vertical
       *
       * @param {jqLite} elem  The jqLite wrapped DOM element
       * @param {number} dim
       * @returns {number}
       */
      setDimension: function(elem, dim) {
        elem.rzsd = dim;
        var css = {};
        css[this.dimensionProperty] = Math.round(dim) + 'px';
        elem.css(css);
        return dim;
      },

      /**
       * Returns a value that is within slider range
       *
       * @param {number} val
       * @returns {number}
       */
      sanitizeValue: function(val) {
        return Math.min(Math.max(val, this.minValue), this.maxValue);
      },

      /**
       * Translate value to pixel position
       *
       * @param {number} val
       * @returns {number}
       */
      valueToPosition: function(val) {
        var fn = this.linearValueToPosition;
        if (this.options.customValueToPosition)
          fn = this.options.customValueToPosition;
        else if (this.options.logScale)
          fn = this.logValueToPosition;

        val = this.sanitizeValue(val);
        var percent = fn(val, this.minValue, this.maxValue) || 0;
        if (this.options.rightToLeft)
          percent = 1 - percent;
        return percent * this.maxPos;
      },

      linearValueToPosition: function(val, minVal, maxVal) {
        var range = maxVal - minVal;
        return (val - minVal) / range;
      },

      logValueToPosition: function(val, minVal, maxVal) {
        val = Math.log(val);
        minVal = Math.log(minVal);
        maxVal = Math.log(maxVal);
        var range = maxVal - minVal;
        return (val - minVal) / range;
      },

      /**
       * Translate position to model value
       *
       * @param {number} position
       * @returns {number}
       */
      positionToValue: function(position) {
        var percent = position / this.maxPos;
        if (this.options.rightToLeft)
          percent = 1 - percent;
        var fn = this.linearPositionToValue;
        if (this.options.customPositionToValue)
          fn = this.options.customPositionToValue;
        else if (this.options.logScale)
          fn = this.logPositionToValue;
        return fn(percent, this.minValue, this.maxValue) || 0;
      },

      linearPositionToValue: function(percent, minVal, maxVal) {
        return percent * (maxVal - minVal) + minVal;
      },

      logPositionToValue: function(percent, minVal, maxVal) {
        minVal = Math.log(minVal);
        maxVal = Math.log(maxVal);
        var value = percent * (maxVal - minVal) + minVal;
        return Math.exp(value);
      },

      getEventAttr: function(event, attr) {
        return event.originalEvent === undefined ? event[attr] : event.originalEvent[attr]
      },

      // Events
      /**
       * Get the X-coordinate or Y-coordinate of an event
       *
       * @param {Object} event  The event
       * @param targetTouchId The identifier of the touch with the X/Y coordinates
       * @returns {number}
       */
      getEventXY: function(event, targetTouchId) {
        /* http://stackoverflow.com/a/12336075/282882 */
        //noinspection JSLint
        var clientXY = this.options.vertical ? 'clientY' : 'clientX';
        if (event[clientXY] !== undefined) {
          return event[clientXY];
        }

        var touches = this.getEventAttr(event, 'touches');

        if (targetTouchId !== undefined) {
          for (var i = 0; i < touches.length; i++) {
            if (touches[i].identifier === targetTouchId) {
              return touches[i][clientXY];
            }
          }
        }

        // If no target touch or the target touch was not found in the event
        // returns the coordinates of the first touch
        return touches[0][clientXY];
      },

      /**
       * Compute the event position depending on whether the slider is horizontal or vertical
       * @param event
       * @param targetTouchId If targetTouchId is provided it will be considered the position of that
       * @returns {number}
       */
      getEventPosition: function(event, targetTouchId) {
        var sliderPos = this.sliderElem.rzsp,
          eventPos = 0;
        if (this.options.vertical)
          eventPos = -this.getEventXY(event, targetTouchId) + sliderPos;
        else
          eventPos = this.getEventXY(event, targetTouchId) - sliderPos;
        return eventPos * this.options.scale - this.handleHalfDim; // #346 handleHalfDim is already scaled
      },

      /**
       * Get event names for move and event end
       *
       * @param {Event}    event    The event
       *
       * @return {{moveEvent: string, endEvent: string}}
       */
      getEventNames: function(event) {
        var eventNames = {
          moveEvent: '',
          endEvent: ''
        };

        if (this.getEventAttr(event, 'touches')) {
          eventNames.moveEvent = 'touchmove';
          eventNames.endEvent = 'touchend';
        } else {
          eventNames.moveEvent = 'mousemove';
          eventNames.endEvent = 'mouseup';
        }

        return eventNames;
      },

      /**
       * Get the handle closest to an event.
       *
       * @param event {Event} The event
       * @returns {jqLite} The handle closest to the event.
       */
      getNearestHandle: function(event) {
        if (!this.range) {
          return this.minH;
        }
        var position = this.getEventPosition(event),
          distanceMin = Math.abs(position - this.minH.rzsp),
          distanceMax = Math.abs(position - this.maxH.rzsp);
        if (distanceMin < distanceMax)
          return this.minH;
        else if (distanceMin > distanceMax)
          return this.maxH;
        else if (!this.options.rightToLeft)
        //if event is at the same distance from min/max then if it's at left of minH, we return minH else maxH
          return position < this.minH.rzsp ? this.minH : this.maxH;
        else
        //reverse in rtl
          return position > this.minH.rzsp ? this.minH : this.maxH;
      },

      /**
       * Wrapper function to focus an angular element
       *
       * @param el {AngularElement} the element to focus
       */
      focusElement: function(el) {
        var DOM_ELEMENT = 0;
        el[DOM_ELEMENT].focus();
      },

      /**
       * Bind mouse and touch events to slider handles
       *
       * @returns {undefined}
       */
      bindEvents: function() {
        var barTracking, barStart, barMove;

        if (this.options.draggableRange) {
          barTracking = 'rzSliderDrag';
          barStart = this.onDragStart;
          barMove = this.onDragMove;
        } else {
          barTracking = 'lowValue';
          barStart = this.onStart;
          barMove = this.onMove;
        }

        if (!this.options.onlyBindHandles) {
          this.selBar.on('mousedown', angular.bind(this, barStart, null, barTracking));
          this.selBar.on('mousedown', angular.bind(this, barMove, this.selBar));
        }

        if (this.options.draggableRangeOnly) {
          this.minH.on('mousedown', angular.bind(this, barStart, null, barTracking));
          this.maxH.on('mousedown', angular.bind(this, barStart, null, barTracking));
        } else {
          this.minH.on('mousedown', angular.bind(this, this.onStart, this.minH, 'lowValue'));
          if (this.range) {
            this.maxH.on('mousedown', angular.bind(this, this.onStart, this.maxH, 'highValue'));
          }
          if (!this.options.onlyBindHandles) {
            this.fullBar.on('mousedown', angular.bind(this, this.onStart, null, null));
            this.fullBar.on('mousedown', angular.bind(this, this.onMove, this.fullBar));
            this.ticks.on('mousedown', angular.bind(this, this.onStart, null, null));
            this.ticks.on('mousedown', angular.bind(this, this.onTickClick, this.ticks));
          }
        }

        if (!this.options.onlyBindHandles) {
          this.selBar.on('touchstart', angular.bind(this, barStart, null, barTracking));
          this.selBar.on('touchstart', angular.bind(this, barMove, this.selBar));
        }
        if (this.options.draggableRangeOnly) {
          this.minH.on('touchstart', angular.bind(this, barStart, null, barTracking));
          this.maxH.on('touchstart', angular.bind(this, barStart, null, barTracking));
        } else {
          this.minH.on('touchstart', angular.bind(this, this.onStart, this.minH, 'lowValue'));
          if (this.range) {
            this.maxH.on('touchstart', angular.bind(this, this.onStart, this.maxH, 'highValue'));
          }
          if (!this.options.onlyBindHandles) {
            this.fullBar.on('touchstart', angular.bind(this, this.onStart, null, null));
            this.fullBar.on('touchstart', angular.bind(this, this.onMove, this.fullBar));
            this.ticks.on('touchstart', angular.bind(this, this.onStart, null, null));
            this.ticks.on('touchstart', angular.bind(this, this.onTickClick, this.ticks));
          }
        }

        if (this.options.keyboardSupport) {
          this.minH.on('focus', angular.bind(this, this.onPointerFocus, this.minH, 'lowValue'));
          if (this.range) {
            this.maxH.on('focus', angular.bind(this, this.onPointerFocus, this.maxH, 'highValue'));
          }
        }
      },

      /**
       * Unbind mouse and touch events to slider handles
       *
       * @returns {undefined}
       */
      unbindEvents: function() {
        this.minH.off();
        this.maxH.off();
        this.fullBar.off();
        this.selBar.off();
        this.ticks.off();
      },

      /**
       * onStart event handler
       *
       * @param {?Object} pointer The jqLite wrapped DOM element; if null, the closest handle is used
       * @param {?string} ref     The name of the handle being changed; if null, the closest handle's value is modified
       * @param {Event}   event   The event
       * @returns {undefined}
       */
      onStart: function(pointer, ref, event) {
        var ehMove, ehEnd,
          eventNames = this.getEventNames(event);

        event.stopPropagation();
        event.preventDefault();

        // We have to do this in case the HTML where the sliders are on
        // have been animated into view.
        this.calcViewDimensions();

        if (pointer) {
          this.tracking = ref;
        } else {
          pointer = this.getNearestHandle(event);
          this.tracking = pointer === this.minH ? 'lowValue' : 'highValue';
        }

        pointer.addClass('rz-active');

        if (this.options.keyboardSupport)
          this.focusElement(pointer);

        ehMove = angular.bind(this, this.dragging.active ? this.onDragMove : this.onMove, pointer);
        ehEnd = angular.bind(this, this.onEnd, ehMove);

        $document.on(eventNames.moveEvent, ehMove)
        $document.on(eventNames.endEvent, ehEnd);
        this.endHandlerToBeRemovedOnEnd = ehEnd;

        this.callOnStart();

        var changedTouches = this.getEventAttr(event, 'changedTouches');
        if (changedTouches) {
          // Store the touch identifier
          if (!this.touchId) {
            this.isDragging = true;
            this.touchId = changedTouches[0].identifier;
          }
        }
      },

      /**
       * onMove event handler
       *
       * @param {jqLite} pointer
       * @param {Event}  event The event
       * @param {boolean}  fromTick if the event occured on a tick or not
       * @returns {undefined}
       */
      onMove: function(pointer, event, fromTick) {
        var changedTouches = this.getEventAttr(event, 'changedTouches');
        var touchForThisSlider;
        if (changedTouches) {
          for (var i = 0; i < changedTouches.length; i++) {
            if (changedTouches[i].identifier === this.touchId) {
              touchForThisSlider = changedTouches[i];
              break;
            }
          }
        }

        if (changedTouches && !touchForThisSlider) {
          return;
        }

        var newPos = this.getEventPosition(event, touchForThisSlider ? touchForThisSlider.identifier : undefined),
          newValue,
          ceilValue = this.options.rightToLeft ? this.minValue : this.maxValue,
          flrValue = this.options.rightToLeft ? this.maxValue : this.minValue;

        if (newPos <= 0) {
          newValue = flrValue;
        } else if (newPos >= this.maxPos) {
          newValue = ceilValue;
        } else {
          newValue = this.positionToValue(newPos);
          if (fromTick && angular.isNumber(this.options.showTicks))
            newValue = this.roundStep(newValue, this.options.showTicks);
          else
            newValue = this.roundStep(newValue);
        }
        this.positionTrackingHandle(newValue);
      },

      /**
       * onEnd event handler
       *
       * @param {Event}    event    The event
       * @param {Function} ehMove   The bound move event handler
       * @returns {undefined}
       */
      onEnd: function(ehMove, event) {
        var changedTouches = this.getEventAttr(event, 'changedTouches');
        if (changedTouches && changedTouches[0].identifier !== this.touchId) {
          return;
        }
        this.isDragging = false;
        this.touchId = null;

        if (!this.options.keyboardSupport) {
          this.minH.removeClass('rz-active');
          this.maxH.removeClass('rz-active');
          this.tracking = '';
        }
        this.dragging.active = false;

        var eventName = this.getEventNames(event);
        $document.off(eventName.moveEvent, ehMove);
        $document.off(eventName.endEvent, this.endHandlerToBeRemovedOnEnd);
        this.endHandlerToBeRemovedOnEnd = null;
        this.callOnEnd();
      },

      onTickClick: function(pointer, event) {
        this.onMove(pointer, event, true);
      },

      onPointerFocus: function(pointer, ref) {
        this.tracking = ref;
        pointer.one('blur', angular.bind(this, this.onPointerBlur, pointer));
        pointer.on('keydown', angular.bind(this, this.onKeyboardEvent));
        pointer.on('keyup', angular.bind(this, this.onKeyUp));
        this.firstKeyDown = true;
        pointer.addClass('rz-active');

        this.currentFocusElement = {
          pointer: pointer,
          ref: ref
        };
      },

      onKeyUp: function() {
        this.firstKeyDown = true;
        this.callOnEnd();
      },

      onPointerBlur: function(pointer) {
        pointer.off('keydown');
        pointer.off('keyup');
        pointer.removeClass('rz-active');
        if (!this.isDragging) {
          this.tracking = '';
          this.currentFocusElement = null
        }
      },

      /**
       * Key actions helper function
       *
       * @param {number} currentValue value of the slider
       *
       * @returns {?Object} action value mappings
       */
      getKeyActions: function(currentValue) {
        var increaseStep = currentValue + this.step,
          decreaseStep = currentValue - this.step,
          increasePage = currentValue + this.valueRange / 10,
          decreasePage = currentValue - this.valueRange / 10;

        //Left to right default actions
        var actions = {
          'UP': increaseStep,
          'DOWN': decreaseStep,
          'LEFT': decreaseStep,
          'RIGHT': increaseStep,
          'PAGEUP': increasePage,
          'PAGEDOWN': decreasePage,
          'HOME': this.minValue,
          'END': this.maxValue
        };
        //right to left means swapping right and left arrows
        if (this.options.rightToLeft) {
          actions.LEFT = increaseStep;
          actions.RIGHT = decreaseStep;
          // right to left and vertical means we also swap up and down
          if (this.options.vertical) {
            actions.UP = decreaseStep;
            actions.DOWN = increaseStep;
          }
        }
        return actions;
      },

      onKeyboardEvent: function(event) {
        var currentValue = this[this.tracking],
          keyCode = event.keyCode || event.which,
          keys = {
            38: 'UP',
            40: 'DOWN',
            37: 'LEFT',
            39: 'RIGHT',
            33: 'PAGEUP',
            34: 'PAGEDOWN',
            36: 'HOME',
            35: 'END'
          },
          actions = this.getKeyActions(currentValue),
          key = keys[keyCode],
          action = actions[key];
        if (action == null || this.tracking === '') return;
        event.preventDefault();

        if (this.firstKeyDown) {
          this.firstKeyDown = false;
          this.callOnStart();
        }

        var self = this;
        $timeout(function() {
          var newValue = self.roundStep(self.sanitizeValue(action));
          if (!self.options.draggableRangeOnly) {
            self.positionTrackingHandle(newValue);
          }
          else {
            var difference = self.highValue - self.lowValue,
              newMinValue, newMaxValue;
            if (self.tracking === 'lowValue') {
              newMinValue = newValue;
              newMaxValue = newValue + difference;
              if (newMaxValue > self.maxValue) {
                newMaxValue = self.maxValue;
                newMinValue = newMaxValue - difference;
              }
            } else {
              newMaxValue = newValue;
              newMinValue = newValue - difference;
              if (newMinValue < self.minValue) {
                newMinValue = self.minValue;
                newMaxValue = newMinValue + difference;
              }
            }
            self.positionTrackingBar(newMinValue, newMaxValue);
          }
        });
      },

      /**
       * onDragStart event handler
       *
       * Handles dragging of the middle bar.
       *
       * @param {Object} pointer The jqLite wrapped DOM element
       * @param {string} ref     One of the refLow, refHigh values
       * @param {Event}  event   The event
       * @returns {undefined}
       */
      onDragStart: function(pointer, ref, event) {
        var position = this.getEventPosition(event);
        this.dragging = {
          active: true,
          value: this.positionToValue(position),
          difference: this.highValue - this.lowValue,
          lowLimit: this.options.rightToLeft ? this.minH.rzsp - position : position - this.minH.rzsp,
          highLimit: this.options.rightToLeft ? position - this.maxH.rzsp : this.maxH.rzsp - position
        };

        this.onStart(pointer, ref, event);
      },

      /**
       * getValue helper function
       *
       * gets max or min value depending on whether the newPos is outOfBounds above or below the bar and rightToLeft
       *
       * @param {string} type 'max' || 'min' The value we are calculating
       * @param {number} newPos  The new position
       * @param {boolean} outOfBounds Is the new position above or below the max/min?
       * @param {boolean} isAbove Is the new position above the bar if out of bounds?
       *
       * @returns {number}
       */
      getValue: function(type, newPos, outOfBounds, isAbove) {
        var isRTL = this.options.rightToLeft,
          value = null;

        if (type === 'min') {
          if (outOfBounds) {
            if (isAbove) {
              value = isRTL ? this.minValue : this.maxValue - this.dragging.difference;
            } else {
              value = isRTL ? this.maxValue - this.dragging.difference : this.minValue;
            }
          } else {
            value = isRTL ? this.positionToValue(newPos + this.dragging.lowLimit) : this.positionToValue(newPos - this.dragging.lowLimit)
          }
        } else {
          if (outOfBounds) {
            if (isAbove) {
              value = isRTL ? this.minValue + this.dragging.difference : this.maxValue;
            } else {
              value = isRTL ? this.maxValue : this.minValue + this.dragging.difference;
            }
          } else {
            if (isRTL) {
              value = this.positionToValue(newPos + this.dragging.lowLimit) + this.dragging.difference
            } else {
              value = this.positionToValue(newPos - this.dragging.lowLimit) + this.dragging.difference;
            }
          }
        }
        return this.roundStep(value);
      },

      /**
       * onDragMove event handler
       *
       * Handles dragging of the middle bar.
       *
       * @param {jqLite} pointer
       * @param {Event}  event The event
       * @returns {undefined}
       */
      onDragMove: function(pointer, event) {
        var newPos = this.getEventPosition(event),
          newMinValue, newMaxValue,
          ceilLimit, flrLimit,
          isUnderFlrLimit, isOverCeilLimit,
          flrH, ceilH;

        if (this.options.rightToLeft) {
          ceilLimit = this.dragging.lowLimit;
          flrLimit = this.dragging.highLimit;
          flrH = this.maxH;
          ceilH = this.minH;
        } else {
          ceilLimit = this.dragging.highLimit;
          flrLimit = this.dragging.lowLimit;
          flrH = this.minH;
          ceilH = this.maxH;
        }
        isUnderFlrLimit = newPos <= flrLimit;
        isOverCeilLimit = newPos >= this.maxPos - ceilLimit;

        if (isUnderFlrLimit) {
          if (flrH.rzsp === 0)
            return;
          newMinValue = this.getValue('min', newPos, true, false);
          newMaxValue = this.getValue('max', newPos, true, false);
        } else if (isOverCeilLimit) {
          if (ceilH.rzsp === this.maxPos)
            return;
          newMaxValue = this.getValue('max', newPos, true, true);
          newMinValue = this.getValue('min', newPos, true, true);
        } else {
          newMinValue = this.getValue('min', newPos, false);
          newMaxValue = this.getValue('max', newPos, false);
        }
        this.positionTrackingBar(newMinValue, newMaxValue);
      },

      /**
       * Set the new value and position for the entire bar
       *
       * @param {number} newMinValue   the new minimum value
       * @param {number} newMaxValue   the new maximum value
       */
      positionTrackingBar: function(newMinValue, newMaxValue) {

        if (this.options.minLimit != null && newMinValue < this.options.minLimit) {
          newMinValue = this.options.minLimit;
          newMaxValue = newMinValue + this.dragging.difference;
        }
        if (this.options.maxLimit != null && newMaxValue > this.options.maxLimit) {
          newMaxValue = this.options.maxLimit;
          newMinValue = newMaxValue - this.dragging.difference;
        }

        this.lowValue = newMinValue;
        this.highValue = newMaxValue;
        this.applyLowValue();
        if (this.range)
          this.applyHighValue();
        this.applyModel(true);
        this.updateHandles('lowValue', this.valueToPosition(newMinValue));
        this.updateHandles('highValue', this.valueToPosition(newMaxValue));
      },

      /**
       * Set the new value and position to the current tracking handle
       *
       * @param {number} newValue new model value
       */
      positionTrackingHandle: function(newValue) {
        var valueChanged = false;
        newValue = this.applyMinMaxLimit(newValue);
        if (this.range) {
          if (this.options.pushRange) {
            newValue = this.applyPushRange(newValue);
            valueChanged = true;
          }
          else {
            if (this.options.noSwitching) {
              if (this.tracking === 'lowValue' && newValue > this.highValue)
                newValue = this.applyMinMaxRange(this.highValue);
              else if (this.tracking === 'highValue' && newValue < this.lowValue)
                newValue = this.applyMinMaxRange(this.lowValue);
            }
            newValue = this.applyMinMaxRange(newValue);
            /* This is to check if we need to switch the min and max handles */
            if (this.tracking === 'lowValue' && newValue > this.highValue) {
              this.lowValue = this.highValue;
              this.applyLowValue();
              this.applyModel();
              this.updateHandles(this.tracking, this.maxH.rzsp);
              this.updateAriaAttributes();
              this.tracking = 'highValue';
              this.minH.removeClass('rz-active');
              this.maxH.addClass('rz-active');
              if (this.options.keyboardSupport)
                this.focusElement(this.maxH);
              valueChanged = true;
            }
            else if (this.tracking === 'highValue' && newValue < this.lowValue) {
              this.highValue = this.lowValue;
              this.applyHighValue();
              this.applyModel();
              this.updateHandles(this.tracking, this.minH.rzsp);
              this.updateAriaAttributes();
              this.tracking = 'lowValue';
              this.maxH.removeClass('rz-active');
              this.minH.addClass('rz-active');
              if (this.options.keyboardSupport)
                this.focusElement(this.minH);
              valueChanged = true;
            }
          }
        }

        if (this[this.tracking] !== newValue) {
          this[this.tracking] = newValue;
          if (this.tracking === 'lowValue')
            this.applyLowValue();
          else
            this.applyHighValue();
          this.applyModel();
          this.updateHandles(this.tracking, this.valueToPosition(newValue));
          this.updateAriaAttributes();
          valueChanged = true;
        }

        if (valueChanged)
          this.applyModel(true);
      },

      applyMinMaxLimit: function(newValue) {
        if (this.options.minLimit != null && newValue < this.options.minLimit)
          return this.options.minLimit;
        if (this.options.maxLimit != null && newValue > this.options.maxLimit)
          return this.options.maxLimit;
        return newValue;
      },

      applyMinMaxRange: function(newValue) {
        var oppositeValue = this.tracking === 'lowValue' ? this.highValue : this.lowValue,
          difference = Math.abs(newValue - oppositeValue);
        if (this.options.minRange != null) {
          if (difference < this.options.minRange) {
            if (this.tracking === 'lowValue')
              return this.highValue - this.options.minRange;
            else
              return this.lowValue + this.options.minRange;
          }
        }
        if (this.options.maxRange != null) {
          if (difference > this.options.maxRange) {
            if (this.tracking === 'lowValue')
              return this.highValue - this.options.maxRange;
            else
              return this.lowValue + this.options.maxRange;
          }
        }
        return newValue;
      },

      applyPushRange: function(newValue) {
        var difference = this.tracking === 'lowValue' ? this.highValue - newValue : newValue - this.lowValue,
          minRange = this.options.minRange !== null ? this.options.minRange : this.options.step,
          maxRange = this.options.maxRange;
        // if smaller than minRange
        if (difference < minRange) {
          if (this.tracking === 'lowValue') {
            this.highValue = Math.min(newValue + minRange, this.maxValue);
            newValue = this.highValue - minRange;
            this.applyHighValue();
            this.updateHandles('highValue', this.valueToPosition(this.highValue));
          }
          else {
            this.lowValue = Math.max(newValue - minRange, this.minValue);
            newValue = this.lowValue + minRange;
            this.applyLowValue();
            this.updateHandles('lowValue', this.valueToPosition(this.lowValue));
          }
          this.updateAriaAttributes();
        }
        // if greater than maxRange
        else if (maxRange !== null && difference > maxRange) {
          if (this.tracking === 'lowValue') {
            this.highValue = newValue + maxRange;
            this.applyHighValue();
            this.updateHandles('highValue', this.valueToPosition(this.highValue));
          }
          else {
            this.lowValue = newValue - maxRange;
            this.applyLowValue();
            this.updateHandles('lowValue', this.valueToPosition(this.lowValue));
          }
          this.updateAriaAttributes();
        }
        return newValue;
      },

      /**
       * Apply the model values using scope.$apply.
       * We wrap it with the internalChange flag to avoid the watchers to be called
       */
      applyModel: function(callOnChange) {
        this.internalChange = true;
        this.scope.$apply();
        callOnChange && this.callOnChange();
        this.internalChange = false;
      },

      /**
       * Call the onStart callback if defined
       * The callback call is wrapped in a $evalAsync to ensure that its result will be applied to the scope.
       *
       * @returns {undefined}
       */
      callOnStart: function() {
        if (this.options.onStart) {
          var self = this,
            pointerType = this.tracking === 'lowValue' ? 'min' : 'max';
          this.scope.$evalAsync(function() {
            self.options.onStart(self.options.id, self.scope.rzSliderModel, self.scope.rzSliderHigh, pointerType);
          });
        }
      },

      /**
       * Call the onChange callback if defined
       * The callback call is wrapped in a $evalAsync to ensure that its result will be applied to the scope.
       *
       * @returns {undefined}
       */
      callOnChange: function() {
        if (this.options.onChange) {
          var self = this,
            pointerType = this.tracking === 'lowValue' ? 'min' : 'max';
          this.scope.$evalAsync(function() {
            self.options.onChange(self.options.id, self.scope.rzSliderModel, self.scope.rzSliderHigh, pointerType);
          });
        }
      },

      /**
       * Call the onEnd callback if defined
       * The callback call is wrapped in a $evalAsync to ensure that its result will be applied to the scope.
       *
       * @returns {undefined}
       */
      callOnEnd: function() {
        if (this.options.onEnd) {
          var self = this,
            pointerType = this.tracking === 'lowValue' ? 'min' : 'max';
          this.scope.$evalAsync(function() {
            self.options.onEnd(self.options.id, self.scope.rzSliderModel, self.scope.rzSliderHigh, pointerType);
          });
        }
        this.scope.$emit('slideEnded');
      }
    };

    return Slider;
  }])

  .directive('rzslider', ['RzSlider', function(RzSlider) {
    'use strict';

    return {
      restrict: 'AE',
      replace: true,
      scope: {
        rzSliderModel: '=?',
        rzSliderHigh: '=?',
        rzSliderOptions: '&?',
        rzSliderTplUrl: '@'
      },

      /**
       * Return template URL
       *
       * @param {jqLite} elem
       * @param {Object} attrs
       * @return {string}
       */
      templateUrl: function(elem, attrs) {
        //noinspection JSUnresolvedVariable
        return attrs.rzSliderTplUrl || 'rzSliderTpl.html';
      },

      link: function(scope, elem) {
        scope.slider = new RzSlider(scope, elem); //attach on scope so we can test it
      }
    };
  }]);

  // IDE assist

  /**
   * @name ngScope
   *
   * @property {number} rzSliderModel
   * @property {number} rzSliderHigh
   * @property {Object} rzSliderOptions
   */

  /**
   * @name jqLite
   *
   * @property {number|undefined} rzsp rzslider label position position
   * @property {number|undefined} rzsd rzslider element dimension
   * @property {string|undefined} rzsv rzslider label value/text
   * @property {Function} css
   * @property {Function} text
   */

  /**
   * @name Event
   * @property {Array} touches
   * @property {Event} originalEvent
   */

  /**
   * @name ThrottleOptions
   *
   * @property {boolean} leading
   * @property {boolean} trailing
   */

  module.run(['$templateCache', function($templateCache) {
  'use strict';

  $templateCache.put('rzSliderTpl.html',
    "<div class=rzslider><span class=rz-bar-wrapper><span class=rz-bar></span></span> <span class=rz-bar-wrapper><span class=\"rz-bar rz-selection\" ng-style=barStyle></span></span> <span class=\"rz-pointer rz-pointer-min\" ng-style=minPointerStyle></span> <span class=\"rz-pointer rz-pointer-max\" ng-style=maxPointerStyle></span> <span class=\"rz-bubble rz-limit rz-floor\"></span> <span class=\"rz-bubble rz-limit rz-ceil\"></span> <span class=rz-bubble></span> <span class=rz-bubble></span> <span class=rz-bubble></span><ul ng-show=showTicks class=rz-ticks><li ng-repeat=\"t in ticks track by $index\" class=rz-tick ng-class=\"{'rz-selected': t.selected}\" ng-style=t.style ng-attr-uib-tooltip=\"{{ t.tooltip }}\" ng-attr-tooltip-placement={{t.tooltipPlacement}} ng-attr-tooltip-append-to-body=\"{{ t.tooltip ? true : undefined}}\"><span ng-if=\"t.value != null\" class=rz-tick-value ng-attr-uib-tooltip=\"{{ t.valueTooltip }}\" ng-attr-tooltip-placement={{t.valueTooltipPlacement}}>{{ t.value }}</span> <span ng-if=\"t.legend != null\" class=rz-tick-legend>{{ t.legend }}</span></li></ul></div>"
  );

}]);

  return module.name
}));
;
/*
 AngularJS v1.4.7
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(G,t,Ra){'use strict';function va(a,b,c){if(!a)throw ngMinErr("areq",b||"?",c||"required");return a}function wa(a,b){if(!a&&!b)return"";if(!a)return b;if(!b)return a;W(a)&&(a=a.join(" "));W(b)&&(b=b.join(" "));return a+" "+b}function Ha(a){var b={};a&&(a.to||a.from)&&(b.to=a.to,b.from=a.from);return b}function S(a,b,c){var d="";a=W(a)?a:a&&M(a)&&a.length?a.split(/\s+/):[];q(a,function(a,u){a&&0<a.length&&(d+=0<u?" ":"",d+=c?b+a:a+b)});return d}function Ia(a){if(a instanceof J)switch(a.length){case 0:return[];
case 1:if(1===a[0].nodeType)return a;break;default:return J(la(a))}if(1===a.nodeType)return J(a)}function la(a){if(!a[0])return a;for(var b=0;b<a.length;b++){var c=a[b];if(1==c.nodeType)return c}}function Ja(a,b,c){q(b,function(b){a.addClass(b,c)})}function Ka(a,b,c){q(b,function(b){a.removeClass(b,c)})}function P(a){return function(b,c){c.addClass&&(Ja(a,b,c.addClass),c.addClass=null);c.removeClass&&(Ka(a,b,c.removeClass),c.removeClass=null)}}function ha(a){a=a||{};if(!a.$$prepared){var b=a.domOperation||
L;a.domOperation=function(){a.$$domOperationFired=!0;b();b=L};a.$$prepared=!0}return a}function da(a,b){xa(a,b);ya(a,b)}function xa(a,b){b.from&&(a.css(b.from),b.from=null)}function ya(a,b){b.to&&(a.css(b.to),b.to=null)}function Q(a,b,c){var d=(b.addClass||"")+" "+(c.addClass||""),g=(b.removeClass||"")+" "+(c.removeClass||"");a=La(a.attr("class"),d,g);c.preparationClasses&&(b.preparationClasses=X(c.preparationClasses,b.preparationClasses),delete c.preparationClasses);d=b.domOperation!==L?b.domOperation:
null;za(b,c);d&&(b.domOperation=d);b.addClass=a.addClass?a.addClass:null;b.removeClass=a.removeClass?a.removeClass:null;return b}function La(a,b,c){function d(a){M(a)&&(a=a.split(" "));var b={};q(a,function(a){a.length&&(b[a]=!0)});return b}var g={};a=d(a);b=d(b);q(b,function(a,b){g[b]=1});c=d(c);q(c,function(a,b){g[b]=1===g[b]?null:-1});var u={addClass:"",removeClass:""};q(g,function(b,c){var g,d;1===b?(g="addClass",d=!a[c]):-1===b&&(g="removeClass",d=a[c]);d&&(u[g].length&&(u[g]+=" "),u[g]+=c)});
return u}function H(a){return a instanceof t.element?a[0]:a}function Ma(a,b,c){var d="";b&&(d=S(b,"ng-",!0));c.addClass&&(d=X(d,S(c.addClass,"-add")));c.removeClass&&(d=X(d,S(c.removeClass,"-remove")));d.length&&(c.preparationClasses=d,a.addClass(d))}function ia(a,b){var c=b?"-"+b+"s":"";ea(a,[fa,c]);return[fa,c]}function ma(a,b){var c=b?"paused":"",d=T+"PlayState";ea(a,[d,c]);return[d,c]}function ea(a,b){a.style[b[0]]=b[1]}function X(a,b){return a?b?a+" "+b:a:b}function Aa(a,b,c){var d=Object.create(null),
g=a.getComputedStyle(b)||{};q(c,function(a,b){var c=g[a];if(c){var f=c.charAt(0);if("-"===f||"+"===f||0<=f)c=Na(c);0===c&&(c=null);d[b]=c}});return d}function Na(a){var b=0;a=a.split(/\s*,\s*/);q(a,function(a){"s"==a.charAt(a.length-1)&&(a=a.substring(0,a.length-1));a=parseFloat(a)||0;b=b?Math.max(a,b):a});return b}function na(a){return 0===a||null!=a}function Ba(a,b){var c=N,d=a+"s";b?c+="Duration":d+=" linear all";return[c,d]}function Ca(){var a=Object.create(null);return{flush:function(){a=Object.create(null)},
count:function(b){return(b=a[b])?b.total:0},get:function(b){return(b=a[b])&&b.value},put:function(b,c){a[b]?a[b].total++:a[b]={total:1,value:c}}}}function Da(a,b,c){q(c,function(c){a[c]=U(a[c])?a[c]:b.style.getPropertyValue(c)})}var L=t.noop,za=t.extend,J=t.element,q=t.forEach,W=t.isArray,M=t.isString,oa=t.isObject,pa=t.isUndefined,U=t.isDefined,Ea=t.isFunction,qa=t.isElement,N,ra,T,sa;pa(G.ontransitionend)&&U(G.onwebkittransitionend)?(N="WebkitTransition",ra="webkitTransitionEnd transitionend"):
(N="transition",ra="transitionend");pa(G.onanimationend)&&U(G.onwebkitanimationend)?(T="WebkitAnimation",sa="webkitAnimationEnd animationend"):(T="animation",sa="animationend");var ja=T+"Delay",ta=T+"Duration",fa=N+"Delay";G=N+"Duration";var Oa={transitionDuration:G,transitionDelay:fa,transitionProperty:N+"Property",animationDuration:ta,animationDelay:ja,animationIterationCount:T+"IterationCount"},Pa={transitionDuration:G,transitionDelay:fa,animationDuration:ta,animationDelay:ja};t.module("ngAnimate",
[]).directive("ngAnimateChildren",[function(){return function(a,b,c){a=c.ngAnimateChildren;t.isString(a)&&0===a.length?b.data("$$ngAnimateChildren",!0):c.$observe("ngAnimateChildren",function(a){b.data("$$ngAnimateChildren","on"===a||"true"===a)})}}]).factory("$$rAFScheduler",["$$rAF",function(a){function b(a){d=d.concat(a);c()}function c(){if(d.length){for(var b=d.shift(),z=0;z<b.length;z++)b[z]();g||a(function(){g||c()})}}var d,g;d=b.queue=[];b.waitUntilQuiet=function(b){g&&g();g=a(function(){g=
null;b();c()})};return b}]).factory("$$AnimateRunner",["$q","$sniffer","$$animateAsyncRun",function(a,b,c){function d(a){this.setHost(a);this._doneCallbacks=[];this._runInAnimationFrame=c();this._state=0}d.chain=function(a,b){function c(){if(d===a.length)b(!0);else a[d](function(a){!1===a?b(!1):(d++,c())})}var d=0;c()};d.all=function(a,b){function c(z){f=f&&z;++d===a.length&&b(f)}var d=0,f=!0;q(a,function(a){a.done(c)})};d.prototype={setHost:function(a){this.host=a||{}},done:function(a){2===this._state?
a():this._doneCallbacks.push(a)},progress:L,getPromise:function(){if(!this.promise){var b=this;this.promise=a(function(a,c){b.done(function(b){!1===b?c():a()})})}return this.promise},then:function(a,b){return this.getPromise().then(a,b)},"catch":function(a){return this.getPromise()["catch"](a)},"finally":function(a){return this.getPromise()["finally"](a)},pause:function(){this.host.pause&&this.host.pause()},resume:function(){this.host.resume&&this.host.resume()},end:function(){this.host.end&&this.host.end();
this._resolve(!0)},cancel:function(){this.host.cancel&&this.host.cancel();this._resolve(!1)},complete:function(a){var b=this;0===b._state&&(b._state=1,b._runInAnimationFrame(function(){b._resolve(a)}))},_resolve:function(a){2!==this._state&&(q(this._doneCallbacks,function(b){b(a)}),this._doneCallbacks.length=0,this._state=2)}};return d}]).factory("$$animateAsyncRun",["$$rAF",function(a){function b(b){c.push(b);1<c.length||a(function(){for(var a=0;a<c.length;a++)c[a]();c=[]})}var c=[];return function(){var a=
!1;b(function(){a=!0});return function(c){a?c():b(c)}}}]).provider("$$animateQueue",["$animateProvider",function(a){function b(a,b,c,q){return d[a].some(function(a){return a(b,c,q)})}function c(a,b){a=a||{};var c=0<(a.addClass||"").length,d=0<(a.removeClass||"").length;return b?c&&d:c||d}var d=this.rules={skip:[],cancel:[],join:[]};d.join.push(function(a,b,d){return!b.structural&&c(b.options)});d.skip.push(function(a,b,d){return!b.structural&&!c(b.options)});d.skip.push(function(a,b,c){return"leave"==
c.event&&b.structural});d.skip.push(function(a,b,c){return c.structural&&2===c.state&&!b.structural});d.cancel.push(function(a,b,c){return c.structural&&b.structural});d.cancel.push(function(a,b,c){return 2===c.state&&b.structural});d.cancel.push(function(a,b,c){a=b.options;c=c.options;return a.addClass&&a.addClass===c.removeClass||a.removeClass&&a.removeClass===c.addClass});this.$get=["$$rAF","$rootScope","$rootElement","$document","$$HashMap","$$animation","$$AnimateRunner","$templateRequest","$$jqLite",
"$$forceReflow",function(d,u,z,x,f,k,$,t,h,I){function A(){var a=!1;return function(b){a?b():u.$$postDigest(function(){a=!0;b()})}}function Y(a,b){var c=H(a),e=[],d=v[b];d&&q(d,function(a){a.node.contains(c)&&e.push(a.callback)});return e}function E(a,e,l){function n(b,c,e,v){z(function(){var b=Y(a,c);b.length&&d(function(){q(b,function(b){b(a,e,v)})})});b.progress(c,e,v)}function v(b){var c=a,e=l;e.preparationClasses&&(c.removeClass(e.preparationClasses),e.preparationClasses=null);e.activeClasses&&
(c.removeClass(e.activeClasses),e.activeClasses=null);Ga(a,l);da(a,l);l.domOperation();f.complete(!b)}var s,C;if(a=Ia(a))s=H(a),C=a.parent();l=ha(l);var f=new $,z=A();W(l.addClass)&&(l.addClass=l.addClass.join(" "));l.addClass&&!M(l.addClass)&&(l.addClass=null);W(l.removeClass)&&(l.removeClass=l.removeClass.join(" "));l.removeClass&&!M(l.removeClass)&&(l.removeClass=null);l.from&&!oa(l.from)&&(l.from=null);l.to&&!oa(l.to)&&(l.to=null);if(!s)return v(),f;var h=[s.className,l.addClass,l.removeClass].join(" ");
if(!Qa(h))return v(),f;var E=0<=["enter","move","leave"].indexOf(e),x=!F||D.get(s),h=!x&&m.get(s)||{},I=!!h.state;x||I&&1==h.state||(x=!ka(a,C,e));if(x)return v(),f;E&&w(a);C={structural:E,element:a,event:e,close:v,options:l,runner:f};if(I){if(b("skip",a,C,h)){if(2===h.state)return v(),f;Q(a,h.options,l);return h.runner}if(b("cancel",a,C,h))if(2===h.state)h.runner.end();else if(h.structural)h.close();else return Q(a,h.options,C.options),h.runner;else if(b("join",a,C,h))if(2===h.state)Q(a,l,{});else return Ma(a,
E?e:null,l),e=C.event=h.event,l=Q(a,h.options,C.options),h.runner}else Q(a,l,{});(I=C.structural)||(I="animate"===C.event&&0<Object.keys(C.options.to||{}).length||c(C.options));if(!I)return v(),y(a),f;var t=(h.counter||0)+1;C.counter=t;r(a,1,C);u.$$postDigest(function(){var b=m.get(s),d=!b,b=b||{},h=0<(a.parent()||[]).length&&("animate"===b.event||b.structural||c(b.options));if(d||b.counter!==t||!h){d&&(Ga(a,l),da(a,l));if(d||E&&b.event!==e)l.domOperation(),f.end();h||y(a)}else e=!b.structural&&c(b.options,
!0)?"setClass":b.event,r(a,2),b=k(a,e,b.options),b.done(function(b){v(!b);(b=m.get(s))&&b.counter===t&&y(H(a));n(f,e,"close",{})}),f.setHost(b),n(f,e,"start",{})});return f}function w(a){a=H(a).querySelectorAll("[data-ng-animate]");q(a,function(a){var b=parseInt(a.getAttribute("data-ng-animate")),c=m.get(a);switch(b){case 2:c.runner.end();case 1:c&&m.remove(a)}})}function y(a){a=H(a);a.removeAttribute("data-ng-animate");m.remove(a)}function e(a,b){return H(a)===H(b)}function ka(a,b,c){c=J(x[0].body);
var d=e(a,c)||"HTML"===a[0].nodeName,v=e(a,z),n=!1,y;for((a=a.data("$ngAnimatePin"))&&(b=a);b&&b.length;){v||(v=e(b,z));a=b[0];if(1!==a.nodeType)break;var r=m.get(a)||{};n||(n=r.structural||D.get(a));if(pa(y)||!0===y)a=b.data("$$ngAnimateChildren"),U(a)&&(y=a);if(n&&!1===y)break;v||(v=e(b,z),v||(a=b.data("$ngAnimatePin"))&&(b=a));d||(d=e(b,c));b=b.parent()}return(!n||y)&&v&&d}function r(a,b,c){c=c||{};c.state=b;a=H(a);a.setAttribute("data-ng-animate",b);c=(b=m.get(a))?za(b,c):c;m.put(a,c)}var m=new f,
D=new f,F=null,s=u.$watch(function(){return 0===t.totalPendingRequests},function(a){a&&(s(),u.$$postDigest(function(){u.$$postDigest(function(){null===F&&(F=!0)})}))}),v={},n=a.classNameFilter(),Qa=n?function(a){return n.test(a)}:function(){return!0},Ga=P(h);return{on:function(a,b,c){b=la(b);v[a]=v[a]||[];v[a].push({node:b,callback:c})},off:function(a,b,c){function e(a,b,c){var d=la(b);return a.filter(function(a){return!(a.node===d&&(!c||a.callback===c))})}var d=v[a];d&&(v[a]=1===arguments.length?
null:e(d,b,c))},pin:function(a,b){va(qa(a),"element","not an element");va(qa(b),"parentElement","not an element");a.data("$ngAnimatePin",b)},push:function(a,b,c,e){c=c||{};c.domOperation=e;return E(a,b,c)},enabled:function(a,b){var c=arguments.length;if(0===c)b=!!F;else if(qa(a)){var e=H(a),d=D.get(e);1===c?b=!d:(b=!!b)?d&&D.remove(e):D.put(e,!0)}else b=F=!!a;return b}}}]}]).provider("$$animation",["$animateProvider",function(a){function b(a){return a.data("$$animationRunner")}var c=this.drivers=
[];this.$get=["$$jqLite","$rootScope","$injector","$$AnimateRunner","$$HashMap","$$rAFScheduler",function(a,g,u,z,x,f){function k(a){function b(a){if(a.processed)return a;a.processed=!0;var e=a.domNode,d=e.parentNode;f.put(e,a);for(var r;d;){if(r=f.get(d)){r.processed||(r=b(r));break}d=d.parentNode}(r||c).children.push(a);return a}var c={children:[]},d,f=new x;for(d=0;d<a.length;d++){var g=a[d];f.put(g.domNode,a[d]={domNode:g.domNode,fn:g.fn,children:[]})}for(d=0;d<a.length;d++)b(a[d]);return function(a){var b=
[],c=[],d;for(d=0;d<a.children.length;d++)c.push(a.children[d]);a=c.length;var m=0,f=[];for(d=0;d<c.length;d++){var g=c[d];0>=a&&(a=m,m=0,b.push(f),f=[]);f.push(g.fn);g.children.forEach(function(a){m++;c.push(a)});a--}f.length&&b.push(f);return b}(c)}var $=[],t=P(a);return function(h,x,A){function Y(a){a=a.hasAttribute("ng-animate-ref")?[a]:a.querySelectorAll("[ng-animate-ref]");var b=[];q(a,function(a){var c=a.getAttribute("ng-animate-ref");c&&c.length&&b.push(a)});return b}function E(a){var b=[],
c={};q(a,function(a,e){var d=H(a.element),v=0<=["enter","move"].indexOf(a.event),d=a.structural?Y(d):[];if(d.length){var m=v?"to":"from";q(d,function(a){var b=a.getAttribute("ng-animate-ref");c[b]=c[b]||{};c[b][m]={animationID:e,element:J(a)}})}else b.push(a)});var e={},d={};q(c,function(c,m){var f=c.from,y=c.to;if(f&&y){var g=a[f.animationID],r=a[y.animationID],s=f.animationID.toString();if(!d[s]){var h=d[s]={structural:!0,beforeStart:function(){g.beforeStart();r.beforeStart()},close:function(){g.close();
r.close()},classes:w(g.classes,r.classes),from:g,to:r,anchors:[]};h.classes.length?b.push(h):(b.push(g),b.push(r))}d[s].anchors.push({out:f.element,"in":y.element})}else f=f?f.animationID:y.animationID,y=f.toString(),e[y]||(e[y]=!0,b.push(a[f]))});return b}function w(a,b){a=a.split(" ");b=b.split(" ");for(var c=[],e=0;e<a.length;e++){var d=a[e];if("ng-"!==d.substring(0,3))for(var m=0;m<b.length;m++)if(d===b[m]){c.push(d);break}}return c.join(" ")}function y(a){for(var b=c.length-1;0<=b;b--){var e=
c[b];if(u.has(e)&&(e=u.get(e)(a)))return e}}function e(a,c){a.from&&a.to?(b(a.from.element).setHost(c),b(a.to.element).setHost(c)):b(a.element).setHost(c)}function ka(){var a=b(h);!a||"leave"===x&&A.$$domOperationFired||a.end()}function r(b){h.off("$destroy",ka);h.removeData("$$animationRunner");t(h,A);da(h,A);A.domOperation();s&&a.removeClass(h,s);h.removeClass("ng-animate");D.complete(!b)}A=ha(A);var m=0<=["enter","move","leave"].indexOf(x),D=new z({end:function(){r()},cancel:function(){r(!0)}});
if(!c.length)return r(),D;h.data("$$animationRunner",D);var F=wa(h.attr("class"),wa(A.addClass,A.removeClass)),s=A.tempClasses;s&&(F+=" "+s,A.tempClasses=null);$.push({element:h,classes:F,event:x,structural:m,options:A,beforeStart:function(){h.addClass("ng-animate");s&&a.addClass(h,s)},close:r});h.on("$destroy",ka);if(1<$.length)return D;g.$$postDigest(function(){var a=[];q($,function(c){b(c.element)?a.push(c):c.close()});$.length=0;var c=E(a),d=[];q(c,function(a){d.push({domNode:H(a.from?a.from.element:
a.element),fn:function(){a.beforeStart();var c,d=a.close;if(b(a.anchors?a.from.element||a.to.element:a.element)){var m=y(a);m&&(c=m.start)}c?(c=c(),c.done(function(a){d(!a)}),e(a,c)):d()}})});f(k(d))});return D}}]}]).provider("$animateCss",["$animateProvider",function(a){var b=Ca(),c=Ca();this.$get=["$window","$$jqLite","$$AnimateRunner","$timeout","$$forceReflow","$sniffer","$$rAFScheduler","$animate",function(a,g,u,z,x,f,k,t){function Fa(a,b){var c=a.parentNode;return(c.$$ngAnimateParentKey||(c.$$ngAnimateParentKey=
++E))+"-"+a.getAttribute("class")+"-"+b}function h(f,e,h,r){var m;0<b.count(h)&&(m=c.get(h),m||(e=S(e,"-stagger"),g.addClass(f,e),m=Aa(a,f,r),m.animationDuration=Math.max(m.animationDuration,0),m.transitionDuration=Math.max(m.transitionDuration,0),g.removeClass(f,e),c.put(h,m)));return m||{}}function I(a){w.push(a);k.waitUntilQuiet(function(){b.flush();c.flush();for(var a=x(),d=0;d<w.length;d++)w[d](a);w.length=0})}function A(c,e,f){e=b.get(f);e||(e=Aa(a,c,Oa),"infinite"===e.animationIterationCount&&
(e.animationIterationCount=1));b.put(f,e);c=e;f=c.animationDelay;e=c.transitionDelay;c.maxDelay=f&&e?Math.max(f,e):f||e;c.maxDuration=Math.max(c.animationDuration*c.animationIterationCount,c.transitionDuration);return c}var Y=P(g),E=0,w=[];return function(a,c){function d(){m()}function r(){m(!0)}function m(b){if(!(E||ua&&l)){E=!0;l=!1;c.$$skipPreparationClasses||g.removeClass(a,Z);g.removeClass(a,X);ma(n,!1);ia(n,!1);q(w,function(a){n.style[a[0]]=""});Y(a,c);da(a,c);Object.keys(v).length&&q(v,function(a,
b){a?n.style.setProperty(b,a):n.style.removeProperty(b)});if(c.onDone)c.onDone();G&&G.complete(!b)}}function D(a){p.blockTransition&&ia(n,a);p.blockKeyframeAnimation&&ma(n,!!a)}function F(){G=new u({end:d,cancel:r});I(L);m();return{$$willAnimate:!1,start:function(){return G},end:d}}function s(){function b(){if(!E){D(!1);q(w,function(a){n.style[a[0]]=a[1]});Y(a,c);g.addClass(a,X);if(p.recalculateTimingStyles){ga=n.className+" "+Z;aa=Fa(n,ga);B=A(n,ga,aa);V=B.maxDelay;C=Math.max(V,0);K=B.maxDuration;
if(0===K){m();return}p.hasTransitions=0<B.transitionDuration;p.hasAnimations=0<B.animationDuration}p.applyAnimationDelay&&(V="boolean"!==typeof c.delay&&na(c.delay)?parseFloat(c.delay):V,C=Math.max(V,0),B.animationDelay=V,ca=[ja,V+"s"],w.push(ca),n.style[ca[0]]=ca[1]);M=1E3*C;P=1E3*K;if(c.easing){var s,k=c.easing;p.hasTransitions&&(s=N+"TimingFunction",w.push([s,k]),n.style[s]=k);p.hasAnimations&&(s=T+"TimingFunction",w.push([s,k]),n.style[s]=k)}B.transitionDuration&&h.push(ra);B.animationDuration&&
h.push(sa);r=Date.now();var l=M+1.5*P;s=r+l;var k=a.data("$$animateCss")||[],x=!0;if(k.length){var F=k[0];(x=s>F.expectedEndTime)?z.cancel(F.timer):k.push(m)}x&&(l=z(d,l,!1),k[0]={timer:l,expectedEndTime:s},k.push(m),a.data("$$animateCss",k));a.on(h.join(" "),f);c.to&&(c.cleanupStyles&&Da(v,n,Object.keys(c.to)),ya(a,c))}}function d(){var b=a.data("$$animateCss");if(b){for(var c=1;c<b.length;c++)b[c]();a.removeData("$$animateCss")}}function f(a){a.stopPropagation();var b=a.originalEvent||a;a=b.$manualTimeStamp||
b.timeStamp||Date.now();b=parseFloat(b.elapsedTime.toFixed(3));Math.max(a-r,0)>=M&&b>=K&&(ua=!0,m())}if(!E)if(n.parentNode){var r,h=[],s=function(a){if(ua)l&&a&&(l=!1,m());else if(l=!a,B.animationDuration)if(a=ma(n,l),l)w.push(a);else{var b=w,c=b.indexOf(a);0<=a&&b.splice(c,1)}},k=0<U&&(B.transitionDuration&&0===R.transitionDuration||B.animationDuration&&0===R.animationDuration)&&Math.max(R.animationDelay,R.transitionDelay);k?z(b,Math.floor(k*U*1E3),!1):b();J.resume=function(){s(!0)};J.pause=function(){s(!1)}}else m()}
var v={},n=H(a);if(!n||!n.parentNode||!t.enabled())return F();c=ha(c);var w=[],x=a.attr("class"),k=Ha(c),E,l,ua,G,J,C,M,K,P;if(0===c.duration||!f.animations&&!f.transitions)return F();var ba=c.event&&W(c.event)?c.event.join(" "):c.event,Q="",O="";ba&&c.structural?Q=S(ba,"ng-",!0):ba&&(Q=ba);c.addClass&&(O+=S(c.addClass,"-add"));c.removeClass&&(O.length&&(O+=" "),O+=S(c.removeClass,"-remove"));c.applyClassesEarly&&O.length&&Y(a,c);var Z=[Q,O].join(" ").trim(),ga=x+" "+Z,X=S(Z,"-active"),x=k.to&&0<
Object.keys(k.to).length;if(!(0<(c.keyframeStyle||"").length||x||Z))return F();var aa,R;0<c.stagger?(k=parseFloat(c.stagger),R={transitionDelay:k,animationDelay:k,transitionDuration:0,animationDuration:0}):(aa=Fa(n,ga),R=h(n,Z,aa,Pa));c.$$skipPreparationClasses||g.addClass(a,Z);c.transitionStyle&&(k=[N,c.transitionStyle],ea(n,k),w.push(k));0<=c.duration&&(k=0<n.style[N].length,k=Ba(c.duration,k),ea(n,k),w.push(k));c.keyframeStyle&&(k=[T,c.keyframeStyle],ea(n,k),w.push(k));var U=R?0<=c.staggerIndex?
c.staggerIndex:b.count(aa):0;(ba=0===U)&&!c.skipBlocking&&ia(n,9999);var B=A(n,ga,aa),V=B.maxDelay;C=Math.max(V,0);K=B.maxDuration;var p={};p.hasTransitions=0<B.transitionDuration;p.hasAnimations=0<B.animationDuration;p.hasTransitionAll=p.hasTransitions&&"all"==B.transitionProperty;p.applyTransitionDuration=x&&(p.hasTransitions&&!p.hasTransitionAll||p.hasAnimations&&!p.hasTransitions);p.applyAnimationDuration=c.duration&&p.hasAnimations;p.applyTransitionDelay=na(c.delay)&&(p.applyTransitionDuration||
p.hasTransitions);p.applyAnimationDelay=na(c.delay)&&p.hasAnimations;p.recalculateTimingStyles=0<O.length;if(p.applyTransitionDuration||p.applyAnimationDuration)K=c.duration?parseFloat(c.duration):K,p.applyTransitionDuration&&(p.hasTransitions=!0,B.transitionDuration=K,k=0<n.style[N+"Property"].length,w.push(Ba(K,k))),p.applyAnimationDuration&&(p.hasAnimations=!0,B.animationDuration=K,w.push([ta,K+"s"]));if(0===K&&!p.recalculateTimingStyles)return F();if(null!=c.delay){var ca=parseFloat(c.delay);
p.applyTransitionDelay&&w.push([fa,ca+"s"]);p.applyAnimationDelay&&w.push([ja,ca+"s"])}null==c.duration&&0<B.transitionDuration&&(p.recalculateTimingStyles=p.recalculateTimingStyles||ba);M=1E3*C;P=1E3*K;c.skipBlocking||(p.blockTransition=0<B.transitionDuration,p.blockKeyframeAnimation=0<B.animationDuration&&0<R.animationDelay&&0===R.animationDuration);c.from&&(c.cleanupStyles&&Da(v,n,Object.keys(c.from)),xa(a,c));p.blockTransition||p.blockKeyframeAnimation?D(K):c.skipBlocking||ia(n,!1);return{$$willAnimate:!0,
end:d,start:function(){if(!E)return J={end:d,cancel:r,resume:null,pause:null},G=new u(J),I(s),G}}}}]}]).provider("$$animateCssDriver",["$$animationProvider",function(a){a.drivers.push("$$animateCssDriver");this.$get=["$animateCss","$rootScope","$$AnimateRunner","$rootElement","$sniffer","$$jqLite","$document",function(a,c,d,g,u,z,x){function f(a){return a.replace(/\bng-\S+\b/g,"")}function k(a,b){M(a)&&(a=a.split(" "));M(b)&&(b=b.split(" "));return a.filter(function(a){return-1===b.indexOf(a)}).join(" ")}
function t(c,h,g){function x(a){var b={},c=H(a).getBoundingClientRect();q(["width","height","top","left"],function(a){var d=c[a];switch(a){case "top":d+=I.scrollTop;break;case "left":d+=I.scrollLeft}b[a]=Math.floor(d)+"px"});return b}function e(){var c=f(g.attr("class")||""),d=k(c,m),c=k(m,c),d=a(r,{to:x(g),addClass:"ng-anchor-in "+d,removeClass:"ng-anchor-out "+c,delay:!0});return d.$$willAnimate?d:null}function z(){r.remove();h.removeClass("ng-animate-shim");g.removeClass("ng-animate-shim")}var r=
J(H(h).cloneNode(!0)),m=f(r.attr("class")||"");h.addClass("ng-animate-shim");g.addClass("ng-animate-shim");r.addClass("ng-anchor");A.append(r);var D;c=function(){var c=a(r,{addClass:"ng-anchor-out",delay:!0,from:x(h)});return c.$$willAnimate?c:null}();if(!c&&(D=e(),!D))return z();var F=c||D;return{start:function(){function a(){c&&c.end()}var b,c=F.start();c.done(function(){c=null;if(!D&&(D=e()))return c=D.start(),c.done(function(){c=null;z();b.complete()}),c;z();b.complete()});return b=new d({end:a,
cancel:a})}}}function G(a,b,c,f){var e=h(a,L),g=h(b,L),k=[];q(f,function(a){(a=t(c,a.out,a["in"]))&&k.push(a)});if(e||g||0!==k.length)return{start:function(){function a(){q(b,function(a){a.end()})}var b=[];e&&b.push(e.start());g&&b.push(g.start());q(k,function(a){b.push(a.start())});var c=new d({end:a,cancel:a});d.all(b,function(a){c.complete(a)});return c}}}function h(c){var d=c.element,f=c.options||{};c.structural&&(f.event=c.event,f.structural=!0,f.applyClassesEarly=!0,"leave"===c.event&&(f.onDone=
f.domOperation));f.preparationClasses&&(f.event=X(f.event,f.preparationClasses));c=a(d,f);return c.$$willAnimate?c:null}if(!u.animations&&!u.transitions)return L;var I=x[0].body;c=H(g);var A=J(c.parentNode&&11===c.parentNode.nodeType||I.contains(c)?c:I);P(z);return function(a){return a.from&&a.to?G(a.from,a.to,a.classes,a.anchors):h(a)}}]}]).provider("$$animateJs",["$animateProvider",function(a){this.$get=["$injector","$$AnimateRunner","$$jqLite",function(b,c,d){function g(c){c=W(c)?c:c.split(" ");
for(var d=[],f={},g=0;g<c.length;g++){var q=c[g],u=a.$$registeredAnimations[q];u&&!f[q]&&(d.push(b.get(u)),f[q]=!0)}return d}var u=P(d);return function(a,b,d,k){function t(){k.domOperation();u(a,k)}function G(a,b,d,f,e){switch(d){case "animate":b=[b,f.from,f.to,e];break;case "setClass":b=[b,A,H,e];break;case "addClass":b=[b,A,e];break;case "removeClass":b=[b,H,e];break;default:b=[b,e]}b.push(f);if(a=a.apply(a,b))if(Ea(a.start)&&(a=a.start()),a instanceof c)a.done(e);else if(Ea(a))return a;return L}
function h(a,b,d,e,f){var g=[];q(e,function(e){var h=e[f];h&&g.push(function(){var e,f,g=!1,k=function(a){g||(g=!0,(f||L)(a),e.complete(!a))};e=new c({end:function(){k()},cancel:function(){k(!0)}});f=G(h,a,b,d,function(a){k(!1===a)});return e})});return g}function I(a,b,d,e,f){var g=h(a,b,d,e,f);if(0===g.length){var k,u;"beforeSetClass"===f?(k=h(a,"removeClass",d,e,"beforeRemoveClass"),u=h(a,"addClass",d,e,"beforeAddClass")):"setClass"===f&&(k=h(a,"removeClass",d,e,"removeClass"),u=h(a,"addClass",
d,e,"addClass"));k&&(g=g.concat(k));u&&(g=g.concat(u))}if(0!==g.length)return function(a){var b=[];g.length&&q(g,function(a){b.push(a())});b.length?c.all(b,a):a();return function(a){q(b,function(b){a?b.cancel():b.end()})}}}3===arguments.length&&oa(d)&&(k=d,d=null);k=ha(k);d||(d=a.attr("class")||"",k.addClass&&(d+=" "+k.addClass),k.removeClass&&(d+=" "+k.removeClass));var A=k.addClass,H=k.removeClass,E=g(d),w,y;if(E.length){var e,J;"leave"==b?(J="leave",e="afterLeave"):(J="before"+b.charAt(0).toUpperCase()+
b.substr(1),e=b);"enter"!==b&&"move"!==b&&(w=I(a,b,k,E,J));y=I(a,b,k,E,e)}if(w||y)return{start:function(){function b(c){f=!0;t();da(a,k);g.complete(c)}var d,e=[];w&&e.push(function(a){d=w(a)});e.length?e.push(function(a){t();a(!0)}):t();y&&e.push(function(a){d=y(a)});var f=!1,g=new c({end:function(){f||((d||L)(void 0),b(void 0))},cancel:function(){f||((d||L)(!0),b(!0))}});c.chain(e,b);return g}}}}]}]).provider("$$animateJsDriver",["$$animationProvider",function(a){a.drivers.push("$$animateJsDriver");
this.$get=["$$animateJs","$$AnimateRunner",function(a,c){function d(c){return a(c.element,c.event,c.classes,c.options)}return function(a){if(a.from&&a.to){var b=d(a.from),t=d(a.to);if(b||t)return{start:function(){function a(){return function(){q(d,function(a){a.end()})}}var d=[];b&&d.push(b.start());t&&d.push(t.start());c.all(d,function(a){g.complete(a)});var g=new c({end:a(),cancel:a()});return g}}}else return d(a)}}]}])})(window,window.angular);
//# sourceMappingURL=angular-animate.min.js.map
;
/*
 AngularJS v1.4.7
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(p,c,n){'use strict';function l(b,a,g){var d=g.baseHref(),k=b[0];return function(b,e,f){var g,h;f=f||{};h=f.expires;g=c.isDefined(f.path)?f.path:d;c.isUndefined(e)&&(h="Thu, 01 Jan 1970 00:00:00 GMT",e="");c.isString(h)&&(h=new Date(h));e=encodeURIComponent(b)+"="+encodeURIComponent(e);e=e+(g?";path="+g:"")+(f.domain?";domain="+f.domain:"");e+=h?";expires="+h.toUTCString():"";e+=f.secure?";secure":"";f=e.length+1;4096<f&&a.warn("Cookie '"+b+"' possibly not set or overflowed because it was too large ("+
f+" > 4096 bytes)!");k.cookie=e}}c.module("ngCookies",["ng"]).provider("$cookies",[function(){var b=this.defaults={};this.$get=["$$cookieReader","$$cookieWriter",function(a,g){return{get:function(d){return a()[d]},getObject:function(d){return(d=this.get(d))?c.fromJson(d):d},getAll:function(){return a()},put:function(d,a,m){g(d,a,m?c.extend({},b,m):b)},putObject:function(d,b,a){this.put(d,c.toJson(b),a)},remove:function(a,k){g(a,n,k?c.extend({},b,k):b)}}}]}]);c.module("ngCookies").factory("$cookieStore",
["$cookies",function(b){return{get:function(a){return b.getObject(a)},put:function(a,c){b.putObject(a,c)},remove:function(a){b.remove(a)}}}]);l.$inject=["$document","$log","$browser"];c.module("ngCookies").provider("$$cookieWriter",function(){this.$get=l})})(window,window.angular);

;
angular.module("gettext",[]),angular.module("gettext").constant("gettext",function(a){return a}),angular.module("gettext").factory("gettextCatalog",["gettextPlurals","gettextFallbackLanguage","$http","$cacheFactory","$interpolate","$rootScope",function(a,b,c,d,e,f){function g(){f.$broadcast("gettextLanguageChanged")}var h,i="$$noContext",j='<span id="test" title="test" class="tested">test</span>',k=angular.element("<span>"+j+"</span>").html()!==j,l=function(a){return h.debug&&h.currentLanguage!==h.baseLanguage?h.debugPrefix+a:a},m=function(a){return h.showTranslatedMarkers?h.translatedMarkerPrefix+a+h.translatedMarkerSuffix:a};return h={debug:!1,debugPrefix:"[MISSING]: ",showTranslatedMarkers:!1,translatedMarkerPrefix:"[",translatedMarkerSuffix:"]",strings:{},baseLanguage:"en",currentLanguage:"en",cache:d("strings"),setCurrentLanguage:function(a){this.currentLanguage=a,g()},getCurrentLanguage:function(){return this.currentLanguage},setStrings:function(b,c){this.strings[b]||(this.strings[b]={});var d=a(b,1);for(var e in c){var f=c[e];if(k&&(e=angular.element("<span>"+e+"</span>").html()),angular.isString(f)||angular.isArray(f)){var h={};h[i]=f,f=h}this.strings[b][e]||(this.strings[b][e]={});for(var j in f){var l=f[j];angular.isArray(l)?this.strings[b][e][j]=l:(this.strings[b][e][j]=[],this.strings[b][e][j][d]=l)}}g()},getStringFormFor:function(b,c,d,e){if(!b)return null;var f=this.strings[b]||{},g=f[c]||{},h=g[e||i]||[];return h[a(b,d)]},getString:function(a,c,d){var f=b(this.currentLanguage);return a=this.getStringFormFor(this.currentLanguage,a,1,d)||this.getStringFormFor(f,a,1,d)||l(a),a=c?e(a)(c):a,m(a)},getPlural:function(a,c,d,f,g){var h=b(this.currentLanguage);return c=this.getStringFormFor(this.currentLanguage,c,a,g)||this.getStringFormFor(h,c,a,g)||l(1===a?c:d),f&&(f.$count=a,c=e(c)(f)),m(c)},loadRemote:function(a){return c({method:"GET",url:a,cache:h.cache}).then(function(a){var b=a.data;for(var c in b)h.setStrings(c,b[c]);return a})}}}]),angular.module("gettext").directive("translate",["gettextCatalog","$parse","$animate","$compile","$window","gettextUtil",function(a,b,c,d,e,f){function g(a){return f.lcFirst(a.replace(j,""))}function h(a,b,c){var d=Object.keys(b).filter(function(a){return f.startsWith(a,j)&&a!==j});if(!d.length)return null;var e=angular.extend({},a),h=[];return d.forEach(function(d){var f=a.$watch(b[d],function(a){var b=g(d);e[b]=a,c(e)});h.push(f)}),a.$on("$destroy",function(){h.forEach(function(a){a()})}),e}var i=parseInt((/msie (\d+)/.exec(angular.lowercase(e.navigator.userAgent))||[])[1],10),j="translateParams";return{restrict:"AE",terminal:!0,compile:function(e,g){f.assert(!g.translatePlural||g.translateN,"translate-n","translate-plural"),f.assert(!g.translateN||g.translatePlural,"translate-plural","translate-n");var j=f.trim(e.html()),k=g.translatePlural,l=g.translateContext;return 8>=i&&"<!--IE fix-->"===j.slice(-13)&&(j=j.slice(0,-13)),{post:function(e,g,i){function m(b){b=b||null;var h;k?(e=o||(o=e.$new()),e.$count=n(e),h=a.getPlural(e.$count,j,k,b,l)):h=a.getString(j,b,l);var i=g.contents();if(i||h){if(h===f.trim(i.html()))return void(p&&d(i)(e));var m=angular.element("<span>"+h+"</span>");d(m.contents())(e);var q=m.contents();c.enter(q,g),c.leave(i)}}var n=b(i.translateN),o=null,p=!0,q=h(e,i,m);m(q),p=!1,i.translateN&&e.$watch(i.translateN,function(){m(q)}),e.$on("gettextLanguageChanged",function(){m(q)})}}}}}]),angular.module("gettext").factory("gettextFallbackLanguage",function(){var a={},b=/([^_]+)_[^_]+$/;return function(c){if(a[c])return a[c];var d=b.exec(c);return d?(a[c]=d[1],d[1]):null}}),angular.module("gettext").filter("translate",["gettextCatalog",function(a){function b(b,c){return a.getString(b,null,c)}return b.$stateful=!0,b}]),angular.module("gettext").factory("gettextPlurals",function(){function a(a){return b[a]||(b[a]=a.split(/\-|_/).shift()),b[a]}var b={pt_BR:"pt_BR","pt-BR":"pt_BR"};return function(b,c){switch(a(b)){case"ay":case"bo":case"cgg":case"dz":case"fa":case"id":case"ja":case"jbo":case"ka":case"kk":case"km":case"ko":case"ky":case"lo":case"ms":case"my":case"sah":case"su":case"th":case"tt":case"ug":case"vi":case"wo":case"zh":return 0;case"is":return c%10!=1||c%100==11?1:0;case"jv":return 0!=c?1:0;case"mk":return 1==c||c%10==1?0:1;case"ach":case"ak":case"am":case"arn":case"br":case"fil":case"fr":case"gun":case"ln":case"mfe":case"mg":case"mi":case"oc":case"pt_BR":case"tg":case"ti":case"tr":case"uz":case"wa":case"zh":return c>1?1:0;case"lv":return c%10==1&&c%100!=11?0:0!=c?1:2;case"lt":return c%10==1&&c%100!=11?0:c%10>=2&&(10>c%100||c%100>=20)?1:2;case"be":case"bs":case"hr":case"ru":case"sr":case"uk":return c%10==1&&c%100!=11?0:c%10>=2&&4>=c%10&&(10>c%100||c%100>=20)?1:2;case"mnk":return 0==c?0:1==c?1:2;case"ro":return 1==c?0:0==c||c%100>0&&20>c%100?1:2;case"pl":return 1==c?0:c%10>=2&&4>=c%10&&(10>c%100||c%100>=20)?1:2;case"cs":case"sk":return 1==c?0:c>=2&&4>=c?1:2;case"sl":return c%100==1?1:c%100==2?2:c%100==3||c%100==4?3:0;case"mt":return 1==c?0:0==c||c%100>1&&11>c%100?1:c%100>10&&20>c%100?2:3;case"gd":return 1==c||11==c?0:2==c||12==c?1:c>2&&20>c?2:3;case"cy":return 1==c?0:2==c?1:8!=c&&11!=c?2:3;case"kw":return 1==c?0:2==c?1:3==c?2:3;case"ga":return 1==c?0:2==c?1:7>c?2:11>c?3:4;case"ar":return 0==c?0:1==c?1:2==c?2:c%100>=3&&10>=c%100?3:c%100>=11?4:5;default:return 1!=c?1:0}}}),angular.module("gettext").factory("gettextUtil",function(){function a(a,b,c){if(!a)throw new Error("You should add a "+b+" attribute whenever you add a "+c+" attribute.")}function b(a,b){return 0===a.indexOf(b)}function c(a){var b=a.charAt(0).toLowerCase();return b+a.substr(1)}var d=function(){return String.prototype.trim?function(a){return"string"==typeof a?a.trim():a}:function(a){return"string"==typeof a?a.replace(/^\s*/,"").replace(/\s*$/,""):a}}();return{trim:d,assert:a,startsWith:b,lcFirst:c}});;
/**
 * This is the basic rendering filter for in app usage,
 * please make sure all changes made into controllerRenderings.js
 * @type {module}
 */
var app = angular.module('app', [
    'formly',
    'angularSpectrumColorpicker',
    'flow',
    'ngFileUpload',
    'ngImgCrop',
    'angular-clipboard',
    'rzModule',
    'ngAnimate',
    'ngCookies',
    'gettext'
]);

// Initialization of gettext component (ONLY FOR our main application).
app.run(['gettextCatalog', '$window', function (gettextCatalog, $window) {
    // window.LANG is set in the PHP layout.
    gettextCatalog.setCurrentLanguage($window.LANG || 'en');
}]);

// Configure $location service for our main app only.
app.config(['$locationProvider', function ($locationProvider) {
    $locationProvider.html5Mode(false);
    $locationProvider.hashPrefix('!');
}]);
;
/**
 * Force to have an hex format
 */
app.filter('hexValue', function () {
    return function (hexString) {
        if (hexString[0] != "#")
            hexString = "#" + hexString.replace(/[^a-f0-9#]$/gi, "");
        else
            hexString = hexString.replace(/[^0-9a-fA-F#]/gi, "");
        return hexString;
    };
});
/**
 * Checks if an object has silblings
 */
app.filter('nonEmpty', function () {
    return function (object) {
        return !!(object && Object.keys(object).length > 0);
    };
});

/**
 * Capitalize the first letter
 */
app.filter('capitalize', function () {
    return function (input) {
        if (typeof input !== "string") {
            return input;
        }
        return input.substring(0, 1).toUpperCase() + input.substring(1).toLowerCase();
    }
});

/**
 * This is the basic rendering filter fot in app usage,
 * please make sure all changes made into controllerRenderings.js
 * @type {boolean}
 */
app.filter('prefixURL', function () {
    return function (url) {
        if (typeof url !== "undefined" && url) {
            url = (url.indexOf('://') == -1) ? 'http://' + url : url;
            return url;
        }
        return "#";

    }
});

/**
 * Remove the parameters form url, use this filter on the frontend to show urls
 * please make sure all changes made into controllerRenderings.js
 * @type {boolean}
 */
app.filter('removeParameterFromURL', function () {
    return function (url) {
        if (typeof url !== "undefined" && url) {
            url = (url.indexOf('?') == -1) ? url : url.substr(0, url.indexOf('?'))
        }
        return url;
    }
});
/**
 * This filter helps us to create <br> tags on input fields that
 * come along with \n
 */
app.filter('nl2br', ['$sce', function ($sce) {

    return function (input) {
        if (input !== void 0) {

            var result = input
                .replace(/&/g, '&amp;')
                .replace(/>/g, '&gt;')
                .replace(/</g, '&lt;')
                .replace(/\n/g, '<br>');

            return $sce.trustAsHtml(result);
        }
    };
}]);

/**
 * This filter helps to create lighter and darker colors of a given hexcode
 * Usage: $scope.view.color1_dark = $filter('colorLuminance')($scope.view.color1,-0.2);
 * @see angular base template - new facebook page
 */
app.filter('colorLuminance', function () {

    return function (hex, lum) {
        // validate hex string
        hex = String(hex).replace(/[^0-9a-f]/gi, '');
        if (hex.length < 6) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        lum = lum || 0;

        // convert to decimal and change luminosity
        var rgb = "#", c, i;
        for (i = 0; i < 3; i++) {
            c = parseInt(hex.substr(i * 2, 2), 16);
            c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
            rgb += ("00" + c).substr(c.length);
        }

        return rgb;
    };
});

/**
 * This filter function will return a subset of industry objects that contain the keyword entered by the user.
 * For example, if the user enters "food" then only the industry objects that contain that keyword somewhere should be displayed.
 * Usage: industrySearch: industrySearchKeyword
 */
app.filter('industrySearch', function () {

    return function (industries, industrySearchKeyword) {
        // Loop through aliases checking if 'industrySearchKeyword' exists
        function checkAliases(aliases, searchKeyword) {
            for (var i = 0; i < aliases.length; i++) {
                if (aliases[i].toLowerCase().indexOf(searchKeyword) > -1) {
                    return true;
                }
            }
            return false;
        }

        // If no keyword is entered, just display all the items
        if (!industrySearchKeyword) {
            return industries;
        } else {
            var newIndustries = [];
            var searchKeyword = industrySearchKeyword.toLowerCase();

            // Create new set of industries where 'industrySearchKeyword' exists in object data
            for (var i = 0; i < industries.length; i++) {
                if (industries[i].name.toLowerCase().indexOf(searchKeyword) > -1 ||
                    checkAliases(industries[i].aliases, searchKeyword)) {
                    newIndustries.push(industries[i]);
                }
            }
            return newIndustries;
        }
    };

});


/**After the AngularJS has been bootstrapped, you can no longer
 * use the normal module methods (ex, app.controller) to add
 * components to the dependency-injection container. Instead,
 * you have to use the relevant providers. Since those are only
 * available during the config() method at initialization time,
 * we have to keep a reference to them.
 * --
 * NOTE: This general idea is based on excellent article by
 * Ifeanyi Isitor: http://ify.io/lazy-loading-in-angularjs/
 */
app.config(
    function ($controllerProvider, $provide, $compileProvider, $filterProvider, $sceDelegateProvider) {

        $sceDelegateProvider.resourceUrlWhitelist([
            // Allow same origin resource loads.
            'self',
            // Allow loading from our assets domain.  Notice the difference between * and **.
            'https://www.facebook.com/**'
        ]);

        //This is used on all hidden input elements that are updated by angular because
        //this won't trigger the change event on the element
        triggerChangeOnElement = function (element) {
            $("[id$='" + element + "']").trigger("change");
        };

        app.triggerChangeOnElement = triggerChangeOnElement;
        // Since the "shorthand" methods for component
        // definitions are no longer valid, we can just
        // override them to use the providers for post-
        // bootstrap loading.

        // Let's keep the older references.
        app._controller = app.controller;
        app._service = app.service;
        app._factory = app.factory;
        app._value = app.value;
        app._directive = app.directive;
        app._filter = app.filter;


        // Provider-based controller.
        app.controller = function (name, constructor) {

            $controllerProvider.register(name, constructor);
            return ( this );

        };

        // Provider-based service.
        app.service = function (name, constructor) {

            $provide.service(name, constructor);
            return ( this );

        };

        // Provider-based factory.
        app.factory = function (name, factory) {

            $provide.factory(name, factory);
            return ( this );

        };

        // Provider-based value.
        app.value = function (name, value) {

            $provide.value(name, value);
            return ( this );

        };

        // Provider-based directive.
        app.directive = function (name, factory) {

            $compileProvider.directive(name, factory);
            return ( this );

        };

        $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|tel|mailto|file|skype|weixin|fb):/);

        // Provider-based directive.
        app.filter = function (name, factory) {
            return ( this );

        };
        // NOTE: You can do the same thing with the "filter"
        // and the "$filterProvider"; but, I don't really use
        // custom filters.

    }
);
/**
 * This function is rerendering and injecting the html of
 * a loaded form
 */
app.renderForm = function () {

    // Get the $compile service from the app's injector
    var injector = $('[ng-app]').injector();
    if (typeof injector === "undefined") {
        window.setTimeout(function () {
            app.renderForm();
        }, 500);
        return false;
    }
    if (!$(".angularWrapper").hasClass("init")) {
        $(".angularWrapper").addClass("init");
        var $compile = injector.get('$compile');

        // Compile the HTML into a linking function...
        var linkFn = $compile($(".angularWrapper").html());
        // ...and link it to the scope we're interested in.
        // Here we'll use the $rootScope.
        var $rootScope = injector.get('$rootScope');
        var elem = linkFn($rootScope);
        $('.angularWrapper').html(elem);


        if (typeof window['afterInitAngular'] == 'function') {
            window['afterInitAngular']();
        }


        // Now that the content has been compiled, linked,
        // and added to the DOM, we must trigger a digest cycle
        // on the scope we used in order to update bindings.
        $rootScope.$digest();

        return $rootScope;
    }

};

/**
 *This function is rerendering and injecting the html of
 * a loaded preview
 */
app.previewRenderer = function () {
    // Get the $compile service from the app's injector
    var injector = $('[ng-app]').injector();

    if (typeof injector === "undefined") {
        window.setTimeout(function () {
            app.previewRenderer();
        }, 100);
        return false;
    }
    if (!$(".angularPreviewWrapper").hasClass("compiled")) {
        $(".angularPreviewWrapper").addClass("compiled");
        var $compile = injector.get('$compile');

        // Compile the HTML into a linking function...
        var linkFn = $compile($(".angularPreviewWrapper").html());
        // ...and link it to the scope we're interested in.
        // Here we'll use the $rootScope.
        var $rootScope = injector.get('$rootScope');
        var elem = linkFn($rootScope);

        $rootScope.$broadcast("preview:update");

        // Now that the content has been compiled, linked,
        // and added to the DOM, we must trigger a digest cycle
        // on the scope we used in order to update bindings.
        $rootScope.$digest();
    } else {

        //This will be called from the iframe an update the iframe itself
        var injector = $('[ng-app]').injector();
        var $rootScope = injector.get('$rootScope');
        //The preview is ready to receive data so lets fetch the data and update the view
        $rootScope.$broadcast("preview:update");
    }

};

/**
 * Update the preview if changes appear
 * @return PreviewController Instanz
 */
app.loadBasePreviewController = function () {

    return app.controller('BasePreviewController', function ($rootScope, $scope, previewService) {
        //Holde the template variables
        this.view = {};

        //Update the preview on change
        $rootScope.$on("preview:update", function () {
            $scope.view = previewService.previewModel;

            //Switch back from qr code to preview modus on changes
            if($(".btn-slide-toggler.active").length==0){
                $(".btn-slide-toggler").mousedown();
            }
        });

        //Check if there are form error that are currently not invalid any more
        $rootScope.$on("preview:checkFormErrors", function () {
            _.delay(function () {
                //Fade Out Errors
                $.each($(".angularWrapper .error > .ng-valid"), function (key, element) {

                    //remove the error class to the parent element for responsive error handling
                    $(element).parents(".error").removeClass("error");

                    //Get the errorholder that belongs to the inputfield
                    $errorMessage = $(".errorHolder", $(element).parents(".formly-field"));

                    //check if there is already a popup on the error holder
                    if ($($errorMessage.attr("data-error-container")).hasAttr("aria-describedby")) {
                        //build the tooltip id
                        var tooltipID = "#" + $($errorMessage.attr("data-error-container")).attr("aria-describedby");
                        //fade out
                        $(tooltipID).removeClass("in");

                        //destroy the tooltip afterwards
                        _.delay(function () {
                            $(tooltipID).popover('destroy');
                        }, 500);
                    }
                });
            }, 100);
        });
    });
};


/**
 * This service helps to broadcast the change of the forms to
 * the preview controller
 */
app.factory("previewService", function ($rootScope) {
    //This hold all the preview data
    var previewModel = {};
    /**
     * Save the data to the model
     * @param model object
     */
    previewModel.pushData = function (model) {
        this.previewModel = model;
        this.render();
        this.updateForm();
    }
    /**
     * Broadcast that there are changes on the input model
     */
    previewModel.render = function () {
        $rootScope.$broadcast("preview:update");
    }
    /**
     * This function is updating the json string from the form
     */
    previewModel.updateForm = function () {
        $("#formHere input[id$='_json_data']").val(JSON.stringify(this.previewModel));
        try {
            //We only have this available on the preview mode inside the app
            window.qr.utils.events.trigger("generatorFormChanged");
        } catch (e) {

        }
    }
    return previewModel;
});
/**
 * This controller is handling all designer related task like validation etc.
 */
app.controller('DesignerController', function ($rootScope, $scope, previewService) {

    var debouncedChange = _.debounce(function ($scope) {
        if ($scope.individualEyes == 0) {
            $scope['lteInnerColor'] = $scope['ForegroundColor'];
            $scope['lteOuterColor'] = $scope['ForegroundColor'];
            $scope['rteInnerColor'] = $scope['ForegroundColor'];
            $scope['rteOuterColor'] = $scope['ForegroundColor'];
            $scope['lbeInnerColor'] = $scope['ForegroundColor'];
            $scope['lbeOuterColor'] = $scope['ForegroundColor'];
            $scope['rteTemplate'] = $scope['lteTemplate'];
            $scope['lbeTemplate'] = $scope['lteTemplate'];
        }
        $scope.$apply();
        $("[id$='Color']").trigger("change");
    }, 500);

    //We need to watch all colorpickers to get the event when they are changing
    $scope.$watchGroup(['ForegroundColor', 'BackgroundColor', 'lteInnerColor', 'lteOuterColor', 'rteInnerColor', 'rteOuterColor', 'lbeInnerColor', 'lbeOuterColor', 'individualEyes', 'lteTemplate'], function (newValues, oldValues, $scope) {
        debouncedChange($scope);
    });
    /**
     * Do a blur on the given element
     * use ng-enter="doBlur($event)"
     * @param $event
     */
    $scope.doBlur = function ($event) {
        var target = $event.target;

        // do more here, like blur or other things
        target.blur();
    }
    /**
     * Check if the input is correct hex format
     * @param field
     */
    $scope.checkHexColor = function (field) {
        var hexString = $scope[field];
        if (hexString[0] != "#")
            hexString = "#" + hexString.replace(/[^a-f0-9#]$/gi, "");
        else
            hexString = hexString.replace(/[^0-9a-fA-F#]/gi, "");

        $scope[field] = hexString;
    }
    /**
     * Create a valid hex color string or do the fallback to the default color
     * @param field
     */
    $scope.makeHexColor = function (field) {
        var hexString = $scope[field];
        var newHex = false;

        var isHexString = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hexString);
        if (isHexString) {
            isShortHex = /(^#[0-9A-F]{3}$)/i.test(hexString);
            if (isShortHex)
                newHex = "#" + hexString[1] + hexString[1] + hexString[2] + hexString[2] + hexString[3] + hexString[3];
            else
                newHex = hexString;
        }
        else {
            newHex = $("#DesignerTemplates_" + field).attr("placeholder");
        }

        $scope[field] = newHex;
    }
});


/**
 * This controller is activating mobile preview item
 */

app.controller('MobilePreviewController', function ($scope) {

    var previousTarget = '';

    $scope.states = {};
    $scope.states.activeItem = '';

    // Activate by default editing view on mobile devices
    $scope.states.viewType = 'create_editView';

    // Define bottom menu items on mobile devices,
    // Also define which class to add to the wrapper element when the element is clicked
    $scope.items = [{
        id: '1',                     // Item ID
        icon: 'pencil-24px  ',       // Icon name
        class: 'create_editView'     // Wrapper switch class
    }, {
        id: '2',                     // Item ID
        icon: 'phone-24px',          // Icon name
        class: 'create_phoneView'    // Wrapper switch class
    }, {
        id: '3',                     // Item ID
        icon: 'qr-code-mobile',      // Icon name
        class: 'create_codeView'     // Wrapper switch class
    }];

    // This function hide the view when we click on the same type of view
    // Ex: If the phone preview is active and we click on the same presentation icon, we hide the preview mode and switch back to edit mode
    $scope.toggleView = function () {

        // Determine whether the active element is the same when we double-click on the same type of view
        if ($scope.states.activeItem === previousTarget) {
            $scope.states.viewType = 'create_editView';
            $scope.states.activeItem = '';

            // After we hide the preview mode, you need to delete the active element class
            $('[data-generate-mobile-bar] li').removeClass('active');
        }

        // If the element that was clicked has a different class, then the element that we clicked must be switch the preview mode to the last one
        previousTarget = $scope.states.activeItem;

        return false;
    };

    // Function to validate the QR code on mobile devices, we will find out whether the QR code is valid or not
    $scope.codeValidation = function() {

        // Check if the form is invalid or angularWrapper has any invalid inputs.
        if (($(".angularWrapper .ng-invalid").length) || ($(".angularWrapper .box-input.error").length)) {
            $.each($(".angularWrapper .canHaveError.ng-invalid"), function (key, element) {

                // Add error handling
                $(element).parent().addClass("error");
                errorMessage = $(".errorHolder", $(element).parents(".formly-field"));
                window.qr.utils.formValidationTooltip(errorMessage.attr("data-error-container"), errorMessage.attr("data-error-msg"), true, true);

            });

            // If the error is present, add the error status to the QR code preview
            $('.mockup__qrcode').addClass('barCodeError');
        } else {

            // Remove the error status from the QR code preview
            $('.mockup__qrcode ').removeClass('barCodeError');
        }
    };

    // The function to prevent body scrolling on mobile devices when accessing the preview mode
    $scope.disableScrolling = function() {
        var tag = document.body;

        // Determine if we are in preview mode, and then add the class to the body
        if ($scope.states.viewType !== 'create_editView') {
            tag.classList.add('no-scroll');
        } else {
            tag.classList.remove('no-scroll');

        }

    }
});


/*
 * angular-marquee v0.1.0
 * https://github.com/emn178/angular-bind-compile
 *
 * Copyright 2014, emn178@gmail.com
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
app.directive('ngBindCompile', ['$sce', '$compile', function($sce, $compile) {
        return {
            restrict: 'A',
            compile: function (tElement, tAttrs) {
                return function (scope, element, attrs) {
                    scope.$watch(function() {
                        return $sce.getTrustedHtml(scope.$eval(attrs.ngBindCompile));
                    }, function (value) {
                        element.html(value);
                        $compile(element.contents())(scope);
                    });
                };
            }
        };
    }]);
;
/**
 * Track user events throughout the app
 */
app.service('tracking', ['api', function (api) {

    this.trackEvent = function (eventName) {

        if (window.GLOBAL_FEATURE_ENABLE_ZENDESK_INTEGRATION === 'true') {
            // Track via our own event-tracking endpoint
            api.trackUserInteraction(eventName);
        }

        // Track Intercom Event
        window.qr.utils.trackUser.event(eventName);
    };
}]);
;
app.service('callbackService', ['$window','$rootScope', 'tracking', function ($window, $rootScope, tracking) {
    var self = this;

    /**
     * Used for refreshing the listview on the usermanagement on add,edit,delete
     * @param data
     * @param fromName
     * @returns {boolean}
     */
    self.usermanagement = function (data, fromName) {
        if (data.status == 'success') {

            if(data.action=='add'){
                tracking.trackEvent('invited_user');
            }

            $(".modal.in").modal("hide");
            $.fn.yiiListView.update('user-model-grid', {
                complete: function(){
                    $(".angularWrapper").removeClass("init");
                    app.renderForm();
                }
            });
        }
        else {
            return self.errorState(data, fromName);
        }
    };

    /**
     * Handling the response of the whitlabel shortener saving process
     * @param data
     * @param formName
     */
    self.whitelabel_subdomain = function (data, formName) {
        if (data.status == 'success') {
            $("#" + formName + ' .alert.alert-success').text(data.msg).removeClass("hidden").attr("style", "").fadeOut(4000, function () {
                $(this).addClass("hidden");
            });
            return true;
        }
        return self.errorState(data, formName);
    };

    /**
     * Show error alert
     * @param data
     * @param formName
     * @returns {boolean}
     */
    self.errorState = function (data, formName) {
        if (!self.hasRestrictions(data, formName))
            $("#" + formName + ' .alert.alert-error').text(data.msg || 'Error').removeClass("hidden").attr("style", "").fadeOut(4000, function () {
                $(this).addClass("hidden");
            });
        return true;
    };

    /**
     * Show success alert
     * @param data
     * @param formName
     * @returns {boolean}
     */
    self.successState = function (data, formName) {

        //If there is no redirect happend proceed with successState
        if (!self.hasRedirect(data, formName)) {
            $("#" + formName + " .update-success.hidden").text(data.msg).attr("style", "").removeClass("hidden").fadeOut(4000, function () {
                $(this).addClass("hidden");
            });
            return true;
        }
    };

    /**
     * Check if the error response is forcing to show a error modal
     * @see example Free Plan | Save shortener domain on /whitelabel
     * @param data
     * @param formName
     * @returns {boolean}
     */
    self.hasRestrictions = function (data, formName) {

        if (typeof data.restrictionMessage !== "undefined" && $(data.restrictionMessage).length) {

            //Check if the restriction message contains dynamic content in the form of __PLACEHOLDER__
            var html = $(data.restrictionMessage).html();
            var regexp = /__(.+?)__/g;
            var placeholders = html.match(regexp);

            //If we found placeholders
            if(placeholders)
                $.each(placeholders, function (index, element) {
                    //Check if there is a variable on the request with the same name
                    var placeholderName = element.replace(/__/g, "").toLowerCase();

                    //If we found one replace the placeholder with the value
                    if (typeof data[placeholderName] !== "undefined") {
                        html = html.replace(element, data[placeholderName]);
                    }
                });
            window.qr.utils.restrictionMessage(html);
            return true;
        }
        return false;//No restriction
    };

    /**
     * Check if a response contain a redirect
     * @param data
     * @param formName
     */
    self.hasRedirect = function (data, formName) {

        if (data.redirect && data.redirect.length) {
            $window.location.href = data.redirect;
            return true;
        }
        return false;
    };
}]);
;
/**
 * The HTTP service for the app.
 */
app.service('http', ['$http', '$httpParamSerializerJQLike', function ($http, $httpParamSerializerJQLike) {
    /**
     * Send a POST request
     * @param url
     * @param data
     * @param success
     * @param [error]
     */
    this.post = function (url, data, success, error) {
        data.YII_CSRF_TOKEN = GLOBAL_CSRF_TOKEN;
        return $http({
            url: url,
            method: 'POST',
            data: $httpParamSerializerJQLike(data),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Requested-With': 'XMLHttpRequest'
            }
        }).then(success, error || false);
    };

    /**
     * Send a GET request
     * @todo Probably the data parameter should be serialized to URL, because it's a GET request.
     * @param url
     * @param data
     * @param success
     * @param [error]
     */
    this.get = function (url, data, success, error) {
        data.YII_CSRF_TOKEN = GLOBAL_CSRF_TOKEN;
        return $http({
            url: url,
            method: 'GET',
            data: $httpParamSerializerJQLike(data),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Requested-With': 'XMLHttpRequest'
            }
        }).then(success, error || false);
    };
}]);
;
/**
 * API service.
 */
app.service('api', ['$http', function ($http) {
    /**
     * Get a list of jobs
     * @param successCallback
     * @param [errorCallback]
     */
    this.getJobs = function (successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/jobs'))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get a list of jobs by type
     * @param {string} type "type"
     * @param successCallback
     * @param [errorCallback]
     */
    this.getJobsByType = function (type , successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/jobs', { type: type }))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Generate a spreadsheet template to mass-create QR codes.
     * @param {string} type "url", "text" or "vcard"
     * @param {string} format "csv", "xls", "xlsx" or "ods"
     * @returns {string}
     */
    this.downloadTemplateForCreate = function (type, format) {
        return this.getUrl('/v1/mass-creation/template-for-create/' + type + '/' + format);
    };

    /**
     * Generate a spreadsheet template to mass-update QR codes.
     * @param {string} type "d_url"
     * @param {string} format "csv", "xls", "xlsx" or "ods"
     * @param {number} folderId
     * @returns {string}
     */
    this.downloadTemplateForUpdate = function (type, format, folderId) {
        return this.getUrl('/v1/mass-update/template-for-update/' + type + '/' + format, {
            folder_id: folderId,
        });
    };

    /**
     * Creates a multiple creation job/task for the queue to process it later.
     * @param {object} params: {type, folder_id, design_template_id, file_key, code_type}
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.createMultipleCreationJob = function (params, successCallback, errorCallback) {
        return $http
            .post(this.getUrl('/v1/jobs'), params)
            .then(successCallback, errorCallback || false);
    };

    /**
     * Validates CSV files for mass-creation.
     * The file must be uploaded to AWS S3 before.
     * @param {object} params: {file_key, code_type}
     * @param {string} templateType
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.validateFile = function (params, templateType, successCallback, errorCallback) {
        var url = '';

        switch (templateType) {
            case 'create':
                url = '/v1/mass-creation/validate';
                break;
            case 'update':
                url = '/v1/mass-update/validate';
                break;
        }

        return $http
            .post(this.getUrl(url), params)
            .then(successCallback, errorCallback || false);
    };

    /**
     * Create a user industries search log message.
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.industriesSearchLogs = function (message, successCallback, errorCallback) {
        return $http
            .post(this.getUrl('/v1/logs'), {message: message})
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get available industries
     * @returns {string}
     */
    this.getIndustries = function (successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/industries'))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get industry solutions
     * @returns {string}
     */
    this.getIndustryDemos = function (industryId, successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/demos', {industry_id: industryId}))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get industry QR Code type demo
     * @returns {array}
     * @limit 1
     */
    this.getIndustryTypeDemo = function (industryId, typeId, successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/demos', {
                industry_id: industryId,
                type_id: typeId,
                list_type: 'all_types'
            }))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get saved account's frames
     * @returns {string}
     */
    this.getAccountFrames = function (successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/account/frames'))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Save frame design to user account
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.saveFrameDesign = function (params, successCallback, errorCallback) {
        return $http
            .post(this.getUrl('/v1/account/frames'), params)
            .then(successCallback, errorCallback || false);
    };

    /**
     * Delete frame design from user account.
     * @param {Number} frameId
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.deleteFrameDesign = function (frameId, successCallback, errorCallback) {
        return $http
            .delete(this.getUrl('/v1/account/frames/' + frameId))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get premium frames
     * @returns {string}
     */
    this.getPremiumFrames = function (qrCodeTypeId, tag, successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/frames', {type_id: qrCodeTypeId, tag: tag}))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get available fonts3
     * @returns {string}
     */
    this.getFonts = function (successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/fonts'))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get the API endpoint.
     * @returns {string}
     */
    this.getBaseUrl = function () {
        return GLOBAL_API_ENDPOINT;
    };

    /**
     * Get the API token.
     * @returns {string}
     */
    this.getApiToken = function () {
        return GLOBAL_API_TOKEN;
    };

    /**
     * Get absolute URL of specified API path.
     * @param {string} path
     * @param [params]
     * @returns {string}
     */
    this.getUrl = function (path, params) {
        var url = this.getBaseUrl() + path + "?access-token=" + this.getApiToken() + "&_lang=" + (LANG || "en");
        angular.forEach(params, function (value, key) {
            url = url + "&" + encodeURIComponent(key) + "=" + encodeURIComponent(value);
        });
        return url;
    };

    /**
     * Get URL for downloading QR codes and frames.
     * @param [params]
     * @returns {string}
     */
    this.getFrameDownloadUrl = function (params) {
        return this.getUrl('/v1/create', params);
    };

    /**
     * Get the API Keys.
     * @param successCallback
     * @param [errorCallback]
     * @returns {string}
     */
    this.getApiKeys = function (successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/access-tokens'))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Create a new API Key.
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.createApiKey = function (successCallback, errorCallback) {
        return $http
            .post(this.getUrl('/v1/access-tokens'))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Delete API Key.
     * @param {Number} keyId
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.deleteApiKey = function (keyId, successCallback, errorCallback) {
        return $http
            .delete(this.getUrl('/v1/access-tokens/' + keyId))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get available folders.
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.getFolders = function (successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/folders'))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Create a folder with specified name.
     * @param {String} folderName
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.createFolder = function (folderName, successCallback, errorCallback) {
        return $http
            .post(this.getUrl('/v1/folders'), {name: folderName})
            .then(successCallback, errorCallback || false);
    };

    /**
     * Update folder's name.
     * @param {Number} folderId
     * @param {String} folderName
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.updateFolder = function (folderId, folderName, successCallback, errorCallback) {
        return $http
            .put(this.getUrl('/v1/folders/' + folderId), {name: folderName})
            .then(successCallback, errorCallback || false);
    };

    /**
     * Delete folder.
     * @param {Number} folderId
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.deleteFolder = function (folderId, successCallback, errorCallback) {
        return $http
            .delete(this.getUrl('/v1/folders/' + folderId))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get QR codes.
     * @param {Number} folderId filter by folder.
     * @param {String} status filter by status.
     * @param {Number} page page index for pagination (1-based, 1..pageCount).
     * @param {Number} pageSize page size for pagination.
     * @param {String} sort sorting.
     * @param {String} searchQuery search query for searching titles, URLs, etc.
     * @param {String} fields list of fields to fetch.
     * @param {String} expand list of extra fields/relations to fetch.
     * @param successCallback
     * @param [errorCallback]
     * @param [disableCache] set to "true" to disable browser's cache.
     * @returns {*}
     */
    this.getCodes = function (folderId, status, page, pageSize, sort, searchQuery, fields, expand, successCallback, errorCallback, disableCache) {
        var options = {};
        if (folderId > 0) {
            options.folder_id = folderId;
        }
        if (status) {
            options.status = status;
        }
        if (page > 0) {
            options.page = page;
        }
        if (pageSize > 0) {
            options['per-page'] = pageSize;
        }
        if (sort) {
            options.sort = sort;
        }
        if (typeof searchQuery === "string" && searchQuery.trim().length > 0) {
            options.search = searchQuery.trim();
        }
        if (fields) {
            options.fields = fields;
        }
        if (expand) {
            options.expand = expand;
        }
        if (disableCache) {
            options.rnd = +new Date();
        }
        return $http
            .get(this.getUrl('/v1/codes', options))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get one QR code.
     * @param {Number} codeId QR code ID.
     * @param {String} expand list of extra fields/relations to fetch.
     * @param successCallback
     * @param [errorCallback]
     * @param [disableCache] set to "true" to disable browser's cache.
     * @returns {*}
     */
    this.getCode = function (codeId, expand, successCallback, errorCallback, disableCache) {
        var options = {};
        if (expand) {
            options.expand = expand;
        }
        if (disableCache) {
            options.rnd = +new Date();
        }
        return $http
            .get(this.getUrl('/v1/codes/' + codeId, options))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Load the demo code data from the server.
     * @param successCallback
     * @returns {*}
     */
    this.getDemoCode = function (successCallback) {
        return $http
            .get(this.getUrl('/v1/codes/1124', {expand: 'folder,campaign'}))
            .then(successCallback);
    };

    /**
     * Update QR code title.
     * @param {Number} codeId
     * @param {String} title
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.updateCodeTitle = function (codeId, title, successCallback, errorCallback) {
        return $http
            .put(this.getUrl('/v1/codes/' + codeId), {title: title})
            .then(successCallback, errorCallback || false);
    };

    /**
     * Update QR code title.
     * @param {Number} codeId
     * @param {String} status "active" or "paused".
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.updateCodeStatus = function (codeId, status, successCallback, errorCallback) {
        return $http
            .put(this.getUrl('/v1/codes/' + codeId), {status: status})
            .then(successCallback, errorCallback || false);
    };

    /**
     * Update QR short code.
     * @param {Number} codeId
     * @param {String} shortCode
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.updateShortCodeAndDomain = function (codeId, shortCode, domainId, successCallback, errorCallback) {
        return $http
            .put(this.getUrl('/v1/codes/' + codeId), {short_code: shortCode, domain_id: domainId})
            .then(successCallback, errorCallback || false);
    };

    /**
     * Pause several QR codes.
     * @param {Array} codeIds
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.massPauseCodes = function (codeIds, successCallback, errorCallback) {
        return $http
            .post(this.getUrl('/v1/codes/mass-pause'), {ids: codeIds})
            .then(successCallback, errorCallback || false);
    };

    /**
     * Activate several QR codes.
     * @param {Array} codeIds
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.massActivateCodes = function (codeIds, successCallback, errorCallback) {
        return $http
            .post(this.getUrl('/v1/codes/mass-activate'), {ids: codeIds})
            .then(successCallback, errorCallback || false);
    };

    /**
     * Delete several QR codes.
     * @param {Array} codeIds
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.massDeleteCodes = function (codeIds, successCallback, errorCallback) {
        return $http
            .post(this.getUrl('/v1/codes/mass-delete'), {ids: codeIds})
            .then(successCallback, errorCallback || false);
    };

    /**
     * Delete QR code.
     * @param {Number} codeId
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.deleteCode = function (codeId, successCallback, errorCallback) {
        return $http
            .delete(this.getUrl('/v1/codes/' + codeId))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Update QR code folder.
     * @param {Number} codeId
     * @param {Number} folderId
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.updateCodeFolder = function (codeId, folderId, successCallback, errorCallback) {
        return $http
            .put(this.getUrl('/v1/codes/' + codeId, {expand: 'folder'}), {folder_id: folderId})
            .then(successCallback, errorCallback || false);
    };

    /**
     * Move several QR codes.
     * @param {Array} codeIds
     * @param {Number} folderId
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.massMoveCodes = function (codeIds, folderId, successCallback, errorCallback) {
        return $http
            .post(this.getUrl('/v1/codes/mass-move'), {ids: codeIds, folder_id: folderId})
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get information about the account.
     * @param {String} extraFields additional fields to get (e.g. "folders,statistics,paymentInfo").
     * @param successCallback
     * @param [errorCallback]
     */
    this.getAccount = function (extraFields, successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/account', {expand: extraFields || ""}))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Request account palettes.
     * @param successCallback
     * @param errorCallback
     * @returns {*}
     */
    this.getPalettes = function (successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/palettes'))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Update account palettes.
     * @param {string} paletteId
     * @param {Array} colors
     * @param successCallback
     * @param errorCallback
     * @returns {*}
     */
    this.updatePalette = function (paletteId, colors, successCallback, errorCallback) {
        return $http
            .put(this.getUrl('/v1/palettes/' + paletteId), {colors: colors})
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get all account's logos (for QR codes).
     * @param {number} qrCodeTypeId
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.getLogos = function (qrCodeTypeId, successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/logos', {type_id: qrCodeTypeId}))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Create a logo object.
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.createLogo = function (successCallback, errorCallback) {
        return $http
            .post(this.getUrl('/v1/logos'), {})
            .then(successCallback, errorCallback || false);
    };

    /**
     * Delete the logo record.
     * @param {Number} logoId ID of the logo to delete.
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.deleteLogo = function (logoId, successCallback, errorCallback) {
        return $http
            .delete(this.getUrl('/v1/logos/' + logoId))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Update QR design.
     * @param {number} codeId
     * @param params
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.updateDesign = function (codeId, params, successCallback, errorCallback) {
        return $http
            .put(this.getUrl('/v1/design/' + codeId, {expand: 'image_url,frame_template'}), params)
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get the list of saved account's designs.
     * @param successCallback
     * @param [errorCallback]
     */
    this.getDesigns = function (successCallback, errorCallback) {
        return $http
            .get(this.getUrl('/v1/design', {expand: 'image_url,frame_template'}))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Save QR design.
     * @param params design information.
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.createDesign = function (params, successCallback, errorCallback) {
        return $http
            .post(this.getUrl('/v1/design', {expand: 'image_url,frame_template'}), params)
            .then(successCallback, errorCallback || false);
    };

    /**
     * Delete saved design.
     * @param {Number} designId ID of the design to delete.
     * @param successCallback
     * @param [errorCallback]
     * @returns {*}
     */
    this.deleteDesign = function (designId, successCallback, errorCallback) {
        return $http
            .delete(this.getUrl('/v1/design/' + designId))
            .then(successCallback, errorCallback || false);
    };

    /**
     * Get QR scans statistics.
     * @param codeId QR Code ID.
     * @param params optional parameters.
     * @param successCallback
     * @returns {*}
     */
    this.getScanStatistics = function (codeId, params, successCallback) {
        if (codeId > 0) { // Protect the API from wrong values of code ID.
            return $http
                .get(this.getUrl('/v1/scans/' + codeId, params))
                .then(successCallback);
        }
    };

    this.resetScanStatistics = function (codeId, successCallback) {
        return $http
            .delete(this.getUrl('/v1/scans/' + codeId))
            .then(successCallback);
    };

    this.getCampaignMediums = function (successCallback) {
        return $http
            .get(this.getUrl('/v1/mediums'))
            .then(successCallback);
    };

    this.createCampaign = function (params, successCallback) {
        return $http
            .post(this.getUrl('/v1/campaigns'), params)
            .then(successCallback);
    };

    this.updateCampaign = function (campaignId, params, successCallback) {
        return $http
            .put(this.getUrl('/v1/campaigns/' + campaignId), params)
            .then(successCallback);
    };

    this.getIsAccountPaused = function (successCallback) {
        return $http
            .get(this.getUrl('/v1/account-paused/paused'))
            .then(successCallback);
    };

    this.updateAbTestData = function (params, successCallback) {
        return $http
            .post(this.getUrl('/v1/ab-tracking'), params)
            .then(successCallback);
    };

    this.getAbTestData = function (params, successCallback) {
        return $http
            .get(this.getUrl('/v1/ab-tracking'), {params: params})
            .then(successCallback);
    };

    /**
     * Track user interaction
     * @param {string} name
     * @param {object} [payload]
     * @param [successCallback]
     * @returns {*}
     */
    this.trackUserInteraction = function (name, payload, successCallback) {
        return $http
            .post(this.getUrl('/v1/tracking/interactions'), {name: name, payload: payload})
            .then(successCallback);
    };
}]);
;
/**
 * The QR service for the app.
 */
app.service('qr', ['$window', function ($window) {
    /**
     * Show form validation tooltip
     * @param {string} formName
     * @param {string} fieldName
     * @param {string} message
     */
    this.showFormValidationTooltip = function (formName, fieldName, message) {
        var selector = 'form[name="' + formName + '"] [name="' + fieldName + '"]';
        if (message != '') {
            $window.qr.utils.formValidationTooltip(selector, message, true);
        }
    };

    /**
     * Hide form validation tooltips
     * @param {string} formName
     */
    this.removeFormValidationTooltip = function (formName) {
        var selector = 'form[name="' + formName + '"] .popover';
        $window.qr.utils.removeFormValidationTooltip(selector);
    };

    /**
     * Show the loader on a submit button
     * @param {string} formName
     */
    this.showSubmitLoader = function (formName) {
        var selector = 'form[name="' + formName + '"] button[type=submit]';
        $window.qr.utils.loader.show(selector);
    };

    /**
     * Hide the submit loader
     * @param {string} formName
     */
    this.hideSubmitLoader = function (formName) {
        var selector = 'form[name="' + formName + '"] button[type=submit]';
        $window.qr.utils.loader.hide(selector);
    };

    /**
     * Start a tour
     * @param tourData
     */
    this.startTour = function (tourData) {
        $window.qr.tour.start(tourData);
    };

    /**
     * Recalculate the PopUp for the uploader
     * */
    this.recalculatePopUp = function (arg) {
        var element = $('[popup="' + arg + '"]');
        var WindowHeight = $(window).height();
        var PopUpHeight = element.height();
        if ($(window).height() > $(window).width()) {
            PopUpHeight = element.width();
            WindowHeight = $(window).width();
        }

        if (PopUpHeight < WindowHeight) {
            var $margin = (WindowHeight - PopUpHeight) / 4;
            element.css("margin-top", $margin + "px");

        } else {
            element.css("position", "absolute");
            element.css("margin-top", ($(document).scrollTop() + 10) + "px");
            var $headerH = $('[popup="' + arg + '"] .popup-main-header').outerHeight();
            var $footerH = $('[popup="' + arg + '"] .popup-main-footer').outerHeight();
            element.css("height", WindowHeight - 20 + "px");
            $('[popup="' + arg + '"] .popup-main-content').css("height", (WindowHeight - 20 - ($headerH + $footerH)) + 'px');
            $('[popup="' + arg + '"] .popup-main-content').slimScroll({
                height: (WindowHeight - 20 - ($headerH + $footerH)) + 'px',
                width: element.outerWidth() + 'px',
                size: '3px',
                color: '#8b969c',
                distance: '2px'
            });
        }
    };
}]);
;
/**
 * Account service contains all information from current user's account.
 */
app.service('account', ['api', function (api) {
    var
        FOLDER_ID_ALL = 0,
        FOLDER_ID_ACTIVE = -1,
        FOLDER_ID_PAUSED = -2,
        FOLDER_ID_EXPIRED = -3,
        account = {
            data: {},
            loading: false
        },
        folders = {
            data: [],
            index: {},
            loading: false
        },
        codes = {
            data: [],
            index: {},
            loading: false
        },
        pagination = {
            page: 1,
            pageSize: 10,
            pageCount: 1,
            totalCount: 0,
            loading: false
        },
        sorting = {
            codes: '-created'
        },
        filters = {
            status: 'all',
            folderId: FOLDER_ID_ACTIVE,
            searchQuery: ''
        },
        view = {
            name: '',
            id: 0
        },
        errors = {
            data: []
        };

    /**
     * Check if there is any errors.
     * @returns {boolean}
     */
    this.hasErrors = function () {
        return errors.data.length > 0;
    };

    /**
     * Clear the list of errors.
     */
    this.clearErrors = function () {
        errors.data = [];
    };

    /**
     * Get account information.
     * @returns {*}
     */
    this.getAccount = function () {
        return account.data;
    };

    /**
     * Check if the account data is loaded and ready.
     * @returns {boolean}
     */
    this.isAccountLoaded = function () {
        return Object.keys(account.data).length > 0;
    };

    /**
     * Get account status.
     * @returns {string}
     */
    this.getAccountStatus = function () {
        if (account.data.trial && new Date(account.data.trial_date).getTime() >= Date.now()) {
            account.data.status = 'trial';
        }
        if (account.data.trial && new Date(account.data.trial_date).getTime() < Date.now()) {
            account.data.status = 'expired';
        }
        return account.data.status;
    };

    /**
     * Get trial days left status.
     * @returns {int}
     */
    this.getAccountTrialDaysLeft = function () {
        var trialExpirationDate = new Date(account.data.trial_date);
        var remainingTime = Date.parse(trialExpirationDate) - new Date();
        account.data.trial_left = Math.floor(remainingTime / (1000 * 60 * 60 * 24));
        return  account.data.trial_left;
    };

    /**
     * Get account payment overdue.
     * @returns {number}
     */
    this.getAccountPaymentOverdue = function () {
        return account.data.payment_overdue;
    };

    /**
     * Get account transaction id
     * @returns {number}
     */
    this.getAccountTxId = function () {
        return account.data.payment_txid;
    };

    /**
     * Get account trial status.
     * @returns {boolean}
     */
    this.isTrial = function() {
        return account.data.trial;
    };

    /**
     * Get account statistics.
     * @returns {*}
     */
    this.getAccountStatistics = function () {
        return account.data.statistics || false;
    };

    /**
     * Check if user has reached limit of dynamic codes.
     * @returns {boolean}
     */
     this.isQrCodeLimitReached = function () {
        return account.data.qrcodes.current >= account.data.qrcodes.allowed;
     };

    /**
     * Check if user has reached limit of static codes.
     * @returns {boolean}
     */
     this.isStaticQrCodeLimitReached = function () {
        return account.data.qrcodes.activeStaticCodes >= account.data.qrcodes.allowedStaticCodes;
     };

    /**
     * Get account's folders.
     * @returns {Array}
     */
    this.getFolders = function () {
        return folders.data;
    };

    /**
     * Get one page of account's QR codes.
     * @returns {Array}
     */
    this.getCodes = function () {
        return codes.data;
    };

    /**
     * Get current pagination info.
     * @returns {*}
     */
    this.getPagination = function () {
        return pagination;
    };

    /**
     * Get current filters.
     * @returns {*}
     */
    this.getFilters = function () {
        return filters;
    };

    /**
     * Get current sorting.
     * @returns {*}
     */
    this.getSorting = function () {
        return sorting;
    };

    /**
     * Set sorting.
     * @param {String} codes
     */
    this.setSorting = function (codes) {
        sorting.codes = codes;
    };

    /**
     * Set all filters.
     * @param {String} status
     * @param {Number} folderId
     * @param {String} searchQuery
     */
    this.setFilters = function (status, folderId, searchQuery) {
        filters.status = status;
        filters.folderId = folderId;
        filters.searchQuery = searchQuery;
    };

    /**
     * Set status filter.
     * @param {String} status
     */
    this.setStatusFilter = function (status) {
        filters.status = status;
    };

    /**
     * Set pagination of QR codes.
     * @param {Number} page
     * @param {Number} pageSize
     */
    this.setPagination = function (page, pageSize) {
        pagination.page = page;
        pagination.pageSize = pageSize;
    };

    this.setFrameTemplate = function (frameTemplate) {
        codes.data[codes.index[frameTemplate.qr_code_id]].lastFrameTemplate = frameTemplate;
    };

    /**
     * Reload folders from the server.
     * @param [callback] any callback function to call on success.
     */
    this.reloadFolders = function (callback) {
        folders.loading = true;
        api.getFolders(function (response) {
            folders.data = response.data;
            sortFoldersByName();
            updateFoldersIndex();
            folders.loading = false;
            if (typeof callback === "function") {
                callback(response);
            }
        }, function () {
            folders.loading = false;
            errors.data.push('reloadFolders');
        });
    };

    /**
     * Reload information about the current account.
     * This includes list of folders and account statistics.
     * @param [callback] any callback function to call on success.
     */
    this.reloadAccount = function (callback) {
        account.loading = true;
        folders.loading = true;
        api.getAccount('folders,statistics,paymentInfo,domains,options', function (response) {
            account.data = response.data;
            folders.data = response.data.folders;
            sortFoldersByName();
            updateFoldersIndex();
            account.loading = false;
            folders.loading = false;
            if (typeof callback === "function") {
                callback(response);
            }
        }, function () {
            account.loading = false;
            folders.loading = false;
            errors.data.push('reloadAccount');
        });
    };

    /**
     * Return true if the folders list is loading.
     * @returns {boolean}
     */
    this.isLoadingFolders = function () {
        return folders.loading;
    };

    /**
     * Return true if the account info is loading.
     * @returns {boolean}
     */
    this.isLoadingAccount = function () {
        return account.loading;
    };

    /**
     * Return true if the list of codes is loading.
     * @returns {boolean}
     */
    this.isLoadingCodes = function () {
        return codes.loading;
    };

    /**
     * Reload QR codes from the server.
     * @param [callback] any callback function to call on success.
     * @param [disableCache] set to "true" to disable browser's cache.
     */
    this.reloadCodes = function (callback, disableCache) {
        var f = getFolderIdAndStatusFilters();
        codes.loading = true;
        pagination.loading = true;
        // (!) If you're changing parameters to api.getCode, please change one more call in this.recheckCodesVisibility below.
        api.getCodes(f.folderId, f.status, pagination.page, pagination.pageSize, sorting.codes, filters.searchQuery, false, 'folder,lastFrameTemplate,style,campaign', function (response) {
            codes.data = response.data;
            updateCodesIndex();
            pagination.pageCount = response.headers('X-Pagination-Page-Count') || 1;
            pagination.totalCount = response.headers('X-Pagination-Total-Count') || 0;
            codes.loading = false;
            pagination.loading = false;
            if (typeof callback === "function") {
                callback(response);
            }
        }, function () {
            codes.loading = false;
            pagination.loading = false;
            errors.data.push('reloadCodes');
        }, disableCache);
    };

    /**
     * Reload QR codes from the server.
     * @param [callback] any callback function to call on success.
     */
    this.reloadCodesScans = function (callback) {
        var f = getFolderIdAndStatusFilters();
        api.getCodes(f.folderId, f.status, pagination.page, pagination.pageSize, sorting.codes, filters.searchQuery, 'id,total_scans,unique_scans', false, function (response) {
            angular.forEach(response.data, function (code) {
                if (code.id in codes.index) {
                    codes.data[codes.index[code.id]].total_scans = code.total_scans;
                    codes.data[codes.index[code.id]].unique_scans = code.unique_scans;
                }
            });
            if (typeof callback === "function") {
                callback(response);
            }
        }, function () {
            // Let's not display the error message if statistics cannot be updated, to not scare users.
            // errors.data.push('reloadCodesScans');
        });
    };

    /**
     * Check visibility of the codes by comparing with filters.
     * Invisible codes will be removed.
     * Then the function will try to load some codes from the server, if reload is true.
     * @param {boolean} [reload] load more codes, if needed.
     */
    this.recheckCodesVisibility = function (reload) {
        var numberOfRemoved = 0, f = getFolderIdAndStatusFilters();
        angular.forEach(codes.data, function (code, key) {
            if ((f.folderId > 0 && code.folder_id !== f.folderId) ||
                (f.status && f.status !== 'all' && code.status !== f.status)
            ) {
                codes.data.splice(key, 1);
                numberOfRemoved++;
            }
        });
        if (numberOfRemoved > 0) {
            updateCodesIndex();
        }
        if (numberOfRemoved > 0 && reload) {
            // TODO request only numberOfRemoved QR codes from the server.
            api.getCodes(f.folderId, f.status, pagination.page, pagination.pageSize, sorting.codes, filters.searchQuery, false, 'folder,lastFrameTemplate,style,campaign', function (response) {
                codes.data = response.data;
                updateCodesIndex();
                pagination.pageCount = response.headers('X-Pagination-Page-Count') || 1;
                pagination.totalCount = response.headers('X-Pagination-Total-Count') || 0;
            }, function () {
                errors.data.push('recheckCodesVisibility');
            });
        }
    };

    /**
     * Reload information about the current account.
     * Excluding folders!
     * @param [callback] any callback function to call on success.
     * @param [ignoreErrors] set to true to ignore connection errors.
     */
    this.reloadAccountWithoutFolders = function (callback, ignoreErrors) {
        account.loading = true;
        api.getAccount('statistics,paymentInfo', function (response) {
            angular.extend(account.data, response.data);
            account.loading = false;
            if (typeof callback === "function") {
                callback(response);
            }
        }, function () {
            account.loading = false;
            if (!ignoreErrors) {
                errors.data.push('reloadAccountWithoutFolders');
            }
        });
    };

    /**
     * Find an array of QR codes specified by IDs.
     * @param {Array} codesIds
     * @returns {Array}
     */
    this.getCodesByIds = function (codesIds) {
        var result = [];
        angular.forEach(codesIds, function (codeId) {
            result.push(codes.data[codes.index[codeId]]);
        });
        return result;
    };

    /**
     * Get ID of current folder.
     * @returns {number}
     */
    this.getCurrentFolderId = function () {
        return filters.folderId;
    };

    /**
     * Change current folder.
     * @param {number} folderId
     */
    this.setCurrentFolderId = function (folderId) {
        filters.folderId = folderId;
    };

    /**
     * @returns {string}
     */
    this.getSearchQuery = function () {
        return filters.searchQuery;
    };

    /**
     * @param {string} searchQuery
     */
    this.setSearchQuery = function (searchQuery) {
        filters.searchQuery = searchQuery;
    };

    /**
     * Find a folder by its ID.
     * @param {number} folderId
     * @returns {*}
     */
    this.findFolderById = function (folderId) {
        if (folderId in folders.index) {
            return folders.data[folders.index[folderId]];
        }
        return false;
    };

    /**
     * Add folder data to the end of folders array.
     * This function doesn't sort the array after, but updates the folders index.
     * @param {*} folder
     */
    this.pushFolder = function (folder) {
        folders.data.push(folder);
        updateFoldersIndex();
    };

    /**
     * Delete one folder object from the folders array.
     * @param folderId
     */
    this.deleteFolderById = function (folderId) {
        if (folderId in folders.index) {
            folders.data.splice(folders.index[folderId], 1);
            updateFoldersIndex();
        }
    };

    /**
     * Get current application view.
     * @returns {string}
     */
    this.getCurrentView = function () {
        return view.name;
    };

    /**
     * @returns {string|number}
     */
    this.getCurrentViewId = function () {
        return view.id;
    };

    /**
     * Set current view name.
     * @param {string} viewName for example '' or 'insights'.
     */
    this.setCurrentView = function (viewName) {
        view.name = viewName;
    };

    /**
     * @params {*} [options] options to change parts of the URL.
     * @returns {string}
     */
    this.getCurrentUrl = function (options) {
        options = options || {};
        var folder = encodeURIComponent(this.convertFolderIdToShortName('folder' in options ? options.folder : filters.folderId));
        var page = encodeURIComponent(options.page || pagination.page);
        var pageSize = encodeURIComponent(options.pageSize || pagination.pageSize);
        var search = encodeURIComponent('search' in options ? options.search : filters.searchQuery);
        var status = encodeURIComponent(options.status || filters.status);
        var sort = encodeURIComponent(options.sort || sorting.codes);
        var viewName = encodeURIComponent('view' in options ? options.view : view.name);
        var viewId = encodeURIComponent('id' in options ? options.id : view.id);
        return '#!/' + viewName + '?folder=' + folder +
            (viewId > 0 ? '&id=' + viewId : '') +
            (page !== '1' ? '&page=' + page : '') +
            (pageSize !== '10' ? '&pageSize=' + pageSize : '') +
            (search !== '' ? '&search=' + search : '') +
            (status !== 'all' ? '&status=' + status : '') +
            (sort !== '-created' ? '&sort=' + sort : '');
    };

    /**
     * Set current state (usually from URL data).
     * @param {*} options
     */
    this.setCurrentState = function (options) {
        options = options || {};
        if ("folder" in options) {
            this.setCurrentFolderId(this.convertFolderShortNameToId(options.folder));
        } else {
            this.setCurrentFolderId(FOLDER_ID_ACTIVE);
        }
        this.setPagination(+options.page || 1, +options.pageSize || 10);
        this.setSearchQuery(options.search || '');
        filters.status = options.status || 'all';
        sorting.codes = options.sort || '-created';
        view.id = options.id || 0;
    };

    /**
     * @param {number} folderId
     * @returns {string|number}
     */
    this.convertFolderIdToShortName = function (folderId) {
        if (folderId === FOLDER_ID_ALL) {
            return 'all';
        } else if (folderId === FOLDER_ID_ACTIVE) {
            return 'active';
        } else if (folderId === FOLDER_ID_PAUSED) {
            return 'paused';
        } else if (folderId === FOLDER_ID_EXPIRED) {
            return 'expired';
        }
        return folderId;
    };

    /**
     * @param {string|number} folderShortName
     * @returns {number}
     */
    this.convertFolderShortNameToId = function (folderShortName) {
        if (folderShortName === 'all') {
            return FOLDER_ID_ALL;
        } else if (folderShortName === 'active') {
            return FOLDER_ID_ACTIVE;
        } else if (folderShortName === 'paused') {
            return FOLDER_ID_PAUSED;
        } else if (folderShortName === 'expired') {
            return FOLDER_ID_EXPIRED;
        }
        return parseInt(folderShortName, 10);
    };

    /**
     * Sort the array of folders by name.
     */
    function sortFoldersByName() {
        folders.data.sort(function (a, b) {
            return a.name < b.name ? -1 : (a.name > b.name ? 1 : 0);
        });
    }

    /**
     * Update folders index for fast search by ID.
     */
    function updateFoldersIndex() {
        folders.index = {};
        angular.forEach(folders.data, function (folder, key) {
            folders.index[folder.id] = key;
        });
    }

    /**
     * Process folderId and status filters for fetching QR codes.
     * @returns {{folderId: number, status: string}}
     */
    function getFolderIdAndStatusFilters() {
        var folderId = filters.folderId, status = "";
        if (folderId === FOLDER_ID_ACTIVE) {
            folderId = 0;
            status = "active";
        } else if (folderId === FOLDER_ID_PAUSED) {
            folderId = 0;
            status = "paused";
        } else if (folderId === FOLDER_ID_EXPIRED) {
            folderId = 0;
            status = "expired";
        }
        if (folderId > 0) {
            status = filters.status;
        }
        return {
            folderId: folderId,
            status: status
        };
    }

    /**
     * Update codes.index that allows to access codes.data by QR code ID instead of array key.
     */
    function updateCodesIndex() {
        codes.index = {};
        angular.forEach(codes.data, function (code, key) {
            codes.index[code.id] = key;
        });
    }

    this.loadDemoCode = function (successCallback) {
        api.getDemoCode(successCallback);
    };


}]);
;
/**
 * Address service to deal with application URL.
 */
app.service('address', ['$location', function ($location) {
    /**
     * Get current folder ID.
     * @returns {number}
     */
    this.getFolder = function () {
        if ('folder' in $location.search()) {
            var folder = parseInt($location.search().folder, 10);
            if (folder >= -3) {
                return folder;
            }
        }
        return -1;
    };

    /**
     * Get current page index.
     * @returns {number}
     */
    this.getPage = function () {
        if ('page' in $location.search()) {
            var page = parseInt($location.search().page, 10);
            if (page >= 1) {
                return page;
            }
        }
        return 1;
    };

    /**
     * Get current page size.
     * @returns {number}
     */
    this.getPageSize = function () {
        if ('pageSize' in $location.search()) {
            var pageSize = parseInt($location.search().pageSize, 10);
            if (pageSize >= 10 && pageSize <= 100) {
                return pageSize;
            }
        }
        return 10;
    };

    /**
     * Get current search query.
     * @returns {string}
     */
    this.getSearch = function () {
        return $location.search().search || '';
    };
}]);
;
/**
 * Some functions related to QR code types.
 */
app.service('qrTypeService', function () {
    /**
     * Get icon for the given QR code type ID.
     * @param {number} codeTypeId
     * @returns {string}
     */
    this.getTypeIconFromTypeId = function (codeTypeId) {
        var icons = {
             1: 'icon-manage-code-url',
             2: 'icon-manage-code-vcard',
             3: 'icon-manage-code-app',
             4: 'icon-manage-code-facebook',
             5: 'icon-manage-code-mp3',
             6: 'icon-manage-code-pdf',
             7: 'icon-manage-code-gallery',
             8: 'icon-manage-code-email',
             9: 'icon-manage-code-sms',
            10: 'icon-manage-code-text',
            11: 'icon-manage-code-multiurl',
            12: 'icon-manage-code-vcard',
            13: 'icon-creation-code-event',
            14: 'icon-creation-code-social',
            15: 'icon-manage-code-business-page',
            16: 'icon-creation-add-video',
            17: 'icon-creation-code-feedback',
            18: 'icon-coupon',
            19: 'icon-creation-code-rating',
            20: 'icon-manage-code-pdf',
            21: 'icon-manage-code-app',
            22: 'icon-manage-code-mp3',
            23: 'icon-manage-code-gallery',
            24: 'icon-creation-code-wifi',
            25: 'icon-creation-code-instagram',
            26: 'icon-gs1',
        };
        return codeTypeId in icons ? icons[codeTypeId] : '';
    };
});
;
/**
 * Additional time-related functions
 */
app.service('timeUtils', function () {
    /**
     * Detect the default time format for the user
     * @returns {string}
     */
    this.getDefaultTimeFormat = function () {
        var localTime = (new Date()).toLocaleTimeString();
        if (localTime.indexOf('AM') > -1 || localTime.indexOf('PM') > -1) {
            return '12';
        }
        return '24';
    };
});
;
/**
 * Service for uploading files to our system and AWS.
 */
app.service('uploaderService', ['$log', 'http', 'Upload', '$q', function ($log, http, Upload, $q) {
    /**
     * Start the uploading process
     * @param config configuration parameters.
     * @param config.file the file object from the file input.
     * @param config.typeId ID of the QR code type.
     * @param config.codeId ID of the QR code.
     * @param config.varname the variable name for registration on the server.
     * @param config.fileExt file extension for the uploaded file (pdf/jpg/png/...).
     * @param config.awsCredentials AWS credentials for uploading files.
     * @param config.onSuccess the success callback.
     * @param config.onError callback called on errors.
     * @param [config.onContentLoaded] callback called when the content of the file is loaded.
     * @param [config.onProgress] the progress callback.
     * @param [config.scope] current scope ($apply will be called).
     * @param [config.status] it will be used to control the process.
     * @returns object to cancel the uploading.
     */
    this.startUploading = function (config) {
        var reader = new FileReader();
        config.status = true;
        reader.onload = function () {
            $log.debug('Reading is done [' + ('' + reader.result).substr(0, 30) + '...]');
            if (!config.status) {
                $log.debug('Uploading is cancelled');
                return;
            }
            if ('onContentLoaded' in config) {
                config.onContentLoaded(reader.result, config);
            }
            registerFile(reader.result, config);
            if ('scope' in config) {
                config.scope.$apply();
            }
        };
        reader.onerror = function () {
            config.onError(config);
        };
        reader.readAsDataURL(config.file);
        return {
            cancel: function () {
                config.status = false;
                config.onError(config);
            }
        };
    };

    /**
     * Register the uploaded file on the server.
     * The second step of uploading process.
     * @param fileContent the content of the file from the previous step.
     * @param config configuration parameters.
     * @param config.typeId ID of the QR code type.
     * @param config.codeId ID of the QR code.
     * @param config.varname the variable name for registration on the server.
     * @param config.fileExt file extension for the uploaded file (pdf/jpg/png/...).
     * @param config.onError callback called on errors.
     */
    function registerFile(fileContent, config) {
        http.post(
            '/media/registerFile',
            {
                qrcode_type_id: config.typeId,
                code_id: config.codeId,
                varname: config.varname,
                file_extension: config.fileExt
            },
            function (response) {
                $log.debug({registerSuccess: response});
                if (!config.status) {
                    $log.debug('Uploading is cancelled');
                    return;
                }
                if (response.data.status === "success") {
                    uploadFileToAWS(response.data, fileContent, config);
                } else {
                    config.onError(config);
                }
            },
            function () {
                config.onError(config);
            }
        );
    }

    /**
     * The last third step of uploading -- upload the file to AWS.
     * @param response the data from the previous step (from the server).
     * @param fileContent the content of the file from the previous step.
     * @param config configuration parameters.
     * @param config.awsCredentials AWS credentials for uploading files.
     * @param config.onSuccess the success callback.
     * @param [config.onProgress] the progress callback.
     * @param config.onError callback called on errors.
     */
    function uploadFileToAWS(response, fileContent, config) {
        var data = {
            varname: response.varname,
            filename: response.filename,
            key: response.key
        };
        angular.forEach(config.awsCredentials.inputs, function (value, key) {
            data[key] = value;
        });
        data.file = Upload.dataUrltoBlob(fileContent);
        var canceller = $q.defer();
        Upload.upload({
            url: config.awsCredentials.url,
            data: data,
            timeout: canceller.promise
        })
        .then(function (result) {
            $log.debug({awsSuccess: result});
            if (!config.status) {
                $log.debug('Uploading is cancelled');
                return;
            }
            config.onSuccess(config.awsCredentials.url + '/' + response.key + '?' + Math.random(), config);
        }, function (result) {
            $log.debug({awsError: result});
            config.onError(config);
        }, function (event) {
            $log.debug({awsProgress: event});
            if (!config.status) {
                $log.debug('Cancel uploading from progress event...');
                canceller.resolve();
                return;
            }
            if ('onProgress' in config) {
                config.onProgress(event.loaded * 100 / event.total, event, config);
            }
        });
    }
}]);
;
/**
 * This thumbnail service can generate thumbnail images.
 */
app.service("thumbnailService", function () {
    /**
     * Make a thumbnail from one image.
     * @param image JS Image object.
     * @param width needed width.
     * @param height needed height.
     * @param [type] image type: "image/png", "image/jpeg". Default is "image/jpeg".
     * @param [quality] quality of the image: from 0 to 1. Default is "0.2".
     * @returns {string}
     */
    this.makeThumbnailFromImage = function (image, width, height, type, quality) {
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        var dataUrl, ratio = Math.min(width / image.width, height / image.height);

        canvas.width = width;
        canvas.height = height;

        try {
            ctx.drawImage(image,
                0, 0, image.width, image.height,
                0, 0, image.width * ratio, image.height * ratio);

            dataUrl = canvas.toDataURL(type || "image/jpeg", quality || 0.2);
        }
        catch (e) {
            dataUrl = false;
        }

        return dataUrl;
    };

    /**
     * Make a low quality JPEG thumbnail from an image.
     * It uses 20% quality.
     * @param image JS Image object.
     * @param width needed width.
     * @param height needed height.
     * @returns {string}
     */
    this.makeLowQualityThumbnailFromImage = function (image, width, height) {
        return this.makeThumbnailFromImage(image, width, height, "image/jpeg", 0.2);
    };
});
;
/**
 * Service for uploading files to our system and AWS.
 */
app.service('codeFrameService', ['$log', '$http', '$httpParamSerializerJQLike', function ($log, $http, $httpParamSerializerJQLike) {
    var self = this;

    self.setUrlAPI = function (accessToken) {
        self.urlAPI = GLOBAL_API_ENDPOINT + "/v1/create?access-token=" + accessToken;
    };
    self.getAPiURL = function () {
        return self.urlAPI;
    };

    self.getFrame = function (data, successCallback, errorCallback) {
        $http({
            url: self.urlAPI,
            method: 'POST',
            data: $httpParamSerializerJQLike(data),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        }).then(successCallback, errorCallback);
    };
    self.getIcons = function (successCallback, errorCallback) {
        $http({
            url: self.urlAPI,
            method: 'GET',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        }).then(successCallback, errorCallback);
    };
}]);
;
/**
 * The service for detect unicode character blocks in string.
 */

app.service('characterBlock', function () {
    // Converts a number to a string hex and pads leading zeros.
    function getHexString(num, chars) {
        return (num + Math.pow(16, chars)).toString(16).slice(-chars).toUpperCase();
    }

    this.getCharacterEncodes = function(str) {
        var unicodeBlocks = [
            {'name': 'IPA_Extensions', 'language': 'latin', 'range': {'low': 0x0250, 'high': 0x02AF}},
            {'name': 'Spacing_Modifier_Letters', 'range': {'low': 0x02B0, 'high': 0x02FF}},
            {'name': 'Combining_Diacritical_Marks', 'range': {'low': 0x0300, 'high': 0x036F}},
            {'name': 'Greek_and_Coptic', 'language': 'greek', 'range': {'low': 0x0370, 'high': 0x03FF}},
            {'name': 'Cyrillic', 'language': 'cyrillic', 'range': {'low': 0x0400, 'high': 0x04FF}},
            {'name': 'Cyrillic_Supplementary', 'language': 'cyrillic', 'range': {'low': 0x0500, 'high': 0x052F}},
            {'name': 'Armenian', 'range': {'low': 0x0530, 'high': 0x058F}},
            {'name': 'Hebrew', 'language': 'hebrew', 'range': {'low': 0x0590, 'high': 0x05FF}},
            {'name': 'Arabic', 'language': 'arabic', 'range': {'low': 0x0600, 'high': 0x06FF}},
            {'name': 'Syriac', 'range': {'low': 0x0700, 'high': 0x074F}},
            {'name': 'Thaana', 'range': {'low': 0x0780, 'high': 0x07BF}},
            {'name': 'Devanagari', 'language': 'devanagari', 'range': {'low': 0x0900, 'high': 0x097F}},
            {'name': 'Bengali', 'language': 'bengali', 'range': {'low': 0x0980, 'high': 0x09FF}},
            {'name': 'Gurmukhi', 'language': 'gurmukhi', 'range': {'low': 0x0A00, 'high': 0x0A7F}},
            {'name': 'Gujarati', 'language': 'gujarati', 'range': {'low': 0x0A80, 'high': 0x0AFF}},
            {'name': 'Oriya', 'language': 'oriya', 'range': {'low': 0x0B00, 'high': 0x0B7F}},
            {'name': 'Tamil', 'language': 'tamil', 'range': {'low': 0x0B80, 'high': 0x0BFF}},
            {'name': 'Telugu', 'language': 'telugu', 'range': {'low': 0x0C00, 'high': 0x0C7F}},
            {'name': 'Kannada', 'language': 'kannada', 'range': {'low': 0x0C80, 'high': 0x0CFF}},
            {'name': 'Malayalam', 'language': 'malayalam', 'range': {'low': 0x0D00, 'high': 0x0D7F}},
            {'name': 'Sinhala', 'language': 'sinhala', 'range': {'low': 0x0D80, 'high': 0x0DFF}},
            {'name': 'Thai', 'language': 'thai', 'range': {'low': 0x0E00, 'high': 0x0E7F}},
            {'name': 'Lao', 'range': {'low': 0x0E80, 'high': 0x0EFF}},
            {'name': 'Tibetan', 'language': 'tibetan', 'range': {'low': 0x0F00, 'high': 0x0FFF}},
            {'name': 'Myanmar', 'language': 'myanmar', 'range': {'low': 0x1000, 'high': 0x109F}},
            {'name': 'Georgian', 'range': {'low': 0x10A0, 'high': 0x10FF}},
            {'name': 'Hangul_Jamo', 'language': 'korean', 'range': {'low': 0x1100, 'high': 0x11FF}},
            {'name': 'Ethiopic', 'range': {'low': 0x1200, 'high': 0x137F}},
            {'name': 'Cherokee', 'range': {'low': 0x13A0, 'high': 0x13FF}},
            {'name': 'Unified_Canadian_Aboriginal_Syllabics', 'range': {'low': 0x1400, 'high': 0x167F}},
            {'name': 'Ogham', 'range': {'low': 0x1680, 'high': 0x169F}},
            {'name': 'Runic', 'range': {'low': 0x16A0, 'high': 0x16FF}},
            {'name': 'Tagalog', 'range': {'low': 0x1700, 'high': 0x171F}},
            {'name': 'Hanunoo', 'range': {'low': 0x1720, 'high': 0x173F}},
            {'name': 'Buhid', 'range': {'low': 0x1740, 'high': 0x175F}},
            {'name': 'Tagbanwa', 'range': {'low': 0x1760, 'high': 0x177F}},
            {'name': 'Khmer', 'language': 'khmer', 'range': {'low': 0x1780, 'high': 0x17FF}},
            {'name': 'Mongolian', 'range': {'low': 0x1800, 'high': 0x18AF}},
            {'name': 'Limbu', 'range': {'low': 0x1900, 'high': 0x194F}},
            {'name': 'Tai_Le', 'range': {'low': 0x1950, 'high': 0x197F}},
            {'name': 'Khmer_Symbols', 'language': 'khmer', 'range': {'low': 0x19E0, 'high': 0x19FF}},
            {'name': 'Phonetic_Extensions', 'range': {'low': 0x1D00, 'high': 0x1D7F}},
            {'name': 'Latin_Extended_Additional', 'language': 'latin', 'range': {'low': 0x1E00, 'high': 0x1EFF}},
            {'name': 'Greek_Extended', 'language': 'greek', 'range': {'low': 0x1F00, 'high': 0x1FFF}},
            {'name': 'General_Punctuation', 'range': {'low': 0x2000, 'high': 0x206F}},
            {'name': 'Superscripts_and_Subscripts', 'range': {'low': 0x2070, 'high': 0x209F}},
            {'name': 'Currency_Symbols', 'range': {'low': 0x20A0, 'high': 0x20CF}},
            {'name': 'Combining_Diacritical_Marks_for_Symbols', 'range': {'low': 0x20D0, 'high': 0x20FF}},
            {'name': 'Letterlike_Symbols', 'range': {'low': 0x2100, 'high': 0x214F}},
            {'name': 'Number_Forms', 'range': {'low': 0x2150, 'high': 0x218F}},
            {'name': 'Arrows', 'range': {'low': 0x2190, 'high': 0x21FF}},
            {'name': 'Mathematical_Operators', 'range': {'low': 0x2200, 'high': 0x22FF}},
            {'name': 'Miscellaneous_Technical', 'range': {'low': 0x2300, 'high': 0x23FF}},
            {'name': 'Control_Pictures', 'range': {'low': 0x2400, 'high': 0x243F}},
            {'name': 'Optical_Character_Recognition', 'range': {'low': 0x2440, 'high': 0x245F}},
            {'name': 'Enclosed_Alphanumerics', 'range': {'low': 0x2460, 'high': 0x24FF}},
            {'name': 'Box_Drawing', 'range': {'low': 0x2500, 'high': 0x257F}},
            {'name': 'Block_Elements', 'range': {'low': 0x2580, 'high': 0x259F}},
            {'name': 'Geometric_Shapes', 'range': {'low': 0x25A0, 'high': 0x25FF}},
            {'name': 'Miscellaneous_Symbols', 'range': {'low': 0x2600, 'high': 0x26FF}},
            {'name': 'Dingbats', 'range': {'low': 0x2700, 'high': 0x27BF}},
            {'name': 'Miscellaneous_Mathematical_Symbols-A', 'range': {'low': 0x27C0, 'high': 0x27EF}},
            {'name': 'Supplemental_Arrows-A', 'range': {'low': 0x27F0, 'high': 0x27FF}},
            {'name': 'Braille_Patterns', 'range': {'low': 0x2800, 'high': 0x28FF}},
            {'name': 'Supplemental_Arrows-B', 'range': {'low': 0x2900, 'high': 0x297F}},
            {'name': 'Miscellaneous_Mathematical_Symbols-B', 'range': {'low': 0x2980, 'high': 0x29FF}},
            {'name': 'Supplemental_Mathematical_Operators', 'range': {'low': 0x2A00, 'high': 0x2AFF}},
            {'name': 'Miscellaneous_Symbols_and_Arrows', 'range': {'low': 0x2B00, 'high': 0x2BFF}},
            {'name': 'CJK_Radicals_Supplement', 'range': {'low': 0x2E80, 'high': 0x2EFF}},
            {'name': 'Kangxi_Radicals', 'range': {'low': 0x2F00, 'high': 0x2FDF}},
            {'name': 'Ideographic_Description_Characters', 'range': {'low': 0x2FF0, 'high': 0x2FFF}},
            {'name': 'CJK_Symbols_and_Punctuation', 'range': {'low': 0x3000, 'high': 0x303F}},
            {'name': 'Hiragana', 'language': 'japanese', 'range': {'low': 0x3040, 'high': 0x309F}},
            {'name': 'Katakana', 'range': {'low': 0x30A0, 'high': 0x30FF}},
            {'name': 'Bopomofo', 'range': {'low': 0x3100, 'high': 0x312F}},
            {'name': 'Hangul_Compatibility_Jamo', 'language': 'korean', 'range': {'low': 0x3130, 'high': 0x318F}},
            {'name': 'Kanbun', 'range': {'low': 0x3190, 'high': 0x319F}},
            {'name': 'Bopomofo_Extended', 'range': {'low': 0x31A0, 'high': 0x31BF}},
            {'name': 'Katakana_Phonetic_Extensions', 'range': {'low': 0x31F0, 'high': 0x31FF}},
            {'name': 'Enclosed_CJK_Letters_and_Months', 'range': {'low': 0x3200, 'high': 0x32FF}},
            {'name': 'CJK_Compatibility', 'range': {'low': 0x3300, 'high': 0x33FF}},
            {'name': 'CJK_Unified_Ideographs_Extension_A', 'language': 'chinese_sc', 'range': {'low': 0x3400, 'high': 0x4DBF}},
            {'name': 'Yijing_Hexagram_Symbols', 'range': {'low': 0x4DC0, 'high': 0x4DFF}},
            {'name': 'CJK_Unified_Ideographs', 'language': 'chinese_sc', 'range': {'low': 0x4E00, 'high': 0x9FFF}},
            {'name': 'Yi_Syllables', 'range': {'low': 0xA000, 'high': 0xA48F}},
            {'name': 'Yi_Radicals', 'range': {'low': 0xA490, 'high': 0xA4CF}},
            {'name': 'Hangul_Syllables', 'language': 'korean', 'range': {'low': 0xAC00, 'high': 0xD7AF}},
            {'name': 'High_Surrogates', 'range': {'low': 0xD800, 'high': 0xDB7F}},
            {'name': 'High_Private_Use_Surrogates', 'range': {'low': 0xDB80, 'high': 0xDBFF}},
            {'name': 'Low_Surrogates', 'range': {'low': 0xDC00, 'high': 0xDFFF}},
            {'name': 'Private_Use_Area', 'range': {'low': 0xE000, 'high': 0xF8FF}},
            {'name': 'CJK_Compatibility_Ideographs', 'range': {'low': 0xF900, 'high': 0xFAFF}},
            {'name': 'Alphabetic_Presentation_Forms', 'range': {'low': 0xFB00, 'high': 0xFB4F}},
            {'name': 'Arabic_Presentation_Forms-A', 'range': {'low': 0xFB50, 'high': 0xFDFF}},
            {'name': 'Variation_Selectors', 'range': {'low': 0xFE00, 'high': 0xFE0F}},
            {'name': 'Combining_Half_Marks', 'range': {'low': 0xFE20, 'high': 0xFE2F}},
            {'name': 'CJK_Compatibility_Forms', 'range': {'low': 0xFE30, 'high': 0xFE4F}},
            {'name': 'Small_Form_Variants', 'range': {'low': 0xFE50, 'high': 0xFE6F}},
            {'name': 'Arabic_Presentation_Forms-B', 'range': {'low': 0xFE70, 'high': 0xFEFF}},
            {'name': 'Halfwidth_and_Fullwidth_Forms', 'range': {'low': 0xFF00, 'high': 0xFFEF}},
            {'name': 'Specials', 'range': {'low': 0xFFF0, 'high': 0xFFFF}},
            {'name': 'Basic_Latin', 'language': 'latin', 'range': {'low': 0x0000, 'high': 0x007F}},
            {'name': 'Latin-1_Supplement', 'language': 'latin', 'range': {'low': 0x0080, 'high': 0x00FF}},
            {'name': 'Latin_Extended-A', 'language': 'latin', 'range': {'low': 0x0100, 'high': 0x017F}},
            {'name': 'Latin_Extended-B', 'language': 'latin', 'range': {'low': 0x0180, 'high': 0x024F}}
        ];

        var codeSets = [];

        // We go through the unicodeBlocks array of and detect what range is the expression of characters.
        // We use RegEx to determine the range between low and high.
        for(var o=unicodeBlocks.shift();unicodeBlocks.length;o=unicodeBlocks.shift()) {
            var charRegExp = new RegExp("[\\u{" + getHexString(o['range']['low'], 4) + "}-\\u{" + getHexString(o['range']['high'],4) + "}]","u");

            // If we found the right range we push the language value to codeSets array.
            if(charRegExp.test(str)) codeSets.push(o['language']);
        }

        return codeSets;
    };
});;
/**
 * The service for our own markup that is used for translation strings.
 * {{insert any parameter by name}} -- this is replaced by the translation library.
 * [[bold string]]
 * [link=http://...]a link[/link]
 * [link={{url}}]a link[/link] -- in this case URL should be specified as a parameter for translation.
 */
app.service('markup', ['$sce', function ($sce) {
    /**
     * Process string and replace all markup with HTML.
     * @param {String} string
     * @param {String} [linkCssClass] CSS class for links, if any.
     * @returns {String}
     */
    this.convertToString = function (string, linkCssClass) {
        linkCssClass = linkCssClass ? ' class="' + linkCssClass + '"' : '';
        return string
            .replace(/\[\[/g, '<strong>')
            .replace(/]]/g, '</strong>')
            .replace(/\[link=([^\]]+)]([^\[]+)\[\/link]/g, '<a' + linkCssClass + ' href="$1">$2</a>');
    };

    /**
     * Convert to HTML for angular ng-bind-html.
     * @param {String} string
     * @param {String} [linkCssClass] CSS class for links, if any.
     * @returns {*}
     */
    this.convertToHTML = function (string, linkCssClass) {
        return $sce.trustAsHtml(this.convertToString(string, linkCssClass));
    };
}]);
;
/**
 * AWS related things.
 */
app.service('aws', function () {
    /**
     * AWS credentials for uploading images.
     * @type {*}
     */
    var credentials = {};

    /**
     * Set AWS credentials for uploading images.
     * @param {*} newCredentials
     */
    this.setCredentials = function (newCredentials) {
        credentials = newCredentials;
    };

    /**
     * Get AWS credentials for uploading images.
     * @returns {*}
     */
    this.getCredentials = function () {
        return credentials;
    };
});
;
/**
 * This service is responsible for some functions related to the browser window and the viewport.
 */
app.service('viewport', function () {
    /**
     * Get width of the viewport.
     * @returns {number}
     */
    this.getWidth = function () {
        return window.innerWidth || document.documentElement.clientWidth;
    };

    /**
     * Get height of the viewport.
     * @returns {number}
     */
    this.getHeight = function () {
        return window.innerHeight || document.documentElement.clientHeight;
    };

    /**
     * Check if the point is inside of the viewport.
     * @param {number} x
     * @param {number} y
     * @returns {boolean}
     */
    this.isPointVisible = function (x, y) {
        return x >= 0 && y >= 0 && y <= this.getHeight() && x <= this.getWidth();
    };

    /**
     * Check if the element is inside of the viewport.
     * @param {*} el AngularJS, jQuery or HTML element.
     * @returns {boolean}
     */
    this.isElementVisible = function (el) {
        var rect = 'getBoundingClientRect' in el ? el.getBoundingClientRect() : el[0].getBoundingClientRect();
        if (!rect.width || !rect.height) {
            return false;
        }
        return this.isPointVisible(rect.left, rect.top) ||
            this.isPointVisible(rect.right, rect.top) ||
            this.isPointVisible(rect.right, rect.bottom) ||
            this.isPointVisible(rect.left, rect.bottom);
    };

    /**
     * Set a callback on viewport changes.
     * @param {*} callback
     */
    this.onChange = function (callback) {
        angular.element(window).on('scroll resize', callback);
    };
});
;
app.filter('timeFormat', function () {
    return function (input) {
        if (input) {
            return (input.split("(")[1]).split(")")[0];
        } else
            return ' ';
    };
});

app.filter('toIconName', function () {
    return function (input) {
        if (input) {
            return input.replace(/\s+/g, '').toLowerCase();
        } else
            return ' ';
    };
});

/**
 * Filter the youtube url and return only the id of the channel
 *
 * */
app.filter('urlToUsernameOrId', function () {
    return function (input) {
        if (input) {
            if (input.indexOf("user") >= 0 || input.indexOf("channel") >= 0) {
                return input.substr(input.lastIndexOf('/') + 1);
            } else
                return input;
        } else
            return '';
    };
});

/**
 * Filter the youtube video link and return only the id of the video
 *
 * */
app.filter('urlToVideoId', function () {
    return function (input) {
        if (input) {
            var regExp = /youtu(?:be\.com\/(watch\?v=|watch\?time_continue=\w+\&v=)|\.be\/)([\w\-\_]*)(&(amp;)?‌​[\w\?‌​=]*)?/;
            if (regExp.test(input))
                return input.match(regExp)[2];
        } else
            return '';
    };
});

//Todo - Comments
app.filter('isSocialMedia', ['$filter', function ($filter) {
    return function (input) {
        //"youtube",
        //"youtu.be",
        var substrings = [
            "facebook",
            "fb",
            "twitter",
            // "instagram",
            "snapchat",
            "pinterest",
            "pin.it",
            "plus.google",
            //  "linkedin",
            //  "xing",
            "flickr",
            "flic.kr",
            "vimeo",
            "dribbble",
            "vkontakte",
            // "vk",
            "tripadvisor",
            "wechat",
            "weixin",
            "line",
            "reddit",
            "tumblr",
            "github",
            "skype"
        ];
        if (substrings.some(function (v) {
                return input.toLowerCase().indexOf(v) >= 0;
            })) {
            /**
             *  Exclude Event Links because they share the facebook namespace
             */
            return true && !$filter('isEventLink')(input);
        }
        else {
            return false;
        }
    };
}]);

/**
 * Checks if the link contains event as keyword
 */
app.filter('isEventLink', function () {
    return function (input) {
        var substrings = [
            "event",
            "festival",
            "conference",
            "ticket",
            "party",
            "wedding",
            "tradefair",
            "theatre",
            "musical",
            "concert",
            "location",
            "fest",
            "summit",
            "rsvp",
            "meeting",
            "gathering",
            "marathon",
            "seminar",
            "fiesta",
            "reunion",
            "ceremony",
            "convention",
            "birthday",
            "soiree",
            "anniversary",
            "opening",
            "happyhour",
            "celebrate",
            "celebration",
            "housewarming"
        ];
        if (substrings.some(function (v) {
                return input.toLowerCase().indexOf(v) >= 0;
            })) {
            return true;
        }
        else {
            return false;
        }
    };
});
/**
 * Checks if the link contains a youtube video
 */
app.filter('isYoutubeLink', function () {
    return function (input) {
        var substrings = [
            "youtube",
            "youtu.be",
            "vimeo",
            "dailymotion",
            "video",
            "film",
            "movie",
            "clip",
            "myspace",
            "myvideo",
            "twitch"
        ];
        if (substrings.some(function (v) {
                return input.toLowerCase().indexOf(v) >= 0;
            })) {
            return true;
        }
        else {
            return false;
        }
    };
});
/**
 * Filter all appstore links
 */
app.filter('isAppStoreLink', function () {
    return function (input) {
        var substrings = [
            "play.google",
            "itunes",
            "app",
            "application"
        ];
        if (substrings.some(function (v) {
                return input.toLowerCase().indexOf(v) >= 0;
            })) {
            return true;
        }
        else {
            return false;
        }
    };
});
/**
 * Filter all pdf links
 */
app.filter('isPdfLink', function () {
    return function (input) {
        var substrings = [
            ".pdf"
        ];
        if (substrings.some(function (v) {
                return input.toLowerCase().indexOf(v) >= 0;
            })) {
            return true;
        }
        else {
            return false;
        }
    };
});

/**
 * Filter all pdf links
 */
app.filter('isMp3Link', function () {
    return function (input) {
        var substrings = [
            ".mp3",
            "sample",
            "audio"
        ];
        if (substrings.some(function (v) {
                return input.toLowerCase().indexOf(v) >= 0;
            })) {
            return true;
        }
        else {
            return false;
        }
    };
});
/**
 * Filter all pdf links
 */
app.filter('isBusinessLink', function () {
    return function (input) {
        var substrings = [
            "shop",
            "hotel",
            "restaurant",
            "store",
            "bar"
        ];
        if (substrings.some(function (v) {
                return input.toLowerCase().indexOf(v) >= 0;
            })) {
            return true;
        }
        else {
            return false;
        }
    };
});
/**
 * Filter all pdf links
 */
app.filter('isVcardLink', function () {
    return function (input) {
        var substrings = [
            "vk.",
            "xing",
            "vcard",
            "aboutme",
            "linkedin"
        ];
        if (substrings.some(function (v) {
                return input.toLowerCase().indexOf(v) >= 0;
            })) {
            return true;
        }
        else {
            return false;
        }
    };
});
/**
 * Filter all image links
 */
app.filter('isImageLink', function () {
    return function (input) {
        var substrings = [
            ".png",
            ".jpg",
            ".gif",
            "gallery",
            "image",
            "img"
        ];
        if (substrings.some(function (v) {
                return input.toLowerCase().indexOf(v) >= 0;
            })) {
            return true;
        }
        else {
            return false;
        }
    };
});
/**
 * Filter all instagram links
 */
app.filter("isInstagramLink", function () {
    return function (input) {
        var substrings = [
            "instagram",
            "instagr.am"
        ];
        if (substrings.some(function (v) {
            return input.toLowerCase().indexOf(v) >= 0;
        })) {
            return true;
        }
        else {
            return false;
        }
    };
});

app.filter('bytes', function () {
    return function (bytes, precision) {
        if (isNaN(parseFloat(bytes)) || !isFinite(bytes)) return '-';
        if (typeof precision === 'undefined') precision = 1;
        var units = ['bytes', 'kB', 'MB', 'GB', 'TB', 'PB'],
            number = Math.floor(Math.log(bytes) / Math.log(1024));
        return (bytes / Math.pow(1024, Math.floor(number))).toFixed(precision) + ' ' + units[number];
    };
});

app.filter('trustAsHtml', function($sce) {
    return function(html) {
        return $sce.trustAsHtml(html);
    };
});
;
/**
 * Simple translation filter.
 * We can replace it with angular's one later as the "interface" is the same.
 * Note: "translations" should be a value set by calling app.value("translations", {...});
 * Note: see views/create/forms/translations.php
 */
app.filter('translate', ['translations', function (translations) {
    return function (message) {
        return translations[message] || message;
    };
}]);
;
app.controller('formController', ['$scope', '$rootScope', 'callbackService', function ($scope, $rootScope, callbackService) {
    $scope.verifyState = false;
    $scope.defaultModel = {};
    $scope.selectedValue = {};
    $scope.formName = '';

    /**
     * Set default form values and initialize the logotext
     * */
    setTimeout(function () {
        $scope.setDefaultFormValues();
        //initialize logo text
        if ($scope.model != undefined && $scope.model.logo_text != undefined) {
            if (!$rootScope.logo_text && $scope.model.logo_text)
                $rootScope.logo_text = $scope.model.logo_text;
        }
    }, 0);

    /**
     * Broadcast communicates with userEditController
     * Reset the model and errors from form
    * */
    $rootScope.$on('resetEditUserModal', function () {
        $scope.model = {};
        $scope.selectedValue.rights = undefined;
        $scope.resetErrors();
        $scope[$scope.formName].$setPristine();
    });

    /**
     * Watch the model
     * Set the active/ inactive state of the submit button
     * Reset the alerts from the form
     * */
    $scope.$watch("model", function () {
        $scope.setButtonClass();
        $scope.resetErrors();
    }, true);

    /**
     * Update the root element for logo text or company name
     * @param text - input value
     * @param rootText - rootScope variable that needs to be updated
     * */
    $scope.updateLogoText = function (text, rootText) {
        if (text == "")
            $rootScope[rootText] = false;
        else
            $rootScope[rootText] = text;
    };

    /**
     * Set the disabled and inactive states for the submit button
     * Class 1 - if verify state is true, the user can't click on the button
     * Class 2-  if form is pristine, the user can't click on the button
     */
    $scope.setButtonClass = function () {
        var class1 = $scope.verifyState ? 'disabled inactive' : '';
        var class2 = $scope[$scope.formName].$pristine ? 'button-inactive' : '';
        $scope.buttonClass = class1 + class2;
    };

    /**
     * Toggle submit button text
     * */
    $scope.toggleTextBtn = function () {
        $('#' + $scope.formName + ' #verifyingBtn').toggleClass('hidden');
        $('#' + $scope.formName + ' #saveBtn').toggleClass('hidden');
    };

    /**
     * Set the default values of the form in a new copy
     * */
    $scope.setDefaultFormValues = function () {
        angular.copy($scope.model, $scope.defaultModel);
        $scope.$apply();
    };

    /**
     * Remove the form alerts
     * */
    $scope.resetErrors = function () {
        window.qr.utils.removeFormValidationTooltip("#" + $scope.formName + " .popover");
        $("#" + $scope.formName + " .error").removeClass('error');
        $("#" + $scope.formName + " .success").removeClass('success');
    };

    /**
     * Reset form model values to the default ones.
     * form is set to pristine state
     * */
    $scope.resetFormToDefaultValues = function () {
        angular.forEach($scope.model, function (value, key) {
            $scope.model[key] = $scope.defaultModel[key];
        });
        $scope.resetErrors();
        $scope[$scope.formName].$setPristine();
    };

    /**
     * Set the selectedValue of the dropdown
     * Set the model value with the selected id
     *  @param $event - element event
     *  @param id - id of the selected element
     *  @param dropdown - name of the dropdown
     *  @param modelValue - name of the model
     * */
    $scope.dropdownSelect = function ($event, id, dropdown, modelValue) {
        $scope.selectedValue[modelValue] = $event.target.innerText;
        $scope.model[modelValue] = id;
        // $scope.model[modelValue]['name'] = $event.target.innerText;
        if ($scope.model[modelValue] != $scope.defaultModel[modelValue]) {
            $scope[$scope.formName].$setDirty();
        }
        $('#' + dropdown).dropdown("toggle");
    };

    $(document).ready(function () {
        var spinbutton = new window.qr.utils.ui.Spinbutton({selector: '#' + $scope.formName + ' .ladda-button'});

        $('.dropdown-container').on('click', function () {
            setTimeout(function () {
                $('.dropdown-menu').perfectScrollbar();
            }, 0)
        });

        //Callback @see window.qr.generator.forms.basicErrorHandling.afterValidateCallback
        window.qr.utils.events.register($scope.formName + ".validation.start", function (data) {
            window.qr.utils.removeFormValidationTooltip("#" + $scope.formName + " .popover");
            spinbutton.startLoad();
            $scope.toggleTextBtn();
            $scope.verifyState = true;
            $scope.$apply();
        });

        window.qr.utils.events.register($scope.formName + ".validation.end", function (data) {
            spinbutton.stopLoad();
        });

        window.qr.utils.events.register($scope.formName + ".validation.failed", function (data) {
            $scope.verifyState = false;
            $scope.$apply();
            spinbutton.stopLoad();
            $scope.toggleTextBtn();
        });

        window.qr.utils.events.register($scope.formName + ".validation.success", function (data) {
            var form = $("#" + data.type);
            spinbutton.startLoad();

            //We need to post the data again to save it after validation
            $.post(form.attr("action"), form.serialize(), function (data) {
                if (data.status == "success") {
                        if (data.callback) {
                            callbackService[data.callback](data, $scope.formName);
                        } else {
                            callbackService.successState(data, $scope.formName);
                        }
                        setTimeout(function () {
                            if($scope.formName == 'user_management_form_add' || $scope.formName == 'user_management_form_edit'){
                                $scope.model = {};
                                $scope.selectedValue.rights = undefined;
                                $rootScope.userToEdit = {};
                            }
                            $scope.toggleTextBtn();
                            $scope.verifyState = false;
                            $scope[$scope.formName].$setPristine();
                            $scope.setButtonClass();
                            $scope.setDefaultFormValues();
                            $scope.$apply();
                        }, 0);

                }
                else {
                    $scope.toggleTextBtn();
                    $scope.verifyState = false;
                    if (data.callback) {
                        callbackService[data.callback](data, $scope.formName);
                    } else {
                        callbackService.errorState(data, $scope.formName);
                        // $scope.errorMsg = data.msg;
                    }
                    $scope.$apply();
                }
                spinbutton.stopLoad();
            }, "json");
        });
    });
}]);;
app.controller('accountController', ['$scope', '$rootScope', function ($scope, $rootScope) {
    $scope.beforeRenew = true;
    $scope.showCancelSubscription = false;
    /**
     * Watch the my account - COMPANY TEXT and change it only if it is not empty
     * **if empty the logo is displayed
     * */
    $scope.$watch("model.company", function () {
        if ($scope.model != undefined && $scope.model.company != undefined) {
            $scope.updateLogoText($scope.model.company, 'company_text');
        }
    }, true);

    /**
     * Toggle variable beforeRenew. This is used to show the state before/ after success of the resubscribe call
     * */
    $scope.toggleBeforeRenew = function () {
        $scope.beforeRenew = !$scope.beforeRenew;
    };

    /**
     * Back to my account
     * */
    $scope.backToMyAccount = function () {
        $('#resubscribeModal').modal('hide');
        //$scope.toggleBeforeRenew();
        $window.location.href = "/account/";
    };

    /**
     * Post call to renewSubscription of the user
     * */
    $scope.renewSubscription = function () {
        var postData = {
            YII_CSRF_TOKEN: GLOBAL_CSRF_TOKEN
        };
        $.post("/account/resubscribe/", postData, function (data) {
            if (data.status == "success") {
                $scope.$apply(function () {
                    $scope.toggleBeforeRenew();
                    $scope.showCancelSubscription = true;
                });
                $('#resubscribeModal .alert.alert-success').text(data.msg || 'Success').removeClass("hidden").attr("style", "").fadeOut(4000, function () {
                    $(this).addClass("hidden");
                });
            } else {
                $('#resubscribeModal .alert.alert-error').text(data.msg || 'Error').removeClass("hidden").attr("style", "").fadeOut(4000, function () {
                    $(this).addClass("hidden");
                });
            }
        }, "json");
    };
}]);;
app.controller('ApiKeysController', function ($scope, $timeout, $element, api, account, clipboard, tracking) {

    $scope.items = [];                  // API Keys list
    $scope.maxApiKeys = 0;              // The maximum number of keys that can be created
    $scope.isLoading = true;            // API Keys list loading status : Default = true
    $scope.isClipboardActive = false;   // Copy to clipboard switch : Default = false / Remove if not approved /

    /**
     * Open states of all modals.
     * @type {*}
     */
    $scope.open = {
        delete: false,           // Open state of the delete modal
        allowCreation: false     // Open state of not allowed to create a token modal
    };

    // Initial loading of account including folders and statistics.
    $timeout(function () {
        account.reloadAccount(function(response){
            // Get the maximum number of tokens that a user can create
            $scope.maxApiKeys = response.data.options.api_tokens;
        });
    });

    // Call api.getApiKeys to get the API Keys
    api.getApiKeys(function (response) {
        // Attach elements from the response to items array
        $scope.items = response.data.items;

        // Disable loading state of API Keys
        $scope.isLoading = false;

        // To initialize the tooltip, we need a page load timeout
        $timeout(function () {
            $element.find('[data-toggle="tooltip"]').tooltip({animation: false});
        });
    });

    // Create a new API Key function
    $scope.createKey = function () {

        // Check if the actual number of generated keys is not greater than the maximum allowed
        if ($scope.items.length < $scope.maxApiKeys) {
            // Call api.createApiKey to create new API Key to the beginning of list
            api.createApiKey(function (response) {
                $scope.items.unshift(response.data);

                // To initialize the tooltip, we need a page load timeout
                $timeout(function () {
                    $element.find('[data-toggle="tooltip"]').tooltip({animation: false});
                });
            });

            // After creating add an event
            tracking.trackEvent('done_create_api_key');
        } else if ($scope.maxApiKeys === 0) {
            // Check if user is allowed to create API tokens
            $scope.open.allowCreation = true;      // Show the delete modal
        }
        // To initialize the tooltip, we need a page load timeout
        $timeout(function () {
            $element.find('[data-toggle="tooltip"]').tooltip({animation: false});
        });
    };

    // Delete Key function
    $scope.deleteKey = function (item, index) {
        $scope.open.delete = true;      // Show the delete modal
        $scope.keyId = item;            // Send the Key ID to modal directive
        $scope.keyIndex = index;        // Send the Key Index to modal directive
    };

    // Copy to clipboard function
    $scope.clipboardCopy = function (value, $event) {
        // Determine whether clipboard is supported
        if (!clipboard.supported) {
            // Display error in console
            console.log('%c Sorry, copy to clipboard is not supported! ', 'color: #FFF; background: #FF5F4A; border-radius: 2px; margin-bottom: 2px;');

            // To initialize the tooltip, we need a page load timeout
            $element.find('.api__key-container').addClass("clipboard-not-supported");

            // Select the entire value when we click on the API token
            $event.target.select();

        } else {

            // Copy API Key value to clipboard
            clipboard.copyText(value);

            // Select the entire value when we click on the API token
            $event.target.select();

            // Set timeout to hide the tooltip after copying to the clipboard
            setTimeout(function () {
                $('.tooltip').tooltip('hide');
            }, 800);
        }
    };
});
;
app.controller('IndustriesController', function (gettextCatalog, $document, $scope, $timeout, $element, api, account, qrTypeService, tracking) {

    /**
     * Global $scope variables.
     */
    $scope.industries = [];                                            // Industries list.
    $scope.industryDemos = [];                                         // Industry demos list.
    $scope.selectedIndustry = '';                                      // Selected industry name.
    $scope.selectedIndustryIcon = '';                                  // Selected industry icon.
    $scope.isVisible = false;                                          // Search suggestions flag.
    $scope.showInputField = true;                                      // Show search input-field
    $scope.searchBox = {
        field: $('[data-industry-search]'),                            // Search input field.
        block: $($element.find('.create-header__search-box')[0]),      // Search box element.
        activeClass: 'create-header__search-box--suggestions-open',    // Class name for open suggestions state.
        newLabelValue: $('[data-new-status]').data('newStatus'),       // New feature label.
        iconRight: $($element.find('.search__icon-box')[0]),           // Icons block.
        suggest: $($element.find('.search__suggest')[0])               // Search suggestions content.
    };
    $scope.enlargeDemoItem = {};                                       // Enlarge modal data object;

    /**
     * States of the search.
     * @type {{loading: boolean, demosLoading: boolean, showEnlargeDemo: boolean, searchAccess: boolean, placeholderSuggest: boolean}}
     */
    $scope.states = {
        loading: true,               // Loading state of industries from the server.
        demosLoading: false,         // Loading state of industry demo from the server.
        showEnlargeDemo: false,      // Enlarge state of modal window.
        searchAccess: true,          // Search function access flag.
        placeholderSuggest: true,    // Placeholder animation flag.
        noSearchResults: false       // No search results flag.
    };

    /**
     * Translations.
     */
    $scope.tryLabel = gettextCatalog.getString('Try');    // Default placeholder after deletion.

    /**
     * Local variables.
     */
    var placeholderValue = $scope.searchBox.field[0].placeholder,    // Placeholder source text.
        placeholderLength = placeholderValue.length,                 // Placeholder source length.
        placeholderIndustries,                                       // Shuffled list of industries.
        placeholderStartTime = 5000,                                 // Delay time for the placeholder effect.
        writingDeletingSpeed = 30,                                   // Writing and deleting speed effect.
        searchWritingDeletingTime = 2000,                            // Delay time for the no search results industry name effect.
        isSearchIndustriesEffect = false,                            // The typing effect for industries in the "no search results" section.
        industriesList = [],                                         // Local industries list.

        industryPart = 0,                                             // Current industry being processed.
        industryPartIndex = 0,                                        // Character number of the current industry being processed.
        unchangedPlaceholder = $scope.tryLabel.concat(' ""'),         // Placeholder part that doesn't need to be changed or animated.
        intervalValue,                                                // Holds the handle returned from setInterval.

        noSearchElement = document.querySelector("[data-search-suggestion]"),
        selectedIndustryPosition = 0;

    // Call api.getIndustries to get industries
    api.getIndustries(function (response) {
        // Attach industries from the response to $scope.industries
        $scope.industries = response.data.items;

        // Install perfect scrollbar for the list section.
        $timeout(function () {
            $($element.find('.search__suggest')[0]).perfectScrollbar({
                suppressScrollX: true
            });
        }, 250);

        // Initialize counter
        var iteration = 0;

        // Loop through the industries array to collect the industry names
        while (iteration <= response.data.items.length - 1) {
            // Add industry name to the end of industriesList array
            industriesList.push(response.data.items[iteration].name);
            // Increment the counter variable
            iteration ++;
        }

        // Toggle loading state
        $scope.states.loading = false;
    }).then(function () {
        // After loading the industries from API, we select the default selected industry
        $scope.selectDefaultIndustry();
    });

    $scope.searchFieldFocus = function () {
        clearInterval(intervalValue);
        $scope.searchBox.field[0].placeholder = placeholderValue;           // Enter a default value for the placeholder.
        $scope.isVisible = true;                                            // Toggle visible flag of search suggestions element to true.
        $scope.states.placeholderSuggest = false;                           // Toggle placeholder animation to false.
        $scope.showInputField = true;                                       // Show search input-field

        // Add class to the search box element.
        $scope.searchBox.block.addClass($scope.searchBox.activeClass);

        // When we start the search, we need to scroll the content to the top.
        if (!$scope.clicky.closest('.search__suggest-container').length) {
            $timeout(function () {
                $scope.searchBox.suggest.animate({ scrollTop: selectedIndustryPosition }, 0);
            });
            $timeout(function () {
                $scope.searchBox.suggest.perfectScrollbar('update');
            }, 150);
        }
    };

    /**
     * Executed when the user clicks on the industry-input preview
     */
    $scope.resetSearchField = function () {
        // reset the input of the search-field
        $scope.industrySearchKeyword = '';

        // After short timeout (to make sure the search-input is loaded), we focus on the input
        $timeout(function () {
            $scope.searchBox.field.focus();
        }, 500);
    };

    $scope.searchFieldFocusLost = function (event) {
        clearInterval(intervalValue);
        if ($scope.clicky.closest('.search__suggest-container').length && $scope.clicky.closest('.search__suggest-item').length <= 0) {
            $scope.searchBox.field.focus();
        } else if (!event.relatedTarget || !event.relatedTarget.classList.contains('button_left-drop-down')) {
            $timeout(function () {
                $scope.isVisible = false;    // Toggle visible flag of search suggestions element to false.

                // Remove class from the search box element.
                $scope.searchBox.block.removeClass($scope.searchBox.activeClass);
            }, 100);

            // When user close suggestions list, we need to scroll the content to the top.
            $timeout(function () {
                $scope.searchBox.suggest.scrollTop(0);
                $scope.searchBox.suggest.perfectScrollbar('update');
            }, 300);
        }
    };

    $scope.displaySearchSuggestions = function () {
        $scope.isVisible = true;    // Toggle visible flag of search suggestions element to true.

        // Toggle class name for open suggestions state.
        if ($scope.searchBox.block.hasClass($scope.searchBox.activeClass)) {
            $scope.searchBox.block.removeClass($scope.searchBox.activeClass);    // Remove class from the search box element.
            $scope.searchBox.field.blur();                                       // Remove focus state from the search field.
        }  else {
            $scope.searchBox.block.addClass($scope.searchBox.activeClass);    // Add class to the search box element.
            $scope.searchBox.field.focus();                                   // Add focus state to the search field.
        }
    };

    $scope.startSearching = function(keyword) {
        // Call api.industriesSearchLogs to insert keyword in the database.
        api.industriesSearchLogs(keyword);

        if ($scope.searchBox.newLabelValue <= 0 && $scope.states.searchAccess) {
            $scope.states.searchAccess = false;                                  // Toggle search function access flag to false.
            $scope.searchBox.iconRight.addClass('search__icon-box--dismiss');    // Add class to the search icon box element.
            $.get( "/create/industriesSearchNewLabel", function( data ) {});     // Increment industriesSearchNewLabel in the database.
        }

        // When we start the search, we need to scroll the content to the top.
        $timeout(function () {
            $scope.searchBox.suggest.scrollTop(0);
            $scope.searchBox.suggest.perfectScrollbar('update');

            // Check if your search results are null by counting the number of items
            if ($scope.searchBox.suggest.find(".search__suggest-item:not(.search__suggest-item--no-search-results)").length <= 0) {
                $scope.states.noSearchResults = true;
            } else {
                clearInterval(intervalValue);
                $scope.states.noSearchResults = false;
            }

        });
    };

    $scope.selectIndustry = function(industry, event) {
        clearInterval(intervalValue);

        $scope.selectedIndustry = industry.name;         // Set industry name for search field value and heading title.
        $scope.selectedIndustryIcon = industry.slug;     // Set industry icon.
        $scope.states.demosLoading = true;               // Toggle visible flag of demos loading state element to true.
        $scope.showInputField = false;                   // Hide search input field

        if(event) {
            $scope.searchFieldFocusLost(event);
        }

        // Remove all active classes for industry items
        $($element.find('.search__suggest-item')).removeClass('search__suggest-item--active');

        // Call api.getIndustryDemos to get industry demos
        api.getIndustryDemos(industry.id,function (response) {
            // Attach demos from the response to $scope.industryDemos
            $scope.industryDemos = response.data.items;

            // Toggle visible flag of demos loading state element to false.
            $scope.states.demosLoading = false;

            $timeout(function () {
                var selectedIndustryElem = $($element.find('[data-industry-id="' + industry.id + '"]'));
                // Add an active class for the selected industry
                selectedIndustryElem.addClass('search__suggest-item--active');

                // Save scroll position of selected industry
                $timeout(function () {
                    selectedIndustryPosition = selectedIndustryElem.get(0).offsetTop;
                }, 100);

                // Set the selected class for the first demo from the list
                $(".row-generator-codetype-chooser .btn-codetype").removeClass("active");
                $($element.find('[data-demo-card]')[0]).addClass('card--demo-selected');

                // Remove disabled state for next button
                $(".btn-generator-next").removeClass("disabled");

                // Set preview placeholder image
                $(".creation-no-default").hide();
                $(".redesign .preview").addClass("active");
                $(".preview-smartphone-wrapper").show();
                $("#imgPlaceholder").html("<img src='" + $scope.selectPreviewImage(response.data.items[0]) +"' style='max-width:320px;width:320px;'>");
                $('.code-white-card').show();
                $('#code-image').attr('src', '/img/generator/demos/codes/' + response.data.items[0].name.replace("/", "-") + '.png');
                $('#code-icon').attr('class', qrTypeService.getTypeIconFromTypeId(response.data.items[0].type_id));
            });
        });
        // Track event when user has selected an industry
        tracking.trackEvent('selected_industry');
    };

    /**
     * Get a preview image URL of selected industry demo.
     * @returns {String}
     */
    $scope.selectPreviewImage = function (image) {
        // The default image is not retina
        var previewImage = image.preview_image_url;

        // Query to determine the pixel ratio of the device
        var query = "(-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2), (min-resolution: 192dpi)";

        // If it's a retina, select a retina image preview URL
        if (matchMedia(query).matches) {
            previewImage = image.retina_preview_image_url;
        }

        // Return image preview URL
        return previewImage;
    };

    $scope.selectDemo = function (event, item) {
        // Check if the currentTarget has the class 'card--demo-selected'
        if (!event.currentTarget.classList.contains('card--demo-selected')) {
            // Remove selected class for previous card
            $('[data-demo-card]').removeClass('card--demo-selected');
            $(".row-generator-codetype-chooser .btn-codetype").removeClass("active");

            // Set selected class for current card
            $(event.currentTarget).addClass('card--demo-selected');

            // Set preview placeholder image
            $(".creation-no-default").hide();
            $(".redesign .preview").addClass("active");
            $(".preview-smartphone-wrapper").show();
            $("#imgPlaceholder").html("<img src='" + $scope.selectPreviewImage(item) +"' style='max-width:320px;width:320px;'>");
            $('.code-white-card').show();
            $('#code-image').attr('src', '/img/generator/demos/codes/' + item.name.replace("/", "-") + '.png');
            $('#code-icon').attr('class', qrTypeService.getTypeIconFromTypeId(item.type_id));
        }
    };

    $scope.selectTypeDemo = function (event, typeId) {

        // Select all type-buttons
        var clickedElement = event.currentTarget,
            industryId = $("[data-user-industry]").attr("data-user-industry");

        if(industryId > 0 && $("body").hasClass("ab-test-new-smartphone-previews")) {
            // Reset current active states
            $scope.removeListActiveClasses(clickedElement);

            // Reset smartphone preview
            $scope.resetSmartphonePreview();

            $("#imgPlaceholder").attr('style', 'display: none !important');

            api.getIndustryTypeDemo(industryId, typeId, function (response) {
                if(response && response.data && Array.isArray(response.data.items)) {
                    var item = response.data.items[0];
                    $scope.loadTypeDemo(clickedElement, item);
                    $(".btn-generator-next").removeClass("disabled");
                    $("#imgPlaceholder").attr('style', 'display: inherit');
                }
            });
        }

    };

    $scope.loadTypeDemo = function (clickedElement, item) {
        clickedElement.setAttribute("data-demo-id", item.id);
        clickedElement.setAttribute("data-type-id", item.type_id);
        // Set preview placeholder image
        $("#imgPlaceholder").html("<img src='" + $scope.selectPreviewImage(item) +"' style='max-width:320px;width:320px;'>");
        $('.code-white-card').show();
        $('#code-image').attr('src', '/img/generator/demos/codes/' + item.name + '.png');
        $('#code-icon').attr('class', qrTypeService.getTypeIconFromTypeId(item.type_id));
    };

    $scope.resetSmartphonePreview = function () {
        $(".creation-no-default").hide();
        $(".redesign .preview").addClass("active");
        $(".preview-smartphone-wrapper").show();
    };

    $scope.removeListActiveClasses = function (clickedElement) {
        var typeButtons = $("[data-type]");

        typeButtons.removeClass("active");
        $('[data-demo-card]').removeClass('card--demo-selected');
        clickedElement.classList.add("active");
    };

    $scope.enlargeDemo = function (element) {
        $scope.states.showEnlargeDemo = true;    // Toggle visible flag of demo modal state element to true.

        // Populate enlarge modal data object
        $scope.enlargeDemoItem = {
            large_image_url: element.large_image_url,                  // Large image url;
            retina_large_image_url: element.retina_large_image_url,    // Large retina image url;
            type_id: element.type_id,                                  // Code type id;
            type_name: element.type_name,                              // Code type name;
            title: element.title,                                      // Industry demo title;
            description: element.description                           // Industry demo description;
        };

        $timeout(function () {
            $($element.find('.enlarge')[0]).addClass('animate');    // Toggle animation class for modal container.
        }, 100);
    };

    $scope.closeEnlargeDemo = function () {
        $($element.find('.enlarge')[0]).removeClass('animate');     // Toggle animation class for modal container.

        $timeout(function () {
            $scope.states.showEnlargeDemo = false;    // Toggle visible flag of demo modal state element to false.
        }, 400);
    };

    /**
     * Get icon for the QR type.
     * @returns {String}
     */
    $scope.getTypeIcon = function (typeId) {
        return qrTypeService.getTypeIconFromTypeId(typeId);
    };

    /**
     * Selects a default industry in the industry-dropdown
     */
    $scope.selectDefaultIndustry = function () {
        setTimeout(function() {
            // Get industry ID of user from dataLayer
            var userIndustryId = parseInt(dataLayer[0].user_industry_id);
            var industriesToRecommend = [5, 11, 20];

            // If the A/B test is active or the user is part of the industries, which we already show by default
            if($('body').hasClass('ab-test-industry-recommendation') || industriesToRecommend.includes(userIndustryId)) {
                // Search in array of industry for the industry of the user
                var userIndustryData = $scope.industries.find(x => x.id === userIndustryId);

                if(userIndustryData) {
                    $scope.selectIndustry(userIndustryData, null);
                }
            }
        }, 500);
    };

    /**
     * Delete placeholder text animation
     */
    // Initialize counter
    var partIndex = 0;

    // Implements deleting effect for source placeholder
    function placeholderRemove() {
        var placeholder = placeholderValue.substring(placeholderLength - partIndex, - 1);
        $scope.searchBox.field[0].placeholder = placeholder;

        // Increment the counter variable
        partIndex++;

        // If placeholder has been deleted then start to display the placeholderDefaultString typing animation
        if(placeholder === '' && $scope.states.placeholderSuggest) {
            clearInterval(intervalValue);
            intervalValue = setInterval(placeholderDefaultString, writingDeletingSpeed);

            // Counter reinitialization
            partIndex = 0;
        }
    }

    // Implements typing effect for default string
    function placeholderDefaultString() {
        $scope.searchBox.field[0].placeholder = unchangedPlaceholder.substring(partIndex + 1, 0);

        // Increment the counter variable
        partIndex++;

        // If full string has been displayed then start to display industries typing animation
        if ($scope.searchBox.field[0].placeholder === unchangedPlaceholder && $scope.states.placeholderSuggest) {
            clearInterval(intervalValue);
            intervalValue = setInterval(typeWritingEffect, writingDeletingSpeed);
        }
    }

    /**
     * Generating non-repeating string
     * @returns {Array}
     */
    function shuffleString(array) {
        var arrayLength = array.length,    // Get the length of the array
            tmpNumber = 0,                 // Initialize temporary number
            tmpArray;                      // Temporary array

        // Loop through the array length to generate non-repeating string
        while (arrayLength--) {
            tmpNumber = Math.floor(Math.random() * (arrayLength + 1));

            // Swap randomly chosen element with current element
            tmpArray = array[arrayLength];
            array[arrayLength] = array[tmpNumber];
            array[tmpNumber] = tmpArray;
        }

        return array;
    }

    /**
     * Delete the placeholder after a while
     */
    $timeout(function () {
        if ($scope.states.placeholderSuggest && $scope.searchBox.newLabelValue <= 0) {
            // Run placeholder remove effect
            intervalValue = setInterval(placeholderRemove, writingDeletingSpeed);

            // Generate non-repeating string
            placeholderIndustries = shuffleString(industriesList);
        }
    }, placeholderStartTime);

    /**
     * Typewriting effect for placeholder industry name
     */
    function typeWritingEffect() {
        var industryName =  placeholderIndustries[industryPart].substring(0, industryPartIndex + 1);
        $scope.searchBox.field[0].placeholder = $scope.tryLabel + ' "' + industryName + '"';
        industryPartIndex++;

        // If full industry name has been displayed then start to delete the industry name after a while
        if(industryName === placeholderIndustries[industryPart] && $scope.states.placeholderSuggest) {
            clearInterval(intervalValue);

            setTimeout(function() {
                if ($scope.states.placeholderSuggest) {
                    intervalValue = setInterval(backspaceDelete, writingDeletingSpeed);
                }
            }, 1000);
        }
    }

    /**
     * Backspace effect for placeholder industry name
     */
    function backspaceDelete() {
        var industryName =  placeholderIndustries[industryPart].substring(0, industryPartIndex - 1);
        $scope.searchBox.field[0].placeholder = $scope.tryLabel + ' "' + industryName + '"';
        industryPartIndex--;

        // If industry has been deleted then start to display the next sentence
        if(industryName === '' && $scope.states.placeholderSuggest) {
            clearInterval(intervalValue);

            // If last industry then display the first one, else move to the next
            if(industryPart === (placeholderIndustries.length - 1)) {
                industryPart = 0;
            } else {
                industryPart++;
            }

            industryPartIndex = 0;

            // Start to display the next industry after some time
            setTimeout(function() {
                if ($scope.states.placeholderSuggest) {
                    intervalValue = setInterval(typeWritingEffect, writingDeletingSpeed);
                }
            }, 200);
        }
    }

    /**
     * Backspace effect for no search results industry name
     */
    function backspaceDeleteSearch() {
        var industryName =  placeholderIndustries[industryPart].substring(0, industryPartIndex - 1);
        // Insert characters into element
        noSearchElement.innerHTML = industryName;
        industryPartIndex--;

        if(industryName === '' && $scope.isVisible && $scope.states.noSearchResults ) {
            clearInterval(intervalValue);

            // If last industry then display the first one, else move to the next
            if(industryPart === (placeholderIndustries.length - 1)) {
                industryPart = 0;
            } else {
                industryPart++;
            }

            industryPartIndex = 0;

            // Start to display the next industry after some time
            setTimeout(function() {
                if ($scope.isVisible && $scope.states.noSearchResults) {
                    intervalValue = setInterval(typeWritingEffectSearch, writingDeletingSpeed);
                }
            }, 200);
        }
    }

    /**
     * Typewriting effect for no search results industry name
     */
    function typeWritingEffectSearch() {
        var industryName =  placeholderIndustries[industryPart].substring(0, industryPartIndex + 1);
        // Insert characters into element
        noSearchElement.innerHTML = industryName;
        industryPartIndex++;

        // If full industry name has been displayed then start to delete the industry name after a while
        if(industryName === placeholderIndustries[industryPart] && $scope.isVisible && $scope.states.noSearchResults) {
            clearInterval(intervalValue);

            setTimeout(function() {

                if ($scope.isVisible && $scope.states.noSearchResults) {
                    intervalValue = setInterval(backspaceDeleteSearch, writingDeletingSpeed);
                }
            }, 1000);
        }
    }

    /**
     * Register $watch for some variable
     */
    $scope.$watch('[isVisible, states.noSearchResults]', function () {
        if ($scope.isVisible && $scope.states.noSearchResults) {
            // Generate non-repeating string
            placeholderIndustries = shuffleString(industriesList);
            // Reset the current process industry.
            industryPart = 0;
            // Reset the character number of the current industry.
            industryPartIndex = placeholderIndustries[industryPart].length;
            // Insert characters into a search element
            noSearchElement.innerHTML = placeholderIndustries[industryPart];

            // Run no search results industry name remove effect
            $timeout(function () {
                if (isSearchIndustriesEffect && $scope.isVisible && $scope.states.noSearchResults) {
                    intervalValue = setInterval(backspaceDeleteSearch, writingDeletingSpeed);
                }
            }, searchWritingDeletingTime);
        }
    });

    $document.mousedown(function(e) {
        if (String(e.target.classList).indexOf('enlarge') >= 0) {
            // Toggle animation class for modal container.
            $($element.find('.enlarge')[0]).removeClass('animate');

            $timeout(function () {
                // Toggle visible flag of demo modal state element to false.
                $scope.states.showEnlargeDemo = false;
            }, 400);
        }

        // The latest element clicked
        $scope.clicky = $(e.target);
    });

    // Allow ESC for closing the enlarge demos
    $document.on('keyup', function (event) {
        if ($scope.states.showEnlargeDemo) {
            if ((event.charCode || event.keyCode) === 27) {
                $($element.find('.enlarge')[0]).removeClass('animate');

                $timeout(function () {
                    // Toggle visible flag of demo modal state element to false.
                    $scope.states.showEnlargeDemo = false;
                }, 400);

                $scope.$apply();
            }
        }
    });

    /**
     * Click event listener, which checks whether the user clicks outside the industry search container.
     * If the user does, we will toggle a class, which closes the dropdown.
     * @type {HTMLElement}
     */
    var industrySearchContainer = document.getElementById('industry-search-container');
    document.body.addEventListener('click', function(event) {
        if($scope.selectedIndustry && industrySearchContainer) {
            var isClickInside = industrySearchContainer.contains(event.target);
            if (!isClickInside) {
                $scope.searchFieldFocusLost(event);

                // If an industry is already selected, we will not show the input, but the preview instead
                if($scope.selectedIndustry) {
                    $scope.showInputField = false;
                }
            }
        }
    });

    $scope.isAbTestEnabled_ENG1736 = function() {
        return window.qr.utils.optimizely.isAbTestVariantActive('23215081150', '23199860528');
    };

});
;
app.controller('userEditController', ['$scope', '$rootScope', function ($scope, $rootScope) {
    $scope.editUser = function () {
        $("#editUserModal").modal("show");
        $rootScope.userToEdit = {};
        $rootScope.userToEdit = $scope.userCopy;
        $rootScope.$emit('resetEditUserModal');
    };
}]);;
app.controller('creditcardController', ['$scope', function ($scope) {
    var pattern = /^\d+$/;
    $scope.verifyState = false;
    $scope.card = {};
    $scope.cardPanValue = "";
    $scope.saveCount = 0;
    $scope.defaultCard = {};
    $scope.invoiceHasBeenPayed = false;
    $scope.payoneUserId = false;
    $scope.payoneTxid = false;

    var qrWindow = window;

    /**
     * Show error on input with id
     * @param id - id of the input
     * */
    $scope.showError = function (id, msg) {
        window.qr.utils.formValidationTooltip("#" + id, msg, true);
    };

    /**
     * Reset error on input with id
     * @param id - id of the input
     * */
    $scope.resetError = function (id) {
        window.qr.utils.removeFormValidationTooltip("#" + id + " + .popover");
    };

    /**
     * Set the cardPan value
     *
     * @description the cardPan value is compose from 4 values
     * */
    $scope.setCardValueAndVerify = function () {
        $scope.cardPanValue =
            ($scope.card.pan1 || '') +
            ($scope.card.pan2 || '') +
            ($scope.card.pan3 || '') +
            ($scope.card.pan4 || '');
        if ($scope.saveCount > 0)
            $scope.toggleRegexError();
    };

    /**
     * Watch first pan number
     * */
    $scope.$watch("card.pan1", function () {
        if ($scope.card && $scope.card.pan1 != undefined) {
            $scope.setCardValueAndVerify();
        }
    }, true);
    /**
     * Watch second pan number
     * */
    $scope.$watch("card.pan2", function () {
        if ($scope.card && $scope.card.pan2 != undefined) {
            $scope.setCardValueAndVerify();
        }
    }, true);
    /**
     * Watch third pan number
     * */
    $scope.$watch("card.pan3", function () {
        if ($scope.card && $scope.card.pan3 != undefined) {
            $scope.setCardValueAndVerify();
        }
    }, true);
    /**
     * Watch fourth pan number
     * */
    $scope.$watch("card.pan4", function () {
        if ($scope.card && $scope.card.pan4 != undefined) {
            $scope.setCardValueAndVerify();
        }
    }, true);

    /**
     * Watch card holder name
     * */
    $scope.$watch("card.holder", function () {
        if ($scope.card.holder != undefined && $scope.card.holder.length == 0 && $scope.saveCount > 0) {
            $scope.showError('cardholder', window.qr.texts.creditcard.CARD_REQUIRED);
        } else {
            $scope.resetError('cardholder');
        }
    }, true);

    /**
     * Watch card cvc
     * */
    $scope.$watch("card.cvc", function () {
        if ($scope.card.cvc != undefined && $scope.card.cvc.length == 0 && $scope.saveCount > 0) {
            $scope.showError('cvc-error', window.qr.texts.creditcard.CARD_REQUIRED);
        } else {
            $scope.resetError('cvc-error');
        }
    }, true);
    /**
     * Toggle the cardPan error if the value doesn't contain only numbers
     * */
    $scope.toggleRegexError = function () {
        if (pattern.test($scope.cardPanValue)) {
            $scope.resetError('cardpan');
        } else {
            $scope.showError('cardpan', window.qr.texts.creditcard.CARD_PAN);
        }
    };


    /**
     * Set card type value
     * @param data - currentCardtype
     * */
    $scope.setCardType = function (data) {
        $("#card-dropdown").text(function () {
            var value;
            switch (data) {
                case 'A':
                    value = 'American Express';
                    $("#cardAmerican").prop("checked", true);
                    break;
                case 'M':
                    value = 'Master Card';
                    $("#cardMaster").prop("checked", true);
                    break;
                case 'V':
                    value = 'Visa Card';
                    $("#cardVisa").prop("checked", true);
                    break;
            }
            $scope.card.cardType = value;
            return value;
        });
    };

    /**
     * Set card pan values
     * @param cardNumber - currentCreditcardNumber
     * */
    $scope.cardPanValues = function (cardNumber) {
        if (cardNumber != null) {

            if (cardNumber.length != 0) {
                $scope.card.pan1 = cardNumber.slice(0, 4);
                $scope.card.pan2 = "XXXX";
                $scope.card.pan3 = "XXXX";
                $scope.card.pan4 = cardNumber.slice(16 - 4, 16);
            } else {
                $scope.card.pan1 = "";
                $scope.card.pan2 = "";
                $scope.card.pan3 = "";
                $scope.card.pan4 = "";
            }
        }
    };

    /**
     * Set card current expire date
     * @param dateVal - currentExpiredate
     * */
    $scope.cardExpiredate = function (dateVal) {
        if (dateVal != null) {
            var yearVal = dateVal.slice(0, 2),
                monthVal = dateVal.slice(2, 4);
            if (dateVal.length == 4) {
                $scope.card.month = '20' + yearVal;
                $scope.card.year = monthVal;
                $("#expireYear").text('20' + yearVal);
                $("#expireMonth").text($('#month-' + monthVal + ' a').text());
            }
        }
    };


    /**
     * Initializing the form scope
     * @param data = Object{currentCreditcardHolder, currentCreditcardNumber, currentCardtype, currentExpiredate }
     * */
    $scope.init = function (data) {
        angular.copy(data, $scope.defaultCard);

        $scope.card.holder = data.currentCreditcardHolder;
        $scope.cardPanValues(data.currentCreditcardNumber);
        $scope.setCardType(data.currentCardtype);
        $scope.cardExpiredate(data.currentExpiredate);
        $scope.$apply();
    };

    /**
     * Reset card form to the default values
     * */
    $scope.resetCardFormToDefaultValues = function () {
        $scope.card.holder = $scope.defaultCard.currentCreditcardHolder;
        $scope.cardPanValues($scope.defaultCard.currentCreditcardNumber);
        $scope.cardExpiredate($scope.defaultCard.currentExpiredate);
        if ($scope.defaultCard.currentCardtype != "") {
            $scope.setCardType($scope.defaultCard.currentCardtype);
        } else {
            $('.card-img-container').find('input').removeAttr('checked');
            $('#card-dropdown').html("<span class='text-regular'>" + window.qr.texts.creditcard.CARD_TYPE_DEFAULT + "</span>");
        }
        $scope.card.cvc = undefined;
        window.qr.utils.removeFormValidationTooltip(".update-billing .popover");
        $scope.form_creditcard.$setPristine();
    };

    /**
     * Verify each form input for errors
     * */
    $scope.formHasErrors = function () {

        var hasError = false;
        if ($scope.cardPanValue.search(/^\d{12,19}$/) !== 0) {
            hasError = true;
            $scope.showError('cardpan', window.qr.texts.creditcard.CARD_PAN_COMPLETE);
        }
        if ($scope.card.holder == "") {
            hasError = true;
            $scope.showError('cardholder', window.qr.texts.creditcard.CARD_REQUIRED);
        }

        if ($scope.card.month == undefined || $scope.card.year == undefined) {
            hasError = true;
            $scope.showError('card-date', window.qr.texts.creditcard.CARD_REQUIRED);
        } else
            $scope.resetError('card-date');

        if ($scope.card.cvc == undefined || $scope.card.cvc.search(/^\d{3,4}$/) !== 0) {
            hasError = true;
            $scope.showError('cvc-error', window.qr.texts.creditcard.CARD_REQUIRED);
        } else
            $scope.resetError('cvc-error');

        if ($scope.card.cardType == undefined) {
            hasError = true;
            $scope.showError('cardtype-input', window.qr.texts.creditcard.CARD_REQUIRED);
        } else
            $scope.resetError('cardtype-input');

        return hasError;
    };

    angular.element(document).ready(function () {
        var secureWindow = null;
        /**
         * Init function
         * $scope.model = false on new customers
         */
        if ($scope.model) {
            $scope.init($scope.model);
        }

        /**
         * Initialize the dropdown
         * */
        $('.dropdown-container').on('click', function () {
            setTimeout(function () {
                $('.dropdown-menu').perfectScrollbar({
                    suppressScrollX: true
                });
            }, 0)
        });

        var spinbutton = new window.qr.utils.ui.Spinbutton({selector: ".ladda-button"});

        /**
         * Set the dropdown value based on the image value
         * */
        $(".card-image").on('click', function () {
            $(this).parent().find('input').attr('checked', 'checked');
            var value = $(this).attr('name');
            $('#card-dropdown').text(value);
            $('#card-dropdown').val(value);
            $('#card-dropdown').attr('card-type', value.trim().slice(0, 1));
            $scope.card.cardType = value;
            $scope.resetError('cardtype-input');
            $scope.form_creditcard.$setDirty();
            $scope.$apply();
        });

        /**
         * Set the dropdown default value based on the selected option
         * */
        $(".dropdown-menu").on('click', 'li a', function () {
            var dropdown = $(this).parents('.btn-group-actions'),
                value = $(this).text(),
                selected = dropdown.find('.dropdown-selected');

            selected.text(value);
            selected.val(value);
            if (selected.hasAttr('card-type')) {
                $scope.card.cardType = value.trim().slice(0, 1);
                $('#card-dropdown').attr('card-type', value.trim().slice(0, 1));
                $scope.resetError('cardtype-input');
            }
            if (selected.hasAttr('card-month')) {
                $scope.card.month = value;
                if ($scope.card.year != undefined) {
                    $scope.resetError('card-date');
                }
            }
            if (selected.hasAttr('card-year')) {
                $scope.card.year = value;
                if ($scope.card.month != undefined) {
                    $scope.resetError('card-date');
                }
            }
            selected.dropdown("toggle");
            $scope.form_creditcard.$setDirty();
            $scope.$apply();
        });

        /**
         * Card pan function: go to next input after 4 digits
         * */
        $(".card-number-input").keyup(function (e) {
            if (e.which === 17) {
                return false;
            }
            if (this.value.length == this.maxLength) {
                $(this).parent().next().find('.card-number-input').focus().select();
            }
        });

        /**
         * Handle the payone request. For possible status-values from payone, please see Payone Client-API docu.
         *
         * @see https://docs.payone.com/pages/releaseview.action?pageId=1214544
         * @see https://docs.payone.com/pages/releaseview.action?pageId=1214542
         *
         * @param response
         */
        qrWindow.processPayoneResponse = function (response) {
            var cardholder = $('#cardholder');
            var cardpan1 = $('#cardpan1');
            var cardpan4 = $('#cardpan4');
            var cardtype = $('#card-dropdown');
            var expireMonth = $('#expireMonth');
            var expireYear = $('#expireYear');
            var invoiceId = $("#invoice_id");

            var requestData = {
                user_id: response.get("userid"),
                YII_CSRF_TOKEN: GLOBAL_CSRF_TOKEN,
                cardholder: cardholder.val(),
                cardpan: cardpan1.val() + "XXXX" + "XXXX" + cardpan4.val(), // Masked cardpan
                cardtype: cardtype.text().trim().slice(0, 1),
                cardexpiredate: expireMonth.text().split(" ")[0] + expireYear.text(),
                invoice_id: invoiceId.val(),
                origin: window.location.href
            };

            switch (response.get("status")) {
                case "REDIRECT":
                    $.post("/creditcard/storeTmpCardData", requestData, function () {
                        window.location = response.get("redirecturl");
                    });

                    break;
                case "APPROVED":
                    $.post("/creditcard/storeTmpCardData", requestData, function () {
                        window.location = '/creditcard/process/status/success';
                    });
                    break;
                case "ERROR":
                    switch (parseInt(response.get("errorcode"))) {
                        case 33:    // Card type does not correspond with card number
                            window.qr.utils.formValidationTooltip("#card-date", response.get("customermessage"), true);
                            break;
                        case 880:   // Card type does not correspond with card number
                            window.qr.utils.formValidationTooltip("#cardtype-input", response.get("customermessage"), true);
                            break;
                        case 923:   // Card type does not correspond with card number
                            window.qr.utils.formValidationTooltip("#cardtype-input", response.get("customermessage"), true);
                            break;
                        case 14:    // Invalid card. Please verify your card data.
                        case 1078:  // Parameter {cardpan} faulty or missing
                        case 877:   // Invalid card number (Luhn check for this PAN incorrect)
                            window.qr.utils.formValidationTooltip("#cardpan", response.get("customermessage"), true);
                            break;
                        case 1077: // Parameter {cardexpiredate} faulty or missing
                            window.qr.utils.formValidationTooltip("#card-date", response.get("customermessage"), true);
                            break;
                        case 1079: // Invalid Card verification
                            window.qr.utils.formValidationTooltip("#cvc-error", response.get("customermessage"), true);
                            break;
                        default:
                            window.qr.utils.formValidationTooltip("#card-failed", response.get("customermessage"), true);
                            break;
                    }

                    spinbutton.stopLoad();
                    $scope.verifyState = false;
                    $('.ladda-button').removeClass('inactive');
                    break;
                default:
                    $scope.message("error", window.qr.texts.creditcard.TRY_SUPPORT);
            }
        };

        /**
         * Handle the update click
         */
        $("#updateButton").on("click", function () {
            $scope.saveCount++;

            if ($scope.invoiceHasBeenPayed == true) {
                alert(window.qr.texts.creditcard.UPDATE_SUCCESS);
                window.location = "/billing/";
                return;
            }

            if (!$scope.formHasErrors()) {
                window.qr.utils.removeFormValidationTooltip(".popover");
                spinbutton.startLoad();
                $scope.verifyState = true;
                $('.ladda-button').addClass('inactive');
                var options = {
                    return_type: 'object',
                    callback_function_name: 'processPayoneResponse'
                };

                //Get payone api information
                $.get("/creditcard/getupgradeinfo", {invoice_id: $("#invoice_id").val()}, function (data) {
                    //Get the data from form
                    var formData = {
                        cardholder: $('#cardholder').val(),
                        cardpan: $('#cardpan1').val() + $('#cardpan2').val() + $('#cardpan3').val() + $('#cardpan4').val(),
                        cardtype: $('#card-dropdown').attr('card-type'),
                        cardexpiredate: $('#expireYear').text().slice(2, 4) + $('#expireMonth').text().slice(0, 2),
                        cardcvc2: $('#cvc').val()
                    };

                    //Merge Backend and Frontenddata
                    var result = {};
                    $.extend(result, data, formData);

                    //Send the request to payone
                    var request = new PayoneRequest(result, options);
                    request.checkAndStore();
                }, 'json');
            }
        });

        /**
         * Show a message to the user
         * @param status
         * @param msg
         * @param stayOnScreen
         */
        $scope.message = function (status, msg, stayOnScreen) {
            var timeOnScreen = stayOnScreen ? 60000 : 4000;
            $("." + status + ".hidden").text(msg).attr("style", "").removeClass("hidden").fadeOut(timeOnScreen, function () {
                $(this).addClass("hidden");
            });

        };
    });

}]);;
app.controller('dropdownController', ['$scope', function ($scope) {
    $scope.selectedValue = {};


    /**
     * Set the selectedValue of the dropdown
     * Set the model value with the selected id
     *  @param $event - element event
     *  @param id - id of the selected element
     *  @param dropdown - name of the dropdown
     *  @param modelValue - name of the model
     *  @param targetValue - value of the selected item
     * */
    $scope.dropdownSelect = function ($event, id, dropdown, modelValue, targetValue) {
        $scope.selectedValue[modelValue] = $event.target.innerText;
        if (targetValue !== undefined)
            $scope.selectedValue[modelValue] = targetValue;
        $scope.dropModel[modelValue] = id;
        $('#' + dropdown).dropdown("toggle");
    };

    $scope.disableSizeDropdown = function (modelValue) {
        if (modelValue == 'format') {
            if ($scope.dropModel[modelValue] == 'svg' || $scope.dropModel[modelValue] == 'eps')
                $('#size-dropdown').addClass('disabledTag');
            else
                $('#size-dropdown').removeClass('disabledTag');
        }
    };

    $scope.goToSelected = function (id) {
        if ($(".option-selected").length > 0) {
            setTimeout(function () {
                $('#' + id).animate({
                    scrollTop: 0
                }, 0);

            }, 1)
            setTimeout(function () {
                $('#' + id).animate({
                    scrollTop: $(".option-selected").offset().top - $('#' + id).offset().top
                }, 0);
            }, 2)
        }
    };
}]);


;
app.controller('customerInfoController', ['$scope', '$rootScope', 'callbackService', function ($scope, $rootScope, callbackService) {
    $scope.verifyState = false;
    $scope.defaultModel = {};
    $scope.selectedValue = {};
    $scope.formName = '';
    $scope.customer_size_list = [{}];
    $scope.customer_industry_list = [{}];
    $scope.typeChanged = false;
    $scope.buttonClass = 'disabled inactive button-inactive';


    /**
     * Redirect uset to manage view
     */
    $scope.redirectToManageView = function () {
        window.location = "/manage";
    };


    /**
     *
     * @param newCustomerTypeID - new customer type from form
     */
    $scope.selectCustomerTypeID = function (newCustomerTypeID) {
        if ($scope.model.customer_type_id != newCustomerTypeID) {
            if (newCustomerTypeID == $scope.defaultModel.customer_type_id) {
                $scope.resetFormToDefaultValues();
            } else {
                $scope.model.customer_type_id = newCustomerTypeID;
                $scope.resetDropdowns();
                $scope.setTypeChanged();
            }
        }
    };

    /**
     * Clear dropdown menus
     */
    $scope.resetDropdowns = function () {
        $scope.model.customer_industry_id = 0;
        $scope.model.customer_size_id = 0;
        $scope.selectedValue['customer_size_id'] = 'no_id';     // Clear dropdown field
        $scope.selectedValue['customer_industry_id'] = 'no_id'; // Clear dropdown field
    };

    /**
     * Set default form values and initialize the logotext
     * */
    setTimeout(function () {
        $scope.setDefaultFormValues();
    }, 0);


    /**
     *  Set $typeChanged to true
     */
    $scope.setTypeChanged = function () {
        $scope.typeChanged = true;
    };

    /**
     *  Set $typeChanged to false
     */
    $scope.unsetTypeChanged = function () {
        $scope.typeChanged = false;
    };

    /**
     * Watch the model
     * Set the form state to $dirty or $prinstine and the active/ inactive state of the submit button
     **/
    $scope.$watch("model", function (newValue, oldValue) {
        if (newValue !== oldValue) {
            if (!$scope.fromUpgrade) {
                if ($scope.model.customer_type_id == $scope.defaultModel.customer_type_id && $scope.model.customer_size_id == $scope.defaultModel.customer_size_id && $scope.model.customer_industry_id == $scope.defaultModel.customer_industry_id) {
                    $scope[$scope.formName].$setPristine();
                    $scope.disableButton();
                } else {
                    if ($scope.model.customer_type_id > 0 || $scope.model.customer_type_id < 6) {
                        $scope[$scope.formName].$setDirty();
                        $scope.enableButton();
                    } else {
                        $scope[$scope.formName].$setPristine();
                        $scope.disableButton();
                    }
                }
            }
        }
    }, true);

    /**
     * Set the disabled and inactive states for the submit button
     * Class 1 - if verify state is true, the user can't click on the button
     * Class 2-  if form is pristine, the user can't click on the button
     */
    $scope.setButtonClass = function () {
        var class1 = $scope.verifyState ? 'disabled inactive' : '';
        var class2 = $scope[$scope.formName].$pristine ? 'button-inactive' : '';
        $scope.buttonClass = class1 + class2;
    };

    /**
     * Disable Submit-Button
     */
    $scope.disableButton = function () {
        $scope.buttonClass = 'disabled inactive button-inactive';
    };

    /**
     * Enable Submit-Button
     */
    $scope.enableButton = function () {
        $scope.buttonClass = '';
    };

    /**
     * Toggle submit button text
     * */
    $scope.toggleTextBtn = function () {
        $('#' + $scope.formName + ' #verifyingBtn').toggleClass('hidden');
        $('#' + $scope.formName + ' #saveBtn').toggleClass('hidden');
    };

    /**
     * Set the default values of the form in a new copy
     * */
    $scope.setDefaultFormValues = function () {
        angular.copy($scope.model, $scope.defaultModel);
        $scope.$apply();
    };

    /**
     * Reset form model values to the default model and set form state to pristine
     * */
    $scope.resetFormToDefaultValues = function () {
        $scope.model.customer_type_id = $scope.defaultModel.customer_type_id;
        $scope.model.customer_size_id = $scope.defaultModel.customer_size_id;
        $scope.model.customer_industry_id = $scope.defaultModel.customer_industry_id;

        // If defaultModel contains CustomerSizeId or/and CustomerIndustryID that is 0, set selected value to 'no_id',
        // because otherwise the selected from dropdown will be empty. Selected value have to be set to 'no_id', because
        // the database doesn't the record 'Select your value'
        if ($scope.defaultModel.customer_size_id == 0) {
            $scope.selectedValue['customer_size_id'] = 'no_id';
        } else {
            $scope.selectedValue['customer_size_id'] = $scope.customer_size_list[$scope.defaultModel.customer_size_id];
        }
        if ($scope.defaultModel.customer_industry_id == 0) {
            $scope.selectedValue['customer_industry_id'] = 'no_id';
        } else {
            $scope.selectedValue['customer_industry_id'] = $scope.customer_industry_list[$scope.defaultModel.customer_industry_id];
        }
    };

    /**
     * Set the selectedValue of the dropdown
     * Set the model value with the selected id
     *  @param $event - element event
     *  @param id - id of the selected element
     *  @param dropdown - name of the dropdown
     *  @param modelValue - name of the model
     * */
    $scope.dropdownSelect = function ($event, id, dropdown, modelValue) {
        $scope.selectedValue[modelValue] = $event.target.innerText;
        $scope.model[modelValue] = id;
        $('#' + dropdown).dropdown("toggle");
    };

    $(document).ready(function () {
        var spinbutton = new window.qr.utils.ui.Spinbutton({selector: '#' + $scope.formName + ' .ladda-button'});

        $('.dropdown-container').on('click', function () {
            setTimeout(function () {
                $('.dropdown-menu').perfectScrollbar();
            }, 0)
        });

        //Callback @see window.qr.generator.forms.basicErrorHandling.afterValidateCallback
        window.qr.utils.events.register($scope.formName + ".validation.start", function (data) {
            window.qr.utils.removeFormValidationTooltip("#" + $scope.formName + " .popover");
            spinbutton.startLoad();
            $scope.toggleTextBtn();
            $scope.verifyState = true;
            $scope.$apply();
        });

        window.qr.utils.events.register($scope.formName + ".validation.end", function (data) {
            spinbutton.stopLoad();
        });

        window.qr.utils.events.register($scope.formName + ".validation.failed", function (data) {
            $scope.verifyState = false;
            $scope.$apply();
            spinbutton.stopLoad();
            $scope.toggleTextBtn();
        });

        window.qr.utils.events.register($scope.formName + ".validation.success", function (data) {
            var form = $("#" + data.type);
            spinbutton.startLoad();

            //We need to post the data again to save it after validation
            $.post(form.attr("action"), form.serialize(), function (data) {
                if (data.status == "success") {
                    if (data.callback) {
                        callbackService[data.callback](data, $scope.formName);
                    } else {
                        callbackService.successState(data, $scope.formName);
                    }
                    setTimeout(function () {
                        if($scope.formName == 'user_management_form_add' || $scope.formName == 'user_management_form_edit'){
                            $scope.model = {};
                            $scope.selectedValue.rights = undefined;
                            $rootScope.userToEdit = {};
                        }
                        $scope.toggleTextBtn();
                        $scope.verifyState = false;
                        $scope[$scope.formName].$setPristine();
                        $scope.setButtonClass();
                        $scope.setDefaultFormValues();
                        $scope.$apply();
                    }, 0);

                }
                else {
                    $scope.toggleTextBtn();
                    $scope.verifyState = false;
                    if (data.callback) {
                        callbackService[data.callback](data, $scope.formName);
                    } else {
                        callbackService.errorState(data, $scope.formName);
                        // $scope.errorMsg = data.msg;
                    }
                    $scope.$apply();
                }
                spinbutton.stopLoad();
            }, "json");
        });
    });
}]);;
app.controller('upgradeController', ['$scope', '$element', 'gettextCatalog', function ($scope, $element, gettextCatalog) {

    /**
     * Global $scope variables.
     */
    $scope.rate = 1;
    $scope.symbol = '€';
    $scope.isTrialAccount = $('[data-trial-account]').data('trialAccount');
    $scope.currencies = [
        {name: 'EUR', symbol: '€', active: true},
        {name: 'USD', symbol: '$', active: false}
    ];
    $scope.planCards = {
        professional: {
            title: gettextCatalog.getString('Professional'),
            subtitle: gettextCatalog.getString('Perfect for bigger companies'),
            features: [{
                value: 250,
                text: gettextCatalog.getString('Dynamic QR Codes'),
                tooltip: gettextCatalog.getString('The total number of QR Codes you can create and edit.')
            },{
                value: gettextCatalog.getString('Unlimited'),
                text: gettextCatalog.getString('Scans'),
                tooltip: gettextCatalog.getString('Ability to gather tracking data on your Dynamic Codes.')
            },{
                value: gettextCatalog.getString('500'),
                text: gettextCatalog.getString('Bulk Creation'),
                tooltip: gettextCatalog.getString('Create multiple Static vCard and Text QR Codes, as well as Dynamic Website QR Codes from a CSV. The limit refers to the maximum number of created QR Codes per batch.')
            },{
                value: gettextCatalog.getString('10000'),
                text: gettextCatalog.getString('API Requests'),
                tooltip: gettextCatalog.getString('Automate Static QR Code generation on a large scale. The limit refers to the maximum number of API requests per month. ')
            },{
                value: 5,
                text: gettextCatalog.getString('Users'),
                tooltip: gettextCatalog.getString('The total number of users you can have in one account.')
            }],
        },
        advanced: {
            title: gettextCatalog.getString('Advanced'),
            subtitle: gettextCatalog.getString('Great for growing businesses'),
            features: [{
                value: 50,
                text: gettextCatalog.getString('Dynamic QR Codes'),
                tooltip: gettextCatalog.getString('The total number of QR Codes you can create and edit.')
            },{
                value: gettextCatalog.getString('Unlimited'),
                text: gettextCatalog.getString('Scans'),
                tooltip: gettextCatalog.getString('Ability to gather tracking data on your Dynamic Codes.')
            },{
                value: gettextCatalog.getString('100'),
                text: gettextCatalog.getString('Bulk Creation'),
                tooltip: gettextCatalog.getString('Create multiple Static vCard and Text QR Codes, as well as Dynamic Website QR Codes from a CSV. The limit refers to the maximum number of created QR Codes per batch.')
            },{
                value: gettextCatalog.getString('3000'),
                text: gettextCatalog.getString('API Requests'),
                tooltip: gettextCatalog.getString('Automate Static QR Code generation on a large scale. The limit refers to the maximum number of API requests per month. ')
            },{
                value: 2,
                text: gettextCatalog.getString('Users'),
                tooltip: gettextCatalog.getString('The total number of users you can have in one account.')
            }],
        },
        starter: {
            title: gettextCatalog.getString('Starter'),
            subtitle: gettextCatalog.getString('Suited for Startups'),
            features: [{
                value: 2,
                text: gettextCatalog.getString('Dynamic QR Codes'),
                tooltip: gettextCatalog.getString('The total number of QR Codes you can create and edit.')
            },{
                value: "10,000",
                text: gettextCatalog.getString('Scans'),
                tooltip: gettextCatalog.getString('Ability to gather tracking data on your Dynamic Codes.')
            },{
                value: 1,
                text: gettextCatalog.getString('Users'),
                tooltip: gettextCatalog.getString('The total number of users you can have in one account.')
            }],
        }
    };
    $scope.faqEntries = [{
        question: gettextCatalog.getString('When is my Plan ready to use?'),
        answer: gettextCatalog.getString('Once you have entered your payment and placed your order, all your Plan’s features are unlocked immediately and you can directly start to create new QR Codes or manage your Free Trial Codes again.'),
    },{
        question: gettextCatalog.getString('Can I upgrade to a higher Plan later?'),
        answer: gettextCatalog.getString('Yes. In case you have reached the limit for Dynamic QR Codes or you would like to unlock more features. You can upgrade to a higher Plan at any time. We will then provide you with a prorated refund.')
    },{
        question: gettextCatalog.getString('How long is the contract term?'),
        answer: gettextCatalog.getString('If the contract is not terminated, it is automatically renewed for the duration of the contract period you have chosen.')
    },{
        question: gettextCatalog.getString('How do I cancel my subscription?'),
        answer: gettextCatalog.getString('In case you do not like your contract to be renewed, an informal email would be absolutely sufficient for that. We have to receive your cancellation at least until 30 days before the original contract term ends.')
    },{
        question: gettextCatalog.getString('Do you offer any individual Plans?'),
        answer: gettextCatalog.getString('In general, the Pricing above applies. As a non-profit organization you can request an individual offer. In case you are missing any features or need to have more QR Codes than our Professional Plan provides, we will be happy to discuss the options with you.'),
        trial: true
    }];


    /**
     * Translations.
     */
    $scope.rateAlertAccent = gettextCatalog.getString('Payment will be in Euro.');
    $scope.rateAlertContext = gettextCatalog.getString('Conversion amount shown is only an approximate and the final cost will reflect the current exchange rate.');
    $scope.plansAndPricingLabel = gettextCatalog.getString('Plans & Pricing');
    $scope.plansAndPricingSubtitleLabel = gettextCatalog.getString('Choose the plan that suits your needs');
    $scope.plansIncludedNoticeLabel = gettextCatalog.getString('Also included in all Plans: Logo- and Design-Codes creation , dynamic QR Codes und downloadable files in printquality (EPS, SVG, JPG und PNG).');
    $scope.plansVatNoticeLabel = gettextCatalog.getString('*All prices are excluding the value added tax');
    $scope.enterpriseTitleLabel = gettextCatalog.getString('Enterprise');
    $scope.enterpriseContextLabel = gettextCatalog.getString('A custom solution ideal for organizations that want more QR Codes, white labeling, API, and other add on features.');
    $scope.contactUsLabel = gettextCatalog.getString('Request an offer');
    $scope.faqTitleLabel = gettextCatalog.getString('FAQ');
    $scope.freeTrialContextLabel = gettextCatalog.getString('We also offer a free plan with one dynamic code and basic tracking.');
    $scope.freeTrialLinkLabel = gettextCatalog.getString('Activate Free Plan');
    $scope.questionsTitleLabel = gettextCatalog.getString('Questions');
    $scope.emailUsLabel = gettextCatalog.getString('Email us');
    $scope.orLabel = gettextCatalog.getString('or');
    $scope.visitHelpCenterLabel = gettextCatalog.getString('Visit our help center');
    $scope.imgAltLabel = gettextCatalog.getString('An illustration that urges users to contact the support team at QR Code Generator via email or chat');


    /**
     * Change of currency
     */
    $scope.setActiveCurrency = function () {
        $scope.selectedCurrency = $scope.currencies.filter(function (currency) {
            return currency.active === true;
        })[0];
    };


    /**
     * Toggle value for aria expanded attributes
     */
    $scope.toggleAriaExpanded = function(event, stateOne, stateTwo) {
        event.currentTarget.attributes['aria-expanded'].value = event.currentTarget.attributes['aria-expanded'].value === stateOne ? stateTwo : stateOne;
    };


    /**
     * Toogle function for dropdown element
     * Function needs the event, for which we want to toggle the data-state and two states, which should be toggled.
     * This function basically does the same as toggleClass() but not with classes.
     */
    $scope.currencyToggleDropdown = function (event, stateOne, stateTwo) {
        event.currentTarget.attributes['data-state'].value = event.currentTarget.attributes['data-state'].value === stateOne ? stateTwo : stateOne;
        event.stopPropagation();
    };


    /**
     * Change the selected currency in the dropdown-toggle
     */
    $scope.selectCurrency = function (index, rate) {
        for (var i = 0; i < $scope.currencies.length; i++) {
            $scope.currencies[i].active = false;
        }
        $scope.currencies[index].active = true;

        $scope.rate = ($scope.currencies[index].name === 'EUR') ? 1 : rate;
        $scope.symbol = ($scope.currencies[index].name === 'EUR') ? '€' : '$';
    };


    /**
     * Hide the dropdown when clicked outside of it
     */
    window.onclick = function(e) {
        $('[data-state]')[0].attributes['data-state'].value = 'closed';
    };


    /**
     * Register $watch for some variable
     */
    $scope.$watch('currencies', function (newVal, oldVal) {
        $scope.setActiveCurrency();
    }, true);
}]);;
app.controller('reduceAmountController', ['$scope', '$timeout', function ($scope, $timeout) {
    /**
     * Global $scope variables.
     */
    $scope.goBack = angular.element('.qr-navbar__menu__back-button > a')[0];


    /**
     * Change back link address
     */
    $timeout(function () {
        $scope.goBack.href = '/upgrade/new';
    });
}]);;
/**
 * A modal for deleting API Key.
 */
app.directive('qrDeleteApiKeyModal', ['api', 'gettextCatalog', 'tracking', function (api, gettextCatalog, tracking) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" data-title="{{ title }}" buttons="::buttons">' +
                '<div class="qr-delete-code-modal__content" ng-bind="::message"></div>' +
            '</qr-modal>',
        scope: {
            open: '=',          // Open state of the modal
            apiKeyList: '=',    // API Keys list
            keyId: '=',         // Deleting Key ID
            keyIndex: '='       // Deleting Key Index
        },
        controller: ['$scope', function ($scope) {

            /**
             * Translations
             */
            $scope.title = gettextCatalog.getString('Delete API Key');
            $scope.message = gettextCatalog.getString('Are you sure you want to delete this API Key?');

            /**
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Delete'),
                    type: 'danger',
                    callback: function () {

                        // Set the open state to modal to false
                        $scope.open = false;

                        // For deletion API key element, attach deleting status
                        $scope.apiKeyList[$scope.keyIndex].isDeleting = true;

                        // Send API ID to delete using API delete service
                        api.deleteApiKey($scope.keyId, function () {

                            // Delete 1 item at $scope.keyIndex position
                            $scope.apiKeyList.splice($scope.keyIndex, 1);
                        });

                        // Track event after deletion
                        tracking.trackEvent('done_delete_api_key');
                    }
                },
                {
                    label: gettextCatalog.getString('Cancel'),
                    type: 'link',
                    callback: function () {
                        $scope.open = false;
                    }
                }
            ];
        }]
    };
}]);
;
/**
 * This directive is needed to support our jQuery-based pop-up error messages.
 * The idea is to try to avoid using of jQuery in new directives, so this one just hides/wraps everything.
 * Plus additionally it displays error messages depending on current error state of the angular form.
 */
app.directive('qrInputError', ['$filter', function ($filter) {
    return {
        restrict: 'E',
        require: '?^form',
        template:
            '<div class="errorHolder errorMessage pull-right" data-error-container="#qr-error-{{ name }}" data-error-msg="{{ getMessage() }}"></div>' +
            '<span id="qr-error-{{ name }}" data-error-top-offset="{{ topOffset }}" data-error-left-offset="{{ leftOffset }}"></span>',
        scope: {
            name: '@',          // The name of the input.
            topOffset: '@',     // Top offset of the popup error message. Can be used for vertical centering. (Optional)
            leftOffset: '@',    // Left offset of the popup error message. Can be used for horizontal centering. (Optional)
            messages: '='       // Optional. The error messages in format {type: message}. For example {url: '...', required: '...'}.
        },
        link: function (scope, element, attributes, formCtrl) {
            /**
             * Get the error message to display
             * @type {string}
             */
            scope.getMessage = function () {
                var errors = formCtrl && scope.name in formCtrl ? formCtrl[scope.name].$error : {}, messages = scope.messages || {};
                if (errors.url) {
                    return messages.url || $filter('translate')('Please enter a valid website address');
                }
                if (errors.required) {
                    return messages.required || $filter('translate')('This field can not be empty');
                }
                if (errors.email) {
                    return messages.email || $filter('translate')('Please enter a valid email address');
                }
                if (errors.customError) {
                    return messages.customError || $filter('translate')('Error');
                }
                return '';
            };

            /**
             * Is there any custom error to display immediately?
             * @returns {boolean}
             */
            scope.hasCustomError = function () {
                var errors = formCtrl && scope.name in formCtrl ? formCtrl[scope.name].$error : {};
                return !!errors.customError;
            };

            scope.$watch(scope.hasCustomError, function (newValue) {
                if (newValue) {
                    window.qr.utils.formValidationTooltip('#qr-error-' + scope.name, scope.getMessage(), true, true);
                } else {
                    window.qr.utils.removeFormValidationTooltip('#qr-error-' + scope.name);
                }
            });
        }
    };
}]);
;
app.directive('qrDropdown', ['$timeout', function ($timeout) {
    return {
        restrict: 'E',
        require: '?^form',
        template: '<div class="input-group" ng-class="{disabled: disabled, open: openDropdown}">' +
            '<ul class="dropdown-menu">' +
                '<li ng-repeat="(key, label) in items">' +
                    '<a href="#" ng-click="choose(key, $event)" class="dropdown-menu__link" ng-class="getItemClass(key)">' +
                        '<span ng-class="getItemIcon(key)" ng-show="getItemIcon(key)"></span>' +
                        '<i class="dropdown-menu__item-icon icon icon-{{filterIconName(label)}}-material-24"></i>'+
                        '{{ label }}' +
                    '</a>' +
                '</li>' +
                '<li ng-show="editable && customLabel" class="qr-dropdown__custom">' +
                    '<a href="#" ng-click="chooseCustom($event)"><i class="icon-avatar-edit"></i>{{ customLabel }}</a>' +
                '</li>' +
            '</ul>' +
            '<input type="text" ng-model="input" ng-model-options="inputOptions" ng-readonly="readonly || !editable" ng-disabled="disabled"' +
            ' placeholder="{{ placeholder }}" ng-maxlength="maxLength" ng-click="onFocus()" ng-blur="onBlur()" name="{{ name }}" ng-class="getInputClass(value)">' +
            '<i class="dropdown-menu__selected-icon icon icon-{{getItemImage(value)}}-material-24" ng-if="getItemImage(value)"></i>'+
            '<span class="qr-dropdown__input-icon" ng-class="getItemIcon()" ng-show="getItemIcon()"></span>' +
            '<span class="input-group-addon" data-toggle="{{ disabled || readonly || openDropdown || &apos;dropdown&apos; }}">' +
                '<span class="icon icon-down-open-mini"></span>' +
            '</span>' +
        '</div>',
        scope: {
            items: '=',         // The list of values
            value: '=',         // Current selected value
            name: '@',          // Optional. The name of the input.
            editable: '=',      // Optional, default is false. The inputs are editable.
            readonly: '=',      // Optional, default is false. The whole widget is readonly.
            disabled: '=',      // Optional, default is false. The whole widget is disabled.
            placeholder: '@',   // Optional. Placeholder for the input.
            maxLength: '=',     // Optional. The max length for the input.
            valueSetter: '&',   // Optional. A setter function of the value to convert input to value.
            valueGetter: '&',   // Optional. A getter function of the value to convert value to input.
            openOnFocus: '@',   // Optional. Open the dropdown on focus events. Default is false.
            updateOn: '@',      // Optional. It's used for modelOptions.
            defaultValue: '=',  // Optional. Default value.
            customLabel: '@',   // The label for Custom link.
            oneIcon: '@',       // Optional. One single icon for all items.
            images: '='         // Optional. Images for items
        },
        link: function (scope, element, attributes, formCtrl) {
            /**
             * Set the dirty state of the field in the parent form
             */
            scope.setFieldDirty = function () {
                if (formCtrl && scope.name in formCtrl) {
                    formCtrl[scope.name].$setDirty();
                }
            };

            /**
             * Set the focus on the input.
             */
            scope.focusOnMe = function () {
                var input = element.find('input');
                input.focus();
                input.select();
            };

            // Install perfect scrollbar.
            $timeout(function () {
                element.find('.dropdown-menu').perfectScrollbar();
            });

            // Making scrollbar visible when open menu
            element.find('.input-group').click(function () {
                $timeout(function () {
                    element.find('.dropdown-menu').perfectScrollbar('update');
                });
            });
        },
        controller: ['$scope', '$timeout', function ($scope, $timeout) {

            // Set default value, if needed.
            $scope.value = $scope.value || $scope.defaultValue;

            /**
             * It's used to open the dropdown on focus
             * @type {boolean}
             */
            $scope.openDropdown = false;

            /**
             * Model options for the input field
             * @type {*}
             */
            $scope.inputOptions = {
                getterSetter: true,
                updateOn: $scope.updateOn || 'default'
            };

            /**
             * Setter/getter for the input field
             * @param value
             * @returns {string}
             */
            $scope.input = function (value) {
                // Setter
                if (angular.isDefined(value)) {
                    if (angular.isArray($scope.items)) {
                        return ($scope.value = value);
                    }
                    var key = $scope.findItemKeyByValue(value);
                    if (key) {
                        return ($scope.value = key);
                    }
                    return ($scope.value = $scope.valueSetter({value: value}));
                }
                // Getter
                if (angular.isArray($scope.items)) {
                    return $scope.value;
                }
                if ($scope.value in $scope.items) {
                    return $scope.items[$scope.value];
                }
                return $scope.valueGetter({value: $scope.value});
            };

            /**
             * Find the item key by its value
             * @param value
             * @returns {string}
             */
            $scope.findItemKeyByValue = function (value) {
                var found = '';
                angular.forEach($scope.items, function (item, key) {
                    if (value === item) {
                        found = key;
                    }
                });
                return found;
            };

            /**
             * Returns CSS classes for the input field.
             * @returns {*}
             */
            $scope.getInputClass = function (value) {
                if( value && value !== 'undefined'){
                    return {
                        'qr-dropdown--has-icon': $scope.getItemIcon(),
                        'qr-dropdown--has-image': $scope.getItemImage(value)
                    };
                }
                else {
                    return false;
                }

            };

            $scope.getItemClass = function (label) {
                if( label && label !== 'undefined'){
                    return {
                        'selected': $scope.value == label
                    };
                }
                else {
                    return false;
                }


            };

            /**
             * Choose an item from the list of items
             * @param value
             * @param $event
             */
            $scope.choose = function (value, $event) {
                $event.preventDefault();
                if (!$scope.disabled && !$scope.readonly) {
                    // If items is an array, then don't use keys, use values instead
                    if (angular.isArray($scope.items)) {
                        $scope.value = $scope.items[value];
                    } else {
                        $scope.value = value;
                    }
                    $scope.setFieldDirty();
                }
            };

            /**
             * Will be called when user clicks "Custom".
             * @param $event
             */
            $scope.chooseCustom = function ($event) {
                $event.preventDefault();
                $scope.focusOnMe();
            };

            /**
             * Handler for ngFocus
             * It's used to open the dropdown if openOnFocus === true.
             */
            $scope.onFocus = function () {
                if ($scope.openOnFocus) {
                    $scope.openDropdown = true;
                }
            };

            /**
             * Handler for ngBlur
             * It's used to close the dropdown in the case of openOnFocus.
             */
            $scope.onBlur = function () {
                // A timeout is needed to close the dropdown a little bit later, after other events.
                $timeout(function () {
                    $scope.openDropdown = false;
                }, 200);
            };

            /**
             * Check if the item needs an icon.
             * @param {string} [key]
             * @returns {string}
             */
            $scope.getItemIcon = function (key) {
                return $scope.oneIcon;
            };

            $scope.getItemImage = function (key) {
                if ($scope.items && $scope.items[key] !== undefined ) {
                    return $scope.items[key].toLowerCase().replace(/[^a-z0-9]+/ig, '-');
                } else {
                    return false;
                }
            };

            $scope.filterIconName = function ( name ) {
                if ( name && name === 'No material' && name !== undefined ) {
                    return false
                }
                else {
                    return name.toLowerCase().replace(/[^a-z0-9]+/ig, '-');

                }
            };
        }]
    };
}]);
;
/**
 * A download button component means the operation of downloading a specific file type and format.
 * @property {string} type "url", "text" or "vcard"
 * @property {string} format "csv", "xls", "xlsx" or "ods"
 */
app.directive('qrButtonDownload', ['api', function (api) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-button-download" ng-class="getButtonClass()" ng-click="downloadAction()">' +
                '<span class="qr-button-download__icon" ng-class="getIconClass()" ng-if="icon"></span>' +
                '{{ label }}' +
            '</div>',
        scope: {
            label: "@",        // A text label that describes the action that will occur.
            icon: "@",         // Button icon name.
            className: '@',    // Custom class for button.
            url: '@'           // URL to download.
        },
        controller: ['$scope', function ($scope) {
            /**
             * Get the CSS class name of the current button
             * @returns {string}
             */
            $scope.getButtonClass = function () {
                return  $scope.className;
            };

            /**
             * Get the CSS class name of the current icon
             * @returns {string}
             */
            $scope.getIconClass = function () {
                return 'icon ' + $scope.icon;
            };

            /**
             * Download the template.
             * @param {string} type
             * @param {string} format
             */
            $scope.downloadAction = function(type, format) {
                // Declare a variable to hold the link element
                var linkTag = document.createElement('a');
                // Set the href property to url obtained from the API
                linkTag.href = $scope.url;
                document.body.appendChild(linkTag);
                linkTag.click();
                document.body.removeChild(linkTag);
            };
        }]
    };
}]);;
/**
 * Reusable directive with dropdown lists.
 */
app.directive('qrButtonDropdown', ['gettextCatalog', function (gettextCatalog) {
    return {
        restrict: 'E',
        template:
            '<div class="dropdown button-dropdown">' +
                '<button class="dropdown-toggle button-dropdown__toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">' +
                    '<span class="icon button-dropdown__icon button-dropdown__icon_left" ng-class="leftIcon" ng-if="leftIcon"></span>' +
                        '{{::buttonLabel}}' +
                    '<span class="icon icon-chevron-down-medium button-dropdown__icon button-dropdown__icon_right"></span>' +
                '</button>' +
                '<ul class="dropdown-menu dropdown-menu-right button-dropdown__menu" aria-labelledby="dropdownMenu1">' +
                    '<li ng-repeat="item in items track by $index" ng-click="click(item)">' +
                        '<a href="#" class="button-dropdown__menu-item" ng-bind="item.label"></a>' +
                    '</li>' +
                '</ul>' +
            '</div>',
        scope: {
            buttonLabel: '@',    // The label for dropdown button.
            leftIcon: '@',
            items: '='
        },
        controller: ['$scope', function ($scope) {

            /**
             * Process item clicks.
             * @param {*} item
             */
            $scope.click = function (item) {
                if ("event" in item) {
                    $scope.$emit(item.event, item);
                } else if ("callback" in item) {
                    item.callback(item);
                }
            };
        }]
    };
}]);
;
app.directive('qrTime', function () {
    return {
        restrict: 'E',
        template:
            '<qr-dropdown items="items" value="value" readonly="readonly" disabled="disabled" placeholder="{{ placeholder }}" editable="editable" value-getter="timeValueGetter(value)" value-setter="timeValueSetter(value)" update-on="blur"></qr-dropdown>',
        scope: {
            value: '=',
            min: '=',           // Optional, default is 00:00
            max: '=',           // Optional, default is 23:59
            step: '=',          // Optional, default is 01:00
            format: '=',        // Optional, default is 24. Values: '24', '12'.
            editable: '=',      // Optional, default is false. The inputs are editable.
            readonly: '=',      // Optional, default is false. The whole widget is readonly.
            disabled: '=',      // Optional, default is false. The whole widget is disabled.
            placeholder: '@'    // Optional. Placeholder for the input.
        },
        controller: ['$scope', function ($scope) {
            $scope.items = {};

            /**
             * Convert a time string in format HH:MM to minutes
             * Also it supports minutes as the parameter. It won't be converted.
             * @param {string|number} time
             * @returns {number|boolean}
             */
            $scope.timeToMinutes = function (time) {
                if (angular.isNumber(time) || angular.isUndefined(time) || time === false) {
                    return time;
                }
                var data = ('' + time).match(/^\s*([01]?\d|2[0-3])(\s*[:.,/\s-]\s*([0-5]?\d))?\s*(am|pm)?\s*$/i);
                if (!data) {
                    return false;
                }
                var hour = parseInt(data[1], 10), minute = parseInt(data[3] || 0, 10), format = data[4];
                if (format && hour >= 13) {
                    return false;
                }
                if (!format || format.toLowerCase() === 'am' || hour === 12) {
                    return hour * 60 + minute;
                }
                return (12 + hour) * 60 + minute;
            };

            /**
             * Convert minutes to the time string to display
             * @param {number|boolean} minutes
             * @param {string} [format]
             * @returns {string|boolean}
             */
            $scope.minutesToTime = function (minutes, format) {
                if (minutes === false || angular.isUndefined(minutes)) {
                    return minutes;
                }
                var hours = Math.floor(minutes / 60);
                minutes = minutes % 60;
                var hourString = (hours >= 10 ? hours : '0' + hours);
                var minuteString = (minutes >= 10 ? minutes : '0' + minutes);
                if (format === '12') {
                    if (hours < 12) {
                        return hourString + ':' + minuteString + ' am';
                    }
                    if (hours > 12) {
                        hours -= 12;
                        return (hours >= 10 ? hours : '0' + hours) + ':' + minuteString + ' pm';
                    }
                    return '12:' + minuteString + ' pm';
                }
                return hourString + ':' + minuteString;
            };

            /**
             * Function to convert time inputs to internal values
             * @param {string} inputValue
             * @return {string|boolean}
             */
            $scope.timeValueSetter = function (inputValue) {
                if (!inputValue) {
                    return inputValue;
                }
                var value = $scope.timeToMinutes(inputValue);
                if (value === false) {
                    return '';
                }
                if ($scope.min && value < $scope.timeToMinutes($scope.min)) {
                    return '';
                } else if ($scope.max && value > $scope.timeToMinutes($scope.max)) {
                    return '';
                }
                return $scope.minutesToTime(value);
            };

            /**
             * Function to convert internal time values to output time to display
             * @param {string} value
             * @return {string}
             */
            $scope.timeValueGetter = function (value) {
                if (!value) {
                    return value;
                }
                return $scope.minutesToTime($scope.timeToMinutes(value), $scope.format);
            };

            /**
             * Generate time items from the dropdown
             * @returns {{}}
             */
            $scope.getItems = function () {
                var minutes, items = {}, max = $scope.timeToMinutes($scope.max || '23:59');
                var step = $scope.timeToMinutes($scope.step || '01:00');

                for (minutes = $scope.timeToMinutes($scope.min || 0); minutes <= max; minutes += step) {
                    items[$scope.minutesToTime(minutes)] = $scope.minutesToTime(minutes, $scope.format);
                }

                return items;
            };

            /**
             * Refresh the items list
             */
            $scope.refreshItems = function () {
                $scope.items = $scope.getItems();
            };

            /**
             * Check the limits of the value
             */
            $scope.checkLimits = function () {
                var value = $scope.timeToMinutes($scope.value);
                if ($scope.min && value < $scope.timeToMinutes($scope.min)) {
                    $scope.value = '';
                } else if ($scope.max && value > $scope.timeToMinutes($scope.max)) {
                    $scope.value = '';
                }
            };

            // Synchronize everything
            $scope.$watch('[min, max, step, format]', function () {
                $scope.refreshItems();
                $scope.checkLimits();
            });
        }]
    };
});
;
app.directive('qrTimeRange', function () {
    return {
        restrict: 'E',
        template:
            '<div class="row">' +
                '<div class="col-xs-6">' +
                    '<qr-time value="from" min="min" max="max" step="step" format="format" readonly="readonly" disabled="disabled" editable="editable"></qr-time>' +
                    '<span>&mdash;</span>' +
                '</div>' +
                '<div class="col-xs-6">' +
                    '<qr-time value="to" min="min ? (from || min) : min" max="max" step="step" format="format" readonly="readonly" disabled="disabled" editable="editable"></qr-time>' +
                '</div>' +
            '</div>',
        scope: {
            from: '=',
            to: '=',
            min: '=',           // Optional, default is 00:00
            max: '=',           // Optional, default is 23:59
            step: '=',          // Optional, default is 01:00
            format: '=',        // Optional, default is 24. Values: '24', '12'.
            editable: '=',      // Optional, default is false. The inputs are editable.
            readonly: '=',      // Optional, default is false. The whole widget is readonly.
            disabled: '='       // Optional, default is false. The whole widget is disabled.
        }
    };
});
;
app.directive('qrTimeRangeList', function () {
    return {
        restrict: 'E',
        template:
            '<div ng-repeat="(key, value) in values">' +
                '<button type="button" class="btn" ng-click="$first ? addOne() : deleteOne(key)" data-ng-disabled="isButtonDisabled($first)">' +
                    '<span class="icon" ng-class="$first ? &apos;icon-plus-1&apos; : &apos;icon-minus-1&apos;"></span>' +
                '</button>' +
                '<qr-time-range from="value.from" to="value.to" min="($first || !min) ? min : values[key-1].to" max="max" step="step" format="format" readonly="readonly" disabled="disabled" editable="editable"></qr-time-range>' +
            '</div>',
        scope: {
            values: '=',
            limit: '=',         // Optional, unlimited by default. The limit of time ranges amount.
            min: '=',           // Optional, default is 00:00
            max: '=',           // Optional, default is 23:59
            step: '=',          // Optional, default is 01:00
            format: '=',        // Optional, default is 24. Values: '24', '12'.
            editable: '=',      // Optional, default is false. The inputs are editable.
            readonly: '=',      // Optional, default is false. The whole widget is readonly.
            disabled: '='       // Optional, default is false. The whole widget is disabled.
        },
        controller: ['$scope', function ($scope) {
            // Normalize values
            $scope.values = $scope.values || [{from: '', to: ''}];

            /**
             * Add one more time range
             */
            $scope.addOne = function () {
                $scope.values.push({from: '', to: ''});
            };

            /**
             * Delete one time range
             * @param key
             */
            $scope.deleteOne = function (key) {
                if ($scope.values.length >= 2) {
                    $scope.values.splice(key, 1);
                }
            };

            /**
             * Check if the add/delete button should be disabled
             * @param {boolean} $first
             * @returns {boolean}
             */
            $scope.isButtonDisabled = function ($first) {
                return ($first && $scope.limit > 0 && $scope.values.length >= $scope.limit) || $scope.disabled || $scope.readonly;
            };
        }]
    };
});
;
/**
 * Universal input to collect information about an action button -- label text and a URL.
 * It supports also a list of predefined labels.
 */
app.directive('qrActionButton', ['$filter', function ($filter) {
    return {
        restrict: 'E',
        template:
            '<div class="row">' +
                '<div class="col-sm-12 col-md-6" ng-show="getVisible()">' +
                    '<label ng-show="label">{{ label }}</label>' +
                    '<qr-dropdown items="items" value="value.label" name="{{ name }}" readonly="readonly" disabled="disabled" editable="editable" max-length="maxLabelLength" placeholder="{{ placeholder }}" open-on-focus="true" custom-label="{{ customLabel }}"></qr-dropdown>' +
                '</div>' +
                '<div class="col-sm-12 col-md-6" ng-show="getVisible()">' +
                    '<label ng-show="urlLabel">{{ urlLabel }}</label>' +
                    '<input type="text" class="canHaveError" ng-readonly="readonly" ng-disabled="disabled" ng-maxlength="maxUrlLength" ng-model="value.url" placeholder="{{ urlPlaceholder }}" name="{{ urlName }}" ng-required="getVisible() && removable" ng-blur="normalizeUrl()">' +
                    '<qr-input-error name="{{ urlName }}" messages="errorMessages"></qr-input-error>' +
                    '<button type="button" class="btn btn-link pull-right" ng-click="removeButton()" ng-show="removable">{{ removeLabel }}</button>' +
                '</div>' +
                '<div class="col-xs-12" ng-hide="getVisible()">' +
                    '<button type="button" class="btn btn-link" ng-click="addButton()">{{ addLabel }}</button>' +
                '</div>' +
            '</div>',
        scope: {
            items: '=',             // The list of predefined labels.
            value: '=',             // Current selected value.
            defaultValue: '=',      // Optional. Default value.
            name: '@',              // The name of the dropdown input.
            urlName: '@',           // The name of the URL input.
            editable: '=',          // Optional, default is false. The inputs are editable.
            readonly: '=',          // Optional, default is false. The whole widget is readonly.
            disabled: '=',          // Optional, default is false. The whole widget is disabled.
            maxLabelLength: '=',    // Optional. The max length for the label input.
            maxUrlLength: '=',      // Optional. The max length for the URL input.
            label: '@',             // Optional. Label for the dropdown.
            urlLabel: '@',          // Optional. Label for the URL input.
            placeholder: '@',       // Optional. Placeholder text of the dropdown.
            urlPlaceholder: '@',    // Optional. Placeholder text of the URL input.
            removable: '@',         // Optional. The button can be removable. It adds additional controls Add/Remove.
            visible: '=',           // Optional. Only for removable buttons. Means that the button is visible now.
            addLabel: '@',          // Optional. The label for the "Add" button.
            removeLabel: '@',       // Optional. The label for the "Remove" button.
            customLabel: '@',       // The label for Custom link.
            errorMessages: '='      // Optional. Error messages for the URL input.
        },
        link: function (scope, element) {
            // Auto-focus after the dropdown is open
            element.on('shown.bs.dropdown', function () {
                element.find('input:first').focus().select();
            });
        },
        controller: ['$scope', function ($scope) {
            $scope.initButton = function () {
                if ($scope.value && $scope.value.isOpen && $scope.value.targetUrl) {
                    $scope.value.url = $scope.value.targetUrl;
                    $scope.value.label = $scope.value.type;
                    $scope.visible = true;
                }
            };
            // Normalize the value
            if ($scope.removable) {
                $scope.value = $scope.value || {label: '', url: ''};
            } else {
                $scope.value = $scope.value || $scope.defaultValue || {label: '', url: ''};
            }

            $scope.addLabel = $scope.addLabel || $filter('translate')('Add button1');
            $scope.removeLabel = $scope.removeLabel || $filter('translate')('Remove button1');

            // If visible is undefined then it will be set depending on the value
            if (angular.isUndefined($scope.visible)) {
                $scope.visible = $scope.value.label || $scope.value.url;
            }

            /**
             * True if the button is visible
             * @returns {boolean}
             */
            $scope.getVisible = function () {
                return $scope.visible || !$scope.removable;
            };

            /**
             * Add the button controls
             */
            $scope.addButton = function () {
                if ($scope.removable) {
                    $scope.visible = true;
                    if ($scope.defaultValue) {
                        $scope.value = $scope.defaultValue;
                    }
                }
            };

            /**
             * Remove the button controls
             */
            $scope.removeButton = function () {
                if ($scope.removable) {
                    $scope.visible = false;
                    $scope.value = {label: '', url: ''};
                }
            };

            /**
             * Add http:// to the URL, if needed
             */
            $scope.normalizeUrl = function () {
                if ($scope.value && $scope.value.url && $scope.value.url.length > 0 && !/^https?:\/\//i.test($scope.value.url)) {
                    $scope.value.url = 'http://' + $scope.value.url;
                }
            };
        }]
    };
}]);
;
app.directive('qrMenuSelect', function () {
    return {
        restrict: 'E',
        template:
            '<div class="btn-group">' +
                '<button type="button" class="btn btn-link" data-ng-disabled="disabled" data-toggle="dropdown">' +
                    '{{ getLabel() }} <span class="icon icon-down-open-mini"></span>' +
                '</button>' +
                '<ul class="dropdown-menu">' +
                    '<li ng-repeat="(key, item) in items">' +
                        '<a href="#" ng-click="choose(key, $event)">' +
                            '{{ item }} <span class="icon icon-up-open-mini" ng-show="$first"></span>' +
                        '</a>' +
                    '</li>' +
                '</ul>' +
            '</div>',
        scope: {
            items: '=',         // The list of available values.
            value: '=',         // Current selected value.
            defaultValue: '@',  // Optional. Default value.
            disabled: '='       // Optional, default is false. The whole widget is disabled.
        },
        controller: ['$scope', function ($scope) {
            // Set default value based on items
            if (angular.isArray($scope.items)) {
                $scope.value = $scope.value || $scope.defaultValue || $scope.items[0];
            } else {
                $scope.value = $scope.value || $scope.defaultValue || Object.keys($scope.items)[0];
            }

            /**
             * Choose an item from the list of items
             * @param value
             * @param $event
             */
            $scope.choose = function (value, $event) {
                $event.preventDefault();
                if (!$scope.disabled) {
                    // If items is an array, then don't use keys, use values instead
                    if (angular.isArray($scope.items)) {
                        $scope.value = $scope.items[value];
                    } else {
                        $scope.value = value;
                    }
                }
            };

            /**
             * Get the label for the current value
             * @returns {string}
             */
            $scope.getLabel = function () {
                if (angular.isArray($scope.items)) {
                    return $scope.value;
                }
                return $scope.items[$scope.value];
            };
        }]
    };
});
;
/**
 * Directive inapp help ad.
 * This directive will pop up when the users types in one of the social media names
 *
 * */
app.directive('inAppHelp', ['$filter', '$timeout', '$window', function ($filter, $timeout, $window) {
    return {
        restrict: 'E',
        templateUrl: 'inAppHelp.html',
        scope: {
            adModel: '=model',              // model to watch
            adIcon: '@icon',                // name of the icon
            adText1: '@text1',              // text1 for the inapp help ad
            adText2: '@text2',              // text2 for the inapp help ad
            adButtonText: '@buttonText',    // text for the first button
            adButtonLink: '@buttonLink',    // link for the first button
            adVideoText: '@videoText',      // text for the second button
            adVideoLink: '@videoLink',      // link fot the second button
            adFilter: '@filter'             // filter for the model (example: isSocialMedia)
        },
        link: function (scope, element, attr) {

            /**
             * Insert wistia video script when button is clicked.
             * Add wistia async class before the script.
             * */
            scope.insertVideoScript = function () {
                $('#v12-video-' + scope.adVideoLink + ' .wistia_embed, #v3-video-' + scope.adVideoLink + ' .wistia_embed')
                    .addClass('wistia_async_' + scope.adVideoLink);
                var head = document.getElementsByTagName('head')[0];

                var script = document.createElement('script');
                script.type = 'text/javascript';
                script.src = scope.getWistiaLink();
                head.appendChild(script);
            };

            /**
             * Remove js file from the scripts
             *
             * @param filename - name of the file that you want to delete
             * @param filetype - type of file js or css
             * */
            function removejscssfile(filename, filetype) {
                var targetelement = (filetype == "js") ? "script" : (filetype == "css") ? "link" : "none"; //determine element type to create nodelist from
                var targetattr = (filetype == "js") ? "src" : (filetype == "css") ? "href" : "none"; //determine corresponding attribute to test for
                var allsuspects = document.getElementsByTagName(targetelement);
                for (var i = allsuspects.length; i >= 0; i--) { //search backwards within nodelist for matching elements to remove
                    if (allsuspects[i] && allsuspects[i].getAttribute(targetattr) != null && allsuspects[i].getAttribute(targetattr).indexOf(filename) != -1)
                        allsuspects[i].parentNode.removeChild(allsuspects[i]); //remove element by calling parentNode.removeChild()
                }
            }

            /**
             * Return the codetype that is promoted on the advertising
             * @returns {string}
             */
            function getAdvertisingCodeType() {
                return scope.adButtonLink;
            }

            /**
             * Get advertising type based on the class inapp-help
             * */
            function getAdvertisingType() {
                var classType = $("div[class*='inapp-help']"),
                    advertisingType = "inapp";

                if (typeof classType !== "undefined") {
                    switch (classType.attr('class').replace(/[^0-9]/gm, "")) {
                        case "1":
                            advertisingType = 'inapp';
                            break;
                        case "2":
                            advertisingType = 'header';
                            break;
                        case "3:":
                            advertisingType = 'tooltip';
                            break;
                    }
                }

                return advertisingType;
            }

            scope.showHelp = false;
            scope.dontShowHelp = false;

            /**
             * Watch video function
             * Google tracking
             * */
            scope.watchVideo = function () {
                //_gaq.push(['_trackEvent', 'InAppAd', 'Show Video - ' + getAdvertisingType() + ' ' + getAdvertisingCodeType()]);
            };

            /**
             * Change solution to the new one
             * Google tracking
             * @param code - type of new code
             * */
            scope.changeCodeTo = function (code) {
                //_gaq.push(['_trackEvent', 'InAppAd', 'Try Solution - ' + getAdvertisingType() + ' ' + getAdvertisingCodeType()]);

                $(".editMode").addClass("switchMode");
                $(".addMode").addClass("switchMode");

                //window.qr.utils.events.trigger("generatorRemoveValidation");
                //window.qr.utils.events.trigger("changeCodeType", code); // this causes a bug
                //window.qr.utils.events.trigger("setCodeTypeAndTemplate", code);

                removejscssfile("E-v1.js", "js");

                // $('a[data-type="' + code + '"]').click();
                // window.qr.utils.events.trigger("generatorFormChanged");
                // For the last year HTML got some changes, now there's different elements with the same CSS classes, so we have to use longer CSS selectors.
                $("button.btn-generator-prev:first").click();
                setTimeout(function () {
                    $('a[data-type="' + code + '"]:first').click();
                    setTimeout(function () {
                        $("button.btn-generator-next:first").click();
                    }, 100);
                }, 100);
            };

            /**
             * Close inAppHelp directive and not show it only after refresh
             * */
            scope.closeInAppHelp = function () {
                scope.dontShowHelp = true;
                scope.showHelp = false;
                console.log("close in-app-help");
            };


            /**
             * Return video link based on the adVideoLink variable
             * */
            scope.getWistiaLink = function () {
                return "https://fast.wistia.com/embed/medias/" + scope.adVideoLink + ".jsonp";
            };

            /**
             * Watch model for changes and show the directive
             * Google tracking
             * */
            var timeoutPromise;
            var delayInMs = 300;
            scope.$watch('adModel', function (p1, p2) {
                if ($('.editMode').length == 0) {
                    if (p1 && (p2 || p2 == "") && p1 != p2) {
                        $timeout.cancel(timeoutPromise);  // does nothing, if timeout already done
                        timeoutPromise = $timeout(function () {
                            scope.showHelp = !!$filter(scope.adFilter)(p1);
                            if (scope.showHelp) {
                                //_gaq.push(['_trackEvent', 'InAppAd', 'Recommendation - ' + getAdvertisingType() + ' ' + getAdvertisingCodeType()]);
                                qr.utils.trackUser.event("inapp_advertising");
                                scope.insertVideoScript();
                            }
                        }, delayInMs);
                    } else
                        scope.showHelp = false;
                }
            }, true);
        }
    };
}]);
;
app.directive('qrEmailInput', function () {
    return {
        restrict: 'E',
        template:
            '<input type="email" class="canHaveError" ng-readonly="readonly" ng-disabled="disabled" ng-maxlength="maxLength" ng-model="value" placeholder="{{ placeholder }}" name="{{ name }}" ng-required="required">' +
            '<qr-input-error name="{{ name }}" messages="messages"></qr-input-error>',
        scope: {
            value: '=',             // Current value.
            name: '@',              // The name of the input.
            readonly: '=',          // Optional, default is false.
            disabled: '=',          // Optional, default is false.
            required: '=',          // Optional, default is false.
            maxLength: '=',         // Optional. The max length for the input.
            placeholder: '@',       // Optional. Placeholder text.
            messages: '='           // Optional. Error messages for the input.
        }
    };
});
;
app.directive('qrPopup', function () {
    return {
        restrict: 'E',
        transclude: true,
        template:
            '<div class="qr-popup {{popupMenuClass}}" ng-class="getPopupClasses()" ng-style="{marginTop: topOffset, minWidth: minWidth, marginLeft: leftOffset, zIndex: getPopupZIndex()}" data-test="{{testEvent}}">' +
                '<ng-transclude></ng-transclude>' +
            '</div>' +
            '<div class="qr-popup__layer" ng-click="onLayerClick($event)" ng-class="getLayerClasses()" ng-style="{zIndex: getLayerZIndex()}"></div>',
        scope: {
            open: '=',          // Is popup open? Default: false.
            right: '@',         // true if it should be aligned to the right
            topOffset: '@',     // The top offset of the popup. It can be used to adjust the vertical position.
            leftOffset: '@',    // The left offset of the popup. Mainly used for submenus.
            visibleLayer: '@',  // true if the background layer should be visible (dark transparent)
            noLayer: '@',       // true if the layer is not needed.
            autoClose: '@',     // Optional. "false" if the popup can't close itself.
            mobileMode: '@',    // Set this to "true" for enabling the mobile mode in which the menu is displayed at the top like a modal (for mobiles only).
            modalMode: '@',     // Optional. "true" if the popup should behave as a modal dialog window.
            minWidth: '@',      // Optional. MinWidth CSS for the popup.
            noPadding: '@',     // Optional flag that removes internal padding.
            popupMenuClass: '@',// Optional custom class name
            testEvent: '@',     // Optional data-attr for testing purpose
        },
        require: '?^^qrPopup',
        link: function(scope, element, attrs, ctrl) {
            // Save link to the parent popup to use it later.
            scope.parentPopup = ctrl;
            // Move the layer to body.
            // This doesn't work - the layer doesn't delete itself after the directive is deleted :(
            // element.find('.qr-popup__layer').appendTo('body');
        },
        controller: ['$rootScope', '$scope', '$document', function ($rootScope, $scope, $document) {
            /**
             * Returns 0 if it's the only open popup on the screen,
             * otherwise returns 1, 2, etc, depending on number of opened popups.
             * @returns {number}
             */
            function getCurrentPopupLevel() {
                return $scope.parentPopup ? $scope.parentPopup.getCurrentPopupLevel() + 1 : 0;
            }

            // This is needed to export public API for other directives.
            this.getCurrentPopupLevel = getCurrentPopupLevel;

            /**
             * Returns z-index of the layer.
             * @returns {number}
             */
            $scope.getLayerZIndex = function () {
                return 19999 + 2 * getCurrentPopupLevel();
            };

            /**
             * Returns z-index of the popup window.
             * @returns {number}
             */
            $scope.getPopupZIndex = function () {
                return $scope.getLayerZIndex() + 1;
            };

            /**
             * Get popup CSS classes
             * @return {{}}
             */
            $scope.getPopupClasses = function () {
                return {
                    "qr-popup--open": $scope.open,
                    "qr-popup--right": $scope.right === "true",
                    "qr-popup--mobile": $scope.mobileMode === "true",
                    "qr-popup--modal": $scope.modalMode === "true",
                    "qr-popup--no-padding": $scope.noPadding === "true"
                };
            };

            /**
             * Get layer CSS classes
             * @return {{}}
             */
            $scope.getLayerClasses = function () {
                if ($scope.noLayer === "true") {
                    return {};
                }
                return {
                    "qr-popup__layer--open": $scope.open,
                    "qr-popup__layer--visible": $scope.visibleLayer === "true",
                    "qr-popup__layer--mobile": $scope.mobileMode === "true"
                };
            };

            /**
             * Will be called on layer clicks.
             */
            $scope.onLayerClick = function (event) {
                if ($scope.autoClose !== "false") {
                    $scope.open = false;
                    $rootScope.$broadcast("openModal:update");
                    event.stopPropagation();
                }
            };

            // Allow ESC for closing the popup
            $document.on('keyup', function (event) {
                if ($scope.open && $scope.autoClose !== "false") {
                    if ((event.charCode || event.keyCode) === 27) {
                        $scope.open = false;
                        $rootScope.$broadcast("openModal:update");
                        $scope.$apply();
                    }
                }
            });
        }]
    };
});
;
/**
 * Custom popup feedback component.
 * Provide valuable, actionable feedback to your users with form validation popup feedback.
 */
app.directive('qrPopupFeedback', ['$window', '$timeout', function ($window, $timeout) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-popup-feedback" ng-class="getPopupFeedbackClasses()" data-popup="feedback"> {{message}} </div>',
        scope: {
            open: '=',          // Is feedback open? Default: false.
            type: '@',          // Type of popup.
            position: '@',      // This is the position that may be used to set the position of the popup feedback.
            mobile: '@',        // Set this to "true" for enabling the mobile mode.
            minWidth: '@',      // Optional. MinWidth CSS for the popup feedback.
            classes: '@',       // Optional custom class name.
            message: '@'        // The content of the popup feedback.
        },
        controller: ['$scope', '$element', '$timeout', function ($scope, $element) {
            /**
             * Global controller $scope variables
             */
            $scope.popupPosition = $scope.position;

            /**
             * Get popup feedback CSS classes
             * @return {{}}
             */
            $scope.getPopupFeedbackClasses = function () {
                return {
                    "qr-popup-feedback--open": $scope.open,
                    // Position
                    "qr-popup-feedback--top": $scope.position === "top",
                    "qr-popup-feedback--bottom": $scope.position === "bottom",
                    "qr-popup-feedback--left": $scope.position === "left",
                    "qr-popup-feedback--right": $scope.position === "right",
                    // Type
                    "qr-popup-feedback--primary": $scope.type === "primary",
                    "qr-popup-feedback--secondary": $scope.type === "secondary",
                    "qr-popup-feedback--success": $scope.type === "success",
                    "qr-popup-feedback--danger": $scope.type === "danger",
                    "qr-popup-feedback--warning": $scope.type === "warning",
                    "qr-popup-feedback--info": $scope.type === "info",
                    "qr-popup-feedback--light": $scope.type === "light",
                    "qr-popup-feedback--dark": $scope.type === "dark",
                    // Mobile mode
                    "qr-popup-feedback--mobile": $scope.mobile === "true",
                };
            };

            /**
             * Get the position of an element relative to the document
             * @param element
             * @returns {{top: number, left: number, bottom: number, width: number, right: number, height: number}}
             */
            $scope.elementOffset = function (element) {
                var rect = element.getBoundingClientRect();
                return {
                    width: rect.width,
                    height: rect.height,
                    top: rect.top,
                    right: rect.right,
                    bottom: rect.bottom,
                    left: rect.left
                };
            };

            $scope.checkSpace = function () {
                $scope.feedbackPosition = $scope.elementOffset($element[0].firstChild);
                $scope.feedbackParentPosition = $scope.elementOffset($element[0].parentNode);

                if ($scope.open && ($scope.feedbackParentPosition.right + $scope.feedbackPosition.width + 40) > window.innerWidth && $scope.popupPosition === 'right') {
                    $scope.position = 'bottom';
                } else if ($scope.open && ($scope.feedbackParentPosition.right + $scope.feedbackPosition.width + 40) < window.innerWidth && $scope.popupPosition === 'right') {
                    $scope.position = 'right';
                }
            };

            /**
             *
             */
            angular.element($window).bind('resize', function () {
                if ($scope.open) {
                    $scope.checkSpace();
                }
            });

            /**
             * $watch
             * Watch input field values
             */
            $scope.$watch('open', function () {
                if ($scope.open && $scope.popupPosition === "right") {
                    $timeout(function () {
                        $scope.checkSpace();
                    });
                }
            });
        }]
    };
}]);
;
// Universal popup menu with sub-menus support.
app.directive('qrPopupMenu', ['$compile', '$window', function ($compile, $window) {
    return {
        restrict: 'E',
        scope: {
            open: '=',          // Is menu open? Default: false.
            alwaysOpen: '@',    // true if the menu should not close itself.
            items: '=',         // Items array in format [{label: "Item label", icon: "icon-class-name", event: "event-to-emit"}]
            right: '@',         // true if it should be aligned to the right
            topOffset: '@',     // The top offset of the menu. It can be used to adjust the vertical position.
            leftOffset: '@',    // The left offset of the popup. Mainly used for submenus.
            visibleLayer: '@',  // true if the background layer should be visible (dark transparent)
            noLayer: '@',       // true if the layer is not needed.
            mobileMode: '@',    // Set this to "true" for enabling the mobile mode in which the menu is displayed at the top like a modal (for mobiles only).
            minWidth: '@',      // Optional. MinWidth CSS for the popup.
            title: '@',         // A title for popup menu in mobile mode.
            subTitle: '@',      // A title for submenus in mobile mode.
            onClose: '&',       // On close handler.
            popupMenuClass: '@' // A custom class name for the pop-up menu
        },
        link: function (scope, element) { // Here the link function is used to workaround angular limitations of recursive directives.
            var template =
                '<qr-popup open="open" right="{{ right }}" popup-menu-class="{{ popupMenuClass }}" top-offset="{{ topOffset }}" visible-layer="{{ visibleLayer }}" min-width="{{ minWidth }}" left-offset="{{ leftOffset }}" no-layer="{{ noLayer }}" mobile-mode="{{ mobileMode }}">' +
                    '<div class="qr-popup-menu" ng-class="{&apos;qr-popup-menu--mobile&apos;: mobileMode}">' +
                        '<div class="qr-popup-menu__header">' +
                            '<span class="qr-popup-menu__close" ng-click="closeThis(); onClose();">&times;</span>' +
                            '<span class="qr-popup-menu__back icon icon-chevron-left-medium" ng-click="closeThis(); onClose();" ng-show="alwaysOpen === &apos;true&apos;"></span>' +
                            '{{ title }}' +
                        '</div>' +
                        '<div ng-repeat="item in items | filter:isVisible track by $index">' +
                            '<button type="button" class="qr-popup-menu__item" ng-click="click(item, $index)" ng-show="item.label" ng-mouseenter="openSubmenu(item, $index)" ng-class="getItemClass(item)" data-test="{{item.testEvent}}">' +
                                '<i class="qr-popup-menu__icon" ng-class="getIconClass(item)" ng-show="getIconClass(item)"></i>' +
                                '<i class="qr-popup-menu__arrow" ng-class="getArrowClass(item)" ng-show="getArrowClass(item)"></i>' +
                                '{{ item.label }}' +
                            '</button>' +
                            '<div class="qr-popup-menu__line" ng-if="!item.label"></div>' +
                            '<qr-popup-menu ng-if="item.items && item.items.length > 0" items="item.items" open="openItem == $index" min-width="{{ minWidth }}" left-offset="{{ minWidth }}" top-offset="-35px" no-layer="true" always-open="true" mobile-mode="{{ mobileMode }}" on-close="closeSubmenu()" title="{{ subTitle }}"></qr-popup-menu>' +
                        '</div>' +
                    '</div>' +
                '</qr-popup>';

            var compiledTemplate = $compile(template)(scope);
            element.replaceWith(compiledTemplate);

            // The moment we close the popup menu, we need to delete the current element and create a new one.
            // This line will solve the problem of creating and duplicating a pop-up menu every time you open it.
            scope.$on('$destroy', function(){
                compiledTemplate.remove();
            });
        },
        controller: ['$scope', function ($scope) {
            /**
             * Index of currently open submenu, if any
             * @type {number}
             */
            $scope.openItem = -1;

            // When the menu is opened or closed, we should close the submenu as well.
            $scope.$watch('open', function () {
                $scope.closeSubmenu();
            });

            /**
             * Close this menu.
             */
            $scope.closeThis = function () {
                if ($scope.alwaysOpen !== "true") {
                    $scope.open = false;
                }
            };

            /**
             * Close current submenu, if any.
             */
            $scope.closeSubmenu = function () {
                $scope.openItem = -1;
            };

            /**
             * Open the submenu of the item, if needed
             * @param item
             * @param {number} itemIndex
             */
            $scope.openSubmenu = function (item, itemIndex) {
                if ("items" in item && item.items.length > 0) {
                    if ($window.innerWidth > 768) { // Don't open submenus on hover for mobiles (only on click).
                        $scope.openItem = itemIndex;
                    }
                }
            };

            /**
             * Check if there's any icons in the items.
             * @returns {boolean}
             */
            $scope.hasIcons = function () {
                var hasIcons = false;
                angular.forEach($scope.items, function (item) {
                    if ("icon" in item && item.icon) {
                        hasIcons = true;
                    }
                });
                return hasIcons;
            };

            /**
             * Get the CSS class of current icon
             * @param item
             * @returns {string}
             */
            $scope.getIconClass = function (item) {
                return 'icon icon-' + item.icon;
            };

            /**
             * Get the CSS class of the right icon
             * @param item
             * @returns {string}
             */
            $scope.getArrowClass = function (item) {
                if ("items" in item && item.items.length > 0) {
                    return 'icon icon-chevron-right-medium';
                }
                if ("arrow" in item) {
                    return item.arrow;
                }
                return '';
            };

            /**
             * This will be executed on clicks on items
             * @param item
             * @param {number} itemIndex
             */
            $scope.click = function (item, itemIndex) {
                if ("items" in item && item.items.length > 0) {
                    $scope.openItem = itemIndex;
                } else if ("event" in item) {
                    $scope.closeThis();
                    $scope.$emit(item.event, item);
                } else if ("callback" in item) {
                    $scope.closeThis();
                    item.callback(item);
                }
            };

            /**
             * Get item CSS classes.
             * @param {*} item
             * @returns {*}
             */
            $scope.getItemClass = function (item) {
                var itemClass = {
                    // To create our own color for menu items, we add our own class for each element.
                    'qr-popup-menu__item--has-icons': $scope.hasIcons(),
                    'qr-popup-menu__item--selected': 'selected' in item && item.selected(item)
                };

                itemClass[item.class] = $scope.hasIcons();

                return itemClass;
            };

            /**
             * Check if the item is visible or not.
             * @param item
             * @returns {boolean}
             */
            $scope.isVisible = function (item) {
                if (!("visible" in item)) {
                    return true;
                }
                if (typeof item.visible === "function") {
                    return item.visible(item);
                }
                return item.visible;
            };
        }]
    };
}]);
;
/**
 * Basic modal directive based on qrPopup.
 */
app.directive("qrModal", [
  "gettextCatalog",
  '$sce',
  'markup',
    function (gettextCatalog, $sce, markup) {
      "use strict";
  return {
    restrict: "E",
    transclude: true,
    template:
      '<qr-popup open="open" popup-menu-class="{{popupMenuClass}}" modal-mode="true" auto-close="{{ autoClose }}" ' +
      'visible-layer="true" no-padding="{{ getNoPadding() }}" min-width="{{ minWidth }}" left-offset="{{ leftOffset }}" ' +
      'top-offset="{{ topOffset }}" test-event="{{testEvent}}">' +
      '<i class="qr-popup__close-icon icon-thin-close" ng-show="closeIcon" ng-click="closeWindow()" data-test="modalClose"></i>' +
      '<h6 class="qr-modal__title" ng-show="title" data-test="qr-modal-title">' +
      "{{ title }}" +
      '<span class="qr-modal__title-label" ng-show="titleLabel" ng-bind="titleLabel"></span>' +
      "</h6>" +
      '<p class="qr-modal__description" ng-show="description" ng-bind="description"></p>' +
      "<ng-transclude></ng-transclude>" +
      '<div class="qr-modal__buttons" ng-class="getButtonsGroupClass()" ng-show="buttons.length > 0">' +
      '<button type="button" ng-repeat="button in buttons" ng-class="getButtonClass(button)" ng-click="click(button)"  data-ng-disabled="button.disabled || false"' +
      ' data-test="{{button.testEvent}}">' +
        '{{ ::button.label }}' +
        '<i ng-show="button.icon" class="icon icon-chevron-right-medium qr-modal__button-icon"></i>' +
        '</button>' +
      "</div>" +
      '<div class="qr-modal__bottom-information-wrapper" ng-show="bottomInformation">'+
        '<p class="qr-modal__bottom-information-text" ng-bind-html="::getBottomInfoTitle"></p>'+
      '</div>'+
      "</qr-popup>",
    scope: {
      open: "=", // Is popup open? Default: false.
      autoClose: "@", // Optional. "false" if the popup can't close itself.
      noPadding: "@", // Optional flag that removes internal padding.
      title: "@", // Optional modal title.
      titleLabel: "@", // Optional modal title label.
      description: "@", // Optional modal description.
      buttons: "=", // Optional buttons for the footer in format {label: ''}.
      minWidth: "@", // Optional. MinWidth CSS for the popup.
      leftOffset: "@", // The left offset of the popup. Mainly used for submenus.
      topOffset: "@", // The top offset of the popup.
      closeIcon: "@", // Optional. "true" if we want to show close icon
      buttonBlueLook: "@", // Optional class to toggle blue button look
      popupMenuClass: "@", // Optional popup menu class
      testEvent: "@", // Optional data-attr for testing purpose
      bottomInformation: "=", // Optional Information on the bottom of the modal
    },
    require: "?^^qrModal",
    link: function (scope, element, attrs, parentModal) {
      /**
       * Locks scrolling on the body.
       * @param {boolean} lock
       */
      scope.lockBodyScroll = function (lock) {
        var scrollbarXWidth = window.innerWidth - document.body.clientWidth;

        if (!parentModal) {
          if (lock) {
            document.body.style.paddingRight = scrollbarXWidth + "px";
            document.body.classList.add("qr-modal-scroll-lock");
            document.querySelector("[data-navbar]").style.paddingRight =
              24 + scrollbarXWidth + "px";
          } else {
            document.body.style.paddingRight = "0";
            document.querySelector("[data-navbar]").style.paddingRight =
              24 + "px";

            document.body.classList.remove("qr-modal-scroll-lock");
          }
        }
      };
    },
    controller: ['$rootScope', '$scope', function ($rootScope, $scope) {
        /**
         * Get buttons classes.
         * @param {*} button
         * @returns {*}
         */
        $scope.getButtonClass = function (button) {
          return {
            "qr-modal__button": true,
            "qr-modal__button--link":
              "type" in button && button.type === "link",
            "qr-modal__button--danger":
              "type" in button && button.type === "danger",
            "qr-modal__button--link qr-modal__button--link-action":
              "type" in button && button.type === "link-action",
            "qr-modal__button--blue-look": $scope.buttonBlueLook === "true",
          };
        };

        /**
         * Get buttons group classes.
         * @param {*} button
         * @returns {*}
         */
        $scope.getButtonsGroupClass = function (button) {
          return {
            "qr-modal__buttons--blue-look": $scope.buttonBlueLook === "true",
          };
        };

        /**
         * Process button clicks.
         * @param {*} button
         */
        $scope.click = function (button) {
          if ("event" in button) {
            $scope.$emit(button.event, button);
          } else if ("callback" in button) {
            button.callback(button);
          }
        };

        /**
         * Get no-padding value for the popup.
         * @returns {string}
         */
        $scope.getNoPadding = function () {
          if ($scope.title) {
            return "true";
          }
          if ($scope.buttons && $scope.buttons.length > 0) {
            return "true";
          }
          return $scope.noPadding;
        };

        /**
         * Closes this modal.
         */
        $scope.closeWindow = function () {
          $rootScope.$broadcast("openModal:update");
          $scope.open = false;
        };

        // Lock the body scrolling when the modal is open.
        $scope.$watch("open", function () {
          $scope.lockBodyScroll($scope.open);
        });

        // Make sure we perform the necessary cleanups when the watchers get removed.
        $scope.$on("$destroy", function() {
          $scope.lockBodyScroll(false);
        });

        $scope.getBottomInfoTitle =
            $sce.trustAsHtml(
                markup.convertToString(
                    gettextCatalog.getString(
                        "Need more information? Please visit our [link={{url}}]Help Center[/link].",
                        {url: "https://support.qr-code-generator.com/hc/en-us/categories/7664991833229-14-Day-Free-Trial"}
                    ),
                    "trial-expires__link"
                ));
      },
    ],
  };
}
]);
;
app.directive('qrIconMenu', function () {
    return {
        restrict: 'E',
        template:
            '<qr-popup open="open" right="{{ right }}" top-offset="{{ topOffset }}" visible-layer="{{ visibleLayer }}">' +
                '<div class="qr-icon-menu">' +
                    '<div class="qr-icon-menu__item" ng-repeat="item in items track by $index" ng-click="click(item)">' +
                        '<i class="qr-icon-menu__icon" ng-class="getIconClass(item)"></i>' +
                    '</div>' +
                '</div>' +
            '</qr-popup>',
        scope: {
            value: '=',         // Currently selected icon
            open: '=',          // Is menu open? Default: false.
            items: '=',         // Array of available icons, or objects in format {icon: 'icon-css-class', value: 'value to return'}.
            right: '@',         // true if it should be aligned to the right
            topOffset: '@',     // The top offset of the menu. It can be used to adjust the vertical position.
            visibleLayer: '@',  // true if the background layer should be visible (dark transparent)
            useRawIconName: '@' // Optional. Set to "true" if the value should be the real CSS class name, otherwise it will be icon name (.icon-ThisPartOfIcon).
        },
        controller: ['$scope', function ($scope) {
            /**
             * Get the CSS class of current icon
             * @param item
             * @returns {string}
             */
            $scope.getIconClass = function (item) {
                var itemClass, itemValue;
                if (typeof item === 'object') {
                    itemClass = item.icon;
                    itemValue = item.value;
                } else {
                    itemClass = item;
                    itemValue = item;
                }
                if ($scope.useRawIconName !== 'true') {
                    itemClass = 'icon icon-' + itemClass;
                }
                return itemClass + ($scope.value === itemValue ? ' qr-icon-menu__icon--active' : '');
            };

            /**
             * This will be executed on clicks on items
             * @param item
             */
            $scope.click = function (item) {
                $scope.open = false;
                $scope.value = typeof item === 'object' ? item.value : item;
            };
        }]
    };
});
;
app.directive('qrSubCategory', function () {
    return {
        restrict: 'E',
        template:
            '<div class="qr-sub-category">' +
                '<input ng-model="value.name" class="qr-sub-category__input" placeholder="{{ getPlaceholder() }}">' +
                '<i class="qr-sub-category__delete icon icon-action-delete" ng-click="delete()"></i>' +
            '</div>',
        scope: {
            value: '=',         // subcategory info in format {id: '555', name: 'Name'}
            messages: '='       // Array of translated messages
        },
        require: '^^qrCategory',
        link: function (scope, element, attributes, qrCategory) {
            scope.qrCategory = qrCategory;
        },
        controller: ['$scope', function ($scope) {
            /**
             * Delete this subcategory
             */
            $scope.delete = function () {
                $scope.qrCategory.deleteSubCategory($scope.value.id);
            };

            /**
             * Get the placeholder for the input.
             * @returns {string}
             */
            $scope.getPlaceholder = function () {
                return $scope.messages.enterCategoryName || $filter('translate')('Enter category name...');
            };
        }]
    };
});
;
app.directive('qrCategory', function () {
    return {
        restrict: 'E',
        template:
            '<div class="qr-category" ng-class="{&apos;qr-category--empty&apos;: !value.sub.length}">' +
                '<div class="qr-category__header">' +
                    '<i class="qr-category__icon" ng-class="getIconClass()" ng-click="isIconsVisible = !isIconsVisible"></i>' +
                    '<span class="qr-category__caret-container" ng-click="isIconsVisible = !isIconsVisible">' +
                        '<span class="qr-category__caret" ng-class="getCaretClass()"></span>' +
                    '</span>' +
                    '<qr-icon-menu value="value.icon" items="icons" open="isIconsVisible" top-offset="3px"></qr-icon-menu>' +
                    '<input ng-model="value.name" class="qr-category__input" placeholder="{{ getPlaceholder() }}">' +
                    '<div class="qr-category__menu">' +
                        '<i class="qr-category__menu-icon icon icon-menu-vertical" ng-click="isActionsVisible = !isActionsVisible"' +
                            ' ng-class="isActionsVisible ? &apos;qr-category__menu-icon--active&apos; : &apos;&apos;"></i>' +
                        '<qr-popup-menu items="actions" open="isActionsVisible" right="true" top-offset="-10px"></qr-popup-menu>' +
                    '</div>' +
                '</div>' +
                '<div class="qr-category__list" ng-show="value.sub">' +
                    '<qr-sub-category ng-repeat="sub in value.sub track by sub.id" value="sub" messages="messages"></qr-sub-category>' +
                '</div>' +
            '</div>',
        scope: {
            value: '=',         // The data in format {id: '123', name: 'Category name', icon: 'icon-name', sub: [{id: '777', name: 'List'}]}
            messages: '=',      // Array of translated messages
            icons: '='          // Array of available icons
        },
        require: '^^qrCategoryList',
        link: function (scope, element, attributes, qrCategoryList) {
            scope.qrCategoryList = qrCategoryList;
        },
        controller: ['$scope', '$filter', function ($scope, $filter) {
            /**
             * True if the action menu on the right is visible
             * @type {boolean}
             */
            $scope.isActionsVisible = false;

            /**
             * True if the icons menu on the left is visible
             * @type {boolean}
             */
            $scope.isIconsVisible = false;

            /**
             * Action menu items
             * @type {{}}
             */
            $scope.actions = [
                {
                    label: $scope.messages.addSubcategory || $filter('translate')('Add sub category'),
                    icon: 'action-create',
                    callback: function () {
                        $scope.value.sub.push({
                            id: $scope.qrCategoryList.generateUniqueID($scope.value.sub),
                            name: ''
                        });
                    }
                },
                {},
                {
                    label: $scope.messages.moveUp || $filter('translate')('Move Up'),
                    icon: 'action-up',
                    callback: function () {
                        $scope.qrCategoryList.moveCategoryUp($scope.value.id);
                    }
                },
                {
                    label: $scope.messages.moveDown || $filter('translate')('Move Down'),
                    icon: 'action-down',
                    callback: function () {
                        $scope.qrCategoryList.moveCategoryDown($scope.value.id);
                    }
                },
                {},
                {
                    label: $scope.messages.deleteCategory || $filter('translate')('Delete'),
                    icon: 'action-delete',
                    callback: function () {
                        $scope.qrCategoryList.deleteCategory($scope.value.id);
                    }
                }
            ];

            /**
             * Delete a subcategory by ID
             * @param {string} id
             */
            this.deleteSubCategory = function (id) {
                for (var index = 0; index < $scope.value.sub.length; ++index) {
                    if ($scope.value.sub[index].id === id) {
                        $scope.value.sub.splice(index, 1);
                        return;
                    }
                }
            };

            /**
             * Get the CSS class of current icon
             * @returns {string}
             */
            $scope.getIconClass = function () {
                return 'icon icon-' + $scope.value.icon + ($scope.isIconsVisible ? ' qr-category__icon--active' : '');
            };

            /**
             * Get the CSS class of the caret icon
             * @returns {string}
             */
            $scope.getCaretClass = function () {
                return $scope.isIconsVisible ? 'qr-category__caret--active' : '';
            };

            /**
             * Get the placeholder for the input.
             * @returns {string}
             */
            $scope.getPlaceholder = function () {
                return $scope.messages.enterCategoryName || $filter('translate')('Enter category name...');
            };
        }]
    };
});
;
app.directive('qrCategoryList', function () {
    return {
        restrict: 'E',
        template:
            '<div class="qr-category-list" ng-show="value && value.length > 0">' +
                '<qr-category ng-repeat="category in value track by category.id" value="category" messages="messages" icons="icons"></qr-category>' +
            '</div>' +
            '<button type="button" class="qr-category-list__add" ng-click="addNewCategory()">{{ messages.addCategory }}</button>' +
            '<span class="qr-category-list__or">{{ messages.or }}</span>' +
            '<span class="qr-category-list__menu">' +
                '<button type="button" class="qr-category-list__toggle" ng-click="isMenuVisible = !isMenuVisible">' +
                    '{{ messages.selectFromList }}' +
                    '<span class="qr-category-list__icon icon icon-down-open-mini" ng-hide="isMenuVisible"></span>' +
                    '<span class="qr-category-list__icon icon icon-up-open-mini" ng-show="isMenuVisible"></span>' +
                '</button>' +
                '<qr-popup-menu items="categoriesMenu" open="isMenuVisible" top-offset="5px" min-width="218px" mobile-mode="true" title="{{ getCategoriesTitle() }}" sub-title="{{ getCategoriesSubTitle() }}"></qr-popup-menu>' +
            '</span>' +
            '<input name="{{ name }}" ng-required="required" style="display: none;" class="canHaveError" ng-model="fakeValue">' +
            '<qr-input-error name="{{ name }}" messages="messages"></qr-input-error>',
        scope: {
            value: '=',         // The data in format [{id: '123', name: 'Name', icon: 'icon', sub: [{id: '222', name: 'Sub1'}, ...]}, ...]
            messages: '=',      // Array of translated messages
            icons: '=',         // Array of available icons
            categories: '=',    // Array of categories and subcategories for "select from list" menu
            required: '=',      // Optional. True if at least one category is required.
            name: '@'           // Name of the input for supporting form errors.
        },
        require: 'qrCategoryList',
        link: function (scope, element, attributes, ctrl) {
            scope.self = ctrl;
        },
        controller: ['$scope', '$filter', function ($scope, $filter) {
            /**
             * This variable controls visibility of the categories menu
             * @type {boolean}
             */
            $scope.isMenuVisible = false;

            $scope.value = $scope.value || [];

            // Available icons
            $scope.icons = $scope.icons || [
                'feedback-dot', 'feedback-more', 'feedback-star',
                'feedback-ambience', 'feedback-availability', 'feedback-parking',
                'feedback-bar', 'feedback-processing-time', 'feedback-catering',
                'feedback-conference-area', 'feedback-program', 'feedback-reception',
                'feedback-food', 'feedback-restrooms', 'feedback-room',
                'feedback-housekeeping', 'feedback-location', 'feedback-seat',
                'feedback-selection', 'feedback-opening-hours', 'feedback-staff',
                'feedback-spa', 'feedback-service', 'feedback-price',
                'feedback-gear'
            ];

            /**
             * Menu actions for the categories menu
             * @type {Array}
             */
            $scope.categoriesMenu = [];

            // Sync the categories menu
            $scope.$watch('categories', function () {
                $scope.categoriesMenu = [];

                angular.forEach($scope.categories, function (subcategories, categoryName) {
                    var menuItem = {
                        label: categoryName,
                        items: [],
                        callback: function () {
                            $scope.self.addCategory(categoryName);
                        }
                    };
                    angular.forEach(subcategories, function (sub) {
                        menuItem.items.push({
                            label: sub.name,
                            arrow: 'icon icon-plus-1',
                            callback: function () {
                                // $scope.self.addSubcategoryToUniqueCategory(categoryName, '', subName);
                                $scope.self.addCategory(sub.name, sub.icon);
                            }
                        });
                    });
                    $scope.categoriesMenu.push(menuItem);
                });
            }, true);

            // This is used for showing input errors.
            // As we have no real input, there's a hidden one.
            $scope.fakeValue = '';

            $scope.$watch('value', function () {
                if ($scope.value && $scope.value.length > 0) {
                    $scope.fakeValue = '1';
                } else {
                    $scope.fakeValue = '';
                }
            }, true);

            /**
             * Find category index by ID
             * @param {string} id
             * @returns {number}
             */
            $scope.findCategoryIndexByID = function (id) {
                for (var index = 0; index < $scope.value.length; ++index) {
                    if ($scope.value[index].id === id) {
                        return index;
                    }
                }
                return -1;
            };

            /**
             * Find category index by name
             * @param {string} name
             * @returns {number}
             */
            $scope.findCategoryIndexByName = function (name) {
                for (var index = 0; index < $scope.value.length; ++index) {
                    if ($scope.value[index].name === name) {
                        return index;
                    }
                }
                return -1;
            };

            /**
             * Button click handler.
             * It adds new empty category to the list.
             */
            $scope.addNewCategory = function () {
                $scope.self.addCategory();
            };

            /**
             * Generate an index which is unique within given list.
             * This implementation generates 20-digit strings: 13 digits of current time plus 7 random digits.
             * @param list
             * @returns {string}
             */
            this.generateUniqueID = function (list) {
                var id;
                do {
                    id = (+new Date()) + '' + Math.floor(Math.random() * 10000000);
                } while (id in list);
                return id;
            };

            /**
             * Add a category to the list
             * @param {string} [name]
             * @param {string} [icon]
             */
            this.addCategory = function (name, icon) {
                var uniqueId = this.generateUniqueID($scope.value);
                $scope.value.push({
                    id: uniqueId,
                    name: name || '',
                    icon: icon || 'feedback-more',
                    sub: []
                });
            };

            /**
             * Add a subcategory into the specified category.
             * @param {string} name category name
             * @param {string} icon category icon
             * @param {string} subName subcategory name
             */
            this.addSubcategoryToUniqueCategory = function (name, icon, subName) {
                var categoryIndex = $scope.findCategoryIndexByName(name);
                if (categoryIndex < 0) {
                    this.addCategory(name, icon);
                    categoryIndex = $scope.findCategoryIndexByName(name);
                }
                $scope.value[categoryIndex].sub.push({
                    id: this.generateUniqueID($scope.value[categoryIndex].sub),
                    name: subName
                });
            };

            /**
             * Delete a category by ID
             * @param {string} id
             */
            this.deleteCategory = function (id) {
                var index = $scope.findCategoryIndexByID(id);
                if (index >= 0) {
                    $scope.value.splice(index, 1);
                }
            };

            /**
             * Move category up
             * @param {string} id
             */
            this.moveCategoryUp = function (id) {
                var index = $scope.findCategoryIndexByID(id);
                if (index >= 1) {
                    var item = $scope.value[index];
                    $scope.value.splice(index, 1);
                    $scope.value.splice(index - 1, 0, item);
                }
            };

            /**
             * Move category down
             * @param {string} id
             */
            this.moveCategoryDown = function (id) {
                var index = $scope.findCategoryIndexByID(id);
                if (index >= 0 && index < $scope.value.length - 1) {
                    var item = $scope.value[index];
                    $scope.value.splice(index, 1);
                    $scope.value.splice(index + 1, 0, item);
                }
            };

            /**
             * Get categories menu title.
             * @returns {string}
             */
            $scope.getCategoriesTitle = function () {
                return $scope.messages.chooseBusinessType || $filter('translate')('Choose business type');
            };

            /**
             * Get subcategories menu title.
             * @returns {string}
             */
            $scope.getCategoriesSubTitle = function () {
                return $scope.messages.chooseSubcategory || $filter('translate')('Choose subcategory');
            };
        }]
    };
});
;
app.directive('qrFrameCard', ['tracking', function (tracking) {
    return {
        restrict: 'AE',
        template:
            '<div class="">' +
                '<div class="frameCard-container">' +
                    '<img ng-src="{{imageLink}}">' +
                    '<div class="col-lg-12 frameCard-content">' +
                        '<div class="frameCard-title mb-15">' +
                        '{{title}}</div>' +
                        '<div class="frameCard-description">' +
                        '{{description}}</div>' +
                        '<div class="frameCard-download">' +
                            '<a class="" ng-click="onDownloadFrame()" href="{{link}}">' +
                            '<i class="icon-download-thin"></i>{{linkText}}</a>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
            '</div>',
        scope: {
            imageLink: '@',
            title: '@',           //
            description: '@',     //
            link: '@',            //
            linkText: '@'         //
        },
        controller: ['$scope', function ($scope) {
            $scope.onDownloadFrame = function () {
                tracking.trackEvent('done_download_frame_set');
            };
        }]
    };
}]);
;
app.directive('qrFileUploader', ['$filter', '$timeout', '$log', 'uploaderService', function ($filter, $timeout, $log, uploaderService) {
    return {
        restrict: 'E',
        require: '?^form',
        template:
        '<div class="qr-file-uploader" ng-style="getStyles()" ng-class="{\'slimDesign\':slimDesign}">' +
            '<div class="drag-table-cell drag-table-cell--min-height">' +
                '<div class="text-container">' +
                    '<span class="qr-file-uploader__prompt" ng-hide="getProgressString()">{{ promptLabel }}</span>' +
                    '<span class="qr-file-uploader__progress" ng-show="getProgressString()">' +
                        '<span class="qr-file-uploader__file-name">{{ getFileNameToDisplay() }}</span>' +
                        '<span class="qr-file-uploader__file-size">{{ getProgressString() }}</span>' +
                    '</span>' +
                '</div>' +
                '<div class="uploader-button" ng-switch="isUploading">' +
                    '<button type="button" class="qr-file-uploader__cancel" ng-switch-when="true" ng-click="cancelUploading()">{{ cancelLabel }}</button>' +
                    '<button type="button" class="qr-file-uploader__upload" ng-class="getButtonClass()" ng-switch-default>' +
                    '<i ng-show="iconButtonUpload" class="{{ iconButtonUpload }}"></i>{{ getUploadLabel() }}</button>' +
                '</div>' +
                '<input type="file" style="display: none;" name="file" accept="{{ accept }}">' +
                '<input name="file1" ng-required="required" style="display: none;" class="canHaveError" ng-model="fakeValue">' +
                '<qr-input-error name="file1" messages="messages" top-offset="25px"></qr-input-error>' +
            '</div>' +
        '</div>',
        scope: {
            value: '=',         // Currently selected file, if any, in format {url: 'http://', name: 'FileName', size: 100, type: 'image/png'}.
            values: '=',        // Currently selected array of files for multiple mode.
            accept: '@',        // File type to accept (e.g. "image/*" or ".pdf" or "image/gif").
            fileTypes: '=',     // If set, it will check file types (e.g. ['image/gif', 'image/png']).
            messages: '=',      // Translations.
            varname: '@',       // The variable name for registration on the server ("avatar" by default).
            codeId: '=',        // ID of the current QR code (it's used for sending files to the server).
            typeId: '=',        // ID of the QR code type (it's used for sending files to the server).
            isUploading: '=',   // True if it's in uploading state.
            awsCredentials: '=',// AWS credentials for uploading files.
            required: '=',      // Optional. True if the file is required.
            fileExt: '@',       // File extension for the uploaded file (pdf/jpg/png/...).
            iconUpload: '@',    // Icon for the upload container
            dragDrop: '@',      // True if drag&drop is allowed
            iconButtonUpload: '@',// Icon for the upload button
            multiple: '@',      // Set to "true" to enable uploading of several files at the same time.
            slimDesign: '@'     // Slim design of the uploader
        },
        link: function (scope, element, attributes, formCtrl) {
            element.on('click', '.qr-file-uploader__upload', function () {
                element.find('[name=file]').click();
            });
            element.find('[name=file]').on('change', function () {
                if ('files' in this) {
                    scope.uploadFileArray(this.files);
                }
                scope.$apply();
            });

            if (scope.multiple === "true") {
                element.find('[name=file]').attr('multiple', '');
            }

            /**
             * This is used to set custom errors on the file input.
             * @param {boolean} validity
             */
            scope.setCustomValidityOfFile = function (validity) {
                if (formCtrl) {
                    formCtrl['file1'].$setValidity('customError', validity);
                }
            };

            /**
             * Callback function for the upload by drag&drop
             * @param e -  element
             * */
            function triggerCallback(e) {
                var files = [];
                if (e.dataTransfer) {
                    files = e.dataTransfer.files;
                } else if (e.target) {
                    files = e.target.files;
                }
                scope.uploadFileArray(files);
                scope.$apply();
            }

            // Get the native element
            var el = element[0];

            /**
             * Add 'dragover' event listener on the element
             * */
            el.addEventListener(
                'dragover',
                function (e) {
                    e.dataTransfer.dropEffect = 'move';
                    // allows us to drop
                    e.preventDefault();
                    e.stopPropagation();
                    this.classList.add('filedrag');
                    return false;
                },
                false
            );

            /**
             * Add 'dragenter' event listener on the element
             * */
            el.addEventListener(
                'dragenter',
                function (e) {
                    this.classList.add('filedrag');
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                },
                false
            );

            /**
             * Add 'dragleave' event listener on the element
             * */
            el.addEventListener(
                'dragleave',
                function (e) {
                    this.classList.remove('filedrag');
                    element.find('.qr-file-uploader__prompt').css({
                        'display': 'inline-block',
                        'visibility': 'visible',
                        'opacity': '1',
                        'width': 'auto'
                    });
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                },
                false
            );

            /**
             * Add 'drop' event listener on the element
             * */
            el.addEventListener(
                'drop',
                function (e) {
                    // Stops some browsers from redirecting.
                    e.preventDefault();
                    e.stopPropagation();

                    this.classList.remove('filedrag');
                    element.find('.qr-file-uploader__prompt').css({
                        'display': 'inline-block',
                        'visibility': 'visible',
                        'opacity': '1',
                        'width': 'auto'
                    });
                    triggerCallback(e);
                    return false;
                },
                false
            );
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            $scope.uploadLabel = $scope.messages.upload || $filter('translate')('Upload');
            $scope.changeLabel = $scope.messages.change || $filter('translate')('Change');
            $scope.cancelLabel = $scope.messages.cancel || $filter('translate')('Cancel');
            $scope.promptLabel = $scope.messages.prompt || '';
            $scope.uploadingLabel = $scope.messages.uploading || $filter('translate')('Uploading {percent}%...');
            $scope.fileSizeLabel = $scope.messages.fileSize || $filter('translate')('File size: {size}KB');

            $scope.value = $scope.value || {};
            $scope.values = $scope.values || [];

            /**
             * Some states of the input.
             * @type {boolean}
             */
            $scope.isSuccess = false;
            $scope.isError = false;

            /**
             * An array of uploader objects.
             * @type {Array}
             */
            $scope.uploaders = [];

            /**
             * This is used for showing input errors.
             * As we have no real input, there's a hidden one.
             * @type {string}
             */
            $scope.fakeValue = '';

            /**
             * @type {boolean}
             */
            $scope.isInit = true;

            $scope.$watch('values', function () {
                if ($scope.isInit && $scope.values.length === 0 && $scope.value && $scope.value.url) {
                    $scope.values = [$scope.value];
                } else {
                    $scope.value = $scope.values[0] || {};
                }

                if ($scope.value && $scope.value.url) {
                    $scope.fakeValue = '1';
                } else {
                    $scope.fakeValue = '';
                }

                $scope.isInit = false;
            }, true);

            /**
             * Get the file name for displaying.
             * @returns {string}
             */
            $scope.getFileNameToDisplay = function () {
                if ($scope.multiple === "true") {
                    return '';
                }
                return $scope.value.name;
            };

            /**
             * Get normalized value of the progress.
             * @returns {number}
             */
            $scope.getProgressValue = function () {
                var progress = $scope.value.progress || 0;
                if ($scope.multiple === "true") {
                    progress = $scope.getMultipleProgress();
                }
                return Math.min(Math.max(0, Math.ceil(progress)), 100);
            };

            /**
             * Get string for displaying the uploading progress info.
             */
            $scope.getProgressString = function () {
                if ($scope.isUploading) {
                    return $scope.uploadingLabel.replace('{percent}', $scope.getProgressValue());
                }
                if ($scope.multiple === "true") {
                    // For multiple mode don't show current file(s)
                    return '';
                }
                if ($scope.value.size > 0) {
                    return $scope.fileSizeLabel.replace('{size}', Math.ceil($scope.value.size / 1024));
                }
                return '';
            };

            /**
             * Return uploadLabel or changeLabel depending on the state.
             * @returns {string}
             */
            $scope.getUploadLabel = function () {
                if ($scope.value.size > 0) {
                    return $scope.changeLabel;
                }
                return $scope.uploadLabel;
            };

            /**
             * Return classes for the upload button.
             */
            $scope.getButtonClass = function () {
                return {
                    'qr-file-uploader__upload--error': $scope.isError,
                    'qr-file-uploader__upload--success': $scope.isSuccess
                };
            };

            /**
             * Get the styles of the uploader.
             * It's used to display the progress bar inside the uploader.
             */
            $scope.getStyles = function () {
                var styles = {};
                if ($scope.isUploading && $scope.getProgressValue() > 0) {
                    styles.background = 'linear-gradient(90deg, #e5f3fa ' + $scope.getProgressValue() + '%, #f7f7f7 0%, #f7f7f7 100%)';
                }
                return styles;
            };

            /**
             * Highlight this element to display a error state.
             */
            $scope.displayErrorState = function () {
                $scope.isError = true;
                $timeout(function () {
                    $scope.isError = false;
                }, 2000);
            };

            /**
             * Highlight this element to display a success state.
             */
            $scope.displaySuccessState = function () {
                $scope.isSuccess = true;

                // After a successful upload, clear the file input to enable uploading the same file again.
                $element.find("input[type='file']").val(null);

                $timeout(function () {
                    $scope.isSuccess = false;
                }, 2000);
            };

            /**
             * Upload array of files.
             * @param fileArray
             */
            $scope.uploadFileArray = function (fileArray) {
                if (fileArray.length > 0) {
                    $scope.values = [];
                    var continueUploading = true;
                    angular.forEach(fileArray, function (file, fileIndex) {
                        if (continueUploading) {
                            continueUploading = $scope.uploadFile(file, fileIndex);
                        }
                    });
                }
            };

            /**
             * The first step of uploading process.
             * @param file
             * @param fileIndex
             * @returns {boolean}
             */
            $scope.uploadFile = function (file, fileIndex) {
                if (!('type' in file)) {
                    $scope.displayErrorState();
                    return false;
                }
                $log.debug('Got file #' + fileIndex + ' type: ' + file.type + ', size: ' + file.size + ', name: ' + file.name);

                // Check file type.
                if ($scope.fileTypes && $scope.fileTypes.length > 0 && $scope.fileTypes.indexOf(file.type) < 0) {
                    $log.debug('Wrong file type: ' + file.type);
                    $scope.setCustomValidityOfFile(false);
                    $scope.displayErrorState();
                    return false;
                } else {
                    $scope.setCustomValidityOfFile(true);
                }

                $scope.values[fileIndex] = {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    progress: 0,
                    url: ''
                };
                $scope.isUploading = true;

                // Get the amount of uploaded images on the gallery
                $scope.nextImageCount = (($scope.$parent.model || {}).images || []).length + fileIndex + 1;

                $scope.uploaders[fileIndex] = uploaderService.startUploading({
                    file: file,
                    scope: $scope,
                    typeId: $scope.typeId,
                    codeId: $scope.codeId,
                    varname: ($scope.varname || 'avatar') + ($scope.nextImageCount <= 0 ? '' : $scope.nextImageCount),
                    fileExt: $scope.fileExt,
                    awsCredentials: $scope.awsCredentials,
                    onSuccess: function (fileUrl) {
                        if ($scope.values.length > 0) {
                            $scope.values[fileIndex].url = fileUrl;
                        }
                        $scope.uploaders[fileIndex] = false;
                        $scope.isUploading = $scope.isStillUploading();
                        $scope.displaySuccessState();
                    },
                    onError: function () {
                        $scope.uploaders[fileIndex] = false;
                        $scope.isUploading = $scope.isStillUploading();
                        // After any error, clear value as it can be invalid.
                        $scope.values = [];
                        $scope.displayErrorState();
                    },
                    onProgress: function (progress) {
                        $scope.values[fileIndex].progress = progress;
                    }
                });

                return true;
            };

            /**
             * Cancel current uploading process.
             */
            $scope.cancelUploading = function () {
                angular.forEach($scope.uploaders, function (uploader, fileIndex) {
                    if (uploader) {
                        uploader.cancel();
                        $scope.uploaders[fileIndex] = false;
                    }
                });
            };

            /**
             * Check all files and return current uploading status.
             * @returns {boolean}
             */
            $scope.isStillUploading = function () {
                var uploading = false;
                angular.forEach($scope.uploaders, function (uploader) {
                    if (uploader) {
                        uploading = true;
                    }
                });
                return uploading;
            };

            /**
             * Get total progress percent based on multiple files for the multiple mode.
             * @returns {number}
             */
            $scope.getMultipleProgress = function () {
                var size = 0, done = 0;
                angular.forEach($scope.values, function (file) {
                    size += file.size;
                    done += Math.max(0, file.progress || 0) * file.size / 100;
                });
                return done / size * 100;
            };
        }]
    };
}]);
;
app.directive('qrFileUploadField', ['$filter', '$timeout', '$log', 'uploaderService', 'api', function ($filter, $timeout, $log, uploaderService, api) {
    return {
        restrict: 'E',
        require: '?^form',
        template:
            '<div class="qr-file-upload-field__container">' +
                '<div class="qr-file-upload-field" ng-class="[getButtonClass(), getButtonState()]" ng-style="getStyles()" ng-click="uploadAction()" data-upload-button>' +
                    '<div class="qr-file-upload-field__upload" ng-if="!isValidationDone">' +
                        '<span class="qr-file-upload-field__icon" ng-class="getIconClass()"></span>' +
                        '<span class="qr-file-upload-field__label">{{ buttonLabel }}</span>' +
                    '</div>' +
                    '<div class="qr-file-upload-field__result" ng-if="isValidationDone">' +
                        '<div class="qr-file-upload-field__result-done">' +
                            '<span class="qr-file-upload-field__icon icon icon-check-circle qr-file-upload-field__icon--result"></span>' +
                            '{{ uploaderOptions.messages.resultSuccess }}' +
                        '</div>' +
                        '<div class="qr-file-upload-field__result-subtitle">{{ codeFound }}</div>' +
                        '<div class="qr-file-upload-field__result-edit-icon">' +
                            '<span class="icon icon-pencil-outline"></span>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<input type="file" ng-show="false" name="file" accept="{{ uploaderOptions.accept }}">' +
                '<input name="file1" ng-required="required" ng-show="false" class="canHaveError" ng-model="fakeValue">' +
                '<qr-popup-feedback open="isError" type="danger" position="right" message="{{ feedbackMessage }}"></qr-popup-feedback>' +
            '</div>',
        scope: {
            uploaderOptions: '=',    // Button options object.
            className: '@',          // Custom class for button.
            varname: '@',            // The variable name for registration on the server ("avatar" by default).
            codeType: '@'            // A parameter that contains the type of coded to be generated.
        },
        link: function (scope, element, document, attributes, formCtrl) {
            /**
             * Get all parents of an element
             * @param elem
             * @returns {[]}
             */
            var getParents = function (elem) {

                // Set up a parent array
                var parents = [];

                // Push each parent element to the array
                for ( ; elem && elem !== document; elem = elem.parentNode ) {
                    parents.push(elem);
                }

                // Return our parent array
                return parents;

            };

            /**
             * Global variables.
             */
            var el = '';
            var elem = element[0].getElementsByClassName('qr-file-upload-field__container')[0];
            var parents = getParents(elem)

            // Find the specific parent we are sending from uploaderOptions
            Object.keys(parents).forEach(function(key) {
                if (parents[key].className === scope.uploaderOptions.customDragover) {
                    el = parents[key]
                }
            });

            /**
             * Attach a click event to the [data-upload-button] to open file selection window
             */
            element.on('click', '[data-upload-button]', function () {
                element.find('[name=file]').click();
            });

            /**
             * Attach a change event to the [name=file] to keep track of changes
             */
            element.find('[name=file]').on('change', function () {
                if ('files' in this) {
                    scope.uploadFileArray(this.files);
                }
                scope.$apply();
            });

            /**
             * This is used to set custom errors on the file input.
             * @param {boolean} validity
             */
            scope.setCustomValidityOfFile = function (validity) {
                if (formCtrl) {
                    formCtrl['file1'].$setValidity('customError', validity);
                }
            };

            /**
             * Callback function for the upload by drag&drop
             * @param {element} e
             */
            function triggerCallback(e) {
                var files = [];
                if (e.dataTransfer) {
                    files = e.dataTransfer.files;
                } else if (e.target) {
                    files = e.target.files;
                }
                scope.uploadFileArray(files);
                scope.$apply();
            }

            /**
             * Add 'dragover' event listener on the element
             */
            el.addEventListener(
                'dragover',
                function (e) {
                    e.dataTransfer.dropEffect = 'move';
                    // Allows us to drop
                    e.preventDefault();
                    e.stopPropagation();
                    this.classList.add('is-dragover');

                    return false;
                },
                false
            );

            /**
             * Add 'dragenter' event listener on the element
             */
            el.addEventListener(
                'dragenter',
                function (e) {
                    this.classList.add('is-dragover');
                    e.preventDefault();
                    e.stopPropagation();

                    return false;
                },
                false
            );

            /**
             * Add 'dragleave' event listener on the element
             */
            el.addEventListener(
                'dragleave',
                function (e) {
                    this.classList.remove('is-dragover');
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                },
                false
            );

            /**
             * Add 'drop' event listener on the element
             */
            el.addEventListener(
                'drop',
                function (e) {
                    // Stops some browsers from redirecting.
                    e.preventDefault();
                    e.stopPropagation();

                    this.classList.remove('is-dragover');
                    triggerCallback(e);
                    return false;
                },
                false
            );
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            /**
             * Global controller $scope variables
             */
            $scope.buttonLabel = $scope.uploaderOptions.messages.upload;
            $scope.value = $scope.value || {};
            $scope.values = $scope.values || [];
            $scope.feedbackMessage = '';
            $scope.codeFound = '';

            /**
             * States of the input.
             * @type {boolean}
             */
            $scope.isSuccess = false;
            $scope.isError = false;
            $scope.isValidationDone = false;

            /**
             * An array of uploader objects
             * @type {Array}
             */
            $scope.uploaders = [];

            /**
             * This is used for showing input errors.
             * As we have no real input, there's a hidden one.
             * @type {string}
             */
            $scope.fakeValue = '';

            /**
             * @type {boolean}
             */
            $scope.isInit = true;

            /**
             * Get the state CSS class name of the current button
             * @returns {{
             *      "qr-file-upload-field--error": boolean,
             *      "qr-file-upload-field--success": boolean
             *      }}
             */
            $scope.getButtonState = function () {
                return {
                    // 'qr-file-upload-field--error': $scope.isError,
                    // 'qr-file-upload-field--success': $scope.isSuccess,
                    'qr-file-upload-field--valid': $scope.isValidationDone,
                };
            };

            /**
             * Get the CSS class name of the current button
             * @returns {string}
             */
            $scope.getButtonClass = function () {
                return  $scope.className;
            };

            /**
             * Get the CSS class name of the current icon
             * @returns {string}
             */
            $scope.getIconClass = function () {
                return 'icon ' + $scope.uploaderOptions.buttonIcon;
            };

            /**
             * Reset the file value each time we access the upload function
             */
            $scope.uploadAction = function () {
                $element.find('[name=file]')[0].value = "";
            };

            /**
             * Upload array of files
             * @param {object} fileArray
             */
            $scope.uploadFileArray = function (fileArray) {
                if (fileArray.length > 0) {
                    $scope.values = [];
                    var continueUploading = true;
                    angular.forEach(fileArray, function (file, fileIndex) {
                        if (continueUploading) {
                            continueUploading = $scope.uploadFile(file, fileIndex);
                        }
                    });
                }
            };

            /**
             * The first step of uploading process
             * @param {object} file
             * @param {number} fileIndex
             * @returns {boolean}
             */
            $scope.uploadFile = function (file, fileIndex) {
                if (!('type' in file)) {
                    $scope.displayErrorState();
                    return false;
                }
                $log.debug('Got file #' + fileIndex + ' type: ' + file.type + ', size: ' + file.size + ', name: ' + file.name);

                if (file.size === 0) {
                    $scope.displayErrorState($scope.uploaderOptions.messages.validateError);
                    return false;
                }

                // Check file type.
                if ($scope.uploaderOptions.fileTypes && $scope.uploaderOptions.fileTypes.length > 0 && $scope.uploaderOptions.fileTypes.indexOf(file.type) < 0) {
                    $log.debug('Wrong file type: ' + file.type);
                    $scope.setCustomValidityOfFile(false);
                    $scope.displayErrorState($scope.uploaderOptions.messages.formatError);
                    return false;
                } else {
                    $scope.setCustomValidityOfFile(true);
                }

                $scope.values[fileIndex] = {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    progress: 0,
                    url: ''
                };

                $scope.isUploading = true;

                $scope.uploaders[fileIndex] = uploaderService.startUploading({
                    file: file,
                    scope: $scope,
                    typeId: $scope.uploaderOptions.typeId,
                    varname: $scope.uploaderOptions.varname || 'avatar',
                    fileExt: $scope.uploaderOptions.fileExt,
                    awsCredentials: $scope.uploaderOptions.awsCredentials,
                    onSuccess: function (fileUrl) {
                        var fileKey = fileUrl.match(/(account[0-9]+\/[^?]*)(\?|$)/i)[1];
                        if ($scope.values.length > 0) {
                            $scope.values[fileIndex].url = fileUrl;
                        }
                        $scope.uploaders[fileIndex] = false;
                        $scope.isUploading = $scope.isStillUploading();
                        $scope.displaySuccessState();
                        $scope.buttonLabel = $scope.uploaderOptions.messages.validating + '...';

                        var onValidateSuccess = function (response) {
                            if (response.data.codes === 1) {
                                $scope.codeFound = $scope.uploaderOptions.messages.codeCount.replace('{count}', response.data.codes);
                            } else {
                                $scope.codeFound = $scope.uploaderOptions.messages.codesCount.replace('{count}', response.data.codes);
                            }
                            $scope.isValidationDone = true;
                            // This goes to the parent <qr-mass-creation-modal> and changes current upload status.
                            $scope.$emit('qr-init-upload-file', true, fileKey);
                            $scope.$emit('qr-found-codes-count', response.data.codes);
                        };

                        var onValidateError = function (response) {
                            $scope.isValidationDone = false;
                            $scope.buttonLabel = $scope.uploaderOptions.messages.upload;

                            if ('messages' in response.data) {
                                if ('userRestrictionError' in response.data.messages[0]) {
                                    $scope.displayErrorState($scope.uploaderOptions.messages.userRestrictionError);
                                } else if('limit' in response.data.messages[0]) {
                                    $scope.displayErrorState(response.data.messages[0].limit);
                                } else if('validationErrorLine' in response.data.messages[0]) {
                                    let errorMessage = $scope.uploaderOptions.messages.invalidLineError;
                                    $scope.displayErrorState(errorMessage.replace(/%s/g, response.data.messages[0].validationErrorLine));
                                } else {
                                    $scope.displayErrorState($scope.uploaderOptions.messages.customError);
                                }
                            } else {
                                $scope.displayErrorState($scope.uploaderOptions.messages.validateError);
                            }
                            // This goes to the parent <qr-mass-creation-modal> and changes current upload status.
                            $scope.$emit('qr-init-upload-file', false);
                        };

                        api.validateFile({file_key: fileKey, code_type: $scope.codeType}, $scope.uploaderOptions.templateType, onValidateSuccess, onValidateError);
                    },
                    onError: function () {
                        $scope.uploaders[fileIndex] = false;
                        $scope.isUploading = $scope.isStillUploading();
                        // After any error, clear value as it can be invalid.
                        $scope.values = [];
                        $scope.displayErrorState($scope.uploaderOptions.messages.customError);
                    },
                    onProgress: function (progress) {
                        $scope.values[fileIndex].progress = progress;
                    }
                });

                return true;
            };

            /**
             * Check all files and return current uploading status
             * @returns {boolean}
             */
            $scope.isStillUploading = function () {
                var uploading = false;
                angular.forEach($scope.uploaders, function (uploader) {
                    if (uploader) {
                        uploading = true;
                    }
                });
                return uploading;
            };

            /**
             * Use this function to display a success state
             */
            $scope.displaySuccessState = function () {
                $scope.isSuccess = true;
                $scope.buttonLabel =  $scope.uploaderOptions.messages.upload;
            };

            /**
             * Use this function to display a error state
             */
            $scope.displayErrorState = function (message) {
                $scope.isSuccess = false;
                $scope.isError = true;

                $scope.feedbackMessage = message;
                $timeout(function () {
                    $scope.isError = false;
                }, 5000);
            };

            /**
             * Get normalized value of the progress
             * @returns {number}
             */
            $scope.getProgressValue = function () {
                var progress = $scope.value.progress || 0;
                return Math.min(Math.max(0, Math.ceil(progress)), 100);
            };

            /**
             * Get string for displaying the uploading progress info
             */
            $scope.getProgressString = function () {
                if ($scope.isUploading) {
                    return $scope.uploadingLabel.replace('{percent}', $scope.getProgressValue());
                }

                if ($scope.value.size > 0) {
                    return $scope.fileSizeLabel.replace('{size}', Math.ceil($scope.value.size / 1024));
                }
                return '';
            };

            /**
             * Get normalized value of the progress
             * @returns {number}
             */
            $scope.getProgressValue = function () {
                var progress = $scope.value.progress || 0;
                return Math.min(Math.max(0, Math.ceil(progress)), 100);
            };

            /**
             * Get the styles of the uploader
             * It's used to display the progress bar inside the uploader
             */
            $scope.getStyles = function () {
                var styles = {};
                if ($scope.isUploading && $scope.getProgressValue() > 0) {
                    $scope.isValidationDone = false
                    $scope.buttonLabel = $scope.uploaderOptions.messages.uploading + '...';
                    styles.background = 'linear-gradient(90deg, rgba(255, 255, 255, .2) ' + $scope.getProgressValue() + '%, transparent 0%, transparent 100%)';
                    styles.border = '1px solid rgba(255, 255, 255, .6)';
                }
                return styles;
            };

            /**
             * $watch
             * Watch input field values
             */
            $scope.$watch('values', function () {
                if ($scope.isInit && $scope.values.length === 0 && $scope.value && $scope.value.url) {
                    $scope.values = [$scope.value];
                } else {
                    $scope.value = $scope.values[0] || {};
                }

                if ($scope.value && $scope.value.url) {
                    $scope.fakeValue = '1';
                } else {
                    $scope.fakeValue = '';
                }

                $scope.isInit = false;
            }, true);
        }]
    };
}]);;
app.directive('qrPreviewBox', ['$filter', '$timeout', '$log', 'uploaderService', function ($filter, $timeout, $log, uploaderService) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-preview-box">' +
                '<span class="qr-preview-box__close" ng-click="closed = true" ng-show="showClose">&times;</span>' +
                '<div class="qr-preview-box__title" ng-show="titleLabel">{{ titleLabel }}</div>' +
                '<div class="qr-preview-box__frames">' +
                    '<div class="qr-preview-box__frame" ng-repeat="image in images" ng-click="activate(image)" ng-class="getClass(image)">' +
                        '<div ng-style="{backgroundImage: &apos;url(&apos; + image + &apos;)&apos;}" class="qr-preview-box__image" ng-show="image"></div>' +
                        '<div class="qr-preview-box__loader" ng-hide="image"></div>' +
                    '</div>' +
                    '<div class="qr-preview-box__frame qr-preview-box__frame--upload" ng-show="isUploadingEnabled()">' +
                        '<i class="qr-preview-box__icon icon-plus-circle"></i>' +
                        '{{ uploadLabel }}' +
                    '</div>' +
                    '<input type="file" style="display: none;" name="file" accept="image/*">' +
                '</div>' +
            '</div>',
        scope: {
            value: '=',         // Currently chosen preview image.
            images: '=',        // Array of preview images.
            messages: '=',      // Translations.
            maxPageNum: '@',    // Max number of previews to display.
            varname: '@',       // The variable name for registration on the server ("avatar" by default).
            codeId: '=',        // ID of the current QR code (it's used for sending files to the server).
            typeId: '=',        // ID of the QR code type (it's used for sending files to the server).
            closed: '=',        // It's used to control visibility.
            showClose: '@',     // Show the close X button.
            isUploading: '=',   // True if it's in uploading state.
            awsCredentials: '=' // AWS credentials for uploading files.
        },
        link: function (scope, element) {
            element.find('.qr-preview-box__frame--upload').on('click', function () {
                element.find('[name=file]').click();
            });
            element.find('[name=file]').on('change', function () {
                scope.uploadFile(('files' in this && this.files.length > 0) ? this.files[0] : {});
                scope.$apply();
            });
        },
        controller: ['$scope', function ($scope) {
            $scope.titleLabel = $scope.messages.title || '';
            $scope.uploadLabel = $scope.messages.upload || $filter('translate')('Upload');

            /**
             * This is the list of supported image types.
             */
            $scope.fileTypes = ['image/gif', 'image/png', 'image/jpeg', 'image/bmp'];

            /**
             * Activate an image.
             * @param image
             */
            $scope.activate = function (image) {
                $scope.value = image;
                $log.debug('Activated preview image: ' + ('' + image).substr(0, 30) + '...');
            };

            /**
             * Check that it's possible to upload files.
             * @returns {boolean}
             */
            $scope.isUploadingEnabled = function () {
                return $scope.typeId && $scope.awsCredentials;
            };

            /**
             * Get image frame CSS class.
             * @param image
             * @returns {*}
             */
            $scope.getClass = function (image) {
                return {
                    'qr-preview-box__frame--active': $scope.value === image
                };
            };

            /**
             * The first step of uploading process.
             * @param file
             */
            $scope.uploadFile = function (file) {
                if (!('type' in file)) {
                    return;
                }
                $log.debug({file: file});

                // Check file type.
                if ($scope.fileTypes && $scope.fileTypes.length > 0 && $scope.fileTypes.indexOf(file.type) < 0) {
                    $log.debug('Wrong file type: ' + file.type);
                    return;
                }

                $scope.isUploading = true;
                var indexOfValue = -1, prevImage = '';
                if ($scope.maxPageNum > 0) {
                    if ($scope.images.length >= $scope.maxPageNum) {
                        indexOfValue = $scope.images.indexOf($scope.value);
                        if (indexOfValue < 0) {
                            prevImage = $scope.images.splice(-1, 1)[0];
                        }
                    }
                }
                if (indexOfValue >= 0) {
                    prevImage = $scope.images[indexOfValue];
                    $scope.images[indexOfValue] = '';
                } else {
                    $scope.images.push('');
                }
                $scope.value = ''; // Uploading should be indicated as empty avatar image, so we should remove currently selected image here.
                uploaderService.startUploading({
                    file: file,
                    scope: $scope,
                    typeId: $scope.typeId,
                    codeId: $scope.codeId,
                    varname: $scope.varname || 'avatar',
                    fileExt: 'jpg',
                    awsCredentials: $scope.awsCredentials,
                    onSuccess: function (fileUrl) {
                        if (indexOfValue >= 0) {
                            $scope.images[indexOfValue] = fileUrl;
                        } else {
                            $scope.images.splice(-1, 1);
                            $scope.images.push(fileUrl);
                        }
                        $scope.value = fileUrl;
                        $scope.isUploading = false;
                    },
                    onError: function () {
                        if (indexOfValue >= 0) {
                            $scope.images[indexOfValue] = prevImage;
                        } else {
                            $scope.images.splice(-1, 1);
                            if (prevImage) {
                                $scope.images.push(prevImage);
                            }
                        }
                        $scope.isUploading = false;
                    }
                });
            };
        }]
    };
}]);
;
app.directive('qrPdfPreviewBox', ['$log', 'http', function ($log, http) {
    return {
        restrict: 'E',
        template: '<qr-preview-box images="images" messages="messages" value="value" varname="{{ varname }}" code-id="codeId" type-id="typeId" aws-credentials="awsCredentials" max-page-num="{{ maxPageNum }}" show-close="{{ showClose }}" closed="closed"></qr-preview-box>',
        scope: {
            value: '=',         // Currently chosen preview image.
            pdfFile: '=',       // Base PDF file for extracting previews.
            messages: '=',      // Translations.
            maxPageNum: '@',    // Max number of pages to display.
            varname: '@',       // The variable name for registration on the server ("avatar" by default).
            codeId: '=',        // ID of the current QR code (it's used for sending files to the server).
            typeId: '=',        // ID of the QR code type (it's used for sending files to the server).
            closed: '=',        // It's used to control visibility.
            images: '=',        // Preview images.
            allPagesMode: '@',  // True if all pages should be requested from the server. Otherwise it will request pages one by one.
            showClose: '@',     // Show the close X button.
            awsCredentials: '=' // AWS credentials for uploading files.
        },
        controller: ['$scope', function ($scope) {
            /**
             * Start loading previews from the server.
             * They can be loaded all at the same time, or one by one (see allPagesMode).
             */
            $scope.startLoadingPreviews = function () {
                $scope.images = [];
                if ($scope.allPagesMode === "true") {
                    // Load all pages at once.
                    $scope.loadPreview(0, $scope.maxPageNum);
                } else {
                    // Load the first page. And then the rest of pages. This way the first page will be shown very fast.
                    $scope.loadPreview(0, 1, function () {
                        $scope.loadPreview(1, $scope.maxPageNum - 1);
                    });
                }
            };

            /**
             * Request new preview image from the server.
             * @param {number} index
             * @param {number|string} maxNum
             * @param [callback]
             */
            $scope.loadPreview = function (index, maxNum, callback) {
                if (!$scope.pdfFile) {
                    return;
                }
                $scope.images.push('');
                http.post(
                    '/pdf/preview',
                    {
                        pdfUrl: $scope.pdfFile,
                        pageNum: maxNum,
                        pageIndex: index,
                        codeId: $scope.codeId,
                        typeId: $scope.typeId
                    },
                    function (response) {
                        $log.debug({pdfProcessed: response});
                        $scope.images.splice(-1, 1);
                        if (response.data.success) {
                            if ('previews' in response.data) {
                                $scope.images = $scope.images.concat(response.data.previews);
                            } else if ('preview' in response.data) {
                                $scope.images.push(response.data.preview);
                            }
                            $scope.value = $scope.images[0]; // Auto-select the first image.
                            if (callback) {
                                callback(response);
                            }
                        }
                    },
                    function () {
                        $scope.images.splice(-1, 1);
                    }
                );
            };

            /**
             * This is used to prevent updating images at the first time when the directive is loaded,
             * if the images are already in $scope.images and pdfFile is not empty.
             * @type {boolean}
             */
            $scope.firstRun = true;

            // Synchronize pdfFile and images.
            $scope.$watch('pdfFile', function () {
                if ($scope.firstRun && $scope.images && $scope.images.length > 0 && $scope.pdfFile) {
                    $scope.firstRun = false;
                    return;
                }
                $scope.firstRun = false;
                $scope.startLoadingPreviews();
            });
        }]
    };
}]);
;
/**
 * This is the modal for activating user accounts after OAuth registration.
 */
app.directive('qrAccountActivationModal', ['$filter', 'http', '$sce', '$window', function ($filter, http, $sce, $window) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="form.open" auto-close="false" test-event="account-activation-modal">' +
                '<div class="qr-account-activation-modal">' +
                    '<h1 class="qr-account-activation-modal__title">{{ messages.title }}</h1>' +
                    '<p class="qr-account-activation-modal__text">{{ messages.text }}</p>' +
                    '<div class="qr-account-activation-modal__checkbox checkbox">' +
                        '<span class="checkboxes-container green-checkbox">' +
                            '<input type="checkbox" class="activated" ng-model="form.agreed" id="qr-account-activation-modal-checkbox" ng-disabled="form.sending" data-test="account-activation-terms-checkbox">' +
                            '<label for="qr-account-activation-modal-checkbox" ng-bind-html="getCheckboxLabel()"></label>' +
                        '</span>' +
                    '</div>' +
                    '<div class="qr-account-activation-modal__error" ng-show="form.showErrors && !form.agreed">{{ messages.required }}</div>' +
                    '<button class="qr-account-activation-modal__button" type="button" ng-click="click()" data-ng-disabled="form.sending" data-test="account-activation-complete-registration-btn">{{ messages.button }}</button>' +
                '</div>' +
            '</qr-modal>',
        scope: {
            messages: '=', // Translations.
            isSubUser: '='
        },
        controller: ['$scope', function ($scope) {
            /**
             * Form data.
             * @type {{agreed: boolean, open: boolean, sending: boolean}}
             */
            $scope.form = {
                agreed: false,
                open: true,
                sending: false,
                showErrors: false
            };

            // The loader/spinner for server requests indication.
            $scope.loader = false;

            // Indication of server requests.
            $scope.$watch('form.sending', function () {
                if ($scope.form.sending) {
                    if (!$scope.loader) {
                        $scope.loader = Ladda.create($window.jQuery('.qr-account-activation-modal__button').get(0));
                    }
                    $scope.loader.start();
                } else if ($scope.loader) {
                    $scope.loader.remove();
                }
            });

            /**
             * Activate the user's account.
             */
            $scope.click = function () {
                if ($scope.form.agreed && !$scope.form.sending) {
                    $scope.form.sending = true;
                    http.post(
                        '/oauth/activate',
                        {},
                        function () {
                            $scope.form.sending = false;
                            $scope.form.open = false;
                            //Track account activation on mixpanel
                            mixpanel.track('account activate');

                            //Track account activation on google
                            var image = new Image(1, 1);
                            image.src = "//www.googleadservices.com/pagead/conversion/954772223/?label=gqsDCNKj7FsQ_9WixwM";

                            // If current user is not subuser
                            if(!$scope.isSubUser) {
                                // We redirect to /getstarted, so the user can select an industry
                                window.location = "/getstarted";
                            } else {
                                // Redirect subusers to manage-view
                                window.location = "/manage";
                            }
                        },
                        function () {
                            $scope.form.sending = false;
                        }
                    );
                } else if (!$scope.form.agreed) {
                    $scope.form.showErrors = true;
                }
            };

            /**
             * Get the checkbox label with links inside.
             */
            $scope.getCheckboxLabel = function () {
                return $sce.trustAsHtml($scope.messages.checkbox
                    .replace('[', '<a href="http://www.qr-code-generator.com/company/terms/" target="_blank">')
                    .replace(']', '</a>')
                    .replace('{', '<a href="http://www.qr-code-generator.com/company/privacy-policy/" target="_blank">')
                    .replace('}', '</a>')
                    .replace('{', '<a href="https://www.qr-code-generator.com/company/acceptable-use-policy/" target="_blank">')
                    .replace('}', '</a>')
                    .replace('{', '<a href="https://www.qr-code-generator.com/company/data-processing-agreement/" target="_blank">')
                    .replace('}', '</a>'));
            };
        }]
    };
}]);
;
/**
 * This directive creates a popup window for choosing from 2 or more options.
 */
app.directive('qrChoiceWindow', [function () {
    return {
        restrict: 'E',
        template:
            '<qr-popup open="open" top-offset="{{ topOffset }}" visible-layer="true" right="true">' +
                '<div class="qr-choice-window">' +
                    '<span class="qr-choice-window__close" ng-click="closeIt()">&times;</span>' +
                    '<div class="qr-choice-window__column" ng-repeat="item in items" ng-style="getColumnStyle()">' +
                        '<div class="qr-choice-window__item" ng-class="getItemClass(item)" ng-click="click(item)">' +
                            '<h6 class="qr-choice-window__title">{{ item.title }}</h6>' +
                            '<p class="qr-choice-window__description">{{ item.description }}</p>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
            '</qr-popup>',
        scope: {
            value: '=',         // Currently selected value.
            items: '=',         // Items to choose from. Format: {title: 'Title', description: 'Some description', value: '42'}
            open: '=',          // Is menu open? Default: false.
            topOffset: '@'      // Optional. The top offset of the menu. It can be used to adjust the vertical position.
        },
        controller: ['$scope', function ($scope) {
            /**
             * This will be executed on clicks on items
             * @param item
             */
            $scope.click = function (item) {
                $scope.open = false;
                $scope.value = item.value;
            };

            /**
             * Close this window.
             */
            $scope.closeIt = function () {
                $scope.open = false;
            };

            /**
             * Get some additional column styles.
             * @returns {{width: string}}
             */
            $scope.getColumnStyle = function () {
                return {
                    width: Math.round(100 / $scope.items.length) + '%'
                };
            };

            /**
             * @param item
             * @returns {*}
             */
            $scope.getItemClass = function (item) {
                return {
                    'qr-choice-window__item--active': $scope.value === item.value
                };
            };
        }]
    };
}]);
;
/**
 * This directive displays application info (it's used to display AppStore apps).
 */
app.directive('qrAppInfo', [function () {
    return {
        restrict: 'E',
        template:
            '<div class="qr-app-info">' +
                '<img class="qr-app-info__image" ng-src="{{ imageUrl }}" alt="" ng-show="imageUrl && !loading">' +
                '<div class="qr-app-info__empty" ng-hide="imageUrl && !loading">' +
                    '<div class="qr-app-info__loader"></div>' +
                '</div>' +
                '<div class="qr-app-info__name" ng-class="{&apos;qr-app-info__name--loading&apos;: loading}">{{ name }}</div>' +
                '<div class="qr-app-info__developer" ng-class="{&apos;qr-app-info__developer--loading&apos;: loading}">{{ developer }}</div>' +
            '</div>',
        scope: {
            name: '=',          // Name of the app.
            image: '=',         // Image URL.
            developer: '=',     // Developer name.
            loading: '='        // Optional. Loading state.
        },
        controller: ['$scope', function ($scope) {
            /**
             * Image URL for displaying.
             * @type {string}
             */
            $scope.imageUrl = '';

            // Make image loading better.
            $scope.$watch('image', function () {
                if (!$scope.image) {
                    $scope.imageUrl = '';
                    return;
                }
                var im = new Image();
                im.onload = function () {
                    $scope.imageUrl = this.src;
                    $scope.$apply();
                };
                im.src = $scope.image;
            });
        }]
    };
}]);
;
/**
 * This directive creates a popup window for searching for app names.
 */
app.directive('qrAppSearch', ['http', '$log', '$timeout', function (http, $log, $timeout) {
    return {
        restrict: 'E',
        template:
            '<qr-popup open="open" right="{{ right }}" top-offset="{{ topOffset }}" visible-layer="{{ visibleLayer }}">' +
                '<div class="qr-app-search">' +
                    '<span class="qr-app-search__icon icon-search"></span>' +
                    '<input class="qr-app-search__input" placeholder="{{ placeholder }}" ng-model="query.value" ng-model-options="{debounce: 1000}">' +
                    '<div class="qr-app-search__app" ng-repeat="item in items track by $index" ng-click="click(item)">' +
                        '<qr-app-info name="item.name" developer="item.developer" image="item.image" loading="!item.name"></qr-app-info>' +
                    '</div>' +
                '</div>' +
            '</qr-popup>',
        scope: {
            value: '=',         // URL of currently selected app.
            open: '=',          // Is menu open? Default: false.
            type: '@',          // Type of the store: apple, google, amazon.
            right: '@',         // Optional. Set to "true" if it should be aligned to the right.
            topOffset: '@',     // Optional. The top offset of the menu. It can be used to adjust the vertical position.
            visibleLayer: '@',  // Optional. Set to "true" if the background layer should be visible (dark transparent).
            placeholder: '@',   // Optional. Placeholder for the search field.
            limit: '@'          // Optional. Default 4. Limit of search results.
        },
        link: function (scope, element) {
            scope.focus = function () {
                $timeout(function () {
                    element.find("input:first").focus();
                }, 100);
            };
        },
        controller: ['$scope', function ($scope) {
            /**
             * Found applications.
             * @type {Array}
             */
            $scope.items = [];

            /**
             * This is used as a constant.
             * @type {{name: string, developer: string, image: string}}
             */
            $scope.emptyItem = {
                name: '',
                developer: '',
                image: ''
            };

            /**
             * The search query (app name).
             * Should be JS object (otherwise it doesn't work, probably because of the qrPopup scope).
             * @type {{value: string}}
             */
            $scope.query = {
                value: ''
            };

            /**
             * This will be executed on clicks on items
             * @param item
             */
            $scope.click = function (item) {
                if (!item.name) {
                    return;
                }
                $scope.open = false;
                $scope.value = item.url;
            };

            // Search when the model updates.
            $scope.$watch('query', function () {
                if ($scope.query.value.length >= 3) {
                    $scope.search();
                }
            }, true);

            // Focus when open.
            $scope.$watch('open', function () {
                if ($scope.open) {
                    $scope.focus();
                }
            });

            /**
             * Make requests to the server to search applications.
             */
            $scope.search = function () {
                var limit = $scope.limit || 4;
                $scope.items = [];
                for (var i = 0; i < limit; ++i) {
                    $scope.items.push($scope.emptyItem);
                }
                http.post(
                    '/appStore/search',
                    {
                        name: $scope.query.value,
                        type: $scope.type,
                        limit: limit
                    },
                    function (response) {
                        if (response.data.success) {
                            $scope.items = response.data.items;
                        } else {
                            $scope.items = [];
                        }
                    },
                    function () {
                        $log.debug('Apps loading error');
                        $scope.items = [];
                    }
                );
            };
        }]
    };
}]);
;
/**
 * Reusable directive for banners
 */
app.directive('qrUpsellingBanner', ['gettextCatalog', function (gettextCatalog) {
    return {
        restrict: 'E',
        template:
            '<div class="qrcg-banner qrcg-banner--blue qrcg-banner--plan-upselling container-fluid" ng-if="!hideUpsellingBanner" data-test="upselling-banner">' +

                '<div class="qrcg-banner__close_btn" ng-click="closeBanner()" data-test="upselling-banner-close-icon">' +
                    '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">' +
                        '<path d="M12 1L11 0L6 5L1 0L0 1L5 6L0 11L1 12L6 7L11 12L12 11L7 6L12 1Z" fill="white"/>' +
                    '</svg>' +
                '</div>' +


                '<div class="row qrcg-banner__row">' +
                    '<div class="col-xs-12">' +
                        '<h2 class="qrcg-banner__header qrcg-banner__header--hidden-large-screen">{{header}}</h2>' +
                    '</div>' +
                    '<div class="col-sm-7 col-xs-12">' +
                        '<h2 class="qrcg-banner__header qrcg-banner__header--hidden-small-screen">{{header}}</h2>' +
                        '<p class="qrcg-banner__subheader">{{subheader}}</p>' +

                        '<ul class="qrcg-banner__feature-list">' +
                            '<li class="qrcg-banner__feature-list-item" ng-repeat="feature in features">' +
                                '<svg width="14" height="12" viewBox="0 0 14 12" fill="none" xmlns="http://www.w3.org/2000/svg">' +
                                    '<path d="M5.13777 11.75C5.03914 11.75 4.94148 11.7306 4.85036 11.6928C4.75924 11.6551 4.67647 11.5997 4.60677 11.5298L0.226771 7.14595C0.155618 7.07652 0.0989369 6.99366 0.0600133 6.90215C0.0210898 6.81064 0.000697303 6.71231 1.75724e-05 6.61286C-0.000662158 6.5134 0.0183844 6.4148 0.0560534 6.32277C0.0937225 6.23074 0.149265 6.1471 0.219463 6.07671C0.289661 6.00632 0.373118 5.95057 0.464998 5.91269C0.556879 5.87482 0.655356 5.85557 0.754723 5.85606C0.85409 5.85655 0.952371 5.87678 1.04387 5.91557C1.13537 5.95435 1.21827 6.01093 1.28777 6.08201L5.07877 9.87635L12.6868 0.504101C12.8151 0.358712 12.9945 0.268587 13.1877 0.252569C13.3808 0.236551 13.5726 0.295879 13.7231 0.41815C13.8735 0.540421 13.9709 0.716168 13.9949 0.908645C14.0189 1.10112 13.9676 1.29543 13.8518 1.45093L5.71877 11.4708C5.65254 11.5525 5.5699 11.6194 5.47619 11.6672C5.38247 11.715 5.27979 11.7425 5.17477 11.748L5.13777 11.75Z" fill="#FDFEFF"/>' +
                                '</svg>' +
                                '<b ng-if="$index === 0">{{qrCodeAmount}}</b>' +
                                '<span>{{feature}}</span>' +
                            '</li>' +
                        '</ul>' +

                        '<a class="qrcg-banner__cta-btn" href="{{ctaButtonLink}}" target="_blank" ng-click="upgradeButtonClicked()" data-test="upselling-banner-cta">{{ctaButtonText}}</a>' +
                    '</div>' +

                    '<div class="col-sm-5 col-xs-12 qrcg-banner__image-container">' +
                        '<img src="/img/banner/upsell-banner.png" alt="">' +
                    '</div>' +
                '</div>' +

            '</div>',
        scope: {},
        controller: ['$scope', function ($scope) {

            // Translations
            $scope.header = gettextCatalog.getString("Unlock the possibilities with more QR Codes");
            $scope.subheader = gettextCatalog.getString("With our Advanced plan you will get access to:");

            // Workaround, since we can't mark specific parts of a translation-string as bold
            $scope.qrCodeAmount = gettextCatalog.getString("50 Dynamic QR Codes") + " ";

            $scope.features = [
                gettextCatalog.getString("with solutions for any use case"),
                gettextCatalog.getString("Unlimited scans of your QR Codes"),
                gettextCatalog.getString("Invite a team member to join with their own login")
            ];
            $scope.ctaButtonText = gettextCatalog.getString("Upgrade to advanced");


            // Additional variables
            $scope.hideUpsellingBanner = window.qr.utils.cookie.get("qrHideUpsellingBanner");

            if(window.qr.utils.optimizely.isAbTestVariantActive("24009620801", "24047030413")) {
                // Variant 1 with deeplink into checkout, with plan pre-selected
                $scope.ctaButtonLink = window.GLOBAL_CHECKOUT_URL + "/features-and-pricing/payment/plan-name/Advanced";
            } else {
                // Variant 2 with link to pricing-page
                $scope.ctaButtonLink = window.GLOBAL_CHECKOUT_URL + "/features-and-pricing";
            }


            // Functions
            $scope.$watch("hideUpsellingBanner", function (newValue) {
                if (newValue) {
                    $scope.hideUpsellingBanner = newValue;
                }
            });

            $scope.closeBanner = function () {
                $scope.hideUpsellingBanner = 1;
                window.qr.utils.cookie.set("qrHideUpsellingBanner", "1", {expires: 30});

                window.qr.utils.optimizely.trackOptimizelyEvent('qrapp_upgrade_banner_close');
            };

            $scope.upgradeButtonClicked = function () {
                window.qr.utils.optimizely.trackOptimizelyEvent('qrapp_upgrade_advanced_clicked');

                window.qr.utils.snowplow.trackUpsellingBannerUpgradeButtonClicked();
            };
        }]
    };
}]);
;
/**
 * Reusable directive for banners
 */
app.directive('qrTrialExpiredBanner', ['gettextCatalog', function (gettextCatalog) {
    return {
        restrict: 'E',
        template:
            '<div class="qrcg-banner qrcg-banner--blue qrcg-banner--trial-expired container-fluid">' +

                '<div class="row qrcg-banner__row">' +
                    '<div class="col-sm-5 col-xs-12 qrcg-banner__image-container--hidden-small-screen qrcg-banner__image-container">' +
                        '<img src="/img/banner/trialExpiredBanner.png" alt="">' +
                    '</div>' +

                    '<div class="flex col-sm-7 col-xs-12">' +
                        '<h2 style="color: #FFCDD7" class="qrcg-banner__header qrcg-banner__header">{{header}}</h2>' +
                        '<p class="qrcg-banner__subheader">{{subheader}}</p>' +

                        '<ul class="qrcg-banner__feature-list">' +
                            '<li class="qrcg-banner__feature-list-item" ng-repeat="feature in features">' +
                                '<svg width="14" height="12" viewBox="0 0 14 12" fill="none" xmlns="http://www.w3.org/2000/svg">' +
                                    '<path d="M5.13777 11.75C5.03914 11.75 4.94148 11.7306 4.85036 11.6928C4.75924 11.6551 4.67647 11.5997 4.60677 11.5298L0.226771 7.14595C0.155618 7.07652 0.0989369 6.99366 0.0600133 6.90215C0.0210898 6.81064 0.000697303 6.71231 1.75724e-05 6.61286C-0.000662158 6.5134 0.0183844 6.4148 0.0560534 6.32277C0.0937225 6.23074 0.149265 6.1471 0.219463 6.07671C0.289661 6.00632 0.373118 5.95057 0.464998 5.91269C0.556879 5.87482 0.655356 5.85557 0.754723 5.85606C0.85409 5.85655 0.952371 5.87678 1.04387 5.91557C1.13537 5.95435 1.21827 6.01093 1.28777 6.08201L5.07877 9.87635L12.6868 0.504101C12.8151 0.358712 12.9945 0.268587 13.1877 0.252569C13.3808 0.236551 13.5726 0.295879 13.7231 0.41815C13.8735 0.540421 13.9709 0.716168 13.9949 0.908645C14.0189 1.10112 13.9676 1.29543 13.8518 1.45093L5.71877 11.4708C5.65254 11.5525 5.5699 11.6194 5.47619 11.6672C5.38247 11.715 5.27979 11.7425 5.17477 11.748L5.13777 11.75Z" fill="#FDFEFF"/>' +
                                '</svg>' +
                                '<span>{{feature}}</span>' +
                            '</li>' +
                        '</ul>' +

                        '<a class="pull-right qrcg-banner__cta-btn" href="{{ctaButtonLink}}" ng-click="upgradeButtonClicked()">{{ctaButtonText}}</a>' +
                    '</div>' +

                '</div>' +

            '</div>',
        scope: {},
        controller: ['$scope', function ($scope) {

            // Translations
            $scope.header = gettextCatalog.getString("Your 14-day Trial has ended. ");
            $scope.subheader = gettextCatalog.getString("Continue where you left off with a subscription.");

            $scope.features = [
                gettextCatalog.getString("Reactivate your expired QR Codes."),
                gettextCatalog.getString("Create unique designs with colors, frames, and logos."),
                gettextCatalog.getString("Track scans and analytics of your QR Codes and campaigns.")
            ];
            $scope.ctaButtonText = gettextCatalog.getString("Upgrade now");

            $scope.ctaButtonLink = '/upgrade/?trial=ended';

            $scope.upgradeButtonClicked = function () {
                window.qr.utils.optimizely.trackOptimizelyEvent('qrapp_trial_expired_banner_upgrade_now_click');
            };
        }]
    };
}]);
;
/**
 * This directive provides an input field for entering app links to varied app stores.
 * e.g. Apple AppStore, Google Play, etc.
 * There's also some search features.
 */
app.directive('qrAppLink', ['$filter', function ($filter) {
    return {
        restrict: 'E',
        require: '?^form',
        template:
            '<div class="qr-app-link">' +
                '<span class="qr-app-link__icon" ng-class="icon"></span>' +
                '<span class="qr-app-link__valid icon-tick" ng-show="isValid()"></span>' +
                '<input type="url" name="{{ name }}" class="qr-app-link__input canHaveError" placeholder="{{ placeholder }}" ng-model="value" ng-required="required">' +
                '<qr-input-error name="{{ name }}" messages="messages" top-offset="{{ errorOffset.top }}" left-offset="{{ errorOffset.left }}"></qr-input-error>' +
                '<button type="button" class="qr-app-link__search-button" ng-click="openSearch()" ng-show="type">' +
                    '{{ searchLabel }}' +
                    '<span class="qr-app-link__chevron" ng-class="isAppSearchOpen ? &apos;icon-up-open-mini&apos; : &apos;icon-down-open-mini&apos;"></span>' +
                '</button>' +
                '<qr-app-search value="value" type="{{ type }}" ng-show="type" open="isAppSearchOpen" right="true" top-offset="25px" placeholder="{{ searchPlaceholder }}"></qr-app-search>' +
            '</div>',
        scope: {
            value: '=',             // App URL.
            name: '@',              // Input field name.
            icon: '@',              // Icon class name.
            type: '@',              // Type of the store: apple, google, amazon.
            required: '=',          // Optional. True if the file is required.
            checkDomain: '@',       // Optional. Domain to check the URL.
            messages: '=',          // Optional. Translations.
            searchLabel: '@',       // Optional. Search button label.
            placeholder: '@',       // Optional. Input field placeholder.
            searchPlaceholder: '@', // Optional. Search input placeholder.
            errorOffset: '='        // Optional. Offset of the error tooltips in format {top: '1px', left: '2px'}.
        },
        link: function (scope, element, attributes, formCtrl) {
            scope.form = formCtrl;

            /**
             * This is used to set custom errors on the input.
             * @param {boolean} validity
             */
            scope.setCustomValidity = function (validity) {
                if (scope.form) {
                    scope.form[scope.name].$setValidity('customError', validity);
                }
            };
        },
        controller: ['$scope', function ($scope) {
            /**
             * @type {boolean}
             */
            $scope.isAppSearchOpen = false;

            /**
             * @type {string}
             */
            $scope.searchLabel = $scope.searchLabel || $scope.messages.search || $filter('translate')('Search');

            // Validate domain, if any.
            $scope.$watch('value', function () {
                if ($scope.checkDomain) {
                    var match = $scope.value.match(/^https?:\/\/([^/]*)/i);
                    if (match && match[1] !== $scope.checkDomain) {
                        $scope.setCustomValidity(false);
                    } else {
                        $scope.setCustomValidity(true);
                    }
                }
            });

            /**
             * Open the search window.
             */
            $scope.openSearch = function () {
                $scope.isAppSearchOpen = !$scope.isAppSearchOpen;
            };

            /**
             * Returns validity of the input.
             * @returns {boolean}
             */
            $scope.isValid = function () {
                return $scope.value && $scope.form && $scope.name in $scope.form && $scope.form[$scope.name].$valid;
            };
        }]
    };
}]);
;
/**
 * This directive displays an image preview, plus the filename and the caption of the image.
 */
app.directive('qrImageItem', ['$filter', '$timeout', 'thumbnailService', function ($filter, $timeout, thumbnailService) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-image-item">' +
                '<div class="qr-image-item__image" ng-style="{backgroundImage: &apos;url(&apos; + imageUrl + &apos;)&apos;}" ng-show="imageUrl"></div>' +
                '<div class="qr-image-item__empty" ng-hide="imageUrl">' +
                    '<div class="qr-image-item__loader"></div>' +
                '</div>' +
                '<input class="qr-image-item__caption" ng-model="image.caption" placeholder="{{ placeholder }}">' +
                '<div class="qr-image-item__name">{{ getImageName() }}</div>' +
                '<i class="qr-image-item__delete icon-action-delete" ng-click="delete()"></i>' +
                '<i class="qr-image-item__up icon-action-up" ng-click="moveUp()" ng-hide="pos == &apos;first&apos;" ng-class="{&apos;qr-image-item__up--centered&apos;: pos == &apos;last&apos;}"></i>' +
                '<i class="qr-image-item__down icon-action-down" ng-click="moveDown()" ng-hide="pos == &apos;last&apos;" ng-class="{&apos;qr-image-item__down--centered&apos;: pos == &apos;first&apos;}"></i>' +
                '<i class="qr-image-item__menu icon-menu-vertical" ng-click="isActionsVisible = !isActionsVisible"></i>' +
                '<qr-popup-menu items="actions" open="isActionsVisible" right="true" top-offset="-2px"></qr-popup-menu>' +
            '</div>',
        scope: {
            image: '=',         // Image in format {url: 'http://...', caption: 'Some label', name: 'file-name.png'}.
            pos: '=',           // first/last/middle, the position of the image inside the list.
            loading: '=',       // Optional. Loading state.
            placeholder: '@',   // Optional placeholder for the input.
            messages: '='       // Translations.
        },
        require: '^^qrImageList',
        link: function (scope, element, attributes, qrImageList) {
            scope.qrImageList = qrImageList;
        },
        controller: ['$scope', function ($scope) {
            $scope.uploadingLabel = $scope.messages.uploading || $filter('translate')('Uploading {percent}%...');
            $scope.placeholder = $scope.placeholder || $scope.messages.placeholder || '';

            /**
             * True if the action menu on the right is visible
             * @type {boolean}
             */
            $scope.isActionsVisible = false;

            /**
             * Image URL for displaying.
             * @type {string}
             */
            $scope.imageUrl = '';

            // Make image loading better. Additionally collect size info.
            $scope.$watch('image.url', function () {
                if (!$scope.image || !$scope.image.url) {
                    $scope.imageUrl = '';
                    return;
                }
                var im = new Image();
                im.onload = function () {
                    $scope.image.width = im.width;
                    $scope.image.height = im.height;
                    // $scope.image.thumbnail = thumbnailService.makeLowQualityThumbnailFromImage(im, 78, 58);
                    $scope.imageUrl = this.src;
                    $scope.$apply();
                };
                // im.crossOrigin = "anonymous"; // This is needed to work with canvas in thumbnailService.
                im.src = $scope.image.url;
            });

            /**
             * Action menu items
             * @type {{}}
             */
            $scope.actions = [
                {
                    label: $scope.messages.moveUp || $filter('translate')('Move Up'),
                    icon: 'action-up',
                    callback: function () {
                        $scope.moveUp();
                    }
                },
                {
                    label: $scope.messages.moveDown || $filter('translate')('Move Down'),
                    icon: 'action-down',
                    callback: function () {
                        $scope.moveDown();
                    }
                },
                {},
                {
                    label: $scope.messages.delete || $filter('translate')('Delete'),
                    icon: 'action-delete',
                    callback: function () {
                        $scope.delete();
                    }
                }
            ];

            /**
             * Delete this item by calling parent's API.
             */
            $scope.delete = function () {
                $timeout(function () {
                    $scope.qrImageList.deleteItem($scope.image.name);
                }, 50);
            };

            /**
             * Move this item up.
             */
            $scope.moveUp = function () {
                $scope.qrImageList.moveItemUp($scope.image.name);
            };

            /**
             * Move this item down.
             */
            $scope.moveDown = function () {
                $scope.qrImageList.moveItemDown($scope.image.name);
            };

            /**
             * Get name of the image, or a progress string, if it's uploading.
             * @returns {string}
             */
            $scope.getImageName = function () {
                if ("progress" in $scope.image && $scope.image.progress > 0 && $scope.image.progress < 100) {
                    return $scope.uploadingLabel.replace('{percent}', Math.ceil($scope.image.progress));
                }
                return $scope.image.name;
            };
        }]
    };
}]);
;
/**
 * This directive displays a list of images for gallery preview.
 */
app.directive('qrImageList', ['$log', function ($log) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-image-list">' +
                '<qr-image-item ng-repeat="image in images track by $index" image="image" messages="messages" pos="getPos($index)"></qr-image-item>' +
            '</div>',
        scope: {
            newFile: '=',       // Attribute for adding new file(s) to the images. Can be an object for one file, or an array for several files.
            images: '=',        // Array of images in format {url: 'http://...', name: 'fileName.jpeg', caption: 'My image'}.
            messages: '='       // Translations.
        },
        controller: ['$scope', function ($scope) {
            $scope.images = $scope.images || [];

            // If newFile is changed then we should add new item(s) to the images list.
            $scope.$watch('newFile', function (newFile) {
                $log.debug({newFile: newFile});
                if (angular.isArray(newFile)) {
                    angular.forEach(newFile, function (file) {
                        $scope.addFile(file);
                    });
                } else if (newFile && "name" in newFile) {
                    $scope.addFile(newFile);
                }
            }, true);

            /**
             * Add new file to the list.
             * @param file
             */
            $scope.addFile = function (file) {
                var index = $scope.findIndexByName(file.name);
                if (index < 0) {
                    index = $scope.images.push({}) - 1;
                }
                $scope.images[index] = angular.extend({}, $scope.images[index], {
                    url: file.url || "",
                    name: file.name,
                    caption: $scope.images[index].caption || "",
                    progress: file.progress || 0
                });
            };

            /**
             * Find image index by name
             * @param {string} name
             * @returns {number}
             */
            $scope.findIndexByName = function (name) {
                for (var index = 0; index < $scope.images.length; ++index) {
                    if ($scope.images[index].name === name) {
                        return index;
                    }
                }
                return -1;
            };

            /**
             * Delete an item by name.
             * It's used as API in the qrImageItem.
             * @param {string} name
             */
            this.deleteItem = function (name) {
                var index = $scope.findIndexByName(name);
                if (index >= 0) {
                    $scope.images.splice(index, 1);
                    $scope.$apply();
                    // After all the images are deleted, it's good to empty newFile to notify qrFileUploader that we're empty.
                    if ($scope.images.length <= 0) {
                        if (angular.isArray($scope.newFile)) {
                            $scope.newFile = [];
                        } else {
                            $scope.newFile = {};
                        }
                    }
                }
            };

            /**
             * Move the item one position up.
             * API for qrImageItem.
             * @param {string} name
             */
            this.moveItemUp = function (name) {
                var index = $scope.findIndexByName(name);
                if (index >= 1) {
                    var item = $scope.images[index];
                    $scope.images.splice(index, 1);
                    $scope.images.splice(index - 1, 0, item);
                }
            };

            /**
             * Move the item one position down.
             * API for qrImageItem.
             * @param {string} name
             */
            this.moveItemDown = function (name) {
                var index = $scope.findIndexByName(name);
                if (index >= 0 && index < $scope.images.length - 1) {
                    var item = $scope.images[index];
                    $scope.images.splice(index, 1);
                    $scope.images.splice(index + 1, 0, item);
                }
            };

            /**
             * Get the position of the current image.
             * It's used to display up/down controls.
             * @param $index
             * @returns {string}
             */
            $scope.getPos = function ($index) {
                if ($index <= 0) {
                    return 'first';
                }
                if ($index >= Object.keys($scope.images).length - 1) {
                    return 'last';
                }
                return 'middle';
            };
        }]
    };
}]);
;
/**
 * Add an attribute 'preload-image' to the img tag to make it begin transparent, then fade in when loaded.
 * Usage: <img ng-src="image.jpg" preload-image>
 */

app.directive('preloadImage', function() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            // Create a new Image object
            var tempImg = new Image();

            // Set initial image
            var imageSrc = attrs.ngSrc;

            // Set initial classes
            element.addClass('image-preload image-preload--preloading');

            if (attrs.preloadImage === 'background') {
                // Wrap image in block
                element.wrap( "<div class='image-preload__wrap placeholder-animation'><div class='image-preload__background image-preload__background--preloading'></div></div>" );
            } else {
                // Wrap image in block
                element.wrap( "<div class='image-preload__wrap placeholder-animation'></div>" );
            }

            // Query to determine the pixel ratio of the device
            var query = "(-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2), (min-resolution: 192dpi)";

            if (matchMedia(query).matches) {
                imageSrc = attrs.retinaImage;
            }

            // Fires when image has fully downloaded
            tempImg.onload = function(){
                if (attrs.preloadImage === 'background') {
                    // Set class to hide image
                    element.addClass('image-preload--hide');

                    // Set backgroung image
                    element.parents(".image-preload__background").css({
                        "background-image": "url("+ imageSrc +")"
                    });

                    // Remove preload classes
                    element.parents(".image-preload__background").removeClass('image-preload__background--preloading');
                }

                // Remove preload classes
                element.removeClass('image-preload--preloading');
                element.parents(".image-preload__wrap").removeClass('placeholder-animation');

                // Delete temporary image
                tempImg = null;
            };

            tempImg.onerror = function() {
                var errorMsg = attrs.errorMsg;
                // Remove preload classes
                element.removeClass('image-preload--preloading');
                element.parents(".image-preload__wrap").removeClass('placeholder-animation');

                element.parent().addClass('image-preload__background--error');

                element.parent().append(
                    '<div class="image-preload__error">' +
                        '<i class="icon icon-image"></i>' +
                        '<p>' + errorMsg + "</p>" +
                    '</div>'
                );
            };

            // Start loading image
            tempImg.src = imageSrc;
        }
    };
});;
app.directive('qrUserInfo', function () {
    return {
        restrict: 'E',
        template:
        '<div class="alert alert-info"  ng-bind-compile="trustedHtml"></div>',
        scope: {
            account: '='
        },
        controller: ['$scope', '$sce', function ($scope, $sce) {


            $scope.copyStringToClipboard =function(str) {
                // Create new element
                var el = document.createElement('textarea');
                // Set value (string to be copied)
                el.value = str;
                // Set non-editable to avoid focus and move outside of view
                el.setAttribute('readonly', '');
                el.style = {position: 'absolute', left: '-9999px'};
                document.body.appendChild(el);
                // Select text inside element
                el.select();
                // Copy text to clipboard
                document.execCommand('copy');
                // Remove temporary element
                document.body.removeChild(el);
            };

            $scope.$watch('account', function() {

                $scope.trialEndDate = "";
                if ($scope.account.trial_date) {
                    var trialDate = $scope.account.trial_date.split(" ");
                    var date = new Date(trialDate[0]);
                    var currentDate = new Date();
                    $scope.trialLeft = Math.ceil((date - currentDate) / (1000 * 3600 * 24)) - 1;
                    $scope.trialEndDate = trialDate[0];
                }

                if ($scope.account.statistics) {
                    if ($scope.account.trial && !$scope.account.payment_open) {
                        $scope.userInfoMessage = "The Free Trial account expires in " + $scope.trialLeft + " days on (<a href='#' ng-click='copyStringToClipboard(\""+$scope.trialEndDate+"\")'>"+$scope.trialEndDate+"</a>). " +
                            "Customer has " + $scope.account.statistics.all + " Dynamic QR Code" +
                            ($scope.account.statistics.all !== 1 ? "s" : "") +
                            " that will be deactivated when free trial ends.";
                    } else {
                        $scope.userInfoMessage = "This is a " + $scope.account.type + " account.<br> Customer has " +
                            $scope.account.statistics.all + " Dynamic QRCode" +
                            ($scope.account.statistics.all !== 1 ? "s" : "") + ".<br> AccountStatus: " +
                            ($scope.account.trial ? "<b style='color:red'>Locked</b>" : "Unlocked") + "<br><b> Is Stripe customer: " +
                            ($scope.account.stripe_id ? "yes</b>" : "no</b>");
                    }
                }

                if ($scope.account.login_disabled) {
                    $scope.userInfoMessage += "<br>Login disabled: <b style='color:red'>yes</b>";
                }

                $scope.trustedHtml = $sce.trustAsHtml($scope.userInfoMessage);


            });
        }]
    };
});
;
/**
 * A button with mutliple qr-choice button for choosing between options.
 */
app.directive('qrMultidropdown', function () {
    return {
        restrict: 'E',
        template:
            '<div class="qr-manage-bar__multidropdown">' +
                '<button type="button" class="qr-choice-button__button" ng-class="getButtonClass()" ng-click="click()">' +
                    '<div class="icon-qr-filters"></div>' +
                    '<span class="qr-choice-button__caret" ng-class="getCaretClass()"></span>' +
                '</button>' +
            '</div>' +
            '<div class="qr-manage-bar__multidropdown__menu" ng-style="!showFilter && {\'max-width\':\'300px\'}" ng-hide="!open">' +
                '<qr-choice-button class="qr-manage-bar__multidropdown__filter" items="filterItems" value="filter" ng-show="showFilter"></qr-choice-button>' +
                '<qr-choice-button class="qr-manage-bar__multidropdown__sort" items="sortItems" right="true" value="sort" ng-class="getSortButtonClass()"></qr-choice-button>' +
            '</div>',
        scope: {
            open: '=',              // Is the panel open? Default: false.
            sortItems: '=',         // Items array in format [{label: 'Label', value: 'Value'}, ...].
            filterItems: '=',       // Items array in format [{label: 'Label', value: 'Value'}, ...].
            filter: '=',            // Current filter.
            sort: '=',              // Current sort mode.
            showFilter: '='         // Show filters or not.
        },
        controller: ['$scope', function ($scope) {
            $scope.getButtonClass = function () {
                return {
                    'qr-choice-button__button--open': $scope.open
                };
            };

            /**
             * Get CSS classes of the caret icon.
             * @returns {*}
             */
            $scope.getCaretClass = function () {
                return {
                    'qr-choice-button__caret--open': $scope.open
                };
            };

            $scope.getSortButtonClass = function () {
               return {
                   'qr-manage-bar__multidropdown__sort--single': !$scope.showFilter
               };
            };

            /**
             * Open the menu.
             */
            $scope.click = function () {
                $scope.open = !$scope.open;
            };
        }]
    };
});
;
/**
 * This directive displays a nice spinner icon to indicate a loading state.
 */
app.directive('qrSpinner', function () {
    return {
        restrict: 'E',
        template: '<div class="qr-spinner" ng-show="loading" ng-style="getStyles()" data-test="{{testEvent}}"></div>',
        scope: {
            loading: '=',           // Loading state (true/false).
            topOffset: '@',         // Optional. The top offset (margin-top) of the spinner. It can be used to adjust the vertical position.
            backgroundColor: '@',   // Optional. A background color to replace the default one.
            size: '@',              // Width and height of the spinner.
            testEvent: '@'          // Event for test-data-attribute
        },
        controller: ['$scope', function ($scope) {
            /**
             * Styles of the spinner element.
             * @returns {*}
             */
            $scope.getStyles = function () {
                return {
                    marginTop: $scope.topOffset,
                    borderTopColor: $scope.backgroundColor,
                    borderRightColor: $scope.backgroundColor,
                    borderBottomColor: $scope.backgroundColor,
                    width: $scope.size,
                    height: $scope.size
                };
            };
        }]
    };
});
;
/**
 * A button with popup menu for choosing between options.
 */
app.directive('qrChoiceButton', function () {
    return {
        restrict: 'E',
        template:
            '<div class="qr-choice-button">' +
                '<button type="button" class="qr-choice-button__button" ng-class="getButtonClass()" ng-click="click()" data-test="manage-qrcode-list-filters">' +
                    '{{ value.label }}' +
                    '<span class="qr-choice-button__caret" ng-class="getCaretClass()"></span>' +
                '</button>' +
                '<qr-popup-menu open="open" items="actions" right="{{ right }}"></qr-popup-menu>' +
            '</div>',
        scope: {
            value: '=',         // Selected value.
            open: '=',          // Is menu open? Default: false.
            items: '=',         // Items array in format [{label: 'Label', value: 'Value'}, ...].
            right: '@',         // true if it should be aligned to the right
            type: '@'           // Optional type/style (small and/or bordered).
        },
        controller: ['$scope', function ($scope) {
            // Set default value.
            $scope.value = $scope.value || angular.extend({}, $scope.items[0]);

            // Sync other fields for default value.
            if (!('label' in $scope.value)) {
                angular.forEach($scope.items, function (item) {
                    if (item.value === $scope.value.value) {
                        angular.extend($scope.value, item);
                    }
                });
            }

            /**
             * Actions for the popup menu.
             * @type {Array}
             */
            $scope.actions = [];

            /**
             * Get button CSS classes.
             * @returns {*}
             */
            $scope.getButtonClass = function () {
                return {
                    'qr-choice-button__button--open': $scope.open,
                    'qr-choice-button__button--small': ('' + $scope.type).indexOf('small') >= 0,
                    'qr-choice-button__button--bordered': ('' + $scope.type).indexOf('bordered') >= 0
                };
            };

            /**
             * Get CSS classes of the caret icon.
             * @returns {*}
             */
            $scope.getCaretClass = function () {
                return {
                    'qr-choice-button__caret--open': $scope.open
                };
            };

            /**
             * Open the menu.
             */
            $scope.click = function () {
                $scope.open = !$scope.open;
            };

            // Sync items with actions.
            $scope.$watch('items', function () {
                $scope.actions = [];
                angular.forEach($scope.items, function (item) {
                    $scope.actions.push(angular.extend({
                        callback: function () {
                            angular.extend($scope.value, item);
                        },
                        selected: function () {
                            return $scope.value && $scope.value.value === item.value;
                        }
                    }, item));
                });
            }, true);
        }]
    };
});
;
/**
 * Directive for displaying QR code image with lazy loading support.
 */
app.directive('qrCodeImage', ['$window', '$timeout', 'account', 'viewport', 'api', function ($window, $timeout, account, viewport, api) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-code-image">' +
                '<img class="qr-code-image__image" ng-src="{{ imageUrl }}" ng-show="imageUrl && !loading" alt="">' +
                '<div class="qr-code-image__spinner" ng-show="loading"><qr-spinner loading="loading" test-event="qrcode-image-spinner"></qr-spinner></div>' +
            '</div>',
        scope: {
            url: '=',       // URL of the QR code image.
            loading: '=',   // Optional flag that the image is currently loading.
            codeId: '=',     // Optional QR code ID for re-generating the image.
            firstImage: '=' //Check if this is the first qr code image on the page
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            /**
             * This variable contains the URL of QR code image.
             * If this variable is not empty, it means that the image is loaded.
             * @type {string}
             */
            $scope.imageUrl = '';

            /**
             * The URL of currently loading image.
             * It's used to avoid starting to load one image several times while it's still loading.
             * @type {string}
             */
            $scope.loadingImageUrl = '';

            /**
             * This is the fallback URL for re-generating QR codes, if they're not available.
             * @type {string}
             */
            $scope.fallbackUrl = api.getUrl('/v1/codes/{id}/refresh-image');

            /**
             * Flag that a fallback image is currently used.
             * @type {boolean}
             */
            $scope.isFallbackImage = false;

            /**
             * Set image URL and stop loading.
             * @param {string} imageUrl
             */
            $scope.setImageUrl = function (imageUrl) {
                $scope.imageUrl = imageUrl;
                $scope.loading = false;
                $scope.loadingImageUrl = '';
            };

            /**
             * Load an image by URL.
             * @param {string} imageUrl
             */
            $scope.loadImage = function (imageUrl) {
                // @todo Move this outside of the component as this component can be used in other places too, not only on the manage view.
                //Bugfix of using previous qr code image, if you create some qr codes in the row
                if($scope.firstImage && $window.location.href.match(/aftercreate=1/))
                {
                    imageUrl = $scope.fallbackUrl.replace('{id}', $scope.codeId);
                }
                if (!imageUrl) {
                    return $scope.setImageUrl('');
                }
                if (imageUrl === $scope.loadingImageUrl) {
                    return;
                }
                $scope.loading = true;
                $scope.loadingImageUrl = imageUrl;
                var image = new Image();
                image.onload = function () {
                    $scope.setImageUrl(this.src);
                    $scope.$apply();
                };
                image.onerror = function () {
                    if ($scope.isFallbackImage) {
                        $scope.setImageUrl('');
                    } else if ($scope.codeId > 0) {
                        $scope.isFallbackImage = true;
                        $scope.loadImage($scope.fallbackUrl.replace('{id}', $scope.codeId));
                    } else {
                        $scope.setImageUrl('');
                    }
                    $scope.$apply();
                };
                image.src = imageUrl;
            };

            // Sync URL and the image.
            $scope.$watch('url', function () {
                if (viewport.isElementVisible($element)) {
                    $scope.loadImage($scope.url);
                } else {
                    // Reset imageUrl. It will be loaded when the element becomes visible.
                    $scope.setImageUrl('');
                    // This is used to check visibility after the element is ready (during initialization).
                    // This is also called when the element becomes visible after loading codes from the server and the url changes,
                    // but the element itself is not visible yet and become visible in a moment after.
                    $timeout(function () {
                        if ($scope.url && !$scope.imageUrl && viewport.isElementVisible($element)) {
                            $scope.loadImage($scope.url);
                        }
                    }, 100);
                }
            });

            // Sync visibility of this QR image and actual element position.
            viewport.onChange(function () {
                if ($scope.url && !$scope.imageUrl && viewport.isElementVisible($element)) {
                    $scope.loadImage($scope.url);
                }
                $scope.$apply(); // For some reason this call must be here, otherwise the changes are applied with delay.
            });

            // When returning to manage view from details need to check the visibility of QR image
            $scope.$watch(function () {
                return account.getCurrentView();
            }, function (newView, oldView) {
                // Determine whether the code is visible when go directly to the details page
                if (!viewport.isElementVisible($element)) { // @todo Check why we should load the image if the component is NOT visible?
                    // if NOT refresh code
                    if ($scope.url && !$scope.imageUrl) {
                        $scope.loadImage($scope.url);
                    }
                }

                // Add timeout to wait the page animation to end
                // Determine if we are returning from details to manage view
                if ('' + oldView === 'insights' && '' + newView === '') {
                    $timeout(function () {
                        if ($scope.url && !$scope.imageUrl && viewport.isElementVisible($element)) {
                            $scope.loadImage($scope.url);
                        }
                    }, 100);
                }
            });
        }]
    };
}]);
;
/**
 * General error modal.
 */
app.directive('qrErrorModal', ['$window', 'gettextCatalog', function ($window, gettextCatalog) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" close-icon="true" auto-close="false">' +
                '<div class="qr-error-modal__content">' +
                    '<img class="qr-error-modal__image" ng-src="{{ getImageSrc() }}">' +
                    '<h1 class="qr-error-modal__title" ng-bind="::title"></h1>' +
                    '<p class="qr-error-modal__message" ng-bind="::message"></p>' +
                '</div>' +
            '</qr-modal>',
        scope: {
            open: '='   // Optional open state of the modal.
        },
        controller: ['$scope', function ($scope) {
            // Translations.
            $scope.title = gettextCatalog.getString('Oops! Something went wrong');
            $scope.message = gettextCatalog.getString('Please try again or contact our support if the problem persists.');

            /**
             * @returns {string}
             */
            $scope.getImageSrc = function () {
                return $scope.open ? $window.CDN_URL+'/img/generator/cody/CodyWhiteBG_Concerned.svg' : '';
            };
        }]
    };
}]);
;
/**
 * General error modal.
 */
app.directive('qrCreateErrorApiModal', ['$window', 'gettextCatalog', function ($window, gettextCatalog) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" close-icon="true" auto-close="false" buttons="::buttons">' +
                '<div class="qr-delete-code-modal__content text-center">' +
                    '<h1 class="qr-error-modal__title" ng-bind="::title"></h1>' +
                    '<p class="qr-error-modal__message" ng-bind="::message"></p>' +
                '</div>' +
            '</qr-modal>',
        scope: {
            open: '='   // Optional open state of the modal.
        },
        controller: ['$scope', function ($scope) {
            // Translations.
            $scope.title = gettextCatalog.getString('Yay, you\'ve found a new feature!');
            $scope.message = gettextCatalog.getString('Unfortunately, it\'s not available to you yet. But not to worry, simply contact us if you\'d like to create your first QR Code API key.');
            $scope.prePopulatedMessage = gettextCatalog.getString('Hey, I like to use your API. Can you please unlock the feature, I like to implemented it in ...');

            /**
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Contact us'),
                    type: 'success',
                    callback: function () {
                        // Open an intercom message with pre-populated message
                        Intercom('showNewMessage', $scope.prePopulatedMessage);
                    }
                },
                {
                    label: gettextCatalog.getString('Learn more'),
                    type: 'link',
                    callback: function () {
                        // Redirect to API web page
                        $window.open('https://www.qr-code-generator.com/qr-code-api/?utm_source=app&utm_medium=link&utm_campaign=qr_code_api_keys&utm_content=tips&utm_term=button_qrcodeapikeys','_blank');
                    }
                }
            ];
        }]
    };
}]);
;
/**
 * This directive displays an input for choosing a color.
 * Moved from "basic_colorpicker.php".
 */
app.directive('qrColor', function () {
    return {
        restrict: 'E',
        template:
            '<div class="qr-color">' +
                '<div class="input-group color-picker colorpicker-element">' +
                    '<input class="form-control" type="text" ng-model="value" ng-model-options="{updateOn: &apos;default blur&apos;}">' +
                    '<span class="input-group-addon">' +
                        '<spectrum-colorpicker options="colorPickerOptions" ng-model="value"></spectrum-colorpicker>' +
                    '</span>' +
                '</div>' +
            '</div>',
        scope: {
            value: '=',         // The chosen color value.
            messages: '='       // Translations.
        },
        controller: ['$scope', function ($scope) {
            $scope.messages = $scope.messages || {};

            /**
             * Options for the color picker directive.
             * @type {{showInput: boolean, className: string, showInitial: boolean, showPalette: boolean, maxPaletteSize: number, clickoutFiresChange: boolean, preferredFormat: string, localStorageKey: string, chooseText: string}}
             */
            $scope.colorPickerOptions = {
                showInput: false,
                className: "full-spectrum",
                showInitial: false,
                showPalette: false,
                maxPaletteSize: 8,
                clickoutFiresChange: true,
                preferredFormat: "hex",
                localStorageKey: "spectrum.demo",
                chooseText: $scope.messages.choose || "Choose"
            };
        }]
    };
});
;
app.directive('qrResources', ['$sce', '$window', 'gettextCatalog', 'markup', '$timeout', function ($sce, $window, gettextCatalog, markup, $timeout) {
    return {
        restrict: 'E',
        template:
        '<div ng-if="!isAbTestEnabled_CNV2467()" class="qr-resources">' +
            '<qr-modal open="open" close-icon="true">' +
                '<iframe id="previewIframe" data-ng-src="{{ url }}"></iframe>' +
            '</qr-modal>' +
            '<div class="qr-resources__resource qr-resources__resource--left" ng-click="!isMobile && openModal(campaignUrl)">' +
                '<i class="icon icon-qr-lightbulb"></i>' +
                '<div class="qr-resources__resource__text" ng-bind-html="::campaignText"></div>' +
            '</div>' +
            '<div class="qr-resources__resource" ng-click="!isMobile && openModal(printUrl)">' +
                '<i class="icon icon-qr-print"></i>' +
                '<div class="qr-resources__resource__text" ng-bind-html="::printText"></div>' +
            '</div>' +
            '<div class="qr-resources__resource qr-resources__resource--right" ng-click="!isMobile && openModal(designUrl)">' +
                '<i class="icon icon-qr-brush"></i>' +
                '<div class="qr-resources__resource__text" ng-bind-html="::designText"></div>' +
            '</div>' +
        '</div>',
        scope: {
        },
        controller: ['$rootScope', '$scope', function ($rootScope, $scope) {
            $scope.open = false;
            $scope.isMobile = ($window.innerWidth < 768);

            $scope.urlParameter = "&utm_source=app_website&utm_medium=managedview&inappusage=true";

            $scope.campaignUrl = "https://www.qr-code-generator.com/examples/?utm_campaign=examples";
            $scope.printUrl = "https://www.qr-code-generator.com/qr-code-marketing/print-qr-codes-correctly/?utm_campaign=print_qr_codes";
            $scope.designUrl = "https://www.qr-code-generator.com/qr-code-marketing/individual-design-of-qr-codes/?utm_campaign=individual_design";

            $scope.campaignText = $sce.trustAsHtml(
                markup.convertToString(
                    gettextCatalog.getString(
                        "Need some inspiration? View our favorite [link={{url}}]QR Code Campaign Examples[/link].",
                        {url: $scope.campaignUrl}
                    ),
                    "qr-resources__resource__link"
                )
            );

            $scope.designText = $sce.trustAsHtml(
                markup.convertToString(
                    gettextCatalog.getString(
                        "Want to get as many scans as possible? [link={{url}}]Check out the How To Design QR Codes Guide[/link].",
                        {url: $scope.designUrl}
                    ),
                    "qr-resources__resource__link"
                )
            );

            $scope.printText = $sce.trustAsHtml(
                markup.convertToString(
                    gettextCatalog.getString(
                        "Ready to go live? Read this [link={{url}}]Top 10 Printing Tips[/link] to get everything right with publishing your Code.",
                        {url: $scope.printUrl}
                    ),
                    "qr-resources__resource__link"
                )
            );

            $scope.url = "";

            $timeout(function () {
                $('.qr-resources__resource__text').find('.qr-resources__resource__link').on('click', function(event) {
                    event.preventDefault();
                    var clickedLink = $(this).attr("href");
                    $scope.openModal(clickedLink);
                    $scope.$apply();
                });
            }, 0);

            $scope.openModal = function (url) {
                if ($scope.isMobile) {
                    $window.open(url + $scope.urlParameter);
                } else {
                    $scope.url = $sce.trustAsResourceUrl(url + $scope.urlParameter);
                    $scope.open = true;
                }
            };

            $rootScope.$on("openModal:update", function () {
                $scope.open = false;
            });

            $scope.$watch("open", function () {
                if ($scope.open === false) {
                    $scope.url = $sce.trustAsResourceUrl("about:blank");
                }
            });

            $scope.isAbTestEnabled_CNV2467 = function() {
                return window.qr.utils.optimizely.isAbTestVariantActive('23988530195', '24017330211');
            };
        }]
    };
}]);
;
/**
 * A modal for mass-creation of QR codes.
 */
app.directive('qrMassCreationModal', ['$window', '$timeout', 'gettextCatalog', 'api', 'account', 'tracking', function ($window, $timeout, gettextCatalog, api, account, tracking) {
    return {
        restrict: 'E',
        template:
            '<qr-modal class="qr-modal_prompt-message" open="state.isMassCreationProgressModal" data-title="{{::progressModalTitleLabel}}" description="{{::progressModalContentLabel}}" buttons="getPromptModalButtons()"></qr-modal>' +
            '<qr-modal class="qr-modal_prompt-message" open="state.isMassCreationStartModal" data-title="{{::creationStartModalTitleLabel}}" description="{{::progressModalContentLabel}}" buttons="getPromptModalButtons()"></qr-modal>' +
            '<qr-modal class="mass-creation__modal qr-modal_center-position qr-modal_center-position-solution" open="state.isMassCreationModal" buttons="getButtons()" close-icon="true">' +
                '<div class="mass-creation__modal-content">' +
                    '<div class="mass-creation__modal-header" data-dragover>' +
                        '<div class="mass-creation__modal-header-content">' +
                            '<h5 class="mass-creation__modal-title">' +
                                '{{::modalTitleLabel}}' +
                                '<span class="label label-default mass-creation__modal-type-label">' +
                                    '<span class="icon mass-creation__modal-type-label-icon" ng-class="typeIcon"></span>' +
                                    '{{typeLabel}}' +
                                '</span>' +
                            '</h5>' +
                            '<p class="mass-creation__modal-description">{{::modalDescriptionLabel}}</p>' +
                            '<div class="mass-creation__modal-file-form mass-creation__modal-file-grid" ng-class="{&apos;mass-creation__modal-file-form_arrow&apos;: state.isArrowDisplayed}">' +
                                '<div class="mass-creation__modal-file-grid-column">' +
                                    '<qr-button-download class-name="btn-block" url="{{templateUrl}}" icon="icon-download-bottom-line" label="{{::downloadCsvLabel}}"></qr-button-download>' +
                                '</div>' +
                                '<div class="mass-creation__modal-file-grid-column">' +
                                    '<qr-file-upload-field class-name="btn-block" uploader-options="uploaderOptions" varname="csv" code-type="{{codeType}}" ng-if="state.isMassCreationModal"></qr-file-upload-field>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="mass-creation__section">' +
                        '<div class="mass-creation__collection">' +
                            '<h5 class="mass-creation__collection-title">' +
                                '{{::selectDesignLabel}}' +
                                '<span class="mass-creation__title-tooltip" data-toggle="tooltip" data-placement="top" title="{{ selectDesignTooltipLabel }}"></span>' +
                            '</h5>' +
                            '<div class="mass-creation__carousel-container" ng-show="!state.loading">' +
                                '<div class="mass-creation__carousel" data-slick-carousel>' +
                                    '<qr-image-tile class="qr-image-tile qr-image-tile--mass-creation" ng-repeat="item in designs track by $index" is-selected="item.id === designTemplateId" image-url="::item.image_url" ng-click="selectDesignTemplate(item)" loading-type="skeleton" is-always-visible="true"></qr-image-tile>' +
                                '</div>' +
                                '<div class="mass-creation__carousel-nav gallery-scroll-btn scroll-right"></div>' +
                                '<div class="mass-creation__carousel-nav gallery-scroll-btn scroll-left"></div>' +
                            '</div>' +
                            '<a href="https://help.qr-code-generator.com/{{appLang}}/articles/3175345" class="mass-creation__design-link" ng-if="state.isCreateDesignLink" target="blank">{{::createDesignLinkLabel}}</a>' +
                            '<div class="skeleton-box skeleton-box--mass-creation-slider" ng-if="state.loading">' +
                                '<div class="skeleton-box__item" ng-repeat="frames in [].constructor(6) track by $index"></div>' +
                            '</div>' +
                        '</div>' +
                        '<div class="mass-creation__collection mass-creation__collection_no-margins">' +
                            '<h5 class="mass-creation__collection-title">{{::pickFolderLabel}}</h5>' +
                            '<qr-dropdown-folders class="dropdown-folder_new-style" value="selectedFolder.id" default-value="0" field-readonly="true" placeholder="{{::pickFolderPlaceholderLabel}}..." ng-if="state.isMassCreationModal"></qr-dropdown-folders>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
            '</qr-modal>',
        scope: {
            open: '=',              // Open state of the modal.
            appLang: '@',           // Application language
            typeIcon: '@',          // Title label icon.
            typeLabel: '@',         // Title label type.
            typeId: '=',            // ID of the QR code type (it's used for sending files to the server).
            codeType: '@',          // A parameter that contains the type of coded to be generated.
            awsCredentials: '=',    // AWS credentials for uploading files.
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            /**
             * Translations.
             */
            $scope.modalTitleLabel = gettextCatalog.getString('Create multiple QR Codes');
            $scope.modalDescriptionLabel = gettextCatalog.getString('Download our ready-made CSV file, fill it with your data and upload the filled file. Check the correctness of your data beforehand.');
            $scope.downloadCsvLabel = gettextCatalog.getString('Download CSV');
            $scope.uploadCsvLabel = gettextCatalog.getString('Upload filled CSV or drop it here');
            $scope.selectDesignLabel = gettextCatalog.getString('Choose a saved design.');
            $scope.selectDesignTooltipLabel = gettextCatalog.getString('This will apply to the QR Codes you are creating.');
            $scope.createDesignLinkLabel = gettextCatalog.getString('Learn to create a new design');
            $scope.pickFolderLabel = gettextCatalog.getString('Pick a folder or create a new one.');
            $scope.pickFolderPlaceholderLabel = gettextCatalog.getString('Choose folder');

            // Already in process modal
            $scope.progressModalTitleLabel = gettextCatalog.getString('The creation process is already underway');
            $scope.progressModalContentLabel = gettextCatalog.getString('As soon as your QR Codes can be downloaded, you will receive an email from us. Even with a large number of QR Codes created, they should be available for download within a few minutes.');

            // Creation process started
            $scope.creationStartModalTitleLabel = gettextCatalog.getString("We're creating your QR Codes now");

            /**
             * Global $scope variables.
             */
            $scope.designTemplateId = 0;
            $scope.isUploadDone = false;
            $scope.fileCsvUrl = '';

            /**
             * ID of the selected folder.
             * @type {*}
             */
            $scope.selectedFolder = {id: 0};

            /**
             * URL of the template to download.
             * @type {string}
             */
            $scope.templateUrl = api.downloadTemplateForCreate($scope.codeType, 'csv');

            /**
             * States of the elements.
             * @type {{
             *      isArrowDisplayed: boolean,
             *      isCreateDesignLink: boolean,
             *      loading: boolean,
             *      isMassCreationModal: boolean,
             *      isMassCreationStartModal: boolean,
             *      isMassCreationProgressModal: boolean
             * }}
             */
            $scope.state = {
                isArrowDisplayed: true,       // Arrow symbol under download and upload buttons.
                isCreateDesignLink: false,    // Learn to create a new design link.
                loading: true,                // Loading designs from the server.
                isMassCreationModal: false,
                isMassCreationStartModal: false,
                isMassCreationProgressModal: false
            };

            /**
             * List of account's designs.
             * @type {Array}
             */
            $scope.designs = [];

            /**
             * Open states of modals.
             * @type {*}
             */
            $scope.show = {
                creationStart: false,
                creationInProgress: false
            };

            /**
             * Array of buttons for the modal.
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Start creating'),
                    disabled: true,
                    callback: function () {
                        if ($scope.isUploadDone && $scope.selectedFolder.id > 0) {
                            var selectedFolderId = parseInt($scope.selectedFolder.id, 10);
                            api.createMultipleCreationJob({
                                type: 'mass_create',
                                folder_id: selectedFolderId,
                                design_template_id: $scope.designTemplateId,
                                file_key: $scope.fileCsvUrl,
                                code_type: $scope.codeType
                            },function () {
                                tracking.trackEvent('action_masscreate');

                                $scope.selectedFolder = {id: 0};
                                $scope.designTemplateId = 0;
                                $scope.fileCsvUrl = '';

                                $scope.state.isMassCreationModal = false;
                                $scope.state.isMassCreationStartModal = true;
                            }, function () {
                                console.log('%c ERROR ', 'color: #FFF; background: #FF5F4A; border-radius: 2px; margin-bottom: 2px;');
                            });

                        }
                    }
                },
                {
                    label: gettextCatalog.getString('Cancel'),
                    type: 'link',
                    callback: function () {
                        $scope.open = false;
                        $scope.state.isMassCreationModal = false;
                    }
                }
            ];

            /**
             * Array of buttons for the progress modal.
             * @type {Array}
             */
            $scope.profressButtons = [
                {
                    label: gettextCatalog.getString('Got it'),
                    callback: function () {
                        $scope.open = false;
                        $scope.state.isMassCreationProgressModal = false;
                        $scope.state.isMassCreationStartModal = false;
                    }
                }
            ];

            /**
             * Returns actual array of buttons for the modal.
             * @returns {Array}
             */
            $scope.getButtons = function () {
                return $scope.buttons;
            };

            /**
             * Returns actual array of buttons for the progress modal.
             * @returns {Array}
             */
            $scope.getPromptModalButtons = function () {
                return $scope.profressButtons;
            };

            /**
             * CSV File Uploader Options
             */
            $scope.uploaderOptions = {
                buttonIcon: 'icon-upload-bottom-line',
                fileTypes: [],
                varname: 'csv',
                fileExt: 'csv',
                accept: '.csv', // File type to accept (e.g. "image/*" or ".pdf" or "image/gif").
                templateType: 'create',
                messages: {
                    upload: gettextCatalog.getString('Upload filled CSV or drop it here'),
                    uploading: gettextCatalog.getString('Uploading'),
                    validating: gettextCatalog.getString('Validating data'),
                    resultSuccess: gettextCatalog.getString('CSV file uploaded'),
                    codeCount: gettextCatalog.getString('{count} QR Code found'),
                    codesCount: gettextCatalog.getString('{count} QR Codes found'),
                    success: gettextCatalog.getString('CSV file uploaded'),
                    codesFound: gettextCatalog.getString('{size} QR Codes found'),
                    formatError: gettextCatalog.getString('Please select a CSV file to upload'),
                    customError: gettextCatalog.getString('Something went wrong. Please try again.'),
                    invalidLineError: gettextCatalog.getString("There's an error in line %s due to invalid characters or missing data."),
                    validateError: gettextCatalog.getString('We are unable to process your file. Please use our CSV file template and fill it out with your data.')
                },
                typeId: $scope.typeId,
                awsCredentials: $scope.awsCredentials,
                customDragover: 'mass-creation__modal-header'   // Use false to set the style for the button itself.
            };

            /**
             * Initialize tooltip submodule
             * To initialize the tooltip, we need a page load timeout
             */
            $timeout(function () {
                $element.find('[data-toggle="tooltip"]').tooltip({animation: false});
            });

            /**
             * Hide arrow icon when using an action to upload or download a file.
             */
            $scope.hideArrow = function () {
                if ($scope.state.isArrowDisplayed) {
                    $scope.state.isArrowDisplayed = false;
                }
            };

            /**
             * Choose design template.
             */
            $scope.selectDesignTemplate = function(item) {
                $scope.designTemplateId = item.id;
            };

            /**
             * Sync uploading status (in case if they're changed somewhere).
             */
            $scope.$on('qr-init-upload-file', function (event, value, fileKey) {
                $scope.isUploadDone = value;
                $scope.fileCsvUrl = fileKey;

                // Hide arrow icon when file validation returns true
                if (value) {
                    $scope.hideArrow();
                }
            });

            /**
             * Sync selected folder (in case if they're changed somewhere).
             */
            $scope.$on('qr-init-folder-id', function (event, id) {
                $scope.selectedFolder.id = id;
            });

            /**
             * Registers a listener callback to be executed whenever the state.isMassCreationModal, state.isMassCreationProgressModal changes.
             * @watchExpression state.isMassCreationModal, state.isMassCreationProgressModal
             * @listener — newValue, oldValue
             */
            $scope.$watch('[state.isMassCreationModal, state.isMassCreationProgressModal]', function (newValue, oldValue) {
                if (!$scope.state.isMassCreationModal || !$scope.state.isMassCreationProgressModal) {
                    $scope.open = false;
                }

                // Run the next section of code only after isMassCreationModal becomes visible
                if ($scope.state.isMassCreationModal) {
                    // API request for a list of users of saved designs
                    api.getDesigns(function (response) {
                        $scope.designs = response.data || [];

                        // Add a custom item to the top of the design list.
                        $scope.designs.unshift({
                            id: 0,
                            "image_url": "/img/qrcode_demo.png"
                        });

                        $scope.state.isCreateDesignLink = response.data.length <= 1;    // If list of designs less than or equal to 1 display design link
                        $scope.state.loading = false;    // Remove skeleton animation

                        // We need to wait a few milliseconds until the modal is displayed after that to start to initialize slider.
                        $timeout(function () {
                            $('[data-slick-carousel]').slick({
                                draggable: false,
                                dots: false,
                                infinite: false,
                                slidesToShow: 6,
                                slidesToScroll: 1,
                                prevArrow: $('.scroll-left'),
                                nextArrow: $('.scroll-right'),
                                variableWidth: true,
                                centerMode: false,
                                responsive: [
                                    {
                                        breakpoint: 1024,
                                        settings: {
                                            slidesToShow: 3,
                                            slidesToScroll: 1
                                        }
                                    },
                                    {
                                        breakpoint: 600,
                                        settings: {
                                            slidesToShow: 2,
                                            slidesToScroll: 1
                                        }
                                    },
                                    {
                                        breakpoint: 480,
                                        settings: {
                                            slidesToShow: 1,
                                            slidesToScroll: 1
                                        }
                                    }
                                ]
                            });
                        }, 200);
                    });

                    $timeout(function () {
                        account.reloadAccount();
                    });
                }

                // When we close the modal isMassCreationProgressModal, we need to reset some variables and slick slider.
                if (newValue[0] === false && oldValue[0] === true) {
                    $scope.designs = [];
                    $scope.designTemplateId = 0;
                    $scope.selectedFolder = {id: 0};
                    $scope.state.isArrowDisplayed = true;
                    $scope.state.isCreateDesignLink = false;
                    $scope.state.loading = true;
                    $scope.buttons[0].disabled = true;
                    $scope.fileCsvUrl = '';
                    $scope.isUploadDone = false;
                    $('[data-slick-carousel]').slick('unslick');
                }
            });

            /**
             * Registers a listener callback to be executed whenever the open changes.
             * @watchExpression open
             * @listener — null
             */
            $scope.$watch('open', function (newOpen, oldOpen) {
                // Run the next section of code only after user call to open mass creation modal
                if ($scope.open) {
                    // API request for a list of active running jobs
                    api.getJobs(function (response) {
                        // Navigate through the keys of the response data
                        // and then check if the value of the keys contains "mass_create"
                        if (response.data.length) {
                            Object.keys(response.data).forEach(function (key) {
                                var values = Object.values(response.data[key]);
                                if (values.indexOf('mass_update') > -1 || values.indexOf('mass_create') > -1) {
                                    $scope.state.isMassCreationProgressModal = true;
                                } else {
                                    $scope.state.isMassCreationModal = true;
                                }
                            });
                        } else {
                            $scope.state.isMassCreationModal = true;
                        }
                    });
                }
            });

            /**
             * Registers a listener callback to be executed whenever the isUploadDone, selectedFolder.id changes.
             * @watchExpression isUploadDone, isUploadDone.id
             * @listener — null
             */
            $scope.$watch('[isUploadDone, selectedFolder.id, fileCsvUrl]', function () {
                if ($scope.isUploadDone && $scope.selectedFolder.id > 0) {
                    $scope.buttons[0].disabled = false;
                }
            });
        }]
    };
}]);
;
/**
 * A modal for mass-downloading of QR codes.
 */
app.directive('qrMassDownloadModal', ['gettextCatalog', 'api', function (gettextCatalog, api) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" data-title="{{ getTitle() }}" buttons="::buttons" close-icon="true">' +
                '<div class="qr-mass-download-modal__content">' +
                    '<button ng-class="getFormatClass(format)" ng-repeat="format in ::formats track by $index" type="button" ng-click="click(format)">' +
                        '{{ format.title }}' +
                        '<span class="qr-mass-download-modal__small">{{ format.smallTitle }}</span>' +
                    '</button>' +
                '</div>' +
            '</qr-modal>',
        scope: {
            open: '=',      // Open state of the modal.
            qrCode: '=',    // QR code data.
            codes: '='      // Array of QR codes IDs, if working with several codes at the same time.
        },
        controller: ['$scope', function ($scope) {
            /**
             * @returns {String}
             */
            $scope.getTitle = function () {
                if ($scope.qrCode || !$scope.codes) {
                    return gettextCatalog.getString('Download QR Code');
                }
                return gettextCatalog.getPlural(
                    $scope.codes.length,
                    'Download 1 QR Code',
                    'Download {{$count}} QR Codes',
                    {}
                );
            };

            /**
             * Array of buttons for the Pause QR Code modal.
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Download'),
                    callback: function () {
                        if (!$scope.selectedFormat) {
                            return;
                        }
                        $scope.open = false;
                        var url, link = document.createElement('a');
                        if ($scope.qrCode) {
                            url = api.getFrameDownloadUrl({
                                qr_code_id: $scope.qrCode.id,
                                frame_name: 'no-frame',
                                image_format: $scope.selectedFormat.format,
                                image_width: 3000,
                                download: true
                            });
                        } else {
                            url = api.getFrameDownloadUrl({
                                qr_codes: $scope.codes, // This is not supported anymore.
                                frame_name: 'no-frame',
                                image_format: $scope.selectedFormat.format,
                                image_width: 3000,
                                download: true
                            });
                        }
                        link.href = url;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    }
                },
                {
                    label: gettextCatalog.getString('Cancel'),
                    type: 'link',
                    callback: function () {
                        $scope.open = false;
                    }
                }
            ];

            /**
             * Array of formats, available for downloading.
             * @type {Array}
             */
            $scope.formats = [
                {
                    title: gettextCatalog.getString('Download PNG'),
                    smallTitle: gettextCatalog.getString('with design'),
                    format: 'PNG'
                },
                // { JPEG works good, but it's disabled, otherwise the second row of buttons has 1 button only.
                //     title: gettextCatalog.getString('Download JPG'),
                //     smallTitle: gettextCatalog.getString('no design'),
                //     format: 'JPG'
                // },
                {
                    title: gettextCatalog.getString('Download SVG'),
                    smallTitle: gettextCatalog.getString('no design'),
                    format: 'SVG'
                }/*,
                { EPS format doesn't work at the moment.
                    title: gettextCatalog.getString('Download EPS'),
                    smallTitle: gettextCatalog.getString('no design'),
                    format: 'EPS'
                }*/
            ];

            /**
             * @type {*}
             */
            $scope.selectedFormat = false;

            /**
             * Select a format for downloading.
             * @param format
             */
            $scope.click = function (format) {
                $scope.selectedFormat = format;
            };

            /**
             * Get CSS classes for formats buttons.
             * @param format
             * @returns {*}
             */
            $scope.getFormatClass = function (format) {
                return {
                    'qr-mass-download-modal__format': true,
                    'qr-mass-download-modal__format--active': format.title === $scope.selectedFormat.title
                };
            };

            // Reset selected format when opening.
            $scope.$watch('open', function () {
                if ($scope.open) {
                    $scope.selectedFormat = false;
                }
            });
        }]
    };
}]);
;
/**
 * A modal for mass-creation of QR codes.
 */
app.directive('qrMassUpdateModal', ['$sce', '$window', '$timeout', 'gettextCatalog', 'api', 'account',  function ($sce, $window, $timeout, gettextCatalog, api, account) {
    return {
        restrict: 'E',
        template:
            '<qr-modal class="qr-modal_prompt-message" open="state.isMassCreationProgressModal" data-title="{{::progressModalTitleLabel}}" description="{{::progressModalContentLabel}}" buttons="getPromptModalButtons()"></qr-modal>' +
            '<qr-modal class="qr-modal_prompt-message" open="state.isMassCreationStartModal" data-title="{{::creationStartModalTitleLabel}}" description="{{::creationStartModalContentLabel}}" buttons="getPromptModalButtons()"></qr-modal>' +
            '<qr-modal class="mass-creation__modal mass-creation__modal--update qr-modal_center-position qr-modal_center-position-solution" open="state.isMassCreationModal" popup-menu-class="{{popupMenuClass}}" buttons="getButtons()" close-icon="true">' +
                '<div class="mass-creation__modal-content">' +
                    '<div class="mass-creation__modal-header" data-dragover>' +
                        '<div class="mass-creation__modal-header-content">' +
                            '<h5 class="mass-creation__modal-title">' +
                                '{{::modalTitleLabel}}' +
                            '</h5>' +
                            '<p class="mass-creation__modal-description">{{::modalDescriptionLabel}}</p>' +
                            '<div class="mass-creation__modal-file-form mass-creation__modal-file-grid" ng-class="{&apos;mass-creation__modal-file-form_arrow&apos;: state.isArrowDisplayed}">' +
                                '<div class="mass-creation__modal-file-grid-column">' +
                                    '<qr-button-download class-name="btn-block" url={{templateUrl}} icon="icon-download-bottom-line" label="{{::downloadCsvLabel}}"></qr-button-download>' +
                                '</div>' +
                                '<div class="mass-creation__modal-file-grid-column">' +
                                    '<qr-file-upload-field class-name="btn-block" uploader-options="uploaderOptions" varname="csv" code-type="{{codeType}}" ng-if="state.isMassCreationModal"></qr-file-upload-field>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                     '<div ng-if="state.isChangeDesign" class="mass-creation__section">' +
                        '<div class="mass-creation__collection">' +
                            '<h5 class="mass-creation__collection-title mass-creation__collection-title--small-margin">' +
                                '{{::selectDesignLabel}}' +
                                '<span class="mass-creation__title-tooltip" data-toggle="tooltip" data-placement="top" title="{{ selectDesignTooltipLabel }}"></span>' +
                            '</h5>' +
                            '<p class="mass-creation__collection-description" ng-bind-html="selectDesignDescription"></p>' +
                            '<div class="mass-creation__carousel-container" ng-show="!state.loading">' +
                                '<div class="mass-creation__carousel" data-slick-carousel>' +
                                    '<qr-image-tile class="qr-image-tile qr-image-tile--mass-creation" ng-repeat="item in designs track by $index" is-selected="item.id === designTemplateId" image-url="::item.image_url" ng-click="selectDesignTemplate(item)" loading-type="skeleton" is-always-visible="true"></qr-image-tile>' +
                                '</div>' +
                                '<div class="mass-creation__carousel-nav gallery-scroll-btn scroll-right"></div>' +
                                '<div class="mass-creation__carousel-nav gallery-scroll-btn scroll-left"></div>' +
                            '</div>' +
                            '<span class="redesign">' +
                                '<a href="" class="mass-creation__design-link" ng-if="state.isCreateDesignLink">{{::createDesignLinkLabel}}</a>' +
                            '</span>' +
                            '<div class="skeleton-box skeleton-box--mass-creation-slider" ng-if="state.loading">' +
                                '<div class="skeleton-box__item" ng-repeat="frames in [].constructor(6) track by $index"></div>' +
                            '</div>' +
                        '</div>' +
                        '<div class="mass-creation__design-action-container">' +
                            '<a href="" class="mass-creation__select-current-design-link" ng-click="selectCurrentDesign()">{{keepCurrentDesign}}</a>' +
                        '</div>' +
                    '</div>' +
                    '<div ng-if="!state.isChangeDesign" class="mass-creation__section mass-creation__section--mobile">' +
                        '<button type="button" class="qr-modal__button qr-modal__button--link qr-modal__button--link-action" ng-click="openDesignSection()">{{::changeDesignButton}}</button>' +
                    '</div>' +
                '</div>' +
            '</qr-modal>',
        scope: {
            open: '=',              // Open state of the modal.
            codeType: '@',          // A parameter that contains the type of coded to be generated.
            folderId: '=',          // Id of the folder to update.
            folderName: '='         // Name of the folder to update.
        },
        controller: ['$scope', '$element', 'aws', function ($scope, $element, aws) {
            /**
             * Translations.
             */
            $scope.modalTitleLabel = gettextCatalog.getString('Bulk update your QR Codes');
            $scope.modalDescriptionLabel = gettextCatalog.getString('Save time by updating multiple QR Codes in one go.\n All you have to do is download the CSV file, update with your data, and upload the updated CSV file. Double-check your data before uploading it to ensure accuracy.');
            $scope.downloadCsvLabel = gettextCatalog.getString('Download CSV');
            $scope.uploadCsvLabel = gettextCatalog.getString('Upload updated CSV or drop it here');
            $scope.selectDesignLabel = gettextCatalog.getString('Choose a saved design.');
            $scope.selectDesignTooltipLabel = gettextCatalog.getString('This will apply to the QR Codes you are updating.');
            $scope.selectDesignDescription = $sce.trustAsHtml('');
            $scope.createDesignLinkLabel = gettextCatalog.getString('Learn to create a new design');
            $scope.pickFolderLabel = gettextCatalog.getString('Pick a folder or create a new one.');
            $scope.pickFolderPlaceholderLabel = gettextCatalog.getString('Choose folder');
            $scope.keepCurrentDesign = gettextCatalog.getString('Keep current design');
            $scope.changeDesignButton = gettextCatalog.getString('Change design?');

            // Already in process modal
            $scope.progressModalTitleLabel = gettextCatalog.getString('We’re still updating your QR Codes');
            $scope.progressModalContentLabel = gettextCatalog.getString('Please wait until your request is completed before starting another bulk update. You will receive an email from us as soon as your QR Codes are ready.');

            // Creation process started
            $scope.creationStartModalTitleLabel = gettextCatalog.getString('We’re updating your QR Codes now');
            $scope.creationStartModalContentLabel = gettextCatalog.getString('You will receive an email from us as soon as your QR Codes are updated and ready to be downloaded. They should be available in a few minutes regardless of the number of QR Codes.');

            /**
             * Global $scope variables.
             */
            $scope.designTemplateId = -1;
            $scope.isUploadDone = false;
            $scope.fileCsvUrl = '';
            $scope.foundCodes = '';
            $scope.popupMenuClass = '';

            /**
             * States of the elements.
             * @type {{
             *      isArrowDisplayed: boolean,
             *      isCreateDesignLink: boolean,
             *      loading: boolean,
             *      isMassCreationModal: boolean,
             *      isMassCreationStartModal: boolean,
             *      isMassCreationProgressModal: boolean
             * }}
             */
            $scope.state = {
                isArrowDisplayed: true,       // Arrow symbol under download and upload buttons.
                isCreateDesignLink: false,    // Learn to create a new design link.
                loading: false,               // Loading designs from the server.
                isMassCreationModal: false,
                isMassCreationStartModal: false,
                isMassCreationProgressModal: false,
                isChangeDesign: false,
            };

            /**
             * List of account's designs.
             * @type {Array}
             */
            $scope.designs = [];

            /**
             * Open states of modals.
             * @type {*}
             */
            $scope.show = {
                creationStart: false,
                creationInProgress: false
            };

            /**
             * Array of buttons for the modal.
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Start updating'),
                    disabled: true,
                    callback: function () {
                        if ($scope.isUploadDone) {
                            api.createMultipleCreationJob({
                                type: 'mass_update',
                                design_template_id: $scope.designTemplateId,
                                file_key: $scope.fileCsvUrl,
                                code_type: $scope.codeType,
                                folder_id: $scope.folderId,
                            },function () {
                                $scope.designTemplateId = -1;
                                $scope.fileCsvUrl = '';

                                $scope.state.isMassCreationModal = false;
                                $scope.state.isMassCreationStartModal = true;
                            }, function () {
                                console.log('%c ERROR ', 'color: #FFF; background: #FF5F4A; border-radius: 2px; margin-bottom: 2px;');
                            });

                        }
                    }
                },
                {
                    label: gettextCatalog.getString('Cancel'),
                    type: 'link',
                    callback: function () {
                        $scope.open = false;
                        $scope.state.isMassCreationModal = false;
                    }
                },
            ];

            var changeDesignButton = {
                label: gettextCatalog.getString('Change design?'),
                type: 'link-action',
                callback: function () {
                    $scope.state.isChangeDesign = true;
                }
            };

            $scope.buttons.push(changeDesignButton);

            /**
             * Array of buttons for the progress modal.
             * @type {Array}
             */
            $scope.progressButtons = [
                {
                    label: gettextCatalog.getString('Got it'),
                    callback: function () {
                        $scope.open = false;
                        $scope.state.isMassCreationProgressModal = false;
                        $scope.state.isMassCreationStartModal = false;
                    }
                }
            ];

            /**
             * Returns actual array of buttons for the modal.
             * @returns {Array}
             */
            $scope.getButtons = function () {
                return $scope.buttons;
            };

            /**
             * Returns actual array of buttons for the progress modal.
             * @returns {Array}
             */
            $scope.getPromptModalButtons = function () {
                return $scope.progressButtons;
            };

            /**
             * CSV File Uploader Options
             */
            $scope.uploaderOptions = {
                buttonIcon: 'icon-upload-bottom-line',
                fileTypes: [],
                varname: 'csv',
                fileExt: 'csv',
                accept: '.csv',
                templateType: 'update',
                messages: {
                    upload: gettextCatalog.getString('Upload updated CSV or drop it here'),
                    uploading: gettextCatalog.getString('Uploading'),
                    validating: gettextCatalog.getString('Validating data'),
                    resultSuccess: gettextCatalog.getString('CSV file uploaded'),
                    codeCount: gettextCatalog.getString('{count} QR Code updated'),
                    codesCount: gettextCatalog.getString('{count} QR Codes updated'),
                    success: gettextCatalog.getString('CSV file uploaded'),
                    codesFound: gettextCatalog.getString('{size} QR Codes updated'),
                    formatError: gettextCatalog.getString('Please select a CSV file to upload'),
                    userRestrictionError: gettextCatalog.getString('Only 5 QR Codes can be updated at a time. Reduce the number of QR Codes in the file and reupload or upgrade your account to unlock unlimited access.'),
                    customError: gettextCatalog.getString('Something went wrong. Please try again.'),
                    invalidLineError: gettextCatalog.getString("There's an error in line %s due to invalid characters or missing data."),
                    validateError: gettextCatalog.getString('We are unable to process your file. Please use our CSV file template and fill it out with your data.')
                },
                awsCredentials: aws.getCredentials(),
                customDragover: 'mass-creation__modal-header'   // Use false to set the style for the button itself.
            };

            /**
             * Hide arrow icon when using an action to upload or download a file.
             */
            $scope.hideArrow = function () {
                if ($scope.state.isArrowDisplayed) {
                    $scope.state.isArrowDisplayed = false;
                }
            };

            /**
             * Choose design template.
             */
            $scope.selectDesignTemplate = function(item) {
                $scope.designTemplateId = item.id;
            };

            /**
             * Reset design selection.
             */
            $scope.selectCurrentDesign = function() {
                $scope.designTemplateId = -1;
                $scope.state.isChangeDesign = false;
                $('[data-slick-carousel]').slick('slickGoTo', 0);
            };

            /**
             * Open select design section
             */
            $scope.openDesignSection = function() {
                $scope.state.isChangeDesign = true;
            };

            /**
             * Sync uploading status (in case if they're changed somewhere).
             */
            $scope.$on('qr-init-upload-file', function (event, value, fileKey) {
                $scope.isUploadDone = value;
                $scope.fileCsvUrl = fileKey;

                // Hide arrow icon when file validation returns true
                if (value) {
                    $scope.hideArrow();
                }
            });

            /**
             * Registers a listener callback to be executed whenever the state.isMassCreationModal, state.isMassCreationProgressModal changes.
             * @watchExpression state.isMassCreationModal, state.isMassCreationProgressModal
             * @listener — newValue, oldValue
             */
            $scope.$watch('[state.isMassCreationModal, state.isMassCreationProgressModal, state.isChangeDesign]', function (newValue, oldValue) {
                if ($scope.state.isChangeDesign) {
                    $scope.buttons = $scope.buttons.slice(0, 2);

                    $timeout(function () {
                        $element.find('[data-toggle="tooltip"]').tooltip({animation: false});
                    });
                } else if(!$scope.state.isChangeDesign && $scope.buttons.length !== 3) {
                    $scope.buttons.push(changeDesignButton);
                }

                if (!$scope.state.isMassCreationModal || !$scope.state.isMassCreationProgressModal) {
                    $scope.open = false;
                }

                // Run the next section of code only after isMassCreationModal becomes visible
                if ($scope.state.isMassCreationModal) {
                    // API request for a list of users of saved designs
                    api.getDesigns(function (response) {
                        $scope.designs = response.data || [];

                        // Add a custom item to the top of the design list.
                        $scope.designs.unshift({
                            id: 0,
                            "image_url": "/img/qrcode_demo.png"
                        });

                        $scope.state.isCreateDesignLink = response.data.length <= 1;    // If list of designs less than or equal to 1 display design link
                        $scope.state.loading = false;    // Remove skeleton animation

                        // We need to wait a few milliseconds until the modal is displayed after that to start to initialize slider.
                        $timeout(function () {
                            $('[data-slick-carousel]').slick({
                                draggable: false,
                                dots: false,
                                infinite: false,
                                slidesToShow: 6,
                                slidesToScroll: 1,
                                prevArrow: $('.scroll-left'),
                                nextArrow: $('.scroll-right'),
                                variableWidth: true,
                                centerMode: false,
                                responsive: [
                                    {
                                        breakpoint: 1024,
                                        settings: {
                                            slidesToShow: 3,
                                            slidesToScroll: 1
                                        }
                                    },
                                    {
                                        breakpoint: 600,
                                        settings: {
                                            slidesToShow: 2,
                                            slidesToScroll: 1
                                        }
                                    },
                                    {
                                        breakpoint: 480,
                                        settings: {
                                            slidesToShow: 1,
                                            slidesToScroll: 1
                                        }
                                    }
                                ]
                            });
                        }, 200);
                    });
                }

                // When we close the modal isMassCreationProgressModal, we need to reset some variables and slick slider.
                if (newValue[0] === false && oldValue[0] === true) {
                    $scope.designs = [];
                    $scope.designTemplateId = -1;
                    $scope.state.isArrowDisplayed = true;
                    $scope.state.isCreateDesignLink = false;
                    $scope.state.loading = true;
                    $scope.state.isChangeDesign = false;
                    $scope.buttons[0].disabled = true;
                    $scope.fileCsvUrl = '';
                    $scope.isUploadDone = false;
                    $scope.selectDesignDescription = $sce.trustAsHtml('');
                    $('[data-slick-carousel]').slick('unslick');
                }
            });

            /**
             * Registers a listener callback to be executed whenever the open changes.
             * @watchExpression open
             * @listener — null
             */
            $scope.$watch('open', function (newOpen, oldOpen) {
                // Run the next section of code only after user call to open mass creation modal
                if ($scope.open) {
                    // API request for a list of active running jobs
                    api.getJobs(function (response) {
                        // Navigate through the keys of the response data
                        // and then check if the value of the keys contains "mass_update"
                        if (response.data.length) {
                            Object.keys(response.data).forEach(function (key) {
                                var values = Object.values(response.data[key]);
                                if (values.indexOf('mass_update') > -1 || values.indexOf('mass_create') > -1) {
                                    $scope.state.isMassCreationProgressModal = true;
                                } else {
                                    $scope.state.isMassCreationModal = true;
                                }
                            });
                        } else {
                            $scope.state.isMassCreationModal = true;
                        }
                    });
                }
            });

            /**
             * Registers a listener callback to be executed whenever the isUploadDone changes.
             * @watchExpression isUploadDone, isUploadDone.id
             * @listener — null
             */
            $scope.$watch('[isUploadDone, fileCsvUrl]', function () {
                if ($scope.isUploadDone) {
                    $scope.buttons[0].disabled = false;
                }
            });

            $scope.$watch('folderId', function(newFolderId, oldFolderId) {
                $scope.templateUrl = api.downloadTemplateForUpdate('d_url', 'csv', $scope.folderId);
            });

            $scope.$watch('state.isChangeDesign', function() {
                $scope.popupMenuClass = $scope.state.isChangeDesign ? 'qr-popup--full-screen' : '';
            });

            $scope.$on('qr-found-codes-count', function (event, count) {
                var folderHTML = '<span class="icon mass-creation__collection-description__label-icon icon-qr-folder"></span>' + $scope.folderName;

                var description = gettextCatalog.getString('The design of all <strong>{count}</strong> QR Codes in {folderHTML} will be changed.')
                    .replace('{count}', count)
                    .replace('{folderHTML}', folderHTML);

                $scope.selectDesignDescription = $sce.trustAsHtml(description);
            });
        }]
    };
}]);
;
/**
 * Vertical tabs component.
 */
app.directive('qrVerticalTabs', ['$timeout', function ($timeout) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-vertical-tabs" ng-class="{&apos;qr-vertical-tabs--full-height&apos;: fullHeight === &apos;true&apos;}">' +
                '<button type="button" class="qr-vertical-tabs__tab" ng-repeat="tab in tabs track by $index" ng-click="click(tab, $index)" ng-class="getClass(tab, $index)" ng-style="getStyle()" ng-show="isVisible(tab)" data-tab-id="{{ tab.id }}">' +
                    '<span class="qr-vertical-tabs__icon" ng-class="tab.icon" ng-show="tab.icon"></span>' +
                    '{{ tab.label }}' +
                '</button>' +
            '</div>',
        scope: {
            tabs: '=',      // Array of tab items.
            activeTab: '=', // ID of currently active tab.
            fullHeight: '@' // Set to "true" to enable full height.
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            /**
             * On click handler.
             * @param tab
             * @param {number} index
             */
            $scope.click = function (tab, index) {

                if ($scope.activeTab !== tab.id) {
                    $element.find('[data-tab-id = ' + $scope.activeTab + ']').removeClass('qr-vertical-tabs__tab--disableAnimation');

                    $scope.activeTab = "id" in tab ? tab.id : index;

                    $timeout(function () {
                        $element.find('[data-tab-id = ' + tab.id + ']').addClass('qr-vertical-tabs__tab--disableAnimation');
                    }, 400);
                }
            };

            /**
             * Get CSS classes for tabs.
             * @param tab
             * @param index
             * @returns {*}
             */
            $scope.getClass = function (tab, index) {
                return {
                    'qr-vertical-tabs__tab--active': $scope.activeTab === ("id" in tab ? tab.id : index),
                    'qr-vertical-tabs__tab--notification': ("notification" in tab ? tab.notification() : false),
                };
            };

            /**
             * Get CSS styles for tabs.
             * @returns {{height: string}}
             */
            $scope.getStyle = function () {
                var visibleTabs = 0;

                angular.forEach($scope.tabs, function (tab) {
                    visibleTabs += $scope.isVisible(tab);
                });

                return {
                    height: (visibleTabs > 0 ? 100 / visibleTabs : 100) + '%'
                };
            };

            /**
             * Check if the tab is visible.
             * @param tab
             */
            $scope.isVisible = function (tab) {
                return "visible" in tab ? tab.visible() : true;
            };
        }]
    };
}]);
;
/**
 * Component for choosing colors.
 * [ ] It's based on https://simonwep.github.io/pickr/
 * [x] It's based on https://ruhley.github.io/angular-color-picker/
 */
app.directive('qrColorPicker', ['gettextCatalog', '$timeout', function (gettextCatalog, $timeout) {
    'use strict';
    return {
        restrict: 'E',
        template:
            '<qr-popup open="open" auto-close="true" no-padding="true" visible-layer="false">' +
                '<div class="qr-color-picker">' +
                    '<div class="qr-color-picker__picker">' +
                        '<color-picker ng-model="value" options="options" api="api" event-api="eventApi"></color-picker>' +
                    '</div>' +
                    '<div class="qr-color-picker__palette"></div>' +
                '</div>' +
            '</qr-popup>',
        scope: {
            open: '=',      // Open state.
            value: '='      // Color value in format #RRGGBB.
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            $scope.options = {
                required: false,
                disabled: false,
                placeholder: '',
                inputClass: '',
                id: undefined,
                name: undefined,
                // validation
                restrictToFormat: false,
                preserveInputFormat: true,
                allowEmpty: false,
                // color
                format: 'hexString',
                case: 'lower',
                // sliders
                hue: true,
                saturation: false,
                lightness: false,
                alpha: false,
                dynamicHue: false,
                dynamicSaturation: false,
                dynamicLightness: false,
                dynamicAlpha: false,
                // swatch
                swatch: true,
                swatchPos: 'left',
                swatchBootstrap: false,
                swatchOnly: false,
                // popup
                round: false,
                pos: 'bottom right',
                inline: true,
                horizontal: false,
                // show/hide
                show: {
                    swatch: true,
                    focus: true
                },
                hide: {
                    blur: false,
                    escape: false,
                    click: false
                },
                // buttons
                close: {
                    show: false,
                    label: 'Close',
                    class: ''
                },
                clear: {
                    show: false,
                    label: 'Clear',
                    class: ''
                },
                reset: {
                    show: false,
                    label: 'Reset',
                    class: ''
                },
            };

            // $timeout(function () {
                // var picker = new Pickr({
                //     el: $element.find('.qr-color-picker__picker')[0],
                //     parent: $element.find('.qr-color-picker__picker')[0],
                //     useAsButton: true,
                //     comparison: true,
                //     default: 'f00',
                //     defaultRepresentation: 'HEX',
                //     showAlways: true,
                //     appendToBody: false,
                //     closeWithKey: 'Escape',
                //     position: 'middle',
                //     adjustableNumbers: true,
                //     strings: {
                //         save: gettextCatalog.getString('Save'),
                //         clear: gettextCatalog.getString('Clear')
                //     },
                //     components: {
                //         preview: false,
                //         opacity: false,
                //         hue: true,
                //         interaction: {
                //             hex: false,
                //             rgba: false,
                //             hsla: false,
                //             hsva: false,
                //             cmyk: false,
                //             input: true,
                //             clear: false,
                //             save: true
                //         }
                //     }
                // });
            // });
        }]
    };
}]);
;
/**
 * @ngdoc directive
 * @name app.directive:qrColorSpot
 * @restrict E
 * @scope
 * @description
 *
 * Component for displaying a color (without an input).
 *
 * @param {string} value Current color value in format '#RRGGBB'.
 * @param {array} palette Palette in format ['#RRGGBB', '#RRGGBB', ...].
 * @param {boolean=} active Is it active at the moment?
 * @param {boolean=} deleting Is it delete mode now?
 * @param {string=} newValue This is set during choosing of new color, but before it's set to value.
 * @param {boolean=} showPlus If true, this component displays (+) sign in the center of the color picker.
 * @param {string=} fullSpectrumPosition You can choose which element the colorpicker container is appended to (default is "body").
 *
 * @example
 * <example module="app">
 *     <file name="index.html">
 *          <qr-color-spot value="'#ff0000'" palette="['#ff0000', '#00ff00', '#0000ff']" deleting="true"></qr-color-spot>
 *     </file>
 * </example>
 */
app.directive('qrColorSpot', ['$timeout', 'gettextCatalog', function ($timeout, gettextCatalog) {
    "use strict";
    return {
        restrict: 'E',
        template:
            '<div class="qr-color-spot" ng-class="{&apos;qr-color-spot--active&apos;: isActive()}">' +
                '<button type="button" class="qr-color-spot__button" ng-click="pickColor()">' +
                    '<span class="qr-color-spot__spot" ng-style="{backgroundColor: getDisplayColor()}" ng-hide="isColorPickerVisible()"></span>' +
                    '<span class="qr-color-spot__picker" ng-show="isColorPickerVisible()" ng-class="{&apos;qr-color-spot__picker--open&apos;: colorPickerIsOpen, &apos;qr-color-spot__picker--plus&apos;: showPlus}"></span>' +
                    '<spectrum-colorpicker ng-if="isColorPickerVisible()" data-ng-model="newValueFunc" ng-model-options="{getterSetter: true}" options="pickerOptions" on-show="startPicking()" on-hide="endPicking(color)"></spectrum-colorpicker>' +
                '</button>' +
                '<button class="qr-color-spot__delete" ng-if="isDeleteVisible()" ng-click="deleteColor()">&times;</button>' +
            '</div>',
        scope: {
            value: '=',
            palette: '=',
            active: '=',
            deleting: '=',
            newValue: '=',
            showPlus: '=',
            fullSpectrumPosition: '='
        },
        link: function (scope, element) {
            /**
             * Opens/closes the color picker.
             */
            scope.toggleColorPicker = function () {
                $timeout(function () {
                    angular.element('body').find('.qr-full-spectrum').find('input').attr('placeholder', '#000000');
                    element.find('input').spectrum('toggle');
                });
            };

            /**
             * Update palette in the color picker.
             * @param palette
             */
            scope.updateColorPickerPalette = function (palette) {
                element.find('input').spectrum('option', 'palette', palette);
            };
        },
        controller: ['$scope', function ($scope) {




            /**
             * Converts all supported formats to HTML color format.
             * @param value
             * @returns {string}
             */
            function valueToColor(value) {
                if (!value) {
                    return '';
                }
                return '' + value;
            }

            /**
             * Function to use as a NG model for newValue.
             * @param [newVal]
             * @returns {string}
             */
            $scope.newValueFunc = function (newVal) {
                return arguments.length ? $scope.newValue = newVal : $scope.newValue;
            };

            /**
             * Settings of the spectrum color picker.
             * @type {*}
             */
            $scope.pickerOptions = {
                allowEmpty: true,
                chooseText: gettextCatalog.getString('Choose'),
                className: 'full-spectrum qr-full-spectrum spectrum--rounded',
                clickoutFiresChange: true,
                localStorageKey: 'spectrum.demo',
                maxPaletteSize: 8,
                preferredFormat: 'hex',
                showAlpha: false,
                showInitial: true,
                showInput: true,
                showPalette: !!$scope.palette,
                palette: $scope.palette,
                showSelectionPalette: false,
                maxSelectionSize: 0,
                selectionPalette: []
            };

            // If we set appendTo through the full-spectrum-position, we add the spectrum to a specific block, otherwise the default is body
            $scope.fullSpectrumPosition ? $scope.pickerOptions.appendTo = $scope.fullSpectrumPosition : $scope.pickerOptions.appendTo = 'body';

            // Sync palette with color picker.
            $scope.$watch('palette', function () {
                $scope.pickerOptions.palette = $scope.palette;
                $scope.updateColorPickerPalette($scope.palette);
            }, true);

            /**
             * Open state for the color picker.
             * @type {boolean}
             */
            $scope.colorPickerIsOpen = false;

            /**
             * This will be called when the color picker opens.
             */
            $scope.startPicking = function () {
                $scope.newValue = '';
                $scope.colorPickerIsOpen = true;
            };

            /**
             * This will be called when the color picker closes.
             * @param {string} color
             */
            $scope.endPicking = function (color) {
                if ($scope.newValue) {
                    $scope.value = $scope.newValue;
                }
                $scope.newValue = '';
                $scope.colorPickerIsOpen = false;
            };

            /**
             * It makes the color active or open the color picker.
             */
            $scope.pickColor = function () {
                if ($scope.isColorPickerVisible()) {
                    if (!$scope.colorPickerIsOpen) {
                        $scope.toggleColorPicker();
                    }
                } else {
                    if (typeof $scope.active === 'boolean') {
                        $scope.active = true;
                    } else {
                        $scope.active = valueToColor($scope.value);
                    }
                }
            };

            /**
             * Returns a display color for HTML style attribute.
             * @returns {string}
             */
            $scope.getDisplayColor = function () {
                return valueToColor($scope.value);
            };

            /**
             * Controls visibility of the color picker.
             * @returns {boolean}
             */
            $scope.isColorPickerVisible = function () {
                return !valueToColor($scope.value);
            };

            /**
             * Returns true if the color is active at the moment.
             * @returns {boolean}
             */
            $scope.isActive = function () {
                if (typeof $scope.active === 'boolean') {
                    return $scope.active === true;
                }
                if ($scope.isColorPickerVisible()) {
                    return false;
                }
                return valueToColor($scope.active) === valueToColor($scope.value);
            };

            /**
             * Clear this color.
             */
            $scope.deleteColor = function () {
                $scope.value = '';
            };

            /**
             * Returns true if the delete button is visible.
             * @returns {boolean}
             */
            $scope.isDeleteVisible = function () {
                return $scope.deleting && !$scope.isColorPickerVisible();
            };
        }]
    };
}]);
;
/**
 * Component for displaying a color palette.
 */
app.directive('qrColorPalette', [function () {
    "use strict";
    return {
        restrict: 'E',
        template:
            '<div class="qr-color-palette">' +
                '<qr-color-spot class="qr-color-palette__color" ng-repeat="color in colors track by $index" value="colors[$index]" deleting="($index < readOnlyLength || color === data.active) ? false : deleting" active="data.active"></qr-color-spot>' +
                '<qr-color-spot class="qr-color-palette__color" value="addColor" show-plus="!maxColors || colors.length < maxColors - 1" new-value="newColor" palette="colors" full-spectrum-position="fullSpectrumPosition"></qr-color-spot>' +
            '</div>',
        scope: {
            colors: '=',                 // Values of colors.
            active: '=',                 // Is it active at the moment? (string, color value)
            deleting: '=',               // Is it delete mode now?
            maxColors: '@',              // Max number of colors in the palette.
            newColor: '=',               // This is set during choosing of new color, but before it's added to the palette.
            readOnlyLength: '@',         // Length of group of read-only colors (1 for one color. counts from the first left color).
            fullSpectrumPosition: '='    // Spectrum position
        },
        controller: ['$scope', function ($scope) {
            /**
             * Variable for adding new colors.
             * @type {string}
             */
            $scope.addColor = '';

            // Initialize the active state with the first color in the palette.
            $scope.data = {
                active: $scope.active || $scope.colors[0] || ''
            };

            // Sync active values.
            $scope.$watch('data.active', function () {
                $scope.active = $scope.data.active;
            });

            $scope.$watch('active', function () {
                $scope.data.active = $scope.active;
            });

            // Remove empty colors from the palette (it happens when user deletes a color).
            $scope.$watch('colors', function () {
                angular.forEach($scope.colors, function (color, index) {
                    if (!color) {
                        $scope.colors.splice(index, 1);
                    }
                });
            }, true);

            // Color adding logic.
            $scope.$watch('addColor', function () {
                // Remove empty values.
                if (!$scope.addColor) {
                    $scope.addColor = '';
                    return;
                }
                // Check max allowed size of the palette.
                if ($scope.maxColors && $scope.colors.length >= $scope.maxColors - 1) {
                    $scope.data.active = $scope.addColor;
                    $scope.addColor = '';
                    return;
                }
                // Remove duplicated values, but make that colors active.
                if ($scope.colors.indexOf($scope.addColor) < 0) {
                    $scope.colors.push($scope.addColor);
                }
                $scope.data.active = $scope.addColor;
                $scope.addColor = '';
            });
        }]
    };
}]);
;
/**
 * Small button that can toggle between two states.
 */
app.directive('qrToggle', function () {
    return {
        restrict: 'E',
        template:
            '<button type="button" class="qr-toggle" ng-click="value = !value" ng-class="{&apos;qr-toggle--toggled&apos;: value}">' +
                '<span class="qr-toggle__state" ng-bind="falseLabel" ng-class="{&apos;qr-toggle__state--active&apos;: !value}" ng-style="getStyles()"></span>' +
                '<span class="qr-toggle__state" ng-bind="trueLabel" ng-class="{&apos;qr-toggle__state--active&apos;: value}" ng-style="getStyles()"></span>' +
            '</button>',
        scope: {
            value: '=',         // Boolean state of the toggle.
            falseLabel: '@',    // Label for the first "false" state.
            trueLabel: '@'      // Label for the second "true" state.
        },
        link: function (scope) {
            // This function adjusts widths of the toggle parts.
            scope.getStyles = function () {
                return {
                    minWidth: Math.max(scope.falseLabel.length, scope.trueLabel.length) / 2 + 2 + 'em'
                };
            };
        }
    };
});
;
/**
 * A modal for Salesforce support-form.
 */
app.directive('qrSupportModal', ['$window', 'gettextCatalog', '$timeout', '$filter', function ($window, gettextCatalog, $timeout, $filter) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" popup-menu-class="qr-support-modal" auto-close="false" top-offset="20px">' +
                '<i class="qr-popup__close-icon icon-thin-close" ng-click="closeWindow()"></i>' +
                '<form name="form" class="qr-support-modal__content" novalidate>' +
                    '<div class="qr-support-modal-head">' +
                        '<h4 class="qr-support-modal-head__header">{{headerTitle}}</h4>' +
                        '<p class="qr-support-modal-head__description">{{headerDescription}}</p>' +
                    '</div>' +

                    '<div class="control-group control-group--pr-4 col-sm-6">' +
                        '<label class="control-label" for="firstName">{{firstName}}</label>' +
                        '<input class="qr-support-modal__input" type="text" name="firstName" ng-model="user.firstName" ng-maxlength="50" required />' +
                        '<div class="support-modal__error" ng-if="submitted && form.firstName.$error.required">{{errorRequired}}</div>' +
                        '<div class="support-modal__error" ng-if="submitted && form.firstName.$error.maxlength">{{errorMaxlength50}}</div>' +
                    '</div>' +

                    '<div class="control-group col-sm-6">' +
                        '<label class="control-label" for="lastName">{{lastName}}</label>' +
                        '<input class="qr-support-modal__input" type="text" name="lastName" ng-model="user.lastName" ng-maxlength="50" required />' +
                        '<div class="support-modal__error" ng-if="submitted && form.lastName.$error.required">{{errorRequired}}</div>' +
                        '<div class="support-modal__error" ng-if="submitted && form.lastName.$error.maxlength">{{errorMaxlength50}}</div>' +
                    '</div>' +

                    '<div class="control-group">' +
                        '<label class="control-label" for="email">{{email}}</label>' +
                        '<input class="qr-support-modal__input" type="email" name="email" ng-model="user.email"/>' +
                    '</div>' +

                    '<div class="control-group">' +
                        '<label class="control-label" for="supportLanguage">{{language}}</label>' +
                        '<div class="actionsContainer dropdown-container support-modal__dropdown" id="supportLanguage">' +
                            '<div class="btn-group-actions position-relative">' +
                                '<a id="supportLanguageDrop" class="dropdown-selected dropdown" data-toggle="dropdown">' +
                                    '<span ng-if="user.languageKey" class="dark-semibold">' +
                                        '{{user.languageKey}}' +
                                    '</span>' +
                                    '<span ng-if="!user.languageKey">{{languageSelect}}</span>' +
                                '</a>' +
                                '<button class="dropdown-toggle billing-button" data-toggle="dropdown">' +
                                    '<i class="caret"></i>' +
                                '</button>' +
                                '<ul class="dropdown-menu always-visible">' +
                                    '<li ng-repeat="lang in ::languages">' +
                                        '<a ng-click="supportModalLangDropdownSelect(lang.value, lang.key)">{{lang.value}}</a>' +
                                    '</li>' +
                                '</ul>' +
                            '</div>' +
                        '</div>' +
                        '<div class="support-modal__error" ng-if="submitted && !user.languageKey">{{errorRequired}}</div>' +
                    '</div>' +

                    '<div class="control-group">' +
                        '<label class="control-label" for="supportTopic">{{supportTopic}}</label>' +
                        '<div class="actionsContainer dropdown-container support-modal__dropdown" id="supportTopic">' +
                            '<div class="btn-group-actions position-relative">' +
                                '<a id="supportTopicDrop" class="dropdown-selected dropdown" data-toggle="dropdown">' +
                                    '<span ng-if="user.topicKey" class="dark-semibold">' +
                                        '{{user.topicKey}}' +
                                    '</span>' +
                                    '<span ng-if="!user.topicKey">{{topicSelect}}</span>' +
                                '</a>' +
                                '<button class="dropdown-toggle billing-button" data-toggle="dropdown">' +
                                    '<i class="caret"></i>' +
                                '</button>' +
                                '<ul class="dropdown-menu always-visible">' +
                                    '<li ng-repeat="topic in ::topics">' +
                                        '<a ng-click="supportModalTopicDropdownSelect(topic.value, topic.key)">{{topic.value}}</a>' +
                                    '</li>' +
                                '</ul>' +
                            '</div>' +
                        '</div>' +
                        '<div class="support-modal__error" ng-if="submitted && !user.topicKey">{{errorRequired}}</div>' +
                    '</div>' +

                    '<div class="control-group">' +
                        '<label class="control-label" for="subject">{{subject}}</label>' +
                        '<input class="qr-support-modal__input" type="text" name="subject" ng-model="user.subject" ng-maxlength="100" required />' +
                        '<div class="support-modal__error" ng-if="submitted && form.subject.$error.required">{{errorRequired}}</div>' +
                        '<div class="support-modal__error" ng-if="submitted && form.subject.$error.maxlength">{{errorMaxlength100}}</div>' +
                    '</div>' +

                    '<div class="control-group">' +
                        '<label class="control-label" for="description">{{description}}</label>' +
                        '<textarea class="qr-support-modal__input qr-support-modal__input-textarea" name="description" ng-model="user.description" ng-trim="false" maxlength="1000" ng-maxlength="1000" required />' +
                        '<span class="qr-support-modal__textarea-counter">{{user.description.length || 0 }} / 1000</span>' +
                        '<div class="support-modal__error" ng-if="submitted && form.description.$error.required">{{errorRequired}}</div>' +
                        '<div class="support-modal__error" ng-if="submitted && form.description.$error.maxlength">{{errorMaxlength1000}}</div>' +
                    '</div>' +

                    '<div class="control-group" style="margin-top: 32px">' +

                        '<button type="submit" class="btn btn-default qr-support-modal__submit" ng-click="submit(userId, userCompany, userCountry, submitConfirmation, userEmail)">' +
                            '{{submitBtnText}}' +
                        '</button>' +
                        '<div class="mt-10 mr-15 pull-right small-paragraph cancel-button" ng-click="closeWindow()">' +
                            '{{cancelBtnText}}' +
                        '</div>' +
                    '</div>' +
                '</form>' +
            '</qr-modal>',
        scope: {
            open: '=',  // Open state of the modal
            userId: '=',
            userCountry: '=',
            userCompany: '=',
            userLang: '=',
            userEmail: '=',
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            /**
             * Form value stored here
             */
            $scope.user = {};

            /**
             * Translations
             */
            $scope.headerTitle = gettextCatalog.getString('Contact Support');
            $scope.headerDescription = gettextCatalog.getString('Submit your request by completing the form and describing your issue, question or feedback precisely.');
            $scope.firstName = gettextCatalog.getString('First Name');
            $scope.lastName = gettextCatalog.getString('Last Name');
            $scope.email = gettextCatalog.getString('Email');
            $scope.language = gettextCatalog.getString('Language');
            $scope.supportTopic = gettextCatalog.getString('Support Topic');
            $scope.subject = gettextCatalog.getString('Subject');
            $scope.description = gettextCatalog.getString('Description');
            $scope.languageSelect = gettextCatalog.getString('Select your language');
            $scope.topicSelect = gettextCatalog.getString('Select your support topic');
            $scope.errorRequired = gettextCatalog.getString('Required');
            $scope.errorMaxlength50 = gettextCatalog.getString('This field should not have more then 50 characters');
            $scope.errorMaxlength100 = gettextCatalog.getString('This field should not have more then 100 characters');
            $scope.errorMaxlength1000 = gettextCatalog.getString('This field should not have more then 1000 characters');
            $scope.errorEmail = gettextCatalog.getString('Invalid email address');
            $scope.submitConfirmation = gettextCatalog.getString("Your request has been submitted. We'll get back to you soon.");
            $scope.cancelBtnText = gettextCatalog.getString("Cancel");
            $scope.submitBtnText = gettextCatalog.getString("Submit");

            $scope.english = gettextCatalog.getString('English');
            $scope.german = gettextCatalog.getString('German');
            $scope.spanish = gettextCatalog.getString('Spanish');
            $scope.italian = gettextCatalog.getString('Italian');
            $scope.portuguese = gettextCatalog.getString('Portuguese');
            $scope.french = gettextCatalog.getString('French');

            /**
             * Dropdown elements
             */
            $scope.languages = [
                { id: 'en', key: 'English', value: $scope.english },
                { id: 'de', key: 'German', value: $scope.german },
                { id: 'es', key: 'Spanish', value: $scope.spanish },
                { id: 'it', key: 'Italian', value: $scope.italian },
                { id: 'pt', key: 'Portuguese', value: $scope.portuguese },
                { id: 'fr', key: 'French', value: $scope.french },
            ];

            /**
             * Here's the list of all topics which the user can pick in the dropdown.
             *
             * key => Is sent via form to Intercom and is visible in Intercom
             * value => Is translated and only used for frontend
             */
            $scope.topics = [
                { key: 'Managing Your Subscription', value: gettextCatalog.getString('Managing Your Subscription') },
                { key: 'Managing Your QR Codes', value: gettextCatalog.getString('Managing Your QR Codes') },
                { key: 'Disabled QR Codes (After Trial)', value: gettextCatalog.getString('Disabled QR Codes (After Trial)') },
                { key: 'Account Deletion', value: gettextCatalog.getString('Account Deletion') },
                { key: 'Subscription cancellation', value: gettextCatalog.getString('Subscription cancellation') },
                { key: 'Failed Payment', value: gettextCatalog.getString('Failed Payment') },
                { key: 'Trial Cancellation', value: gettextCatalog.getString('Trial Cancellation') },
                { key: 'Monthly or Individual Payment Options', value: gettextCatalog.getString('Monthly or Individual Payment Options') },
                { key: '14 Day Withdrawal', value: gettextCatalog.getString('14 Day Withdrawal') },
            ];

            /**
             * Closes this modal and resets form.
             */
            $scope.closeWindow = function () {
                $scope.open = false;
                $scope.submitted = false;
            };

            /**
             * Selects the support-topic from dropdown.
             */
            $scope.supportModalTopicDropdownSelect = function (selectedValue, selectedKey) {
                $scope.user.topicValue = selectedValue;
                $scope.user.topicKey = selectedKey;
                $('#supportTopicDrop').dropdown("toggle");
            };

            /**
             * Selects the language from dropdown.
             */
            $scope.supportModalLangDropdownSelect = function (selectedValue, selectedKey) {
                $scope.user.languageValue = selectedValue;
                $scope.user.languageKey = selectedKey;
                $('#supportLanguageDrop').dropdown("toggle");
            };

            /**
             * Submits form and sends request to Salesforce.
             */
            $scope.submit = function (userId, userCompany, userCountry, submitConfirm, userEmail) {
                // Set submitted state for form
                $scope.submitted = true;

                // After short timeout we send request to Salesforce
                $timeout(function () {
                    if ($element.find(".support-modal__error").length === 0) {
                        var currency = "EUR"; // ToDo: Add currency, once implemented

                        var salesforceFormBody = {
                            orgid: salesforceID || '',
                            User_ID__c: userId,
                            company: userCompany || '',
                            Country__c: userCountry || '',
                            currency: currency || 'EUR',
                            First_Name__c: $scope.user.firstName,
                            Last_Name__c: $scope.user.lastName,
                            email: $scope.user.email || userEmail,
                            Language__c: $scope.user.languageKey,
                            reason: $scope.user.topicKey,
                            subject: $scope.user.subject,
                            description: $scope.user.description,
                        };

                        var salesforceUrl = salesforceURL || '';
                        fetch(salesforceUrl, {
                            method: 'POST',
                            mode: 'no-cors',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',
                            },
                            body: new URLSearchParams(salesforceFormBody),
                        });

                        $scope.open = false;
                        $scope.user = {};
                        $scope.submitted = false;
                        alert( submitConfirm );

                        window.dataLayer.push({
                            event: 'submit_support_form'
                        });
                    }
                }, 500);
            };

            $scope.$watch('open', function (newOpen) {
                if(newOpen) {
                    $scope.user.email = $scope.user.email || $scope.userEmail;
                    if(!$scope.user.languageKey && $scope.userLang) {
                        // Pre-select language of user for dropdown
                        var filteredLang = $filter('filter')($scope.languages, {'id':$scope.userLang})[0].key;

                        if(filteredLang) {
                            $scope.user.languageKey = filteredLang;
                        }
                    }
                }
            });
        }]
    };
}]);
;
/**
 * Selector of QR position marker shapes.
 */
app.directive('qrMarkerShape', function () {
    return {
        restrict: 'E',
        template:
            '<button type="button" class="qr-marker-shape" ng-click="open = !open" ng-class="{&apos;qr-marker-shape--open&apos;: open}">' +
                '<span class="qr-marker-shape__marker" ng-class="getMarkerClass()"></span>' +
            '</button>' +
            '<qr-icon-menu open="open" value="value" items="::markers" top-offset="{{ ::getTopOffset() }}"></qr-icon-menu>',
        scope: {
            open: '=',  // Open state of the menu.
            value: '=', // ID of selected marker shape.
            dropUp: '@' // Set to "true" if the icon menu should be dropped up instead of down.
        },
        controller: ['$scope', function ($scope) {
            /**
             * Array of available markers.
             * @type {Array}
             */
            $scope.markers = [
                {
                    icon: 'variante17',
                    value: 'version17'
                },
                {
                    icon: 'variante1',
                    value: 'version1'
                },
                {
                    icon: 'variante2',
                    value: 'version2'
                },
                {
                    icon: 'variante3',
                    value: 'version3'
                },
                {
                    icon: 'variante4',
                    value: 'version4'
                },
                {
                    icon: 'variante5',
                    value: 'version5'
                },
                {
                    icon: 'variante6',
                    value: 'version6'
                },
                {
                    icon: 'variante7',
                    value: 'version7'
                },
                {
                    icon: 'variante8',
                    value: 'version8'
                },
                {
                    icon: 'variante9',
                    value: 'version9'
                },
                {
                    icon: 'variante10',
                    value: 'version10'
                },
                {
                    icon: 'variante11',
                    value: 'version11'
                },
                {
                    icon: 'variante13',
                    value: 'version13'
                },
                {
                    icon: 'variante15',
                    value: 'version15'
                },
                {
                    icon: 'variante16',
                    value: 'version16'
                }
            ];

            /**
             * Set default value for the marker shape.
             * @type {string}
             */
            $scope.value = $scope.value || $scope.markers[0].value || '';

            /**
             * Returns CSS class for selected marker.
             * @returns {string}
             */
            $scope.getMarkerClass = function () {
                return $scope.value ? $scope.value.replace('version', 'icon icon-variante') : '';
            };

            /**
             * If dropUp is set to true, the icon menu should be moved up.
             * @returns {string}
             */
            $scope.getTopOffset = function () {
                return $scope.dropUp === 'true' ? '-197px' : '';
            };
        }]
    };
});
;
app.directive('qrStatisticsView', ['$window', '$sce', '$timeout', 'gettextCatalog', 'account', 'tracking', function ($window, $sce, $timeout, gettextCatalog, account, tracking) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-navbar-v2__button qr-navbar-v2__back-btn qr-navbar-v2__back-btn--fixed" ng-show="open">' +
                '<a ng-href="{{ getBackUrl() }}" ng-click="delayTransition($event)">' +
                    '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n' +
                        '<path class="b" d="M22.923,12.382a1,1,0,0,0-.217-1.09l-8-8a1,1,0,1,0-1.414,1.414L19.586,11H2a1,1,0,0,0,0,2H19.586l-6.293,6.293a1,1,0,1,0,1.414,1.414l8-8a1.011,1.011,0,0,0,.216-.325Z" transform="translate(0 0.002)"/>\n' +
                    '</svg>' +
                    '<span>{{ ::backLabel }}</span>' +
                '</a>' +
            '</div>' +
            '<div class="qr-statistics-view" ng-class="getStatisticsClass()" ng-show="open">' +
                '<div class="qr-demo-banner" ng-if="showOpenDemoBanner" ng-switch="isDemo">' +
                    '<div class="qr-demo-banner__container" ng-switch-when="false">' +
                        '<h6 class="qr-demo-banner__title">{{ ::demoBannerTitle }}</h6>' +
                        '<span class="qr-demo-banner__button" ng-click="openDemo()">{{ ::demoBannerButton }}</span>' +
                        '<i class="qr-demo-banner__close-icon icon-thin-close" ng-click="closeDemoBanner()"></i>' +
                    '</div>' +
                    '<div class="qr-demo-banner__container" ng-switch-when="true">' +
                        '<h6 class="qr-demo-banner__title">{{ ::demoBannerTitleExit }}</h6>' +
                        '<span class="qr-demo-banner__button qr-demo-banner__button--demo" ng-click="closeDemoBanner()">{{ ::demoBannerButtonExit }}</span>' +
                    '</div>' +
                '</div>' +
                '<div class="top-header">' +
                    '<div class="code-info">' +
                        '<qr-manage-code value="code" is-admin="false" checkbox="false" is-demo="isDemo"></qr-manage-code>' +
                        '<div class="redesign" ng-if="!hidePhonePreview">' +
                            '<i class="icon-thin-close" ng-click="closeFullPreview()"></i>' +
                            '<div class="preview active" ng-click="openFullPreview()">' +
                                '<div class="preview-smartphone active">' +
                                    '<iframe class="code-preview" ng-hide="fullPreview" scrolling="no" data-ng-src="{{ getCodeUrl() }}"></iframe>' +
                                    '<iframe class="code-preview" ng-show="fullPreview" scrolling="yes" data-ng-src="{{ getCodeUrl() }}"></iframe>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                        '<span class="code-status" ng-show="getStatus()" ng-class="getStatusClass()" ng-bind="getStatus()"></span>' +
                    '</div>' +
                '</div>' +
                '<div class="statistics-content">' +
                    '<qr-campaign-info value="code" disabled="isDemo" open="open"></qr-campaign-info>' +
                    '<qr-campaign-charts value="code" disabled="isDemo"></qr-campaign-charts>' +
                '</div>' +
            '</div>',
        scope: {
            open: '=',
            code: '=',
            isDemo: '='
        },
        controller: ['$scope', function ($scope) {

            $scope.fullPreview = false;
            $scope.showOpenDemoBanner = false;
            $scope.hidePhonePreview = false;

            $scope.backLabel = gettextCatalog.getString('Back');
            $scope.demoBannerTitle = gettextCatalog.getString('Wondering what this page looks like after receiving some scans?');
            $scope.demoBannerTitleExit = gettextCatalog.getString('Exit Demo and go back to your QR Code?');
            $scope.demoBannerButton = gettextCatalog.getString('View demo');
            $scope.demoBannerButtonExit = gettextCatalog.getString('Exit demo');

            $scope.manageContent = angular.element(".qr-manage-content");
            $scope.menuPanel = angular.element(".qr-manage-panel");
            $scope.menuButton = angular.element(".qr-navbar__menu");
            $scope.alertBanner = angular.element(".qr-manage-content__banner");

            /**
             * State of the menu panel on the right.
             * @type {string}
             */
            $scope.menuPanelState = "";

            $scope.getStatisticsClass = function () {
                // Hide phone preview for specific QR Code types (defined via id in following array)
                $scope.hidePhonePreview = [1, 25, 26].includes($scope.code.type_id);

                return {
                    'qr-statistics-view--no-preview': $scope.hidePhonePreview
                };
            };

            /**
             * Get the status.
             * @returns {String}
             */
            $scope.getStatus = function () {
                if ($scope.code.status === 'paused') {
                    return gettextCatalog.getString('Paused');
                }
                if ($scope.code.status === 'expired') {
                    return gettextCatalog.getString('Expired');
                }
                return '';
            };

            /**
             * Get status CSS classes.
             * @returns {*}
             */
            $scope.getStatusClass = function () {
                return {
                    'code-status--expired': $scope.code.status === 'expired'
                };
            };

            $scope.openFullPreview = function () {
                $scope.fullPreview = true;
                $(".redesign").addClass("full-preview");
            };

            $scope.closeFullPreview = function () {
                $scope.fullPreview = false;
                $(".redesign").removeClass("full-preview");
            };

            /**
             * This function scrolls the window to the top with animation.
             */
            $scope.animateToTop = function () {
                $window.scrollTo({top: 0});
            };

            /**
             * Returns a URL to go back to the manage view.
             * @returns {string}
             */
            $scope.getBackUrl = function () {
                return account.getCurrentUrl({
                    view: '',
                    id: 0
                });
            };

            /**
             * Click delay before navigating
             */
            $scope.delayTransition = function ($event) {

                $event.preventDefault();

                var goTo = angular.element($event.currentTarget).attr("href");

                $scope.manageContent.addClass("demo__content_transition-backwards");

                $timeout(function () {
                    window.location = goTo;
                    $scope.alertBanner.removeClass("hidden");
                    $('.qr-navbar-v2__menu-trigger').show();
                }, 600);

            };

            /**
             * Returns qrcode short url to correctly open it inside iframe
             * @returns {string} || undefined
             */
            $scope.getCodeUrl = function () {
                if ($scope.code.short_url != undefined && $scope.code.type_id != 1) {
                    return $sce.trustAsResourceUrl('/shortener/index/loadShortener/true/code/' + $scope.code.short_code + '?disable_statistics=1');
                }
                return undefined;
            };

            $scope.openDemo = function () {
                account.setCurrentView('demo');
                tracking.trackEvent('done_visit_tracking_demo');
            };

            $scope.closeDemoBanner = function () {
                $scope.showOpenDemoBanner = false;

                if ($scope.isDemo) {
                    if ('insights' === account.getCurrentView()) {
                        account.setCurrentView('');
                    } else if ('demo' === account.getCurrentView()) {
                        account.setCurrentView('insights');
                    }

                }
            };

            $scope.$watch('open', function () {
                if ($scope.open) {

                    $('.qr-navbar-v2__menu-trigger').hide();

                    // Animation class for transition between manage page and details
                    $scope.manageContent.removeClass("demo__content_transition-panel");
                    $scope.manageContent.removeClass("demo__content_transition-backwards");
                    $scope.manageContent.addClass("demo__content_transition");

                    if ($scope.menuPanel.hasClass("qr-manage-panel--close")) {
                        $scope.menuPanelState = "closed";
                        $scope.manageContent.removeClass("qr-manage-content--panel-open");
                    } else {
                        $scope.menuPanelState = "open";

                        // Animation class for transition between hand page and details
                        $scope.menuPanel.addClass("demo__panel_transition");
                        $scope.manageContent.addClass("demo__content_go-open");
                        $scope.menuPanel.removeClass("demo__panel_transition-reverse");
                        $scope.manageContent.addClass("qr-manage-content--panel-open");
                    }

                    if ($scope.menuPanelState === "open") {
                        $scope.menuPanel.addClass("qr-manage-panel--close");
                        $scope.manageContent.addClass("qr-manage-content--panel-close");

                    }

                    $scope.menuButton.hide();

                    // Add a delay to scroll up to wait for the animation to complete the transition from the manage page to the details.
                    $timeout(function () {
                        $scope.animateToTop();
                    }, 300);

                    if ($scope.code.total_scans < 5 || $scope.isDemo) {
                        $scope.showOpenDemoBanner = true;
                    }

                } else {

                    $scope.showOpenDemoBanner = false;

                    // Animation class for transition between manage page and details
                    $scope.manageContent.removeClass("demo__content_transition");

                    if ($scope.menuPanelState === "open") {

                        // Animation class for transition between manage page and details
                        $scope.manageContent.removeClass("demo__content_go-open");
                        $scope.menuPanel.addClass("demo__panel_transition-reverse");

                        $scope.manageContent.addClass("demo__content_transition-panel");
                        $scope.menuPanel.removeClass("qr-manage-panel--close");

                        $scope.manageContent.removeClass("qr-manage-content--panel-close");
                        $scope.manageContent.addClass("demo__content_transition-backwards");
                    }

                    $scope.menuButton.show();

                    $scope.menuPanel.removeClass("demo__panel_transition");
                }
            });
        }]
    };
}]);
;
app.directive('qrCampaignInfo', ['$sce', '$window', 'gettextCatalog', 'api', function ($sce, $window, gettextCatalog, api) {
    return {
        restrict: 'E',
        template:
            '<qr-campaign-info-modal open="openCampaignModal" campaign-info="campaign" items="items" item-images="itemImages" qr-code="value"></qr-campaign-info-modal>' +
            '<qr-demo-modal open="openDemoModal"></qr-demo-modal>' +
            '<div class="qr-campaign-info">' +
                '<div class="qr-campaign-info__total-scans">' +
                    '<span class="title">{{totalScansLabel}}</span>' +
                    '<div class="total-scans">{{value.total_scans}}</div>' +
                    '<span class="divider">/</span>'+
                    '<div class="unique-scans">{{value.unique_scans}} {{uniqueScansLabel}}</div>' +
                '</div>' +
                '<div class="qr-campaign-info__menu">' +
                    '<div class="qr-campaign-info__menu__element">' +
                        '<span class="title">{{mediumLabel}}</span>' +
                        '<i class="icon icon-qr-plus-squared" ng-click="openCampaignInfoModal()" ng-hide="campaign.imageName"></i>' +
                        '<img class="qr-campaign-info__menu__element__material-image" ng-click="openCampaignInfoModal()" ng-if="campaign.imageName" ng-src="/img/campaign/{{campaign.imageName}}.svg">' +
                        '<a ng-switch="campaign.material" ng-click="openCampaignInfoModal()" class="add-info" ng-class="getLinkStyle(campaign.material)">' +
                            '<i ng-switch-when="" class="qr-campaign-info__menu__element__icon icon icon-event-about"></i>' +
                            '<span ng-switch-when="">{{addInfoLabel}}</span>' +
                            '<span ng-switch-default>{{campaign.material}}</span>' +
                        '</a>' +
                    '</div>' +
                    '<div class="qr-campaign-info__menu__element">' +
                        '<span class="title">{{printRunLabel}}</span>' +
                        '<a ng-switch="campaign.printRun" ng-click="openCampaignInfoModal()" class="add-info" ng-class="getLinkStyle(campaign.printRun)">' +
                            '<i ng-switch-when="" class="qr-campaign-info__menu__element__icon icon icon-event-about"></i>' +
                            '<span ng-switch-when="">{{addInfoLabel}}</span>' +
                            '<span ng-switch-default>{{campaign.printRun}}</span>' +
                        '</a>' +
                    '</div>' +
                    '<div class="qr-campaign-info__menu__element">' +
                        '<span class="title">{{campaignStartLabel}}</span>' +
                        '<a ng-switch="campaign.dateStart" ng-click="openCampaignInfoModal()" class="add-info" ng-class="getLinkStyle(campaign.dateStart)">' +
                            '<i ng-switch-when="" class="qr-campaign-info__menu__element__icon icon icon-event-about"></i>' +
                            '<span ng-switch-when="">{{addInfoLabel}}</span>' +
                            '<span ng-switch-default>{{campaign.dateStart}}</span>' +
                        '</a>' +
                    '</div>' +
                    '<div class="qr-campaign-info__menu__element">' +
                        '<span class="title">{{campaignEndLabel}}</span>' +
                        '<a ng-switch="campaign.dateEnd" ng-click="openCampaignInfoModal()" class="add-info" ng-class="getLinkStyle(campaign.dateEnd)">' +
                            '<i ng-switch-when="" class="qr-campaign-info__menu__element__icon icon icon-event-about"></i>' +
                            '<span ng-switch-when="">{{addInfoLabel}}</span>' +
                            '<span ng-switch-default>{{campaign.dateEnd}}</span>' +
                        '</a>' +
                    '</div>' +
                '</div>' +
            '</div>',
        scope: {
            open: '=',
            value: '=',
            disabled: '='
        },
        controller: ['$scope', function ($scope) {

            //Translations for labels
            $scope.totalScansLabel = gettextCatalog.getString('Total Scans');
            $scope.uniqueScansLabel = gettextCatalog.getString('Unique');

            $scope.mediumLabel = gettextCatalog.getString('Medium');
            $scope.printRunLabel = gettextCatalog.getString('Print Run');
            $scope.campaignStartLabel = gettextCatalog.getString('Campaign Start');
            $scope.campaignEndLabel = gettextCatalog.getString('Campaign End');

            $scope.addInfoLabel = gettextCatalog.getString('Add info');

            //Params for API call (type of statistic & date range)
            $scope.apiScanParams = {
                type: "totals",
                from: $window.moment($scope.value.created).format('YYYY-MM-DD'),
                to: $window.moment().format('YYYY-MM-DD')
            };

            //Campaign object to be displayed on page
            $scope.campaign = {
                id: "",
                material: "",
                imageName: "",
                printRun: "",
                dateStart: "",
                dateEnd: "",
                campaignId: ""
            };

            $scope.reloadCampaign = function () {
                $scope.campaign = {
                    id: "",
                    material: "",
                    imageName: "",
                    printRun: "",
                    dateStart: "",
                    dateEnd: "",
                    campaignId: ""
                };

                if (!$scope.value || !$scope.value.campaign) {
                    return;
                }

                $scope.campaign.campaignId = $scope.value.campaign.id;
                $scope.campaign.id = $scope.value.campaign.medium_id;

                if ($scope.value.campaign.print_run != null) {
                    $scope.campaign.printRun = $scope.value.campaign.print_run;
                }

                if ($window.moment($scope.value.campaign.campaign_start).isValid()) {
                    $scope.campaign.dateStart = $window.moment($scope.value.campaign.campaign_start).format('MMM D, YYYY');
                }

                if ($window.moment($scope.value.campaign.campaign_end).isValid()) {
                    $scope.campaign.dateEnd = $window.moment($scope.value.campaign.campaign_end).format('MMM D, YYYY');
                }
            };

            //Object which contains available mediums to display in medium dropdown
            $scope.items = {};

            //Contains image names of available mediums
            $scope.itemImages = {};

            $scope.pushCampaignMediums = function (response) {
                angular.forEach(response.data.items, function (value) {
                    $scope.items[value.id] = value.name;
                    $scope.itemImages[value.id] = value.image_name;
                });

                //Assign selected/saved campaign medium
                if($scope.campaign.id > 1) {
                    $scope.campaign.material = $scope.items[$scope.campaign.id];
                    $scope.campaign.imageName = $scope.itemImages[$scope.campaign.id];
                }

            };

            api.getCampaignMediums($scope.pushCampaignMediums);

            $scope.openCampaignModal = false;
            $scope.openDemoModal = false;

            $scope.openCampaignInfoModal = function () {
                if (!$scope.disabled) {
                    $scope.openCampaignModal = true;
                } else {
                    $scope.openDemoModal = true;
                }
            };

            $scope.getLinkStyle = function (edit) {
              return {
                  "add-info--edit": edit
              };
            };

            //"No material" is saved with id = 1. If id = 1 we don't need to update materials
            $scope.$watch('campaign.id', function (newValue, oldValue) {

                if($scope.campaign.id && $scope.campaign.id != 1 && newValue != oldValue) {
                    $scope.campaign.material = $scope.items[$scope.campaign.id];
                    $scope.campaign.imageName = $scope.itemImages[$scope.campaign.id];
                } else {
                    $scope.campaign.material = "";
                    $scope.campaign.imageName = "";
                }

            });

            $scope.$watch('open', function () {

                $scope.campaign.material = $scope.items[$scope.campaign.id];
                $scope.campaign.imageName = $scope.itemImages[$scope.campaign.id];

                $scope.reloadCampaign();
            });

            $scope.$watch('disabled', function () {
                if ($scope.value.campaign) {
                    $scope.reloadCampaign();
                } else {
                    $scope.campaign = {
                        id: "",
                        material: "",
                        imageName: "",
                        printRun: "",
                        dateStart: $window.moment($scope.value.created).format('MMM D, YYYY'),
                        dateEnd: "",
                        campaignId: ""
                    };
                }
            });

            $scope.$watch('value', function () {
                //If code has campaign then assign full data else assign only default campaign start date
                if ($scope.value.campaign) {
                    $scope.reloadCampaign();
                } else {
                    $scope.campaign.dateStart = $window.moment($scope.value.created).format('MMM D, YYYY');
                }
            });

            $scope.$watch('value', function () {
                //If code has campaign then assign full data else assign only default campaign start date
                if ($scope.value.campaign) {
                    $scope.reloadCampaign();
                } else {
                    $scope.campaign.dateStart = $window.moment($scope.value.created).format('MMM D, YYYY');
                }
            });

        }]
    };
}]);
;
/**
 * The modal for QR Code campaign.
 */
app.directive('qrCampaignInfoModal', ['api', '$window', 'gettextCatalog', function (api, $window, gettextCatalog) {
    return {
        restrict: 'E',
        template:
            '<qr-modal data-title="{{ ::titleLabel }}" open="open" buttons="getButtons()" auto-close="false" close-icon="true" class="qr-campaign-info-modal">' +
                '<div ng-init="initDatepicker()" ng-if="open" class="qr-campaign-info-modal__content">' +
                    '<div class="qr-campaign-info-modal__content__material-dropdown">' +
                        '<span class="title">{{mediumLabel}}</span>' +
                        '<qr-dropdown placeholder="{{pleaseSelectLabel}}" items="items" open-on-focus="true" images="itemImages" value="selectedData.materialId"></qr-dropdown>' +
                    '</div>' +
                    '<form name="print_run" class="qr-campaign-info-modal__content__print-run">' +
                        '<span class="title">{{printRunLabel}}<i ng-init="tooltipInit()" class="icon-help" data-toggle="tooltip" data-original-title="{{printRunTooltipLabel}}" data-placement="top"></i></span>' +
                        '<input placeholder="e.g. 1000" type="text" ng-model="selectedData.printRun" ng-pattern="/^[0-9]{1,7}$/">' +
                        '<span class="error" ng-show="print_run.$error.pattern">{{validationErrorLabel}}!</span>' +
                    '</form>' +
                    '<div class="qr-campaign-info-modal__content__date">' +
                        '<div id="campaign-start" class="qr-campaign-info-modal__content__date__campaign-start">' +
                            '<span class="title">{{campaignStartLabel}}</span>' +
                            '<div class="input-group date" id="datetimepickerstart">' +
                                '<input placeholder="{{pleaseSelectLabel}}" type="text" class="form-control" readonly/>' +
                                '<span class="input-group-addon">' +
                                    '<span class="icon-qr-calendar"></span>' +
                                '</span>' +
                            '</div>' +
                        '</div>' +
                        '<span class="divider"> - </span>' +
                        '<div id="campaign-end" class="qr-campaign-info-modal__content__date__campaign-end">' +
                            '<span class="title">{{campaignEndLabel}}<i ng-init="tooltipInit()" class="icon-help" data-toggle="tooltip" data-original-title="{{campaignEndTooltipLabel}}" data-placement="top"></i></span>' +
                            '<div class="input-group date" id="datetimepickerend">' +
                                '<input placeholder="{{pleaseSelectLabel}}" type="text" class="form-control" readonly/>' +
                                '<span class="input-group-addon">' +
                                    '<span class="icon-qr-calendar"></span>' +
                                '</span>' +
                            '</div>' +
                        '</div>' +
                        '<a class="remove-date" ng-show="selectedData.dateEnd" ng-click="removeCampaignEnd()">{{removeDateLabel}}</a>' +
                    '</div>' +
                '</div>' +
            '</qr-modal>',
        scope: {
            open: '=',
            campaignInfo: '=',
            items: '=',
            itemImages: '=',
            qrCode: '='
        },
        controller: ['$scope', function ($scope) {

            var par1 = ('#campaign-start');
            var par2 = ('#campaign-end');

            //Translations for labels
            $scope.titleLabel = gettextCatalog.getString('Campaign Info');

            $scope.mediumLabel = gettextCatalog.getString('Medium');
            $scope.printRunLabel = gettextCatalog.getString('Print Run');
            $scope.campaignStartLabel = gettextCatalog.getString('Campaign Start');
            $scope.campaignEndLabel = gettextCatalog.getString('Campaign End');

            $scope.pleaseSelectLabel = gettextCatalog.getString('Please select');

            $scope.removeDateLabel = gettextCatalog.getString('Remove date');
            $scope.validationErrorLabel = gettextCatalog.getString('Not a valid number');

            $scope.printRunTooltipLabel = gettextCatalog.getString('How many QR Code copies have you printed or are planning to print?');
            $scope.campaignEndTooltipLabel = gettextCatalog.getString('Enter an end date if your campaign has a limited duration.');

            $scope.invalidDate = gettextCatalog.getString('Invalid date');

            /**
             * Tooltip for print run input
             */
            $scope.tooltipInit = function () {
                $('[data-toggle="tooltip"]').tooltip({
                    delay: {
                        show: 500,
                        hide: 200
                    }
                });
            };

            //Date pickers for campaign start/end range
            //By default we use date of qr code creation if nothing else specified
            $scope.initDatepicker = function () {
                $('#datetimepickerstart').datetimepicker({
                    widgetParent: par1,
                    format: "MMM DD, YYYY",
                    defaultDate: $scope.selectedData.dateStart
                });
                $('#datetimepickerend').datetimepicker({
                    widgetParent: par2,
                    format: "MMM DD, YYYY",
                    useCurrent: false,
                    minDate: $scope.selectedData.dateStart,
                    defaultDate: $scope.selectedData.dateEnd
                });

                $("#datetimepickerstart").on("dp.change", function (e) {
                    $scope.selectedData.dateStart = $("#datetimepickerstart").find("input").val();
                    $('#datetimepickerend').data("DateTimePicker").setMinDate(e.date);
                });
                $("#datetimepickerend").on("dp.change", function (e) {
                    $scope.selectedData.dateEnd = $("#datetimepickerend").find("input").val();
                    //we need this eval here because without it we'll have a delay in "remove date" button appearing
                    $scope.$evalAsync();
                    $('#datetimepickerstart').data("DateTimePicker").setMaxDate(e.date);
                });

                $(".bootstrap-datetimepicker-widget").attr("id", "qr-calendar");
            };

            /**
             * This function deletes campaign end date
             * When campaign end date specified user can remove it
             */
            $scope.removeCampaignEnd = function () {
                $('#datetimepickerend').data("DateTimePicker").setDate(null);
            };

            /**
             * Array of buttons for the move modal.
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Save'),
                    callback: function () {
                        //Update campaign object in order to display it after modal is closed
                        $scope.campaignInfo.id = $scope.selectedData.materialId;
                        $scope.campaignInfo.dateStart = $scope.selectedData.dateStart;
                        $scope.campaignInfo.dateEnd = $scope.selectedData.dateEnd;
                        $scope.campaignInfo.printRun = $scope.selectedData.printRun;

                        var dateEnd = "";

                        //If campaign end field is not empty we can assign correct value of date picker
                        //Without this validation empty field will be shown as "Invalid date"
                        if ($window.moment($scope.selectedData.dateEnd).isValid()) {
                            dateEnd = $window.moment($scope.selectedData.dateEnd).format('YYYY-MM-DD HH:MM:SS');
                        }

                        //Decide if we should create new campaign or update existing one
                        if (!$scope.campaignInfo.campaignId) {
                            api.createCampaign(
                                {
                                    qrcode_id: $scope.qrCode.id,
                                    campaign_start: $window.moment($scope.selectedData.dateStart).format('YYYY-MM-DD HH:MM:SS'),
                                    campaign_end: dateEnd,
                                    print_run: $scope.selectedData.printRun,
                                    medium_id: $scope.selectedData.materialId
                                },
                                function (response) {
                                    $scope.campaignInfo.campaignId = response.data.id;
                                    $scope.qrCode.campaign = response.data;
                                }
                            );
                        } else {
                            api.updateCampaign(
                                $scope.campaignInfo.campaignId,
                                {
                                    qrcode_id: $scope.qrCode.id,
                                    campaign_start: $window.moment($scope.selectedData.dateStart).format('YYYY-MM-DD HH:MM:SS'),
                                    campaign_end: dateEnd,
                                    print_run: $scope.selectedData.printRun,
                                    medium_id: $scope.selectedData.materialId
                                },
                                function (response) {
                                    $scope.qrCode.campaign = response.data;
                                }
                            );
                        }

                        $scope.open = false;
                    }
                },
                {
                    label: gettextCatalog.getString('Cancel'),
                    type: 'link',
                    callback: function () {
                        $scope.selectedData.materialId = $scope.campaignInfo.id;
                        $scope.selectedData.dateStart = $scope.campaignInfo.dateStart;
                        $scope.selectedData.dateEnd = $scope.campaignInfo.dateEnd;
                        $scope.selectedData.printRun = $scope.campaignInfo.printRun;

                        $('#datetimepickerstart').data("DateTimePicker").setDate($scope.campaignInfo.dateStart);
                        $('#datetimepickerend').data("DateTimePicker").setDate($scope.campaignInfo.dateEnd);

                        $scope.open = false;
                    }
                }
            ];


            /**
             * Returns actual array of buttons for the modal.
             * @returns {Array}
             */
            $scope.getButtons = function () {
                return $scope.buttons;
            };

            $scope.$watch('campaignInfo', function () {

                //Object which contains modal data. Assign data from campaign object
                $scope.selectedData = {
                    materialId: $scope.campaignInfo.id,
                    dateStart: $scope.campaignInfo.dateStart,
                    dateEnd: $scope.campaignInfo.dateEnd,
                    printRun: $scope.campaignInfo.printRun
                };

            }, true);
        }]
    };
}]);
;
app.directive('qrCampaignCharts', ['$sce', '$window', 'gettextCatalog', 'markup', '$timeout', 'api', function ($sce, $window, gettextCatalog, markup, $timeout, api) {
    return {
        restrict: 'E',
        template:
            '<qr-demo-modal open="openDemoModal"></qr-demo-modal>' +
            '<qr-datepicker-modal open="open.modal.datepicker" from="apiScanParams.from" to="apiScanParams.to" group="apiScanParams.group_by"></qr-datepicker-modal>' +
            '<qr-reset-scans-modal open="open.modal.reset"></qr-reset-scans-modal>' +
            '<div class="qr-campaign-charts">' +
                '<button class="qr-campaign-charts__date" type="button" ng-click="menuDayClick()">' +
                    '<span class="icon-qr-calendar"></span>' +
                    '{{date}}' +
                    '<span ng-hide="open.menu.day" class="icon-down-open-mini"></span>' +
                    '<span ng-show="open.menu.day" class="icon-up-open-mini"></span>' +
                '</button>' +
                '<div class="datePopup">'+
                    '<qr-popup-menu open="open.menu.day" items="::dateItems" ng-if="open.menu.day"></qr-popup-menu>' +
                '</div>' +
                '<button class="qr-campaign-charts__groupBy" type="button" ng-click="menuGroupByClick()">' +
                    '{{groupByLabel}}' +
                    '<span ng-hide="open.menu.groupBy" class="icon-down-open-mini"></span>' +
                    '<span ng-show="open.menu.groupBy" class="icon-up-open-mini"></span>' +
                '</button>' +
                '<div class="groupPopup">'+
                    '<qr-popup-menu open="open.menu.groupBy" items="::groupByItems" ng-if="open.menu.groupBy"></qr-popup-menu>' +
                '</div>' +
                '<button class="qr-campaign-charts__download" type="button" ng-click="menuDownloadClick()">' +
                    '<span class="icon-options"></span>' +
                    '{{optionsLabel}}' +
                    '<span ng-hide="open.menu.download" class="icon-down-open-mini"></span>' +
                    '<span ng-show="open.menu.download" class="icon-up-open-mini"></span>' +
                '</button>' +
                '<qr-popup-menu open="open.menu.download" items="::actions" right="true" top-offset="-10px" ng-if="open.menu.download" class="qr-campaign-charts__download-popup"></qr-popup-menu>' +
                '<div class="qr-campaign-charts__statistics">' +
                    '<div ng-if="openEmptyState" class="qr-campaign-charts__statistics--empty">' +
                        '<div class="cody">' +
                            '<img ng-src="{{openEmptyState && cdnUrl+\'/img/generator/cody/CodyE_PointingRight.svg\' || \'\'}}" />' +
                            '<span class="hint">{{emptyStateLabel}}</span>' +
                        '</div>' +
                    '</div>' +
                    '<div class="qr-campaign-charts__statistics__element line-chart">' +
                        '<span class="title">{{scansOverTimeLabel}}</span>' +
                        '<canvas ng-hide="chartLoading" style="width: 100% !important;height: auto !important;" id="scansOverTime"></canvas>' +
                        '<div ng-show="chartLoading" class="qr-campaign-charts__statistics__element--loading">' +
                            '<qr-spinner class="qr-manage-content__spinner" loading="true" size="32px"></qr-spinner>' +
                            '<div class="loadingMessage">{{loadingScansLabel}}</div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="qr-campaign-charts__statistics__element horizontal-bar-chart">' +
                        '<span class="title">{{scansByOSLabel}}</span>' +
                        '<div ng-show="OSLoading" class="qr-campaign-charts__statistics__element--loading">' +
                            '<qr-spinner class="qr-manage-content__spinner" loading="true" size="32px"></qr-spinner>' +
                            '<div class="loadingMessage">{{loadingOSLabel}}</div>' +
                        '</div>' +
                        '<table ng-hide="OSLoading" class="qr-campaign-charts__statistics__element__table">' +
                            '<thead>' +
                                '<tr>' +
                                    '<th style="min-width: 120px">{{OSLabel}}</th>' +
                                    '<th style="width: 67%">{{scansLabel}}</th>' +
                                    '<th>%</th>' +
                                '</tr>' +
                            '</thead>' +
                        '</table>' +
                        '<div ng-show="!OSLoading && !OSstatistics.length" class="emptyMessage">{{noScansLabel}}</div>' +
                        '<div class="content-scrollable" data-chart="platform" data-page="1">' +
                            '<table ng-hide="OSLoading" class="qr-campaign-charts__statistics__element__table">' +
                                '<tbody>' +
                                '<tr ng-repeat="item in OSstatistics track by $index">' +
                                    '<td style="width:10%">{{item[0] ? item[0] : "Undefined"}}</td>' +
                                    '<td class="scans--percentage">' +
                                        '<div class="progress-bar" ng-style="{width: item[3] + \'%\'}" ng-init="tooltipInit()" data-original-title="{{getTooltipTitle(item[1], item[0])}}" data-toggle="tooltip" data-container="body" data-placement="top"></div>' +
                                    '</td>' +
                                    '<td style="width:30%">{{item[2]}}%</td>' +
                                '</tr>' +
                                '</tbody>' +
                            '</table>' +
                            '<div class="contentLoading">' +
                                '<qr-spinner loading="true" size="22px"></qr-spinner>' +
                                '<span class="lzLoadingMessage">{{lazyLoadingLabel}}...</span>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="horizontal-line" ng-class="getChartsClass()"></div>' +
                    '<div class="vertical-line"></div>' +
                    '<div class="show-full" ng-click="toggleStatistics()">' +
                        '<span ng-hide="showFullStatistics">{{showFullStatisticsLabel}}<span class="icon-down-open-mini"></span></span>' +
                        '<span ng-show="showFullStatistics">{{showLessStatisticsLabel}}<span class="icon-up-open-mini"></span></span>' +
                        '</div>' +
                    '<div class="tables" ng-class="getChartsClass()">' +
                        '<div class="qr-campaign-charts__statistics__element top-countries">' +
                            '<span class="title">{{scansByCountriesLabel}}</span>' +
                            '<div ng-show="countryLoading" class="qr-campaign-charts__statistics__element--loading">' +
                                '<qr-spinner class="qr-manage-content__spinner" loading="true" size="32px"></qr-spinner>' +
                                '<div class="loadingMessage">{{loadingCountriesLabel}}</div>' +
                            '</div>' +
                            '<table ng-hide="countryLoading" class="qr-campaign-charts__statistics__element__table">' +
                                '<thead>' +
                                    '<tr>' +
                                        '<th style="width:10%">#</th>' +
                                        '<th style="width:55%">{{countryLabel}}</th>' +
                                        '<th style="width:25%">{{scansLabel}}</th>' +
                                        '<th style="width:10%">%</th>' +
                                    '</tr>' +
                                '</thead>' +
                            '</table>' +
                            '<div ng-show="!countryLoading && !countryStatistics.length" class="emptyMessage">{{noScansLabel}}</div>' +
                            '<div class="content-scrollable" data-chart="country" data-page="1">' +
                                '<table ng-hide="countryLoading" class="qr-campaign-charts__statistics__element__table">' +
                                    '<tbody>' +
                                        '<tr ng-repeat="item in countryStatistics track by $index">' +
                                            '<td style="width:10%">{{$index + 1}}</td>' +
                                            '<td style="width:55%">{{item[0] ? item[0] : "Undefined"}}</td>' +
                                            '<td style="width:25%"class="scans">{{item[1]}}</td>' +
                                            '<td style="width:10%">{{item[2]}}%</td>' +
                                        '</tr>' +
                                    '</tbody>' +
                                '</table>' +
                                '<div class="contentLoading">' +
                                    '<qr-spinner loading="true" size="22px"></qr-spinner>' +
                                    '<span class="lzLoadingMessage">{{lazyLoadingLabel}}...</span>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                        '<div class="qr-campaign-charts__statistics__element top-cities">' +
                            '<span class="title">{{scansByCitiesLabel}}</span>' +
                            '<div ng-show="cityLoading" class="qr-campaign-charts__statistics__element--loading">' +
                                '<qr-spinner class="qr-manage-content__spinner" loading="true" size="32px"></qr-spinner>' +
                                '<div class="loadingMessage">{{loadingCitiesLabel}}</div>' +
                            '</div>' +
                            '<table ng-hide="cityLoading" class="qr-campaign-charts__statistics__element__table">' +
                                '<thead>' +
                                    '<tr>' +
                                        '<th style="width:10%">#</th>' +
                                        '<th style="width:55%">{{cityLabel}}</th>' +
                                        '<th style="width:25%">{{scansLabel}}</th>' +
                                        '<th style="width:10%">%</th>' +
                                    '</tr>' +
                                '</thead>' +
                            '</table>' +
                            '<div ng-show="!cityLoading && !cityStatistics.length" class="emptyMessage">{{noScansLabel}}</div>' +
                            '<div class="content-scrollable" data-chart="city" data-page="1">' +
                                '<table ng-hide="cityLoading" class="qr-campaign-charts__statistics__element__table">' +
                                    '<tr ng-repeat="item in cityStatistics track by $index">' +
                                        '<td style="width:10%" >{{$index + 1}}</td>' +
                                        '<td style="width:55%" >{{item[0] ? item[0] : "Undefined"}}</td>' +
                                        '<td style="width:25%"  class="scans">{{item[1]}}</td>' +
                                        '<td style="width:10%" >{{item[2]}}%</td>' +
                                    '</tr>' +
                                '</table>' +
                                '<div class="contentLoading">' +
                                    '<qr-spinner loading="true" size="22px"></qr-spinner>' +
                                    '<span class="lzLoadingMessage">{{lazyLoadingLabel}}...</span>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
            '</div>',
        scope: {
            value: '=',
            disabled: '='
        },
        controller: ['$scope', function ($scope) {

            $scope.cdnUrl = $window.CDN_URL;

            $scope.openEmptyState = false;
            $scope.openDemoModal = false;

            $(".contentLoading").hide();

            //Translations for labels
            $scope.emptyStateLabel = gettextCatalog.getString('Scan your QR Code to view full statistics');

            $scope.optionsLabel = gettextCatalog.getString('Options');

            $scope.scansOverTimeLabel = gettextCatalog.getString('Scans over time');
            $scope.scansByOSLabel = gettextCatalog.getString('Scans by operating system');
            $scope.scansByCountriesLabel = gettextCatalog.getString('Scans by top countries');
            $scope.scansByCitiesLabel = gettextCatalog.getString('Scans by top cities');

            $scope.loadingScansLabel = gettextCatalog.getString('Loading Scans');
            $scope.loadingOSLabel = gettextCatalog.getString('Loading Operating Systems');
            $scope.loadingCountriesLabel = gettextCatalog.getString('Loading Countries');
            $scope.loadingCitiesLabel = gettextCatalog.getString('Loading Cities');

            $scope.lazyLoadingLabel = gettextCatalog.getString('Loading');

            $scope.showFullStatisticsLabel = gettextCatalog.getString('Show full statistics');
            $scope.showLessStatisticsLabel = gettextCatalog.getString('Show less');

            $scope.scansLabel = gettextCatalog.getString('Scans');
            $scope.OSLabel = gettextCatalog.getString('OS');
            $scope.countryLabel = gettextCatalog.getString('Country');
            $scope.cityLabel = gettextCatalog.getString('City');

            $scope.noScansLabel = gettextCatalog.getString('No data available');

            $scope.scansOnOSTooltipLabel = gettextCatalog.getString('scans on');

            /**
             * Tooltip for OS charts in order to show amount
             * of scans for specific platform
             */
            $scope.tooltipInit = function () {
                $('[data-toggle="tooltip"]').tooltip({
                    delay: {
                        show: 500,
                        hide: 200
                    }
                });
            };

            /**
             * Dynamically assign tooltip title
             *
             * @param scanAmount
             * @param osName
             *
             * @returns {string}
             */
            $scope.getTooltipTitle = function (scanAmount, osName) {
                if (!osName) {
                    osName = gettextCatalog.getString('Undefined');
                }
                return scanAmount + " " + $scope.scansOnOSTooltipLabel + " " + osName;
            };

            $scope.showFullStatistics = false;

            //This objects contain all statistic data
            $scope.OSstatistics = [];
            $scope.CountryStatistics = [];
            $scope.CityStatistics = [];

            //Params for API call (type of statistic, pagination and date ranges)
            $scope.apiScanParams = {
                type: "totals",
                page: 1,
                from: "", //$window.moment().subtract(30, 'days').format('YYYY-MM-DD'),
                to: "", //$window.moment().format('YYYY-MM-DD'),
                group_by: "" //'date'
            };


            // Images to show as icons inside chart legend
            var totalScansImg = new Image();
            var uniqueScansImg = new Image();

            // To avoid problems with IE 11 when loading the page,
            // use .png images, because chart.js has a problem loading .svg
            totalScansImg.src = '/img/TotalScans_Icon.png';
            uniqueScansImg.src = '/img/UniqueScans_Icon.png';

            totalScansImg.width = 15;
            totalScansImg.height = 15;

            uniqueScansImg.width = 15;
            uniqueScansImg.height = 15;

            //This object contains options for chart.js lib
            $scope.chartParams = {
                type: 'bar',

                // The data for our dataset
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: gettextCatalog.getString('Unique'),
                            backgroundColor: 'rgba(71, 189, 239, 0.9)',
                            borderColor: 'rgba(71, 189, 239, 1)',
                            data: [],
                            pointStyle: uniqueScansImg,
                            hidden: true
                        },
                        {
                            label: gettextCatalog.getString('Total'),
                            backgroundColor: 'rgba(132, 206, 107, 0.9)',
                            borderColor: 'rgba(132, 206, 107, 1)',
                            data: [],
                            pointStyle: totalScansImg
                        },
                        {
                            label: gettextCatalog.getString(''),
                            backgroundColor: 'rgba(0, 0, 0, 0)',
                            borderColor: 'rgba(0, 0, 0, 0)',
                            data: [],
                            hidden: true
                        }
                    ]
                },

                // Configuration options
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    legend: {
                        reverse: true,
                        labels: {
                            // This more specific font property overrides the global property
                            fontColor: '#a4a6a8',
                            fontStyle: '600',
                            usePointStyle: true,
                            filter: function (item) {
                                return item.datasetIndex !== 2;
                            }
                        }
                    },
                    tooltips: {
                        callbacks: {
                            title: function (tooltipItem, data) {
                                if ($scope.apiScanParams.group_by == 'hour') {
                                    return $window.moment.utc(data.labels[tooltipItem[0].index]).format("MMM DD, YYYY HH:00");
                                } else if ($scope.apiScanParams.group_by == 'month') {
                                    return $window.moment.utc(data.labels[tooltipItem[0].index]).format("MMM, YYYY");
                                } else {
                                    return $window.moment.utc(data.labels[tooltipItem[0].index]).format("MMM DD, YYYY");
                                }
                            },
                            label: function (tooltipItem, data) {
                                return data.datasets[tooltipItem.datasetIndex].label + ": " + tooltipItem.yLabel;
                            },
                        }
                    },
                    scales: {
                        yAxes: [{
                            stacked: false,
                            ticks: {
                                beginAtZero: true,
                                fontColor: '#a4a6a8',
                                //fontStyle: "600",
                                callback: function(value) {
                                    if (value % 1 === 0 && value !== 0) {
                                        return value;
                                    }
                                } //Remove steps like 0, 0.1, 0.2 etc
                            }
                        }],
                        xAxes: [{
                            offset: true,
                            stacked: true,
                            type: 'time',
                            time: {
                                unit: 'day'
                            },
                            bounds: 'ticks',
                            gridLines: {
                                drawOnChartArea: false
                            },
                            ticks: {
                                autoSkip: true,
                                fontColor: '#a4a6a8',
                                //fontStyle: "600",
                                maxRotation: 0
                            }
                        }]
                    }
                }
            };

            $scope.chartLoading = true;
            $scope.OSLoading = true;
            $scope.countryLoading = true;
            $scope.cityLoading = true;

            $scope.contentLoading = false;

            $scope.actions = [
                // We'll need this section later to enable download features
                // {
                //     label: gettextCatalog.getString('Download as PDF'),
                //     icon: 'download-normal',
                //     callback: function () {
                //         console.log('pdf');
                //     }
                // },
                {
                    label: gettextCatalog.getString('Download as CSV'),
                    icon: 'download-normal',
                    callback: function () {
                        var params = {
                            from: $scope.apiScanParams.from,
                            to: $scope.apiScanParams.to
                        };
                        window.location.assign(api.getUrl('/v1/export/' + $scope.value.id, params));
                    }
                },
                {
                    label: gettextCatalog.getString('Reset Scans'),
                    icon: 'reset',
                    callback: function () {
                        if (!$scope.disabled) {
                            $scope.open.modal.reset = true;
                        } else {
                            $scope.openDemoModal = true;
                        }
                    }
                }
            ];

            //This object contains date ranges to filter statistics data
            $scope.dateItems = [
                {
                    label: gettextCatalog.getString('Auto-Range'),
                    callback: function (item) {
                        //$scope.date = item.label;
                        // $scope.open.modal.datepicker = true;
                        $scope.apiScanParams.from = "";
                        $scope.apiScanParams.to = "";
                        $scope.apiScanParams.group_by = "";

                        if ($scope.value.total_scans != 0) {
                            $scope.updateAllScans();
                        } else {
                            $scope.date = $window.moment($scope.value.created).format('MMM DD, YYYY') +
                                " - " + $window.moment().format('MMM DD, YYYY');
                            $scope.apiScanParams.group_by = 'date';
                        }
                    }
                },
                {
                    label: gettextCatalog.getString('Last 48 hours'),
                    callback: function (item) {
                        $scope.apiScanParams.from = $window.moment().subtract(2, 'days').format('YYYY-MM-DD');
                        $scope.apiScanParams.to = $window.moment().format('YYYY-MM-DD');
                        $scope.apiScanParams.group_by = 'hour';

                        if ($scope.value.total_scans != 0) {
                            $scope.updateAllScans();
                        } else {
                            $scope.date = $window.moment($scope.apiScanParams.from).format("MMM DD, YYYY") +
                                " - " + $window.moment($scope.apiScanParams.to).format("MMM DD, YYYY");
                        }
                    }
                },{
                    label: gettextCatalog.getString('Last 30 days'),
                    callback: function (item) {
                        $scope.apiScanParams.from = $window.moment().subtract(30, 'days').format('YYYY-MM-DD');
                        $scope.apiScanParams.to = $window.moment().format('YYYY-MM-DD');
                        $scope.apiScanParams.group_by = 'date';

                        if ($scope.value.total_scans != 0) {
                            $scope.updateAllScans();
                        } else {
                            $scope.date = $window.moment($scope.apiScanParams.from).format("MMM DD, YYYY") +
                                " - " + $window.moment($scope.apiScanParams.to).format("MMM DD, YYYY");
                        }
                    }
                },{
                    label: gettextCatalog.getString('Last 12 months'),
                    callback: function (item) {
                        $scope.apiScanParams.from = $window.moment().subtract(12, 'month').format('YYYY-MM-DD');
                        $scope.apiScanParams.to = $window.moment().format('YYYY-MM-DD');
                        $scope.apiScanParams.group_by = 'month';

                        if ($scope.value.total_scans != 0) {
                            $scope.updateAllScans();
                        } else {
                            $scope.date = $window.moment($scope.apiScanParams.from).format("MMM DD, YYYY") +
                                " - " + $window.moment($scope.apiScanParams.to).format("MMM DD, YYYY");
                        }
                    }
                },
                {
                    label: gettextCatalog.getString('Custom'),
                    callback: function (item) {
                        $scope.open.modal.datepicker = true;
                    }
                }
            ];

            //This object contains grouping parameter to display statistics grouped by hour/month or daily
            $scope.groupByItems = [
                {
                    label: gettextCatalog.getString('Hour'),
                    callback: function (item) {
                        $scope.chartLoading = true;
                        $scope.groupByLabel = item.label;

                        $scope.apiScanParams.group_by = 'hour';
                        $scope.apiScanParams.type = "totals";

                        //Checking lenght of date range
                        var to = new Date($scope.apiScanParams.to);
                        var from = new Date($scope.apiScanParams.from);

                        var utc2 = Date.UTC(to.getFullYear(), to.getMonth(), to.getDate());
                        var utc1 = Date.UTC(from.getFullYear(), from.getMonth(), from.getDate());

                        var diff =  Math.floor((utc2 - utc1) / (1000 * 60 * 60 * 24)) + 1;

                        //If range between dates is more than 7 days we're unable to display chart with hour grouping
                        //Automatically change range to 2 days
                        if (diff > 7) {
                            $scope.apiScanParams.from = $window.moment().subtract(2, 'days').format('YYYY-MM-DD');
                            $scope.apiScanParams.to = $window.moment().format('YYYY-MM-DD');
                        }
                        if ($scope.value.total_scans != 0) {
                            api.getScanStatistics($scope.value.id, $scope.apiScanParams, $scope.updateChartScans);
                        }

                    }
                },{
                    label: gettextCatalog.getString('Day'),
                    callback: function (item) {
                        $scope.chartLoading = true;
                        $scope.groupByLabel = item.label;

                        $scope.apiScanParams.group_by = 'date';
                        $scope.apiScanParams.type = "totals";

                        if ($scope.value.total_scans != 0) {
                            api.getScanStatistics($scope.value.id, $scope.apiScanParams, $scope.updateChartScans);
                        }
                    }
                },{
                    label: gettextCatalog.getString('Month'),
                    callback: function (item) {
                        $scope.chartLoading = true;
                        $scope.groupByLabel = item.label;

                        $scope.apiScanParams.group_by = 'month';
                        $scope.apiScanParams.type = "totals";

                        if ($scope.value.total_scans != 0) {
                            api.getScanStatistics($scope.value.id, $scope.apiScanParams, $scope.updateChartScans);
                        }
                    }
                },
            ];

            //Object which contains states of modal windows and menus
            $scope.open = {
                menu: {
                    day: false,
                    download: false,
                    groupBy: false
                },
                modal: {
                    datepicker: false,
                    reset: false
                }
            };

            $scope.menuDayClick = function () {
                // console.log($('.qr-campaign-charts__date').outerWidth());
                $timeout(function () {
                    $('.datePopup .qr-popup').css('width', $('.qr-campaign-charts__date').innerWidth());
                });

                $scope.open.menu.day = !$scope.open.menu.day;
            };

            $scope.menuGroupByClick = function () {
                $scope.open.menu.groupBy = !$scope.open.menu.groupBy;
            };

            $scope.menuDownloadClick = function () {
                $scope.open.menu.download = !$scope.open.menu.download;
            };

            $scope.getCaretClass = function () {
                return {
                    'qr-choice-button__caret--open': $scope.open
                };
            };

            //Chart initialization
            var scansOverTime = document.getElementById('scansOverTime').getContext('2d');
            var chartLine = new Chart(scansOverTime, $scope.chartParams);

            /**
             * By default we don't load Country and City statistics
             * We call API only when tables are visible to user (Show full statistics/Show less)
             */
            $scope.toggleStatistics = function () {
                $scope.showFullStatistics = !$scope.showFullStatistics;
                if ($scope.showFullStatistics) {

                    $scope.apiScanParams.type = "country";
                    api.getScanStatistics($scope.value.id, $scope.apiScanParams, $scope.updateCountryScans);

                    $scope.apiScanParams.type = "city";
                    api.getScanStatistics($scope.value.id, $scope.apiScanParams, $scope.updateCityScans);
                }

            };

            /**
             * Return additional class to show/hide full statistics table
             * @returns {string}
             */
            $scope.getChartsClass = function () {
                if (!$scope.showFullStatistics) {
                    return 'tables--less';
                }
            };

            /**
             * This function updates datasets in chart
             * For example when date range filter is changed
             * @param response
             */
            $scope.updateChartScans = function (response) {
                chartLine.destroy();

                //Resetting current datasets
                $scope.chartParams.data.labels = [];
                $scope.chartParams.data.datasets[0].data = [];
                $scope.chartParams.data.datasets[1].data = [];

                $scope.chartParams.data.datasets[2].data = [];

                var maxValue = 0;

                //Pushing new received data
                angular.forEach(response.data.items, function (value) {
                    $scope.chartParams.data.labels.push(value[0]);
                    $scope.chartParams.data.datasets[1].data.push(value[1]);
                    $scope.chartParams.data.datasets[0].data.push(value[2]);

                    //define max value of dataset
                    if (value[1] > maxValue) {
                        maxValue = value[1];
                    }

                    if (value[2] > maxValue) {
                        maxValue = value[2];
                    }
                });

                //Add 5% additional offset for chart
                $scope.chartParams.data.datasets[2].data.push(maxValue + (maxValue*5)/100);

                if (response.data.dateRange.type == "month") {
                    $scope.chartParams.options.scales.xAxes[0].time.unit = 'month';
                } else {
                    $scope.chartParams.options.scales.xAxes[0].time.unit = 'day';
                }

                //If API date range params ("from" and "to") wasn't specified
                //we're applying received from API date range
                if ($scope.apiScanParams.from == "" && $scope.apiScanParams.to == "") {

                    if (response.data.dateRange.start && response.data.dateRange.end && response.data.dateRange.type) {
                        $scope.date = $window.moment(response.data.dateRange.start).format("MMM DD, YYYY") +
    -                        " - " + $window.moment(response.data.dateRange.end).format("MMM DD, YYYY");
    
                        $scope.apiScanParams.from = response.data.dateRange.start;
                        $scope.apiScanParams.to = response.data.dateRange.end;
                        $scope.apiScanParams.group_by = response.data.dateRange.type;
    
                        if (response.data.dateRange.type == "date") {
                            $scope.groupByLabel = "Day";
                        } else {
                            $scope.groupByLabel = response.data.dateRange.type;
                        }
                        
                    } else {
                        // Potentially no scans found - API provides empty date range
                        // fallback date range to the last 30 days
                        $scope.date = $window.moment().subtract(30, 'days').format('MMM DD, YYYY') +
                        " - " + $window.moment().format('MMM DD, YYYY');
                        $scope.groupByLabel = gettextCatalog.getString('Month');
                    }
                    
                } else {
                    $scope.date = $window.moment($scope.apiScanParams.from).format("MMM DD, YYYY") +
                        " - " + $window.moment($scope.apiScanParams.to).format("MMM DD, YYYY");
                }

                //New chart with updated data
                chartLine = new Chart(scansOverTime, $scope.chartParams);
                $scope.chartLoading = false;
            };

            /**
             * This function updates data in OS scans table
             * For example when date range filter is changed
             * @param response
             */
            $scope.updatePlatformScans = function (response) {
                //Resetting old data
                $scope.OSstatistics = [];

                if (response.data.items.length > 0) {
                    //We're recalculate here our percentages in order to
                    //make first top entry (for example 5% of total scans) as 100%
                    var topReference = response.data.items[0][2];

                    //First element will be 100%
                    //others will be recalculated according to top reference

                    angular.forEach(response.data.items, function (value) {
                        value[3] = ((value[2] / topReference) * 100).toFixed(2);
                        $scope.OSstatistics.push(value);
                    });
                }
                $scope.OSLoading = false;
            };

            /**
             * This function updates data in Country scans table
             * For example when date range filter is changed
             * @param response
             */
            $scope.updateCountryScans = function (response) {
                $scope.countryStatistics = [];

                angular.forEach(response.data.items, function (value) {
                    $scope.countryStatistics.push(value);
                });

                $scope.countryLoading = false;
            };

            /**
             * This function updates data in City scans table
             * For example when date range filter is changed
             * @param response
             */
            $scope.updateCityScans = function (response) {
                $scope.cityStatistics = [];

                angular.forEach(response.data.items, function (value) {
                    $scope.cityStatistics.push(value);
                });

                $scope.cityLoading = false;
            };

            /**
             * Callback of reseting all statistics and chart
             * @param response
             */
            $scope.resetStatistics = function (response) {
                $scope.OSstatistics = [];
                $scope.countryStatistics = [];
                $scope.cityStatistics = [];

                $scope.value.total_scans = 0;
                $scope.value.unique_scans = 0;

                $scope.apiScanParams.type = "totals";

                $scope.date = $window.moment().subtract(30, 'days').format('MMM DD, YYYY') +
                    " - " + $window.moment().format('MMM DD, YYYY');
                $scope.groupByLabel = gettextCatalog.getString('Month');

                $scope.apiScanParams.group_by = "month";
                $scope.apiScanParams.from = $window.moment().subtract(30, 'days').format('YYYY-MM-DD');
                $scope.apiScanParams.to = $window.moment().format('YYYY-MM-DD');

                api.getScanStatistics($scope.value.id, $scope.apiScanParams, $scope.updateChartScans);

                $scope.showFullStatistics = false;
            };

            /**
             * Function which call above function on API success callback
             * This will reset all user statistics data
             */
            this.resetScans = function () {
                api.resetScanStatistics($scope.value.id, $scope.resetStatistics);
            };

            this.updateScans = function (from, to, group) {
                $scope.apiScanParams.from = from;
                $scope.apiScanParams.to = to;
                $scope.apiScanParams.group_by = group;

                if ($scope.value.total_scans != 0) {
                    $scope.updateAllScans();
                } else {
                    $scope.date = $window.moment($scope.apiScanParams.from).format("MMM DD, YYYY") +
                        " - " + $window.moment($scope.apiScanParams.to).format("MMM DD, YYYY");
                }
            };

            /**
             * This function is triggered when data range is changed
             * Inside we trigger update function for each statistic table
             */
            $scope.updateAllScans = function () {
                $scope.chartLoading = true;
                $scope.OSLoading = true;
                $scope.countryLoading = true;
                $scope.cityLoading = true;

                chartLine.clear();

                $('.content-scrollable').attr("data-page", 1);
                $scope.apiScanParams.page = 1;

                if ($scope.apiScanParams.from == "" && $scope.apiScanParams.to == "") {
                    $scope.date = "Auto";
                    $scope.groupByLabel = "Auto";
                } else {
                    $scope.date = $window.moment($scope.apiScanParams.from).format("MMM DD, YYYY") +
                        " - " + $window.moment($scope.apiScanParams.to).format("MMM DD, YYYY");
                }

                $scope.apiScanParams.type = "totals";
                api.getScanStatistics($scope.value.id, $scope.apiScanParams, $scope.updateChartScans);

                $scope.apiScanParams.type = "platform";
                api.getScanStatistics($scope.value.id, $scope.apiScanParams, $scope.updatePlatformScans);

                if ($scope.showFullStatistics) {

                    $scope.apiScanParams.type = "country";
                    api.getScanStatistics($scope.value.id, $scope.apiScanParams, $scope.updateCountryScans);

                    $scope.apiScanParams.type = "city";
                    api.getScanStatistics($scope.value.id, $scope.apiScanParams, $scope.updateCityScans);
                }
            };

            $('.content-scrollable').perfectScrollbar({suppressScrollX: true});

            // Using this $scope.$watch, we detect changes in the id value and reset the date range to "Auto"
            // Also determine if the QR code has zero scans, then we set the date range to the last 30 days

            $scope.$watch('value.id', function () {
                //Selected filter range by default
                //By default we have Auto-Range option
                if ($scope.value.total_scans != 0) {
                    $scope.date = "Auto";
                    $scope.groupByLabel = "Auto";

                    $scope.apiScanParams.from = "";
                    $scope.apiScanParams.to = "";
                    $scope.apiScanParams.group_by = "";

                    // Update scans using the "Auto" range
                    $timeout(function () {
                        $scope.updateAllScans();
                    });
                } else {
                    // Set the date range to the last 30 days
                    $scope.date = $window.moment().subtract(30, 'days').format('MMM DD, YYYY') +
                        " - " + $window.moment().format('MMM DD, YYYY');
                    $scope.groupByLabel = gettextCatalog.getString('Month');

                    // Clear chart to not display previous data
                    chartLine.clear();
                }
            });

            /**
             * Changing group by label if dates has been selected via custom datepicker
             */
            $scope.$watch('apiScanParams.group_by', function () {
                if ($scope.apiScanParams.group_by != "") {
                    if ($scope.apiScanParams.group_by == "date") {
                        $scope.groupByLabel = "Day";
                    } else {
                        $scope.groupByLabel = $scope.apiScanParams.group_by;
                    }
                }
            });

            $scope.$watch('disabled', function (newVal, oldVal) {
                if (newVal == true) {
                    $scope.showFullStatistics = false;

                    $scope.apiScanParams.from = "";
                    $scope.apiScanParams.to = "";

                    $scope.toggleStatistics();
                    $scope.updateAllScans();
                } else if (newVal == false && oldVal == true) {
                    $scope.showFullStatistics = true;

                    $scope.toggleStatistics();
                    $scope.updateAllScans();
                }
            });

            /**
             * This function is watching total scans count
             * If code has less than 100 scans then we can provide live monitoring
             * of scans and update it if someone has scanned this code
             */
            $scope.$watch('value.total_scans', function (newValue, oldValue) {
                if (newValue != oldValue && newValue != 0) {
                    if (newValue <= 100 || $scope.disabled) {
                        $scope.updateAllScans();
                        $scope.openEmptyState = false;
                    }
                } else if (newValue == 0) {
                    $scope.openEmptyState = true;
                }
            });
        }]
    };
}]);
;
/**
 * The modal for QR Code campaign statistics chart datepicker.
 */
app.directive('qrDatepickerModal', ['api', '$window', 'gettextCatalog', 'markup', 'account', function (api, $window, gettextCatalog, markup, account) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" buttons="getButtons()" class="qr-datepicker-modal">' +
            '<div ng-init="initDatepicker()" class="qr-datepicker-modal__content">' +
                '<div id="dp1"><input id="chartdatetimepickerstart" type="hidden"></div>' +
                '<div id="dp2"><input id="chartdatetimepickerend" type="hidden"></div>' +
            '</div>' +
            '</qr-modal>',
        scope: {
            open: '=',
            from: '=',
            to: '=',
            group: '='
        },
        require: '^^qrCampaignCharts',
        link: function (scope, element, attributes, qrCampaignCharts) {
            scope.qrCampaignCharts = qrCampaignCharts;
        },
        controller: ['$scope', function ($scope) {

            //Specify parent elements for each datepicker
            //This helps us to bind date picker elements correctly
            var par1 = ('#dp1');
            var par2 = ('#dp2');

            $scope.initDatepicker = function () {

                $scope.selectedDate = {
                    from: "",
                    to: ""
                };

                $('#chartdatetimepickerstart').datetimepicker({
                    widgetParent: par1,
                    format: "YYYY-MM-DD"
                });
                $('#chartdatetimepickerend').datetimepicker({
                    widgetParent: par2,
                    format: "YYYY-MM-DD",
                    maxDate: new Date()
                });

                $("#chartdatetimepickerstart").on("dp.change", function (e) {
                    $scope.selectedDate.from = $('#chartdatetimepickerstart').data("DateTimePicker").getDate().format('YYYY-MM-DD');
                    $('#chartdatetimepickerend').data("DateTimePicker").setMinDate(e.date);
                });
                $("#chartdatetimepickerend").on("dp.change", function (e) {
                    $scope.selectedDate.to = $('#chartdatetimepickerend').data("DateTimePicker").getDate().format('YYYY-MM-DD');
                    $('#chartdatetimepickerstart').data("DateTimePicker").setMaxDate(e.date);
                });

                $(".bootstrap-datetimepicker-widget").attr("id", "qr-calendar");

                $('#chartdatetimepickerstart').click();
                $('#chartdatetimepickerend').click();
            };

            $scope.getGroupBy = function () {
                var to = new Date($scope.selectedDate.to);
                var from = new Date($scope.selectedDate.from);

                var utc2 = Date.UTC(to.getFullYear(), to.getMonth(), to.getDate());
                var utc1 = Date.UTC(from.getFullYear(), from.getMonth(), from.getDate());

                var diff =  Math.floor((utc2 - utc1) / (1000 * 60 * 60 * 24)) + 1;

                if (diff <= 2) {
                    return "hour";
                } else if (diff > 2 && diff <= 60) {
                    return "date";
                } else {
                    return "month";
                }
            };

            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Save'),
                    callback: function () {
                        // $scope.label = $window.moment($scope.selectedDate.from).format("MMM DD, YYYY") +
                        //     " - " + $window.moment($scope.selectedDate.to).format("MMM DD, YYYY");

                        $scope.group = $scope.getGroupBy();

                        $scope.from = $scope.selectedDate.from;
                        $scope.to = $scope.selectedDate.to;

                        $scope.qrCampaignCharts.updateScans($scope.from, $scope.to, $scope.group);

                        $scope.open = false;
                    }
                },
                {
                    label: gettextCatalog.getString('Cancel'),
                    type: 'link',
                    callback: function () {
                        //$scope.selectedDate.from = "";
                        //$scope.selectedDate.to = "";
                        $scope.open = false;
                    }
                }
            ];

            $scope.getButtons = function () {
                return $scope.buttons;
            };

            $scope.$watchGroup(['from', 'to'], function () {
                $('#chartdatetimepickerstart').data("DateTimePicker").setDate(new Date($scope.from));
                $('#chartdatetimepickerend').data("DateTimePicker").setDate(new Date($scope.to));
            });

        }]
    };
}]);
;
/**
 * A modal for pausing QR codes.
 */
app.directive('qrResetScansModal', ['api', 'gettextCatalog', '$sce', function (api, gettextCatalog, $sce) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" data-title="{{ title }}" buttons="::buttons">' +
                '<div class="qr-reset-scans-modal__content" ng-bind-html="::message"></div>' +
            '</qr-modal>',
        scope: {
            open: '=',      // Open state of the modal.
        },
        require: '^^qrCampaignCharts',
        link: function (scope, element, attributes, qrCampaignCharts) {
            scope.qrCampaignCharts = qrCampaignCharts;
        },
        controller: ['$scope', function ($scope) {

            $scope.title = gettextCatalog.getString('Reset Scans');

            /**
             * Translations
             */
            $scope.message = $sce.trustAsHtml(
                gettextCatalog.getString('Resetting your scans will make you lose all scan data related to this QR Code. Are you sure?')
            );

            /**
             * Array of buttons for the Pause QR Code modal.
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Cancel'),
                    callback: function () {
                        $scope.open = false;
                    }
                },
                {
                    label: gettextCatalog.getString('Reset'),
                    type: 'link',
                    callback: function () {
                        $scope.qrCampaignCharts.resetScans();
                        $scope.open = false;
                    }
                }
            ];
        }]
    };
}]);
;
/**
 * A modal for pausing QR codes.
 */
app.directive('qrDemoModal', ['gettextCatalog', function (gettextCatalog) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" data-title="{{ ::title }}" buttons="::buttons" close-icon="true">' +
                '<div class="qr-pause-code-modal__content" ng-bind="::message"></div>' +
            '</qr-modal>',
        scope: {
            open: '=',      // Open state of the modal.
        },
        controller: ['$scope', function ($scope) {
            // Translations.
            $scope.title = gettextCatalog.getString('Feature not available');
            $scope.message = gettextCatalog.getString('This feature is not available in the Demo Statistics.');

            /**
             * Array of buttons for the Pause QR Code modal.
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('OK'),
                    callback: function () {
                        $scope.open = false;
                    }
                }
            ];
        }]
    };
}]);
;
/**
 * Input for displaying/editing a short URL.
 */
app.directive('qrShortUrl', ['gettextCatalog', 'account', '$timeout', '$document', function (gettextCatalog, account, $timeout, $document) {
    'use strict';
    return {
        restrict: 'E',
        template:
            '<div class="qr-short-url" ng-class="{&apos;qr-short-url--editing&apos;: isEditing}">' +
                '<div class="qr-short-url__input">' +
                    '<div class="qr-short-url__domain" ng-mouseenter="showTooltip = true" ng-mouseleave="showTooltip = false" ng-click="indicatorClick()">' +
                        '<span ng-bind="getDomainBeginning()"></span>' +
                        '<span ng-bind="getDomainEnding()"></span>' +
                    '</div>' +
                    '<span aria-hidden="true" class="qr-short-url__dropdown-indicator" ng-click="indicatorClick()" ng-if="isEditing" ng-class="{&apos;qr-short-url__dropdown-indicator--open&apos;: open}">' +
                        '<i class="icon icon-down-open-mini"></i>' +
                    '</span>' +
                    '<input class="qr-short-url__code" ng-model="code" ng-readonly="!isEditing" ng-keydown="keyPressed($event)" ng-mousemove="checkTooltipVisibility($event, true)" ng-mouseleave="showTooltip = false" ng-class="{&apos;qr-short-url__code--error&apos;: errors.code}" ng1change="errors.code = &apos;&apos;">' +
                    '<button type="button" class="qr-short-url__edit" ng-click="isEditing = true">' +
                        '<span class="icon icon-avatar-edit"></span>' +
                    '</button>' +
                    '<qr-popup-menu open="open" items="::actions" popup-menu-class="qr-short-url__dropdown-menu" no-layer="true"></qr-popup-menu>' +
                '</div>' +
                '<div class="qr-short-url__tooltip" ng-bind="shortUrl" ng-class="{&apos;qr-short-url__tooltip--open&apos;: showTooltip && !isEditing}" ng-mousemove="checkTooltipVisibility($event)" ng-mouseleave="showTooltip = false"></div>' +
                '<div class="qr-short-url__error" ng-bind="errors.code" ng-show="errors.code"></div>' +
                '<div class="qr-short-url__actions">' +
                    '<button type="button" class="qr-short-url__cancel" ng-bind="::cancelLabel" ng-click="cancel()"></button>' +
                    '<button type="button" class="qr-short-url__save" ng-bind="::saveLabel" ng-click="save()"></button>' +
                '</div>' +
            '</div>',
        scope: {
            open: '=',          // Open states.
            shortUrl: '=',      // The short URL to display/edit.
            shortCode: '=',     // This short code is set by the component.
            isEditing: '=',     // Will be set to "true" by the component while editing.
            validation: '@',    // Set to "true" to enable external validation. In this case the field does not change isEditing on save.
            errors: '=',        // Validation errors.
            shortDomain: '='
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            /**
             * Translations.
             */
            $scope.setUpOwnLabel = gettextCatalog.getString('Set up your own');
            $scope.cancelLabel = gettextCatalog.getString('Cancel');
            $scope.saveLabel = gettextCatalog.getString('Save');

            /**
             * The first part of the short URL parsed by this component.
             * @type {string}
             */
            $scope.domain = '';

            /**
             * Short code variable for the input.
             * @type {string}
             */
            $scope.code = '';

            /**
             * This controls displaying of the URL tooltip.
             * @type {boolean}
             */
            $scope.showTooltip = false;

            /**
             * Validation errors.
             * @type {{code: string}}
             */
            $scope.errors = {
                code: ''
            };

            /**
             * Get the actual short code from the shortUrl.
             * @returns {string}
             */
            $scope.getShortCodeFromUrl = function () {
                return ('' + $scope.shortUrl).split('/').slice(-1)[0];
            };

            /**
             * Get the actual domain from the shortUrl.
             * @returns {string}
             */
            $scope.getDomainFromUrl = function () {
                return ('' + $scope.shortUrl).split('/').slice(0, -1).join('/') + '/';
            };

            /**
             * Handler for clicks on the menu button.
             * It simply opens the menu.
             */
            $scope.indicatorClick = function () {
                $scope.open = !$scope.open;
            };

            $document.bind('click', function(event){
                var isClickedElementChildOfPopup = $element.find(event.target).length > 0;

                if (isClickedElementChildOfPopup) {
                    return;
                }

                $scope.open = false;
                $scope.$apply();
            });

            /**
             * Save the short code.
             */
            $scope.save = function () {
                if ($scope.getShortCodeFromUrl() === $scope.code && $scope.getDomainFromUrl() === $scope.domain && !$scope.errors.code) { // Nothing was changed.
                    $scope.isEditing = false;
                    return;
                }
                if (!$scope.code) { // Save with empty value means cancel.
                    $scope.cancel();
                    return;
                }
                // $scope.shortUrl = $scope.domain + $scope.code; Don't change shortUrl, change only shortCode
                // (at least now as it makes problems with cancelling of editing and restoring old value of shortCode).
                $scope.shortCode = $scope.code;
                $scope.shortDomain = $scope.domain;

                if ($scope.validation !== 'true') {
                    $scope.isEditing = false;
                }
            };

            /**
             * Actions for the menu.
             * @type {*}
             */

            $timeout(function () {
                // We go through the entire list of user domains and filter domains from those that are active or they
                // are already selected at the moment. After that we create a list of domains that will be displayed in dropdown
                $scope.actions = account.getAccount().domains.filter(function (domain) {
                    return domain.is_enabled || $scope.domain === domain.url;
                }).map(function (domain) {
                    return {
                        label: domain.url,
                        callback: function () {
                            $scope.domain = domain.url;
                        }
                    };
                });

                // Add a custom item that we give as an opportunity to add your own domain
                $scope.actions.push({
                    label: $scope.setUpOwnLabel,
                    callback: function () {
                        // Open the white label in a new tab
                        window.open('/whitelabel');
                    }
                });
            }, 300);



            /**
             * Cancel editing and restore the code from shortUrl.
             */
            $scope.cancel = function () {
                $scope.domain = $scope.getDomainFromUrl();
                $scope.code = $scope.getShortCodeFromUrl();
                $scope.shortCode = $scope.code;
                $scope.shortDomain = $scope.domain;
                $scope.isEditing = false;
            };

            /**
             * Returns first characters of the domain except the ending (see below).
             * @returns {string}
             */
            $scope.getDomainBeginning = function () {
                return $scope.domain.substr(0, $scope.domain.length - 10);
            };

            /**
             * Returns last several characters of the domain to implement ellipsis in the middle of string.
             * @returns {string}
             */
            $scope.getDomainEnding = function () {
                return $scope.domain.substr(-10);
            };

            /**
             * Process Enter and Esc key presses as save and cancel.
             * @param $event
             */
            $scope.keyPressed = function ($event) {
                if ($event.keyCode === 13) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $scope.save();
                } else if ($event.keyCode === 27) {
                    $event.preventDefault();
                    $event.stopPropagation();
                    $scope.cancel();
                }
            };

            /**
             * If the mouse is moving over the tooltip and going to the edit button,
             * we should hide the tooltip.
             * @param $event
             * @param [isShortCode] true if the it's an event from the short code field.
             */
            $scope.checkTooltipVisibility = function ($event, isShortCode) {
                var activeWidth = (isShortCode ? 0 : $element.find('.qr-short-url__domain')[0].clientWidth) + $element.find('.qr-short-url__code')[0].clientWidth;
                $scope.showTooltip = ($event.offsetX || 0) < activeWidth - 10;
            };

            // Sync $scope.url and shortUrl.
            $scope.$watch('shortUrl', function (shortUrl) {
                $scope.code = ('' + shortUrl).split('/').slice(-1)[0];
                $scope.domain = ('' + shortUrl).split('/').slice(0, -1).join('/') + '/';
                $scope.shortCode = $scope.code;
                $scope.shortDomain = $scope.domain;

            });

            // Focus on the input, if open.
            $scope.$watch('isEditing', function (isEditing) {
                var $input = $element.find('input');
                if (isEditing) {
                    // $input.focus(); temporary disabled because users can enter data in the input while a message window is above the input.
                } else {
                    $scope.errors.code = '';
                    $input[0].value = ''; // This is needed to reset scrolling and selection of the input.
                    $timeout(function () {
                        $input[0].setSelectionRange(0, 0);
                        $input[0].value = $scope.code;
                    }, 100);
                }
            });

            // This makes in sync length of domain name and width of the DOM element.
            $scope.$watch('domain', function (domain) {
                $element.find('.qr-short-url__domain').css('flex-shrink', ('' + domain).length <= 20 ? '0' : '1');
            });
        }]
    };
}]);
;
// Icon buttons with actions for QR codes.
app.directive('qrDownloadManage', function () {
    'use strict';
    return {
        restrict: 'E',
        template:
            '<qr-demo-modal open="open.demo" ng-if="open.demo"></qr-demo-modal>' +
            '<button ng-style="{cursor:cursorType}" class="qr-icon-menu__item" ng-repeat="item in items track by $index" ng-if="$index <= 2 && isVisible(item)" ng-click="click(item)" data-toggle="tooltip" data-placement="bottom" title="{{ ::item.tooltip }}" data-test="{{item.testEvent}}">' +
                '<i class="qr-icon-menu__icon" ng-class="getIconClass(item)"></i>' +
            '</button>',
        scope: {
            items: '=', // Array of available actions.
            isDemo: '='
        },
        controller: ['$scope', '$element', '$timeout', function ($scope, $element, $timeout) {
            // Open state for the demo modal.
            $scope.open = {
                demo: false
            };

            /**
             * Get the CSS class of current icon
             * @param item
             * @returns {string}
             */
            $scope.getIconClass = function (item) {
                return 'icon icon-' + item.icon;
            };

            /**
             * This will be executed on clicks on items
             * @param item
             * @param itemIndex
             */
            $scope.click = function (item, itemIndex) {
                if($scope.isAbTestEnabled_CNV2467()) {
                    return;
                }
                if ($scope.isDemo) {
                    $scope.open.demo = true;
                } else {
                    if ("event" in item) {
                        $scope.$emit(item.event, item);
                    } else if ("callback" in item) {
                        item.callback(item);
                    }
                }
            };

            /**
             * Check if the item is visible or not.
             * @param item
             * @returns {boolean}
             */
            $scope.isVisible = function (item) {
                if (!("visible" in item)) {
                    return true;
                }
                if (typeof item.visible === "function") {
                    return item.visible(item);
                }

                return item.visible;
            };

            $scope.$watch("items", function () {

                $timeout(function () {
                    $element.find('[data-toggle="tooltip"]').tooltip({animation: false});
                });

            });

            $scope.isAbTestEnabled_CNV2467 = function() {
                return window.qr.utils.optimizely.isAbTestVariantActive('23988530195', '24017330211');
            };

            $scope.cursorType = function() {
                if($scope.isAbTestEnabled_CNV2467()) {
                    return 'not-allowed'
                } else {
                    return 'pointer'
                }
            }
        }]
    };
});
;
// This is a component for displaying an image button with lazy loading and with support of deletion X button.
app.directive('qrImageTile', ['viewport', '$timeout', function (viewport, $timeout) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-image-tile">' +
                '<button type="button" class="qr-image-tile__image" ng-click="click()" ng-style="styles.image" ng-class="getImageClasses()"></button>' +
                '<button type="button" class="qr-image-tile__delete" ng-if="(states.editing && !states.selected) || (states.editing && deleteSelected)" ng-click="delete()">&times;</button>' +
                '<div class="qr-image-tile__spinner" ng-if="states.waiting && loadingType !== &apos;skeleton&apos;">' +
                    '<qr-spinner loading="states.waiting">' +
                '</div>' +
            '</div>',
        scope: {
            imageUrl: '=',          // URL of the image.
            fallbackUrl: '=',       // Fallback URL (optional).
            isEditing: '=',         // Flag to enable/disable editing mode.
            isSelected: '=',        // Flag to control selected state of the component.
            isAlwaysVisible: '@',   // Set to "true" to make the element always visible and to disable the viewport logic.
            deleteSelected: '=',    // Flag to enable/disable deleting the active component.
            loadingType: '@',       // Skeleton / spinner
            onClick: '&',           // Clicks handler.
            onDelete: '&'           // Deletion handler.
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            // States of the component.
            $scope.states = {
                waiting: true,  // The image is loading or the component is waiting for an image URL (initial state).
                editing: false, // The component is in edit mode and can be deleted.
                selected: false // The component is selected.
            };

            // Internal data of the component.
            $scope.data = {
                realImageUrl: ''
            };

            // Dynamic component's CSS styles.
            $scope.styles = {
                image: {
                    backgroundImage: ''
                }
            };

            // Returns CSS classes of the image button.
            $scope.getImageClasses = function () {
                return {
                    'qr-image-tile__image--selected': $scope.states.selected,
                    'qr-image-tile__image--waiting': $scope.states.waiting,
                    'qr-image-tile--loading': $scope.loadingType === 'skeleton' & $scope.states.waiting
                };
            };

            // This function starts image loading if possible and the component is visible in the viewport.
            // @todo This code has problems in case of frequently changing images (when one image is not yet loaded, but another image is coming).
            // @todo In this case the waiting status is turned off after the first image, but should be after the second.
            $scope.startImageLoading = function (imageUrl) {
                if (imageUrl && imageUrl !== $scope.data.realImageUrl && ($scope.isAlwaysVisible === 'true' || viewport.isElementVisible($element))) {
                    $scope.states.waiting = true;
                    var image = new Image();
                    image.onload = function () {
                        $scope.data.realImageUrl = imageUrl;
                        $scope.styles.image.backgroundImage = 'url(' + image.src + ')';
                        $scope.states.waiting = false;
                        $scope.$apply();
                    };
                    image.onerror = function () {
                        // @todo We should also add some special behaviour when the image can't be loaded.
                        if ($scope.fallbackUrl && this.src.indexOf($scope.fallbackUrl) < 0) {
                            $timeout(function () {
                                $scope.startImageLoading($scope.fallbackUrl);
                            });
                        } else {
                            $scope.states.waiting = true;
                            $scope.$apply();
                        }
                    };
                    image.src = imageUrl;
                }
            };

            // Clicks handler for the main image button.
            $scope.click = function () {
                if (!$scope.states.editing) {
                    $scope.onClick();
                }
            };

            // Clicks handler for the deletion button.
            // Selected items can't be deleted.
            $scope.delete = function () {
                if (($scope.states.editing && !$scope.states.selected) || ($scope.states.editing && $scope.deleteSelected)) {
                    $scope.states.waiting = true; // Mark the image with the waiting status before the request.
                    $scope.onDelete();
                }
            };

            // This keeps the image in sync with the imageUrl attribute.
            $scope.$watch('imageUrl', function (imageUrl, oldImageUrl) {
                if (imageUrl !== '' + oldImageUrl) {
                    $scope.startImageLoading(imageUrl);
                }
            });

            // This synchronizes the edit mode.
            $scope.$watch('isEditing', function (isEditing) {
                $scope.states.editing = isEditing;
            });

            // This syncs selected state.
            $scope.$watch('isSelected', function (isSelected) {
                $scope.states.selected = isSelected;
            });

            // These lines initiate image loading when the component is ready or the viewport is changed.
            $timeout(function () { $scope.startImageLoading($scope.imageUrl); }, 100);
            if ($scope.isAlwaysVisible !== 'true') {
                viewport.onChange(function () {
                    $scope.startImageLoading($scope.imageUrl);
                    $scope.$apply(); // TODO Maybe it can be deleted?
                });
            }
        }]
    };
}]);
;
app.directive("qrCountdownTimer", [
  "gettextCatalog",
  "account",
  "$interval",
  function (gettextCatalog, account, $interval) {
    "use strict";
    return {
      restrict: "E",
      template:
        '<div id="countdown">' +
        '<div class="countdown__wrapper" ng-class="getExpirationClass()">' +
        '<div class="countdown__numbers">' +
        '<span data-test="qr-code-countdown-timer-days-left">{{CountDown.days}}</span>' +
        '<div class="countdown__label">{{ days }}</div>' +
        "</div>" +
        "</div>" +
        '<div class="countdown__wrapper" ng-class="getExpirationClass()">' +
        '<div class="countdown__numbers">' +
        "<span>{{CountDown.hours}}</span>" +
        '<div class="countdown__label">{{ hours }}</div>' +
        "</div>" +
        "</div>" +
        '<div class="countdown__wrapper countdown__wrapper--last" ng-class="getExpirationClass()">' +
        '<div class="countdown__numbers">' +
        "<span>{{CountDown.minutes}}</span>" +
        '<div class="countdown__label">{{ minutes }}</div>' +
        "</div>" +
        "</div>" +
        '<div class="countdown__wrapper countdown__wrapper--last" ng-show="displaySeconds" ng-class="getExpirationClass()">'+
        '<div class="countdown__numbers">'+
             "<span>{{CountDown.seconds}}</span>" +
             '<div class="countdown__label">{{ seconds }}</div>' +
           '</div>'+
        "</div>" +
        "</div>",
      scope: {
        displaySeconds: '=', // Is div wrapper with seconds visible? Default: false.
      },
      controller: [
        "$scope",
        function ($scope) {

          $scope.days = gettextCatalog.getString("Days");
          $scope.hours = gettextCatalog.getString("Hours");
          $scope.minutes = gettextCatalog.getString("Minutes");
          $scope.seconds = gettextCatalog.getString("Seconds");
          $scope.timeInterval = null;
          $scope.CountDown = {
            days: 0,
            hours: 0,
            minutes: 0,
            seconds: 0,
            getTimeRemaining: (trialExpirationDate) => {
              var remainingTime =
                Date.parse(trialExpirationDate) - new Date();
              return {
                total: remainingTime,
                days: Math.floor(remainingTime / (1000 * 60 * 60 * 24)),
                hours: Math.floor((remainingTime / (1000 * 60 * 60)) % 24),
                minutes: Math.floor((remainingTime / 1000 / 60) % 60),
                seconds: Math.floor((remainingTime / 1000) % 60),
              };
            },
            initializeClock: function (trialExpirationDate) {
              var updateClock = () => {
                var t =
                  $scope.CountDown.getTimeRemaining(trialExpirationDate);
                $scope.CountDown.days = t.days.toString().padStart(2, "0");
                $scope.CountDown.hours = t.hours.toString().padStart(2, "0");
                $scope.CountDown.minutes = t.minutes
                  .toString()
                  .padStart(2, "0");
                $scope.CountDown.seconds = t.seconds
                  .toString()
                  .padStart(2, "0");

                if (t.total <= 0) {
                  $interval.cancel($scope.timeInterval);
                }
              };
              updateClock();
              $scope.timeInterval = $interval(updateClock, 1000);
            },
          };
          var trialExpirationDate = new Date(account.getAccount().trial_date);
          $scope.CountDown.initializeClock(trialExpirationDate);

          $scope.getExpirationClass = () =>
            parseInt($scope.CountDown.days) === 0
              ? "countdown__wrapper--is-last-day"
              : "";
        },
      ],
    };
  },
]);
;
app.directive('qrListOfContents',  [function () {
    'use strict';
    return {
        restrict: 'E',
        template:
            '<div class="list-of-contents">' +
            '   <p class="list-of-contents__content" ng-repeat="list in lists">' +
                '<img class="list-of-contents__img" ng-src="{{cdnUrl+ list.imgPath }}\"/>'+
                    '{{list.label}}'+
                '</p>'+
            '</div>',
        scope: {
            open: '=',      // Optional open states of modals.
            lists: '='     // Define the list items
        }
    };
}]);
;
app.directive('limitCurrentPlan',['gettextCatalog', function (gettextCatalog) {
    return {
        restrict: 'E',
        transclude: true,
        template:
        '<div class="qr-navbar__element qr-navbar__element_limit-container qr-navbar-v2__alert-container">' +
            '<div class="qr-navbar__element qr-navbar__element_limit-text-plan qr-navbar-v2__alert-container-text">' +
                '{{::upgradePlanLabel}}' +
            '</div>' +
            '<div class="qr-navbar__element qr-navbar__element_limit-button qr-navbar-v2__alert-container-button-wrapper">' +
                '<a class="qr-navbar__upgrade-limit-button qr-navbar-v2__alert-container-button" href="/upgrade/?from=navbar_more_codes">' +
                    '{{::upgradeButtonLabel}}' +
                '</a>' +
            '</div>' +
        '</div>',
        scope: {
        },
        controller: function ($scope) {
            /**
             * Translations.
             */
            $scope.upgradePlanLabel = gettextCatalog.getString('Need more QR Codes?');
            $scope.upgradeButtonLabel = gettextCatalog.getString('Upgrade');
        }
    };
}]);
;
app.directive('pricingPlanCard',['gettextCatalog', 'api', function (gettextCatalog, api) {
    return {
        restrict: 'E',
        transclude: true,
        template:
            '<qr-paused-modal open="states.pausedModal" paused-until="pausedSubscriptionUntil"></qr-paused-modal>' +
            '<qr-subscription-resume-modal open="states.resumeModal" ng-if="states.resumeModal"></qr-subscription-resume-modal>' +

            '<div class="pricing-box__container" ng-class="{&apos;pricing-box__container_most-popular&apos;: isMostPopular}">' +
                // element: Most popular header
                '<div ng-if="isMostPopular" class="pricing-box__popular-header">{{mostPopularLabel}}</div>' +

                '<div class="pricing-box__content-wrapper">' +
                    '<div class="row row_flex">' +
                        // begin: Title
                        '<div class="col-xs-12 col-sm-4 col-md-12 pricing-box__title-container">' +
                            '<div class="pricing-box__title">' +
                                '<h3 class="heading-h3 heading-h3_blue">{{planTitle}}</h3>' +
                                '<p class="caption pricing-box__caption">{{planSubTitle}}</p>' +
                            '</div>' +
                        '</div>' +
                        // end: Title

                        // begin: Price
                        '<div class="col-xs-12 col-sm-4 col-md-12 d-flex pricing-box__price-container">' +
                            '<div class="pricing-box__price">' +
                                '<span class="price__currency">{{currencySymbol}}</span>' +
                                '<p class="price__calculated-price">' +
                                    '<span>{{price/planRate | number:2}}</span>' +
                                '</p>' +
                                '<span class="price__billing-type">/{{monthLabel}}</span>' +
                                '<span class="price__billing-note">{{billedAnnuallyLabel}}</span>' +
                            '</div>' +
                        '</div>' +
                        // end: Price

                        // begin: CTA button
                        '<div class="col-xs-12 col-sm-4 col-md-12 pricing-box__cta-btn-container">' +
                            '<button id="plan{{planIndex}}" class="button button_primary pricing-box__cta-btn" ng-class="getButtonClass()" ng-click="selectPlan(planIndex)" ng-disabled="planIndex === planId && !trialAccount">{{createPlanButton(planIndex)}}</button>' +
                        '</div>' +
                        // end: CTA button
                    '</div>' +

                    '<hr class="pricing-box__seperator pricing-box__seperator_top">' +

                    // begin: Features
                    '<div class="pricing-box__features row row_flex">' +
                        '<div ng-repeat="feature in features track by $index" class="feature__row col-xs-12 col-sm-3 col-md-12">' +
                            '<div class="feature__wrapper">' +
                                '<div class="feature__amount">{{feature.value}}</div>' +
                                '<div class="feature__name">' +
                                    '<span class="feature__name_underline">{{feature.text}}</span>' +
                                    '<div class="feature__tooltip">' +
                                        '<span class="feature__tooltip-text">{{feature.tooltip}}</span>' +
                                    '</div>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                    // end: Features

                    '<hr ng-if="premiumSupport" class="pricing-box__seperator pricing-box__seperator_bottom">' +

                    '<p ng-if="premiumSupport" class="pricing-box__support">{{premiumSupportLabel}}</p>' +
                '</div>' +
            '</div>',
        scope: {
            appLang: '@',          // Application language
            trialAccount: '=',     // Trial account flag
            pausedSubscription: '=', // Paused subscription flag
            pausedSubscriptionUntil: '=', // Paused subscription flag
            isMostPopular: '=',    // Show bestseller badge
            planId: '@',           // General planID
            planTitle: '@',        // Title of the plan
            planSubTitle: '@',     // Subtitle of the plan
            price: '=',            // Price of the plan
            priceMonth: '=',       // Price per month for the plan
            features: '=',         // Array with features of the plan
            planIndex: '@',        // Plan index
            currencySymbol: '=',   // Currency symbol
            planRate: '=',         // Currency rate value
            premiumSupport: '='    // Show premium support option
        },
        controller: function ($scope) {
            /**
             * Translations.
             */
            $scope.billedAnnuallyLabel = gettextCatalog.getString('Billed annually');
            $scope.monthLabel = gettextCatalog.getString('Month');
            $scope.premiumSupportLabel = gettextCatalog.getString('Premium Support');
            $scope.mostPopularLabel = gettextCatalog.getString('Most Popular');

            $scope.buttonProceedCheckoutLabel = gettextCatalog.getString('Proceed to checkout');
            $scope.buttonSelectedLabel = gettextCatalog.getString('Selected');
            $scope.buttonUpgradeLabel = gettextCatalog.getString('Upgrade');
            $scope.buttonDowngradeLabel = gettextCatalog.getString('Downgrade');

            $scope.states = {
                'pausedModal': false,
                'resumeModal': false
            };

            /**
             * Catch opening event for resume modal
             */
            $scope.$on('openResumeModal', function () {
                $scope.states.resumeModal = true;
            });

            /**
             * Catch closing event for resume modal
             */
            $scope.$on('closeResumeModal', function () {
                $scope.states.resumeModal = false;
            });

            /**
             * Return button text
             * @param plan - directive plan index
             *  @returns {string}
             */
            $scope.createPlanButton = function (plan) {
                if ($scope.trialAccount || $scope.planId === '0')
                    return $scope.buttonProceedCheckoutLabel;
                switch (true) {
                    case (plan === $scope.planId):
                        return $scope.buttonSelectedLabel;
                    case (plan > $scope.planId):
                        return $scope.buttonUpgradeLabel;
                    case (plan < $scope.planId):
                        return $scope.buttonDowngradeLabel;
                }
            };


            /**
             * Get button CSS classes.
             * @returns {*}
             */
            $scope.getButtonClass = function () {
                return {
                    'button_medium': $scope.trialAccount || $scope.planId === '0',
                    'button_large': !$scope.trialAccount && $scope.planId !== '0',
                    'button_outline': ($scope.trialAccount && ($scope.planIndex === '3' || $scope.planIndex === '1')) || ($scope.planId === '0' && $scope.planIndex !== '2'),
                    'button_disabled': !$scope.trialAccount  && $scope.planIndex === $scope.planId,
                    'button_outline_grey': !$scope.trialAccount && (($scope.planId === '2' && $scope.planIndex === '1') || ($scope.planId === '3' && $scope.planIndex !== '3') || ($scope.planId === '4'))
                }
            };

            /**
             * Redirect to selected plan. If subscription is paused, show a warning.
             * @param plan - directive plan index
             */
            $scope.selectPlan = function (planId) {
                if ($scope.pausedSubscription) {
                    $scope.states.pausedModal = true;
                } else {
                    window.location = "/" + $scope.appLang + "/upgrade/paymentform/?plan=paid" + planId + "&new=1";
                }
            };

        }
    };
}]);
;
app.directive('qrDropdownFolders', ['$window', '$timeout', 'api', 'gettextCatalog', 'account', function ($window, $timeout, api, gettextCatalog, account) {
    return {
        restrict: 'E',
        require: '?^form',
        template:
            '<qr-paused-modal open="open.paused" ng-if="open.paused"></qr-paused-modal>' +
            '<qr-expired-modal open="open.expire" ng-if="open.expire"></qr-expired-modal>' +
            '<div class="input-group show dropdown_divider-action" ng-class="{disabled: disabled, open: open.dropdown}">' +
                '<div class="dropdown-menu dropdown-folder" data-js="dropdownFolderMenu">' +
                    '<button type="button" href="#" ng-click="addFolder($event)" class="dropdown-folder__new-link"  data-ng-disabled="open.isFolderAdd" data-test="folder-dropdown-add-folder">' +
                        '<span class="dropdown-folder__icon icon icon-plus-1"></span>' +
                        '{{ labelNewFolder }}' +
                    '</button>' +
                    '<qr-dropdown-folder-add ng-show="open.isFolderAdd" open="open.isFolderAdd" new-folder-name="newFolderName"></qr-dropdown-folder-add>' +
                    '<ul class="list-unstyled">' +
                        '<li class="dropdown-folder__item" ng-repeat="(key, item) in items">' +
                            '<a href="#" ng-click="choose(key, $event)" ng-class="getItemClass(key)" data-test="folder-dropdown-item">' +
                                '<span class="dropdown-folder__add-icon icon-qr-folder"></span>' +
                                '{{ item }}' +
                            '</a>' +
                        '</li>' +
                    '</ul>' +
                '</div>' +
                '<input type="text" class="dropdown-folder__input qr-dropdown--has-icon" ng-model="inputField" ng-model-options="input" ng-readonly="fieldReadonly" ng-disabled="disabled"' +
                ' placeholder="{{ placeholder }}" ng-maxlength="maxLength" ng-click="openDropdownContent()" name="{{ name }}" data-js="dropdownFolderInput"' +
                ' data-test="folder-dropdown">' +
                '<span class="qr-dropdown__input-icon icon-qr-folder" ng-class="{selected: isFolderSelected}"></span>' +
            '</div>',
        scope: {
            value: '=',         // Current selected value
            name: '@',          // Optional. The name of the input.
            fieldReadonly: '=', // Optional, default is false. The whole widget is readonly.
            disabled: '=',      // Optional, default is false. The whole widget is disabled.
            placeholder: '@',   // Optional. Placeholder for the input.
            maxLength: '=',     // Optional. The max length for the input.
            valueSetter: '&',   // Optional. A setter function of the value to convert input to value.
            valueGetter: '&',   // Optional. A getter function of the value to convert value to input.
            updateOn: '@',      // Optional. It's used for modelOptions.
            defaultValue: '=',  // Optional. Default value.
            customLabel: '@',   // The label for Custom link.
            images: '=',        // Optional. Images for items.
            isAdmin: '=',       // Show info about user if admin is logged in.
            hasNoFolder: '='
        },
        link: function (scope, element, attributes, formCtrl) {
            /**
             * Set the dirty state of the field in the parent form
             */
            scope.setFieldDirty = function () {
                if (formCtrl && scope.name in formCtrl) {
                    formCtrl[scope.name].$setDirty();
                }
            };
            /**
             * Set the focus on the input.
             */
            scope.focusOnMe = function () {
                var input = element.find('input');
                input.focus();
                input.select();
            };

            // Install perfect scrollbar.
            $timeout(function () {
                element.find('.dropdown-menu').perfectScrollbar();
            });

            // Making scrollbar visible when open menu
            element.find('.input-group').click(function () {
                $timeout(function () {
                    element.find('.dropdown-menu').perfectScrollbar('update');
                });
            });

        },
        controller: ['$scope', '$timeout', function ($scope, $timeout) {

            /**
             * Global $scope variables.
             */

            $scope.value = $scope.value || $scope.defaultValue;    // Set default value, if needed.
            $scope.newFolderName = '';
            $scope.isFolderSelected = false;

            /**
             * A map of folders ID => Name. It's needed for the folders list.
             * @type {*}
             */
            $scope.items = {};

            /**
             * Open states of the components.
             * @type {{expire: boolean}} Open state of the expire modal.
             * @type {{dropdown: boolean}} It's used to open the folders dropdown.
             * @type {{isFolderAdd: boolean}} Indicator of add folder input.
             */
            $scope.open = {
                paused: false,
                expire: false,
                dropdown: false,
                isFolderAdd: false
            };

            /**
             * Model options for the input field
             * @type {*}
             */
            $scope.input = {
                getterSetter: true,
                updateOn: $scope.updateOn || 'default'
            };

            /**
             * Data of the folder that is in edit mode now.
             * @type {{id: number}}
             */
            $scope.editing = {
                id: 0
            };

            /**
             * Translations for this directive.
             */
            $scope.labelNewFolder = gettextCatalog.getString('New Folder');

            /**
             * Handler for ngClick
             * It's used to open the dropdown if openDropdownContent === true.
             */
            $scope.openDropdownContent = function () {
                $scope.open.dropdown = !$scope.open.dropdown;
            };

            /**
             * Setter/getter for the input field
             * @param value
             * @returns {string}
             */
            $scope.inputField = function (value) {
                // Setter
                if (angular.isDefined(value)) {
                    if (angular.isArray($scope.items)) {
                        return ($scope.value = value);
                    }
                    var key = $scope.findItemKeyByValue(value);
                    if (key) {
                        return ($scope.value = key);
                    }
                    return ($scope.value = $scope.valueSetter({value: value}));
                }

                // Getter
                if (angular.isArray($scope.items)) {
                    return $scope.value;
                }
                if ($scope.value in $scope.items) {
                    return $scope.items[$scope.value];
                }
                return $scope.valueGetter({value: $scope.value});
            };

            /**
             * Find the item key by its value
             * @param value
             * @returns {string}
             */
            $scope.findItemKeyByValue = function (value) {
                var found = '';
                angular.forEach($scope.items, function (item, key) {
                    if (value === item) {
                        found = key;
                    }
                });
                return found;
            };

            /**
             * Set selected class name.
             * It's used to set the selected class for selected folder.
             */
            $scope.getItemClass = function (label) {
                return {
                    'selected': $scope.value === label
                };
            };

            /**
             * Choose an item from the list of items
             * @param value
             * @param $event
             */
            $scope.choose = function (value, $event) {
                $event.preventDefault();
                if (!$scope.disabled && !$scope.readonly) {
                    // If items is an array, then don't use keys, use values instead
                    if (angular.isArray($scope.items)) {
                        $scope.value = $scope.items[value];
                    } else {
                        $scope.value = value;
                    }
                    $scope.setFieldDirty();
                }
                // A timeout is needed to close the dropdown a little bit later, after other events.
                $timeout(function () {
                    $scope.open.dropdown = false;
                    $scope.open.isFolderAdd = false;
                    $scope.isFolderSelected = true;
                    $scope.$emit('qr-init-folder-id', value);
                }, 100);
            };

            /**
             * Close the dropdown
             * It's used to close the dropdown in the case of outside mouseup.
             */
            angular.element(document).mousedown(function (event) {
                var customText = angular.element(document).find('[data-js="dropdownFolderMenu"]');
                var customTextAction = angular.element(document).find('[data-js="dropdownFolderInput"]');

                if (!customText.is(event.target) && customText.has(event.target).length === 0 && !customTextAction.is(event.target) && customTextAction.has(event.target).length === 0) {
                    $timeout(function () {
                        $scope.open.dropdown = false;
                        $scope.open.isFolderAdd = false;
                    }, 100);
                }
            });

            /**
             * Get the array of user's folders.
             * @type {Array}
             */
            $scope.getFolders = function () {
                return account.getFolders();
            };

            /**
             * Find folder by name.
             * @param {string} folderName
             * @param {number} [ignoreFolderId]
             * @returns {*}
             */
            $scope.findFolderByName = function (folderName, ignoreFolderId) {
                var result = false;
                angular.forEach(account.getFolders(), function (folder) {
                    if (folder.name === folderName && folder.id !== ignoreFolderId) {
                        result = folder;
                    }
                });
                return result;
            };

            /**
             * Find an unique folder name.
             * @param {string} baseFolderName
             * @param {number} [ignoreFolderId]
             * @returns {string}
             */
            $scope.findUniqueFolderName = function (baseFolderName, ignoreFolderId) {
                var i, folderName = baseFolderName;
                for (i = 2; $scope.findFolderByName(folderName, ignoreFolderId); ++i) {
                    folderName = baseFolderName + ' ' + i;
                }
                return folderName;
            };

            /**
             * Create new folder and select it.
             */
            $scope.addFolder = function ($event) {
                if (account.getAccountStatus() === 'paused' && !$scope.isAdmin) {
                    $scope.open.paused = true;
                    $scope.open.dropdown = false;
                } else if (account.getAccountStatus() === 'expired' && !$scope.isAdmin) {
                    $scope.open.expire = true;
                    $scope.open.dropdown = false;
                } else {
                    $scope.open.isFolderAdd = true;
                    $scope.newFolderName = $scope.findUniqueFolderName(gettextCatalog.getString('Untitled folder'));
                }
            };

            /**
             * Sync created folder, hide the drop-down menu and select the created folder
             */
            $scope.$on('qr-init-add-folder-done', function (event, folderID) {
                $scope.open.dropdown = false;
                $scope.choose(folderID, event);
            });

            /**
             * Registers a listener callback that will be executed on each change.
             * @watchExpression —
             * @listener —
             */
            $scope.$watch(function () {
                return account.getFolders();
            }, function () {
                $scope.folders = account.getFolders();

                // Check if the component should use the option "No folder"
                if ($scope.hasNoFolder) {
                    $scope.items = {
                        0: gettextCatalog.getString('No folder')
                    };
                }

                // Sync the folders map (items for the dropdown).
                angular.forEach($scope.folders, function (folder) {
                    $scope.items[folder.id] = folder.name;
                });
            }, true);
        }]
    };
}]);
;
/**
 * Directive to add a new folder to the drop-down list.
 */
app.directive('qrDropdownFolderAdd', ['api', 'gettextCatalog', 'markup', 'account', '$timeout', function (api, gettextCatalog, markup, account, $timeout) {
    return {
        restrict: 'E',
        template:
            '<div class="dropdown-folder__add">' +
                '<label for="addFolder" class="dropdown-folder__add-icon dropdown-folder__add-icon_color_green dropdown-folder__icon_edit icon-qr-folder"></label>' +
                '<input class="dropdown-folder__add-input" id="addFolder" ng-model="newFolderName" ng-blur="finishAdding()" ng-keyup="keyUp($event)">' +
            '</div>',
        scope: {
            newFolderName: '=',         // Folder information in format {id: 123, name: 'Abc'}.
            open: '='
        },
        link: function (scope, element) {
            /**
             * Focus on the input.
             */
            scope.setFocus = function () {
                $timeout(function () {
                    element.find('.dropdown-folder__add-input').focus();
                }, 100);
            };
        },
        controller: ['$scope', function ($scope) {
            $scope.running = true;

            /**
             * Handler for ngBlur
             * It's used to close the dropdown in the case of openOnFocus.
             */
            $scope.finishAdding = function () {
                /**
                 * API: Create a folder with specified name.
                 * @param {{$scope.newFolderName}} folderName
                 * @param {{response}} successCallback
                 * @param [errorCallback]
                 */
                if ($scope.running) {
                    api.createFolder($scope.newFolderName, function (response) {
                        $scope.open = false;
                        account.pushFolder(response.data);
                        $scope.$emit('qr-init-add-folder-done', response.data.id);
                    }, function () {
                        $scope.open = false;
                    });

                    $scope.running = !$scope.running;

                    $timeout(function () {
                        $scope.running = true;
                    }, 100);
                }
            };

            /**
             * Handler for ngKeyup
             * Process some keys for the input.
             * Finish adding new folder when Enter or ESC is pressed.
             * @param $event
             */
            $scope.keyUp = function ($event) {
                if ($scope.open && ($event.keyCode === 13 || $event.keyCode === 27)) {
                    $event.stopPropagation();    // Prevent closing the modal window when pressing ESC
                    $scope.open = false;
                }
            };

            /**
             * Registers a listener callback to be executed whenever the open changes.
             * @watchExpression open
             * @listener -
             */
            $scope.$watch('open', function () {
                $scope.setFocus();
            });
        }]
    };
}]);;
/**
 * A modal for downloading QR codes with customization.
 */
app.directive('qrCustomDownload', ['gettextCatalog', 'api', '$timeout', '$window', 'account', '$cookies', 'characterBlock', 'tracking', function (gettextCatalog, api, $timeout, $window, account, $cookies, characterBlock, tracking) {
    "use strict";
    return {
        restrict: 'E',
        template:
            '<qr-frame-store class="qr-frame-store--hide" qr-code="qrCode" account-frame-id="style.accountFrameId" frame-color="style.frameColor" frame-name="style.frameName" open="isFrameStoreVisible.value" palette="palettes.foreground" ng-class="getFrameStoreModalClass()"></qr-frame-store>' +
            '<qr-modal class="qr-custom-download" open="open" data-title="{{ ::title }}" close-icon="true" auto-close="{{ isFrameStoreVisible.value ? &apos;false&apos; : &apos;true&apos; }}" min-width="790px" left-offset="-395px" ng-class="getModalClass()">' +
                '<div class="qr-custom-download__content" ng-class="getContentClasses()">' +
                    '<div class="qr-custom-download__right" ng-class="{&apos;qr-custom-download__right--dark-mode&apos; : isDarkMode, &apos;overflow_hidden&apos; : isOverflowHidden}" data-download-right>' +
                        '<button type="button" class="qr-custom-download__button qr-custom-download__button--print" ng-click="printCode()">' +
                            '<i class="icon icon-qr-print"></i>' +
                        '</button>' +
                        '<button type="button" class="qr-custom-download__button qr-custom-download__button--customize" ng-click="toggleDownload()">' +
                            '<span class="qr-custom-download__button-icon icon-event-back"></span>' +
                            '{{ ::customizeLabel }}' +
                        '</button>' +
                        '<div id="printContent">' +
                            '<img class="qr-custom-download__code" ng-src="{{ image.url }}" alt="" ng-show="image.url && !image.loading" ng-style="getImageStyles()">' +
                        '</div>' +
                        '<div class="qr-custom-download__spinner" ng-show="image.loading">' +
                            '<qr-spinner loading="image.loading"></qr-spinner>' +
                            '<span ng-bind="image.state" ng-show="image.state"></span>' +
                        '</div>' +
                        '<button type="button" ng-hide="isOnCreateOwn.value" ng-click="download()" class="qr-custom-download__button qr-custom-download__button--download" data-ng-disabled="isQrDownloading">' +
                            '<span class="qr-custom-download__button-icon icon-download-normal" ng-style="{visibility: isQrDownloading ? &apos;hidden&apos; : &apos;visible&apos;}"></span>' +
                            '<img class="qr-custom-download__spinner-image" src="/img/spinner-white.svg" ng-show="isQrDownloading" alt="">' +
                            '{{ ::downloadLabel }}' +
                        '</button>' +
                        '<button type="button" class="qr-custom-download__button qr-custom-download__button--menu" ng-hide="isOnCreateOwn.value" ng-click="toggleDownloadMenu()" data-ng-disabled="isQrDownloading">' +
                            '<span class="icon-menu-vertical"></span>' +
                        '</button>' +
                        '<button type="button" ng-show="isOnCreateOwn.value" class="qr-custom-download__button qr-custom-download__button--save-frame-design" ng-click="saveFrameDesign()" data-ng-disabled="isFrameSaving">' +
                            '<img class="qr-custom-download__spinner-image" src="/img/spinner-white.svg" ng-show="isFrameSaving" alt="Saving Frame Design">' +
                            '{{ ::saveFrameDesignLabel }}' +
                        '</button>' +
                            '<div class="qr-custom-download__download-menu" ng-class="{&apos;qr-custom-download__download-menu--open&apos;: isDownloadMenuOpen}">' +
                            '<button type="button" class="qr-custom-download__download-close" ng-click="toggleDownloadMenu()">&times;</button>' +
                            '<span class="qr-custom-download__download-prompt" ng-bind="::selectFormatLabel"></span>' +
                            '<button type="button" class="qr-custom-download__button qr-custom-download__button--download-format" ng-click="download(&apos;PNG&apos;)" ng-bind="::downloadPngLabel"></button>' +
                            '<button type="button" class="qr-custom-download__button qr-custom-download__button--download-format" ng-click="download(&apos;JPG&apos;)" ng-bind="::downloadJpgLabel"></button>' +
                            '<button type="button" class="qr-custom-download__button qr-custom-download__button--download-format" ng-click="download(&apos;SVG&apos;)" ng-bind="::downloadSvgLabel"></button>' +
                            '<span class="qr-custom-download__download-prompt qr-custom-download__download-prompt--secondary" ng-bind="::withoutCustomizationsLabel"></span>' +
                            '<button type="button" class="qr-custom-download__button qr-custom-download__button--download-format" ng-click="download(&apos;EPS&apos;)" ng-bind="::downloadEpsLabel"></button>' +
                            '<span class="qr-custom-download__download-checkbox checkboxes-container blue-checkbox">' +
                                '<input type="checkbox" id="qr-custom-download-checkbox" ng-model="errorCorrection.isHigh">' +
                                '<label for="qr-custom-download-checkbox" ng-bind="::highCorrectionLabel"></label>' +
                            '</span>' +
                        '</div>' +
                    '</div>' +
                    '<qr-vertical-tabs class="qr-custom-download__tabs" tabs="tabs" active-tab="activeTab.id" full-height="true"></qr-vertical-tabs>' +
                    '<div class="action-bar action-bar_download">' +
                        '<div class="action-bar__shadow" ng-class="{&apos;action-bar__shadow_remove&apos; : activeTab.id !== &apos;frame&apos;}">' +
                            '<div class="action-bar__color" ng-if="activeTab.id === &apos;frame&apos; && isMobile">' +
                                '<qr-color-palette class="action-bar__palette" colors="palettes.foreground" deleting="editing" active="style.frameColor" max-colors="14" new-color="style.newFrameColor" read-only-length="1" full-spectrum-position="&apos;.action-bar__color&apos;"></qr-color-palette>' +
                            '</div>' +
                            '<button type="button" ng-if="activeTab.id === &apos;frame&apos; && isMobile" class="qr-custom-download-frame__option-text" ng-click="toggleCustomTextVisibility()" data-js="customTextAction">' +
                                '<span class="icon icon-text"></span>' +
                            '</button>' +
                            '<button type="button" class="qr-custom-download__button qr-custom-download__button--open-download action-bar__download" ng-click="toggleDownload()" data-button="toggleDownload">' +
                                '{{ ::openDownloadLabel }}' +
                                '<span class="qr-custom-download__button-icon icon-qr-insights"></span>' +
                            '</button>' +
                        '</div>' +
                        '<div class="qr-custom-download-frame__custom-text-container" ng-show="isCustomTextVisible" data-js="customText">' +
                            '<div class="qr-custom-download-frame__custom-text-input">' +
                                '<input class="qr-custom-download-frame__custom-text-field" ng-model="style.frameText" ng-model-options="{updateOn: &apos;default blur&apos;, debounce: {default: 750, blur: 0}}">' +
                            '</div>' +
                            '<div class="qr-custom-download-frame__custom-text-action">' +
                                '<button type="button" class="qr-custom-download-frame__custom-text-button" ng-click="toggleCustomTextVisibility()">' +
                                    '{{ ::customTextButtonLabel }}' +
                                '</button>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="qr-custom-download__left" data-download-left>' +
                        '<button type="button" ng-show="activeTab.id === &apos;frame&apos;" class="qr-custom-download__button qr-custom-download__button--open-download qr-custom-download__button--save-frame hiddenAbsolute" ng-click="saveFrameDesign()" data-ng-disabled="isFrameSaving" data-button="savePremiumDesign">' +
                            '<img class="qr-custom-download__spinner-image" src="/img/spinner-white.svg" ng-show="isFrameSaving" alt="Saving Frame Design">' +
                            '{{ ::saveFrameDesignLabel }}' +
                        '</button>' +
                        '<qr-custom-download-frame saved-frame-styles="data.savedCustomFrames" all-user-frames="data.allUserFrames" open="open" qr-code="qrCode" account-frame-id="style.accountFrameId" is-create-own-visible="isOnCreateOwn.value" is-frame-store-visible="isFrameStoreVisible.value" palette="palettes.foreground" ng-show="activeTab.id === &apos;frame&apos;" is-visible="activeTab.id === &apos;frame&apos;" frame-color="style.frameColor" new-frame-color="style.newFrameColor" frame-name="style.frameName" frame-text="style.frameText" frame-text-color="style.frameTextColor" frame-text-alignment="style.frameTextAlignment" frame-text-font="style.frameTextFont" frame-icon-name="style.frameIconName"></qr-custom-download-frame>' +
                        '<qr-custom-download-color pattern-name="style.patternName" is-contrast-ratio="isCodeContrastRatio" foreground-palette="palettes.foreground" background-palette="palettes.background" ng-show="activeTab.id === &apos;color&apos;" background-color="style.backgroundColor" foreground-color="style.foregroundColor" new-background-color="style.newBackgroundColor" new-foreground-color="style.newForegroundColor"></qr-custom-download-color>' +
                        '<qr-custom-download-logo ng-show="activeTab.id === &apos;logo&apos;" is-visible="activeTab.id === &apos;logo&apos;" logo-name="style.logoName" logo-id="style.logoId" qr-code-type-id="qrCode.type_id"></qr-custom-download-logo>' +
                        '<qr-custom-download-edges is-contrast-ratio="isEdgeContrastRatio" ng-if="activeTab.id === &apos;edges&apos;"' +
                            ' top-left-inner-color="style.topLeftInnerColor" top-left-outer-color="style.topLeftOuterColor" top-left-shape="style.topLeftShape"' +
                            ' new-top-left-inner-color="style.newTopLeftInnerColor" new-top-left-outer-color="style.newTopLeftOuterColor"' +
                            ' top-right-inner-color="style.topRightInnerColor" top-right-outer-color="style.topRightOuterColor" top-right-shape="style.topRightShape"' +
                            ' new-top-right-inner-color="style.newTopRightInnerColor" new-top-right-outer-color="style.newTopRightOuterColor"' +
                            ' bottom-left-inner-color="style.bottomLeftInnerColor" bottom-left-outer-color="style.bottomLeftOuterColor" bottom-left-shape="style.bottomLeftShape"' +
                            ' new-bottom-left-inner-color="style.newBottomLeftInnerColor" new-bottom-left-outer-color="style.newBottomLeftOuterColor"' +
                            ' palette="palettes.foreground"></qr-custom-download-edges>' +
                        '<qr-custom-download-designs ng-show="activeTab.id === &apos;designs&apos;" is-visible="activeTab.id === &apos;designs&apos;" qr-code="qrCode" actual-styles="style"></qr-custom-download-designs>' +
                        '<qr-custom-download-url ng-if="activeTab.id === &apos;url&apos;" qr-code="qrCode"></qr-custom-download-url>' +
                        '<button type="button" class="qr-custom-download__button qr-custom-download__button--preview" ng-click="preview.open = true" data-button="preview" ng-if="false">' +
                            '<span class="qr-custom-download__button-icon icon-qrcode-1-1"></span>' +
                            '{{ ::previewLabel }}' +
                        '</button>' +
                    '</div>' +

                    '<qr-popup class="qr-custom-download__preview" open="preview.open" visible-layer="true" auto-close="true" ng-if="preview.open" ng-click="stopPropagation($event)">' +
                        '<div class="qr-custom-download__preview-content">' +
                                '<button type="button" class="qr-custom-download__button qr-custom-download__button--print" ng-click="printCode()">' +
                                    '<i class="icon icon-qr-print"></i>' +
                                '</button>' +
                            '<img class="qr-custom-download__code" ng-src="{{ image.url }}" alt="" ng-show="image.url && !image.loading" ng-style="getImageStyles()">' +
                            '<div class="qr-custom-download__spinner" ng-show="image.loading">' +
                                '<qr-spinner loading="image.loading"></qr-spinner>' +
                                '<span ng-bind="image.state" ng-show="image.state"></span>' +
                            '</div>' +
                            '<button type="button" class="qr-custom-download__preview-close" ng-click="closePreview($event)">' +
                                '<span>&times;</span>' +
                                '{{ ::closeLabel }}' +
                            '</button>' +
                        '</div>' +
                    '</qr-popup>' +
                '</div>' +
            '</qr-modal>',
        scope: {
            open: '=',      // Open state of the modal.
            openTab: '=',   // ID of the tab to open.
            qrCode: '='     // QR code data.
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            /**
             * Translations.
             */
            $scope.title = $window.innerWidth <= 790 ? gettextCatalog.getString('Customize & Download') : gettextCatalog.getString('Customize & Download your QR Code');
            $scope.vectorLabel = gettextCatalog.getString('Vector');
            $scope.downloadLabel = gettextCatalog.getString('Download');
            $scope.downloadPngLabel = gettextCatalog.getString('Download PNG');
            $scope.downloadJpgLabel = gettextCatalog.getString('Download JPG');
            $scope.downloadSvgLabel = gettextCatalog.getString('Download SVG');
            $scope.downloadEpsLabel = gettextCatalog.getString('Download EPS');
            $scope.openDownloadLabel = gettextCatalog.getString('Download');
            $scope.selectFormatLabel = gettextCatalog.getString('Select your format');
            $scope.withoutCustomizationsLabel = gettextCatalog.getString('Note: EPS files currently only deliver black on white QR Codes without any designs. For custom QR Codes, please select one of the formats above.');
            $scope.previewLabel = gettextCatalog.getString('Preview');
            $scope.customizeLabel = gettextCatalog.getString('Customize');
            $scope.closeLabel = gettextCatalog.getString('Close');
            $scope.autoPreviewLabel = gettextCatalog.getString('Auto preview');
            $scope.stateSavingDesign = gettextCatalog.getString('Saving design...');
            $scope.stateLoadingImage = gettextCatalog.getString('Loading image...');
            $scope.stateApplyingDesign = gettextCatalog.getString('Applying design...');
            $scope.highCorrectionLabel = gettextCatalog.getString('Use high error correction');
            $scope.saveFrameDesignLabel = gettextCatalog.getString('Save Frame Design');
            $scope.customTextButtonLabel = gettextCatalog.getString('OK');

            /**
             * Global $scope variables.
             */
            $scope.lastSentEventEdge = '';
            $scope.lastSentEventCode = '';
            $scope.isDarkMode = false;          // Declare a variable to determine if we need a dark mode if the user chooses white color
            $scope.isFrameStoreVisible = {      // Frame store visibility flag
                value: false
            };
            $scope.isOnCreateOwn = {            // Create your own section visibility flag
                value: false
            };
            $scope.data = {
                intercomChangeFrameText: true,    // Intercom event for change frame text.
                allUserFrames: [],                // list of all user frames, only premium frames not custom saved.
                savedCustomFrames: []             // List of all account saved custom frames.
            };
            $scope.isCustomTextVisible = false;

            var lastFrameTemplate = $scope.qrCode.lastFrameTemplate || {},
                qrStyle = $scope.qrCode.style || {};

            /**
             * Returns name of the QR code logo.
             */
            function getLogoName() {
                var logoName = (qrStyle.qr_code_logo || '').length <= 1 ? '' : qrStyle.qr_code_logo;
                if (!/^(scan-me(-square)?|account[0-9]+\/logo\/[a-f0-9]+\.(png|svg|jpe?g)|_logotemplates\/.*)$/i.test(logoName)) {
                    logoName = '';
                }
                return logoName;
            }

            /**
             * Returns icon name based on type of the QR code.
             * @param {number} qrCodeTypeId
             * @returns {string}
             */
            function selectIconName(qrCodeTypeId) {
                var icons = {
                    1: 'mobile',
                    4: 'facebook',
                    12: 'vcard',
                    13: 'event',
                    14: 'social',
                    15: 'business',
                    16: 'video',
                    17: 'feedback',
                    18: 'coupon',
                    19: 'rating',
                    20: 'pdf',
                    21: 'app',
                    22: 'mp3',
                    23: 'gallery'
                };
                return icons[qrCodeTypeId] || '';
            }

            /**
             * Converts specified colors to empty value. Keeps other colors unchanged.
             * @param {string} color
             * @param {Array} listOfColors
             * @returns {string}
             */
            function colorsToEmpty(color, listOfColors) {
                return (listOfColors || []).indexOf(color) >= 0 ? '' : color;
            }

            /**
             * This flag will be set if styles got changed.
             * @type {boolean}
             */
            $scope.stylesAreChanged = false;

            /**
             * Style of the QR code.
             * @type {*}
             */
            $scope.style = {};

            // Initialize QR styles.
            $scope.initStyles = function () {
                $scope.style = {
                    foregroundColor: qrStyle.foreground_color || '#000000',
                    newForegroundColor: '', // Tmp variable to use with color picker.
                    backgroundColor: qrStyle.background_color || '#ffffff',
                    newBackgroundColor: '', // Tmp variable to use with color picker.
                    frameColor: lastFrameTemplate.frame_color || '#000000',
                    newFrameColor: '', // Tmp variable to use with color picker.
                    accountFrameId: lastFrameTemplate.account_frame_id || 0,
                    frameName: lastFrameTemplate.frame_name || '', // Default frame will be set later after all frames are loaded from the server.
                    frameText: 'text' in lastFrameTemplate ? lastFrameTemplate.text : null,
                    frameTextColor: lastFrameTemplate.frame_text_color || '',
                    frameTextAlignment: lastFrameTemplate.frame_text_alignment || 'center',
                    frameTextFont: lastFrameTemplate.frame_text_font || 'noto-sans',
                    frameIconName: 'icon_name' in lastFrameTemplate ? lastFrameTemplate.icon_name : selectIconName($scope.qrCode.type_id),
                    topLeftShape: qrStyle.marker_left_template || 'version1',
                    topLeftInnerColor: colorsToEmpty(qrStyle.marker_left_inner_color, ['#000000', qrStyle.foreground_color]),
                    newTopLeftInnerColor: '',
                    topLeftOuterColor: colorsToEmpty(qrStyle.marker_left_outer_color, ['#000000', qrStyle.foreground_color]),
                    newTopLeftOuterColor: '',
                    topRightShape: qrStyle.marker_right_template || 'version1',
                    topRightInnerColor: colorsToEmpty(qrStyle.marker_right_inner_color, ['#000000', qrStyle.foreground_color]),
                    newTopRightInnerColor: '',
                    topRightOuterColor: colorsToEmpty(qrStyle.marker_right_outer_color, ['#000000', qrStyle.foreground_color]),
                    newTopRightOuterColor: '',
                    bottomLeftShape: qrStyle.marker_bottom_template || 'version1',
                    bottomLeftInnerColor: colorsToEmpty(qrStyle.marker_bottom_inner_color, ['#000000', qrStyle.foreground_color]),
                    newBottomLeftInnerColor: '',
                    bottomLeftOuterColor: colorsToEmpty(qrStyle.marker_bottom_outer_color, ['#000000', qrStyle.foreground_color]),
                    newBottomLeftOuterColor: '',
                    logoName: getLogoName(),
                    logoId: qrStyle.logo_id || 0,
                    patternName: 'qr_code_pattern' in qrStyle ? qrStyle.qr_code_pattern : 'rounded-2'
                };
            };

            $scope.initStyles();

            // Sync with actual QR styles (in case if they're changed somewhere).
            $scope.$on('qr-init-download-styles', function (event, design) {
                $scope.image.state = $scope.stateApplyingDesign;
                angular.extend(qrStyle, design);
                angular.extend(lastFrameTemplate, design.frame_template || {});
                $scope.initStyles();
            });

            /**
             * Available palettes.
             * @type {{background: string[], foreground: string[]}}
             */
            $scope.palettes = {
                foreground: ['#000000', '#47bdef', '#ff7a69', '#47d79a'],
                background: ['#ffffff'],
                loading: true // This will be set to "false" when all palettes will be loaded from the server.
            };

            function appendAdditionalColors() {
                // Append saved colors to the palettes.
                if ($scope.style.frameColor && $scope.palettes.foreground.indexOf($scope.style.frameColor) < 0) {
                    $scope.palettes.foreground.push($scope.style.frameColor);
                }
                if ($scope.style.foregroundColor && $scope.palettes.foreground.indexOf($scope.style.foregroundColor) < 0) {
                    $scope.palettes.foreground.push($scope.style.foregroundColor);
                }
                if ($scope.style.backgroundColor && $scope.palettes.background.indexOf($scope.style.backgroundColor) < 0) {
                    $scope.palettes.background.push($scope.style.backgroundColor);
                }
            }

            appendAdditionalColors();

            api.getPalettes(function (response) {
                angular.forEach(response.data.items || [], function (item) {
                    if (item.name === 'foreground_palette') {
                        $scope.palettes.foreground = item.colors;
                    } else if (item.name === 'background_palette') {
                        $scope.palettes.background = item.colors;
                    }
                });
                appendAdditionalColors();
                $timeout(function () { // A timeout is needed to finish all angular things before.
                    $scope.palettes.loading = false;
                });
            }, function () {
                $timeout(function () {
                    $scope.palettes.loading = false;
                });
            });

            /**
             * ID of the active tab (it's inside an object to fix angular scopes problems).
             * @type {{id: string, prev: string}}
             */
            $scope.activeTab = {
                id: $window.innerWidth <= 790 ? '' : 'frame', // This will be set after the download pop-up is closed in $scope.toggleDownload().
                prev: 'frame' // ID of the previous tab. Will be changed when download pop-up is opened in order to reset currently selected tab.
            };

            /**
             * State of the preview window.
             * @type {*}
             */
            $scope.preview = {
                open: false,
                auto: true
            };

            /**
             * QR image properties.
             * "image.loading" will be set to Image instance while it's loading -- this way we use only the latest image with latest parameters.
             * @type {{width: number, loading: boolean|HTMLImageElement, url: string, height: number, state: string}}
             */
            $scope.image = {
                url: '',
                height: 0,
                width: 0,
                loading: false,
                state: ''
            };

            /**
             * True if the right column is visible in mobile mode.
             * @type {boolean}
             */
            $scope.isDownloadOpen = true;

            /**
             * This indicates if the QR code is downloading or not.
             * @type {boolean}
             */
            $scope.isQrDownloading = false;

            /**
             * This indicates if the Frame is saving or not.
             * @type {boolean}
             */
            $scope.isFrameSaving = false;

            /**
             * @type {boolean}
             */
            $scope.isDownloadMenuOpen = false;
            $scope.isOverflowHidden = false;

            /**
             * Error correction for EPS downloading.
             * @type {*}
             */
            $scope.errorCorrection = {
                isHigh: false
            };

            /**
             * Timers are used to load images when QR code is updated to merge some updates before loading.
             * @type {*}
             */
            var timers = {
                image: null,       // a timer for image based on all styles from $scope.style except "$scope.style.new*".
                newImage: null,    // a timer for temporary image based on styles "$scope.style.new*".
                preview: null
            };

            /**
             * Returns frame params for downloading or for updating styles.
             * @param {string} imageFormat
             * @param {number} imageWidth
             * @param {boolean} isDownload
             * @param {boolean} [useNewStylesToo] if true, the temporary values in $scope.style.new* will be used too for making result.
             * @returns {*}
             */
            $scope.getFrameParams = function (imageFormat, imageWidth, isDownload, useNewStylesToo) {
                return {
                    qr_code_id: $scope.qrCode.id,
                    image_format: imageFormat,
                    image_width: imageWidth,
                    foreground_color: useNewStylesToo ? ($scope.style.newForegroundColor || $scope.style.foregroundColor) : $scope.style.foregroundColor,
                    background_color: useNewStylesToo ? ($scope.style.newBackgroundColor || $scope.style.backgroundColor) : $scope.style.backgroundColor,
                    frame_color: useNewStylesToo ? ($scope.style.newFrameColor || $scope.style.frameColor) : $scope.style.frameColor,
                    frame_name: $scope.style.frameName || 'no-frame',
                    account_frame_id: $scope.style.accountFrameId,
                    frame_text: $scope.style.frameText || '',
                    frame_text_color: $scope.style.frameTextColor || '#FFFFFF',
                    frame_text_alignment: $scope.style.frameTextAlignment || '',
                    frame_text_font: $scope.style.frameTextFont || '',
                    frame_icon_name: $scope.style.frameIconName || '',
                    marker_left_template: $scope.style.topLeftShape,
                    marker_left_inner_color: useNewStylesToo ? ($scope.style.newTopLeftInnerColor || $scope.style.topLeftInnerColor) : $scope.style.topLeftInnerColor,
                    marker_left_outer_color: useNewStylesToo ? ($scope.style.newTopLeftOuterColor || $scope.style.topLeftOuterColor) : $scope.style.topLeftOuterColor,
                    marker_right_template: $scope.style.topRightShape,
                    marker_right_inner_color: useNewStylesToo ? ($scope.style.newTopRightInnerColor || $scope.style.topRightInnerColor) : $scope.style.topRightInnerColor,
                    marker_right_outer_color: useNewStylesToo ? ($scope.style.newTopRightOuterColor || $scope.style.topRightOuterColor) : $scope.style.topRightOuterColor,
                    marker_bottom_template: $scope.style.bottomLeftShape,
                    marker_bottom_inner_color: useNewStylesToo ? ($scope.style.newBottomLeftInnerColor || $scope.style.bottomLeftInnerColor) : $scope.style.bottomLeftInnerColor,
                    marker_bottom_outer_color: useNewStylesToo ? ($scope.style.newBottomLeftOuterColor || $scope.style.bottomLeftOuterColor) : $scope.style.bottomLeftOuterColor,
                    qr_code_logo: $scope.style.logoName || 'no-logo',
                    download: isDownload ? 1 : 0, // Numbers should be used instread of booleans. Otherwise PHP will see string "false" that will work as TRUE.
                    error_correction: isDownload && imageFormat === 'EPS' && $scope.errorCorrection.isHigh ? 'H' : '',
                    qr_code_pattern: $scope.style.patternName || ''
                };
            };

            /**
             * Returns URL for downloading the frame image.
             * @param {string} imageFormat
             * @param {number} imageWidth
             * @param {boolean} isDownload
             * @param {boolean} addRandomParam
             * @param {boolean} [useNewStylesToo] if true, the temporary values in $scope.style.new* will be used too for making result.
             * @returns {string}
             */
            $scope.getFrameUrl = function (imageFormat, imageWidth, isDownload, addRandomParam, useNewStylesToo) {
                var url = api.getFrameDownloadUrl($scope.getFrameParams(imageFormat, imageWidth, isDownload, useNewStylesToo));
                if (addRandomParam) {
                    url += '&rnd=' + (new Date().getTime());
                }
                return url;
            };

            // Sync image.url with its dependencies including the short URL.
            $scope.$watch(function () {
                return $scope.qrCode.short_url + $scope.getFrameUrl('PNG', 500, false, false);
            }, function () {
                if (timers.image) {
                    // Cancel the old timer as we're starting a new one.
                    $timeout.cancel(timers.image);
                }
                $scope.isDownloadMenuOpen = false;
                // We start loading of QR codes only after 300ms after last change.
                // This allows us to accumulate some changes and don't make too many requests.
                timers.image = $timeout(function () {
                    timers.image = null;
                    $scope.image.loading = true;
                    if ($scope.image.url) { // Save design and then reload the image.
                        $scope.stylesAreChanged = true;
                        $scope.image.state = $scope.image.state || $scope.stateSavingDesign;
                        var frameParams = $scope.getFrameParams('PNG', 500, false);
                        api.updateDesign($scope.qrCode.id, frameParams, function () {
                            $scope.setQrCodeAndFrameDesign(frameParams);
                            $scope.startReloadingImage();
                            // If the dialog is already closed, we should update the image on the manage view one more time to ensure that it's up-to-date.
                            if (!$scope.open) {
                                api.getCode($scope.qrCode.id, '', function (response) {
                                    angular.extend(account.getCodesByIds([$scope.qrCode.id])[0], response.data);
                                });
                            }
                        }, function () {
                            if (!timers.image) {
                                $scope.image.loading = false;
                                $scope.image.state = '';
                            }
                        });
                    } else { // Reload the image only (called during initialization).
                        $scope.image.state = $scope.stateLoadingImage;
                        $scope.startReloadingImage();
                    }
                }, 300);

                // Call code contrast check function
                $scope.checkCodeContrast($scope.style.foregroundColor, $scope.style.backgroundColor);

                // Call edges contrast check function
                $scope.checkEdgeContrast();
            });

            // This $watch will update the image only in case of temporary changes (all styles starting with "new*").
            $scope.$watch(function () {
                return [
                    $scope.style.newForegroundColor, $scope.style.newBackgroundColor,
                    $scope.style.newFrameColor,
                    $scope.style.newTopLeftInnerColor, $scope.style.newTopLeftOuterColor,
                    $scope.style.newTopRightInnerColor,$scope.style.newTopRightOuterColor,
                    $scope.style.newBottomLeftInnerColor, $scope.style.newBottomLeftOuterColor
                ].join(''); // "join" makes nulls and empty values behave the same way, so opening the color picker doesn't change the QR image.
            }, function (newValues, oldValues) {

                if ($scope.style.newForegroundColor) {
                    $scope.checkCodeContrast($scope.style.newForegroundColor, $scope.style.backgroundColor);
                }

                if ($scope.style.newBackgroundColor) {
                    $scope.checkCodeContrast($scope.style.foregroundColor, $scope.style.newBackgroundColor);
                }

                // List all combinations for edges
                var combinations  = [
                    $scope.style.newTopLeftOuterColor, $scope.style.newTopLeftInnerColor, $scope.style.newTopRightOuterColor,
                    $scope.style.newTopRightInnerColor, $scope.style.newBottomLeftOuterColor, $scope.style.newBottomLeftInnerColor
                ];

                //go through all the combinations to find if the contrast ratio is false
                for (var i=0; i < combinations.length; i++) {

                    // If there are combinations
                    if (combinations[i]) {
                        // Check contrast ratio
                        $scope.isEdgeContrastRatio = chroma.contrast(combinations[i], $scope.style.backgroundColor) < 1.8;

                        // If there is a false status, stop the cycle
                        if ($scope.isEdgeContrastRatio) {
                            break;
                        }
                    }
                }

                // Check whether a warning is present or is resolved to add an intercom event for each case
                if ($scope.isEdgeContrastRatio && $scope.lastSentEventEdge !== 'low_contrast_ratio_warning_show') {
                    tracking.trackEvent('low_contrast_ratio_warning_show');
                    $scope.lastSentEventEdge = 'low_contrast_ratio_warning_show';
                } else if (!$scope.isEdgeContrastRatio && $scope.lastSentEventEdge !== 'low_contrast_ratio_warning_solved'){
                    tracking.trackEvent('low_contrast_ratio_warning_solved');
                    $scope.lastSentEventEdge = 'low_contrast_ratio_warning_solved';
                }

                if (angular.equals(newValues, oldValues)) {
                    return; // Skip the first call on initialization.
                }
                if (timers.newImage) {
                    $timeout.cancel(timers.newImage);
                    timers.newImage = null;
                }
                if (!newValues) { // If new values are empty, it means that the image will be re-generated by the watch above instead of this one.

                    // Add intercom event if user applied the low contrast ration on color picker
                    if ($scope.isCodeContrastRatio && $scope.activeTab.id === 'color') {
                        tracking.trackEvent('low_contrast_ratio_color_applied');
                    } else if ($scope.isEdgeContrastRatio && $scope.activeTab.id === 'edges') {
                        tracking.trackEvent('low_contrast_ratio_color_applied');
                    }
                    return;
                }
                $scope.isDownloadMenuOpen = false;
                timers.newImage = $timeout(function () {
                    timers.newImage = null;
                    $scope.image.loading = true;
                    $scope.image.state = $scope.stateLoadingImage;
                    $scope.startReloadingImage(false, true);
                }, 300);
            });


            // Auto-preview support.
            $scope.$watch('[style, qrCode.short_url]', function (newValue, oldValue) {
                // Watch if a new frame color from the color picker or white is selected, activate the dark mode.
                $scope.isDarkMode = ($scope.style.newFrameColor || $scope.style.frameColor) === '#ffffff';

                if ($scope.style.newFrameColor === null ||
                    ($scope.style.newFrameColor === "" && oldValue[0].newFrameColor === null) ||
                    ($scope.style.newFrameColor === "" && oldValue[0].newFrameColor) ||
                    (newValue[0].frameColor !== oldValue[0].frameColor)) {
                    return;
                }

                // Opening preview makes sense only on customization page, that's why we're checking $scope.isDownloadOpen here.
                if ($scope.preview.auto && $window.innerWidth <= 790 && !$scope.isDownloadOpen) {
                    if (timers.preview) {
                        $timeout.cancel(timers.preview);
                    }
                    timers.preview = $timeout(function () {
                        timers.preview = null;
                        $scope.preview.open = true;
                    }, 300);
                }
            }, true);

            /**
             * Update design data on angular side.
             * @param frameParams all params related to frame styles and QR styles.
             */
            $scope.setQrCodeAndFrameDesign = function (frameParams) {
                // frameParams contains styles as well, so we can just put them to QR code data as the format is the same.
                var code = account.getCodesByIds([$scope.qrCode.id])[0];
                code.style = frameParams;
                code.lastFrameTemplate = frameParams;
                code.lastFrameTemplate.text = frameParams.frame_text;
                code.lastFrameTemplate.icon_name = frameParams.frame_icon_name;
                angular.extend($scope.qrCode.style, frameParams);
            };

            /**
             * Close the preview window and stopPropagation to close ColorPicker
             * @param event
             */
            $scope.closePreview = function (event) {
                $scope.preview.open = false;
                event.stopPropagation();
            };

            /**
             * On click toggle visibility for custom text on frames.
             */
            $scope.toggleCustomTextVisibility = function () {
                $scope.isCustomTextVisible = !$scope.isCustomTextVisible;
            };

            /**
             * stopPropagation to close ColorPicker
             * @param event
             */
            $scope.stopPropagation = function (event) {
                event.stopPropagation();
            };

            /**
             * Refresh the QR image.
             * @param [callback]
             * @param [useNewStylesToo]
             */
            $scope.startReloadingImage = function (callback, useNewStylesToo) {
                var imageUrl = $scope.getFrameUrl('PNG', 500, false, true, useNewStylesToo);
                var image = new Image();
                image.onload = function () {
                    if ($scope.image.loading === image) {
                        $scope.image.url = this.src;
                        $scope.image.height = this.height;
                        $scope.image.width = this.width;
                        $scope.image.loading = false;
                        $scope.image.state = '';
                        if (callback) {
                            callback(true);
                        }
                        $scope.$apply();
                    }
                };
                image.onerror = function () {
                    if ($scope.image.loading === image) {
                        $scope.image.url = '';
                        $scope.image.height = 0;
                        $scope.image.width = 0;
                        $scope.image.loading = false;
                        $scope.image.state = '';
                        if (callback) {
                            callback(false);
                        }
                        $scope.$apply();
                    }
                };
                $scope.image.loading = image;
                image.src = imageUrl;
            };

            /**
             * Configuration of the vertical tabs.
             * @type {Array}
             */
            $scope.tabs = [
                {
                    id: 'frame',
                    label: gettextCatalog.getString('Frame'),
                    icon: 'icon-qr-frame'
                },
                {
                    id: 'color',
                    label: gettextCatalog.getString('Code'),
                    icon: 'icon-qr-palette',
                    notification: function () {
                        return $scope.isCodeContrastRatio;
                    }
                },
                {
                    id: 'logo',
                    label: gettextCatalog.getString('Logo'),
                    icon: 'icon-qr-logo'
                },
                {
                    id: 'edges',
                    label: gettextCatalog.getString('Edges'),
                    icon: 'icon-qr-edge',
                    notification: function () {
                        return $scope.isEdgeContrastRatio;
                    }
                },
                {
                    id: 'designs',
                    label: gettextCatalog.getString('Designs'),
                    icon: 'icon-qr-save-design'
                },
                {
                    id: 'url',
                    label: gettextCatalog.getString('URL'),
                    icon: 'icon-qr-url',
                    visible: function () {
                        return !!$scope.qrCode.trackable;
                    }
                }
            ];

            /**
             * Download the image.
             * @param {String} [format]
             */
            $scope.download = function (format) {
                $scope.isDownloadMenuOpen = false;
                var frameParams = $scope.getFrameParams(format || 'PNG', 3000, false);
                api.updateDesign($scope.qrCode.id, frameParams, function () {
                    // frameParams contains styles as well, so we can just put them to QR code data as the format is the same.
                    var code = account.getCodesByIds([$scope.qrCode.id])[0];
                    code.style = frameParams;
                    code.lastFrameTemplate = frameParams;
                    angular.extend($scope.qrCode.style, frameParams);
                    var link = document.createElement('a');
                    link.href = $scope.getFrameUrl(format || 'PNG', 3000, true, true);
                    document.body.appendChild(link);
                    // Use cookie to track downloading.
                    $cookies.put('qr_downloading', 1, {
                        path: '/',
                        secure: false,
                        expires: new Date(3500 + (+new Date())),
                        domain: '.qr-code-generator.com'
                    });
                    $scope.isQrDownloading = true;
                    link.click();
                    document.body.removeChild(link);
                    // Track downloads.
                    $timeout(function () {
                        window.mixpanel.track(account.getAccountStatus() === 'trial' ? 'download code trial' : 'download code', {
                            format: format
                        });

                        tracking.trackEvent('done_download_code');
                        if (frameParams.frame_name && frameParams.frame_name !== 'no-frame') {
                            tracking.trackEvent('done_download_code_with_frame');
                        }

                        if (frameParams.frame_name && frameParams.frame_name.includes("contactless-menu")) {
                            tracking.trackEvent('done_download_template');
                            mixpanel.track('done_download_template', {
                                frame_name: frameParams.frame_name
                            });
                        }
                    });
                });
            };

            /**
             * Toggle the right column with download related controls.
             */
            $scope.toggleDownload = function () {
                $scope.isDownloadOpen = !$scope.isDownloadOpen;
                if ($scope.isDownloadOpen) {
                    $scope.activeTab.prev = $scope.activeTab.id;
                    $scope.activeTab.id = '';
                } else {
                    $scope.activeTab.id = $scope.activeTab.prev || 'frame';
                }
            };

            /**
             * Toggle the download menu with file formats.
             */
            $scope.toggleDownloadMenu = function () {
                $scope.isDownloadMenuOpen = !$scope.isDownloadMenuOpen;

                if ($scope.isDownloadMenuOpen) {
                    $scope.isOverflowHidden = true;
                } else {
                    $timeout(function () {
                        $scope.isOverflowHidden = false;
                    }, 250);
                }
            };

            /**
             * Print QR Code.
             */
            $scope.printCode = function () {
                var printContent = document.getElementById("printContent").innerHTML;
                var body = document.getElementsByTagName("BODY")[0];

                //Create a dynamic IFRAME.
                var frameTmp = document.createElement("IFRAME");
                frameTmp.name = "frameTmp";
                frameTmp.setAttribute("style", "position:absolute;top:-1000000px");
                body.appendChild(frameTmp);

                //Create a Frame Document.
                var frameDoc = frameTmp.contentWindow ? frameTmp.contentWindow : frameTmp.contentDocument.document ? frameTmp.contentDocument.document : frameTmp.contentDocument;
                frameDoc.document.open();

                //Append the external CSS file.
                frameDoc.document.write('<link href="/css/build/print_code.css" rel="stylesheet" type="text/css" />');

                //Append the DIV contents.
                frameDoc.document.write(printContent);
                frameDoc.document.close();

                $window.setTimeout(function () {
                    $window.frames['frameTmp'].focus();
                    $window.frames['frameTmp'].print();
                    body.removeChild(frameTmp);
                }, 500);

                tracking.trackEvent('open_print_dialog');
            };

            /**
             * Save frame design to user account
             */

            // Default frame identifier
            var frameId = 4;

            $scope.saveFrameDesign = function () {

                // Enable saving status of frame
                $scope.isFrameSaving = true;

                // Define the frame name to send a specific identifier to the database
                if ($scope.style.frameName === 'bottom-frame') {
                    frameId = 1;
                } else if ($scope.style.frameName === 'bottom-tooltip') {
                    frameId = 2;
                } else if ($scope.style.frameName === 'top-header') {
                    frameId = 3;
                }

                // Variable to save the selected frame style that will be sent to the API request
                var selectedFrameStyles = {
                    frame_id: frameId,
                    frame_color: $scope.style.frameColor,
                    frame_icon_name: $scope.style.frameIconName,
                    frame_text: $scope.style.frameText,
                    frame_text_color: $scope.style.frameTextColor // The text color should be sent for old frames, otherwise the text color is black.
                };

                // API request to save selected styles in user account frames
                api.saveFrameDesign(selectedFrameStyles, function (response) {
                    $scope.isOnCreateOwn.value = false;    // Hide "Create your own" section
                    $scope.isFrameSaving = false;          // Disable saving the status for the frame in the section "Create your own"

                    // Send data to the add_frame event at qrCustomDownloadFrame component
                    $scope.$broadcast('add_frame', response.data);

                    $scope.style.accountFrameId = response.data.id;    // Activate the current saved frame by attaching the created frame ID

                    angular.element(document).find('[data-button="savePremiumDesign"]').addClass('hiddenAbsolute');
                    angular.element(document).find('[data-button="toggleDownload"]').removeClass('hiddenAbsolute');

                }, function () {
                    console.log('Error saving frame');
                });

                // Event for save frame styles from "Create your own" section
                tracking.trackEvent('frameshop_custom_choose');
            };

            /**
             * @returns {*}
             */
            $scope.getContentClasses = function () {
                return {
                    'qr-custom-download__content--toggled': $scope.isDownloadOpen,
                    'qr-custom-download__content--own-animation': $scope.isOnCreateOwn.value
                };
            };

            /**
             * Get QR code image styles to fix scaling of frames.
             * @returns {*}
             */
            $scope.getImageStyles = function () {
                var availableHeight = 250,
                    newImageHeight = $scope.image.height * 250 / $scope.image.width,
                    marginTop = Math.floor((availableHeight - newImageHeight) / 2);
                return {
                    width: marginTop >= 0 ? '250px' : 'auto',
                    height: marginTop >= 0 ? 'auto' : (availableHeight + 'px'),
                    marginTop: marginTop >= 0 ? ((50 + marginTop) + 'px') : '50px'
                };
            };

            // Install perfect scrollbar for the left section.
            $timeout(function () {
                $($element.find('.qr-custom-download__left')[0]).perfectScrollbar({
                    suppressScrollX: true
                });
                $element.find('.qr-custom-download__left').addClass('qr-custom-download__left--ready');
            });

            // Update the scrollbar when current tab is changed.
            $scope.$watch('activeTab.id', function () {
                if (!$scope.activeTab.id) {
                    return;
                }

                $scope.isMobile = $scope.activeTab.id === 'frame';
                $scope.isDownloadMenuOpen = false;
                if ($scope.isDownloadOpen) {
                    $scope.isDownloadOpen = false;
                }
                var leftColumn = $element.find('.qr-custom-download__left')[0];
                if ("scrollTo" in leftColumn) { // MS Edge doesn't support this method.
                    leftColumn.scrollTo(0, 0);
                }
                $timeout(function () {
                    $(leftColumn).perfectScrollbar('update');
                });
            });

            // This function is used to track QR code downloading.
            function cookieWatcher() {
                if ($cookies.get('qr_downloading')) {
                    $timeout(cookieWatcher, 300);
                } else {
                    $scope.isQrDownloading = false;
                }
            }

            $scope.$watch('isQrDownloading', function (isDownloading) {
                if (isDownloading) {
                    $timeout(cookieWatcher, 300);
                }
            });

            // This synchronizes foreground palette with the server.
            $scope.$watch('palettes.foreground', function (newPalette, oldPalette) {
                if (!$scope.palettes.loading && !angular.equals(newPalette, oldPalette)) {
                    api.updatePalette('foreground_palette', $scope.palettes.foreground);
                }
            }, true);

            // This synchronizes background palette with the server.
            $scope.$watch('palettes.background', function (newPalette, oldPalette) {
                if (!$scope.palettes.loading && !angular.equals(newPalette, oldPalette)) {
                    api.updatePalette('background_palette', $scope.palettes.background);
                }
            }, true);

            // When the dialog is closing, update the QR image on the manage view.
            $scope.$watch('open', function (newOpen, oldOpen) {
                if (!newOpen && oldOpen && $scope.stylesAreChanged) {
                    api.getCode($scope.qrCode.id, '', function (response) {
                        angular.extend($scope.qrCode, response.data);
                    });
                }
            });

            // This allows to open a tab from outside of this component.
            $scope.$watch('openTab', function (openTab) {
                if (openTab) {
                    $scope.activeTab.id = '' + openTab;
                }
            });

            /**
             * Check contrast ratio for code colors
             * @type {boolean}
             */
            $scope.checkCodeContrast = function (foregroundColor, backgroundColor) {
                $scope.isCodeContrastRatio = chroma.contrast(foregroundColor, backgroundColor) < 1.8;

                // Check whether a warning is present or is resolved to add an intercom event for each case
                if ($scope.isCodeContrastRatio && $scope.lastSentEventCode !== 'low_contrast_ratio_warning_show') {
                    tracking.trackEvent('low_contrast_ratio_warning_show');
                    $scope.lastSentEventCode = 'low_contrast_ratio_warning_show';
                } else if (!$scope.isCodeContrastRatio && $scope.lastSentEventCode !== 'low_contrast_ratio_warning_solved'){
                    tracking.trackEvent('low_contrast_ratio_warning_solved');
                    $scope.lastSentEventCode = 'low_contrast_ratio_warning_solved';
                }
            };

            /**
             * Check contrast ratio for edges colors
             * @type {boolean}
             */
            $scope.checkEdgeContrast = function () {
                // Define the left column element
                var leftColumn = $element.find('.qr-custom-download__left')[0];

                // List all combinations for edges
                var combinations  = [
                    $scope.style.topLeftOuterColor, $scope.style.topLeftInnerColor, $scope.style.topRightOuterColor,
                    $scope.style.topRightInnerColor, $scope.style.bottomLeftOuterColor, $scope.style.bottomLeftInnerColor
                ];

                //go through all the combinations to find if the contrast ratio is false
                for (var i=0; i < combinations.length; i++) {

                    // If there are combinations
                    if (combinations[i]) {
                        // Check contrast ratio
                        $scope.isEdgeContrastRatio = chroma.contrast(combinations[i], $scope.style.backgroundColor) < 1.8;

                        // If there is a false status, stop the cycle
                        if ($scope.isEdgeContrastRatio) {
                            break;
                        }
                    } else {
                        // If all edge colors are good, the return value is false, which means that the contrast ratio is above 1.8
                        $scope.isEdgeContrastRatio = false;
                    }
                }

                // If we have an error contrast ratio, then we need to update the scroll bar and scroll to the top
                // content to see the error
                if ($scope.isEdgeContrastRatio) {

                    // Update perfectScrollbar function
                    $timeout(function () {
                        $(leftColumn).perfectScrollbar('update');
                    });

                    // Scroll to top content
                    if ("scrollTo" in leftColumn) { // MS Edge doesn't support this method.
                        leftColumn.scrollTo(0, 0);
                    }
                }
            };

            /**
             * Check if frame store is visible
             * @type {*}
             */
            $scope.getModalClass = function () {
                return {'qr-custom-download--store-open' : $scope.isFrameStoreVisible.value};
            };

            /**
             * When the modal frame store appears, add the class to it
             * @type {*}
             */
            $scope.getFrameStoreModalClass = function () {
                return {'qr-frame-store--open' : $scope.isFrameStoreVisible.value};
            };

            angular.element($window).bind('resize', function () {
                $scope.isMobile = $window.innerWidth <= 790;
                $scope.isCustomTextVisible = false;

                if ($window.innerWidth > 790) {
                    $scope.preview.open = false;
                }
            });

            /**
             * Determine when we click outside the custom text on the frame container.
             * Also detect clicking on the icon text component.
             */
            angular.element(document).mousedown(function (e) {
                var customText = angular.element(document).find('[data-js="customText"]');
                var customTextAction = angular.element(document).find('[data-js="customTextAction"]');

                if (!customText.is(e.target) && customText.has(e.target).length === 0 && !customTextAction.is(e.target) && customTextAction.has(e.target).length === 0) {
                    $scope.isCustomTextVisible = false;
                }
            });
            $scope.fonts = [];

            api.getFonts(function (response) {
                $scope.fonts = response.data || [];
            });

            /**
             * Reverse a string.
             * @param {string} str
             */
            $scope.reverseString = function (str) {
                return str.split("").reverse().join("");
            };

            /**
             * Unicode and language detection for text
             * @param {string} text
             **/
            $scope.languageDetection = function (text, reverse) {
                // Detect the character encoding.
                // The return value be one of the "Available Encodings" below.
                var detected = characterBlock.getCharacterEncodes(text);
                if (detected[0] === 'latin') {
                    ($scope.data.allUserFrames || []).forEach(function (element, i) {
                        if ($scope.data.allUserFrames[i].name.indexOf($scope.style.frameName) >= 0) {
                            $scope.style.frameTextFont = $scope.data.allUserFrames[i].frame_text_font;
                        }
                    });
                } else {
                    // Browse the list of fonts to determine the first font that supports the detected language and apply it
                    for (var i = 0; i < $scope.fonts.length; i++) {
                        if ($scope.fonts[i].language_list.indexOf(detected[0]) >= 0) {
                            $scope.style.frameTextFont = $scope.fonts[i].name;
                            break;
                        }
                    }
                }

                // Define a text language, and if the text is RTL, we need to reverse the string
                // else keep the original text
                if ((detected[0] === 'arabic' || detected[0] === 'hebrew') && reverse) {
                    $scope.style.frameText = $scope.reverseString(text);
                } else {
                    $scope.style.frameText = text;
                }
            };

            /**
             * When the user changes the default call to the action of frame title
             */
            $scope.$watch('style.frameText', function (newFrameText, oldFrameText) {
                if (newFrameText === oldFrameText) {
                    return;
                }

                if (oldFrameText && (newFrameText !== $scope.reverseString(oldFrameText))) {
                    $scope.languageDetection($scope.style.frameText, true);
                }

                if ($scope.data.intercomChangeFrameText) {
                    tracking.trackEvent('done_change_frame_text');
                    $scope.data.intercomChangeFrameText = false;
                }
            });

            /**
             * Search by frame name in the all user frames
             * @param {string} frameName
             * @returns {object}
             */
            $scope.searchFrameByName = function(frameName) {
                var result = false;

                ($scope.data.allUserFrames || []).forEach(function (frame) {
                    if (frame.name === frameName) {
                        result = frame;
                    }
                });

                return result;
            };

            /**
             * Search by frame name in the all saved custom frames
             * @param {number} frameId
             * @returns {object}
             */
            $scope.searchFrameById = function(frameId) {
                var result = false;

                ($scope.data.savedCustomFrames || []).forEach(function (frame) {
                    if (frame.id === frameId) {
                        result = frame;
                    }
                });

                return result;
            };

            /**
             * When the user changes the default call to the action of frame title
             */
            $scope.$watch('style.frameName', function (newFrameName, oldFrameName) {
                if (!$scope.style.frameText || $scope.style.frameText === $scope.searchFrameByName(oldFrameName).frame_text) {
                    $scope.style.frameText = $scope.searchFrameByName(newFrameName).frame_text;
                }

                $scope.languageDetection($scope.style.frameText, false);

            });

            /**
             * When the user changes the frame watch the frame ID
             */
            $scope.$watch('style.accountFrameId', function (newAccountFrameId) {

                if ($scope.searchFrameById(newAccountFrameId).frame_text) {
                    $scope.style.frameText = $scope.searchFrameById(newAccountFrameId).frame_text;
                }

            });

            /**
             * When the user changes the default call to the action of frame title
             */
            $scope.$watch('data.allUserFrames', function (newAllUserFrames, oldAllUserFrames) {
                if (!$scope.style.frameText && $scope.searchFrameByName($scope.style.frameName) && newAllUserFrames.length > 5) {
                    $scope.style.frameText = $scope.searchFrameByName($scope.style.frameName).frame_text;
                    $scope.style.frameTextFont = $scope.searchFrameByName($scope.style.frameName).frame_text_font;
                    $scope.style.frameTextAlignment = $scope.searchFrameByName($scope.style.frameName).frame_text_alignment;
                }
            });
        }]
    };
}]);
;
/**
 * Tab "Color" for the new custom download dialog.
 */
app.directive('qrCustomDownloadColor', ['$sce', '$window', '$timeout', 'gettextCatalog', 'markup', function ($sce, $window, $timeout, gettextCatalog, markup) {
    'use strict';
    return {
        restrict: 'E',
        template:
            '<div class="qr-resources">' +
                '<qr-modal open="open" close-icon="true">' +
                    '<iframe id="previewIframe" data-ng-src="{{ url }}"></iframe>' +
                '</qr-modal>' +
            '</div>' +
            '<div ng-show="isContrastRatio" class="message message_warning qr-custom-download__ratio-warning" ng-class="!isContrastRatio ? &apos;&apos; : &apos;qr-custom-download__ratio-warning-appear&apos;">' +
                '<h6 class="message__heading">{{ ::warningHeading }}</h6>' +
                '<div class="message__content" ng-bind-html="::designText">' +
                    '{{ ::designText }}' +
                    '<a href="" class="message__link" ng-click="!isMobile && openModal(designUrl)">{{ ::learnMoreLabel }}</a>' +
                '</div>' +
            '</div>' +
            '<div class="qr-custom-download-color">' +
                '<label class="qr-custom-download-color__title" ng-bind="::shapesTitle"></label>' +
                '<div class="qr-custom-download-color__shape-container">' +
                    '<button type="button" class="qr-custom-download-logo__logo qr-custom-download-logo__logo--nologo" ng-class="{&apos;qr-custom-download-logo__logo--active&apos;: !patternName || patternName === &apos;&apos;}" ng-click="clickPattern({name: &apos;&apos;})">' +
                        '{{ ::noShapeLabel }}' +
                    '</button>' +
                    '<qr-image-tile class="qr-custom-download-color__shape" ng-repeat="pattern in patterns | limitTo:100:1" image-url="pattern.image" ng-click="clickPattern(pattern)" is-selected="isPatternSelected(pattern)" is-always-visible="true"></qr-image-tile>' +
                '</div>' +
                '<button class="qr-custom-download-color__edit" type="button" ng-click="editing = true" ng-hide="editing">' +
                    '<span class="icon icon-avatar-edit"></span>' +
                    '{{ ::editLabel }}' +
                '</button>' +
                '<button class="qr-custom-download-color__edit" type="button" ng-click="editing = false" ng-show="editing" ng-bind="::doneLabel"></button>' +
                '<label class="qr-custom-download-color__subtitle" ng-bind="::title"></label>' +
                '<qr-color-palette class="qr-custom-download-color__palette" colors="foregroundPalette" deleting="editing" active="foregroundColor" max-colors="14" new-color="newForegroundColor" read-only-length="1"></qr-color-palette>' +
                '<button class="qr-custom-download-color__subtitle qr-custom-download-color__subtitle--hover" ng-click="openBackgroundColors = !openBackgroundColors" ng-class="{&apos;qr-custom-download-color__subtitle--open&apos;: openBackgroundColors}" ng-switch="openBackgroundColors">' +
                    '{{ ::backgroundLabel }}' +
                    '<span class="icon icon-down-open-mini" ng-switch-default></span>' +
                    '<span class="icon icon-up-open-mini" ng-switch-when="true"></span>' +
                '</button>' +
                '<qr-color-palette class="qr-custom-download-color__palette" colors="backgroundPalette" deleting="editing" active="backgroundColor" ng-show="openBackgroundColors" max-colors="14" new-color="newBackgroundColor" read-only-length="1"></qr-color-palette>' +
            '</div>',
        scope: {
            foregroundPalette: '=',     // Foreground colors.
            backgroundPalette: '=',     // Background colors.
            foregroundColor: '=',       // Current foreground color.
            backgroundColor: '=',       // Current background color.
            newForegroundColor: '=',    // New foreground color that is currently inside the color picker.
            newBackgroundColor: '=',    // New background color that is currently inside the color picker.
            patternName: '=',           // Name of data pattern to render the QR blocks.
            isContrastRatio: '='        // Is the contrast of two colors sufficient?
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            /**
             * Translations.
             */
            $scope.title = gettextCatalog.getString('Color');
            $scope.shapesTitle = gettextCatalog.getString('Shapes');
            $scope.editLabel = gettextCatalog.getString('Edit');
            $scope.doneLabel = gettextCatalog.getString('Done');
            $scope.learnMoreLabel = gettextCatalog.getString('Learn more');
            $scope.backgroundLabel = gettextCatalog.getString('Add background color');
            $scope.warningHeading = gettextCatalog.getString('QR Code may not be scannable');
            $scope.warningParagraph = gettextCatalog.getString('Some smartphones or apps may have trouble reading your QR Code. We recommend using dark QR Code colors and light background colors.');
            $scope.noShapeLabel = gettextCatalog.getString('No Shape');

            $scope.clickPattern = function (pattern) {
                $scope.patternName = pattern.name;
            };

            $scope.isPatternSelected = function (pattern) {
                return pattern.name === ($scope.patternName || '');
            };

            /**
             * Available data patterns.
             * There's also original SVG images, but we use PNG to avoid some SVG rendering problems like lines between blocks.
             * @type {Array}
             */
            $scope.patterns = [
                {
                    name: '',
                    image: '/img/patterns/default.png'
                },
                {
                    name: 'rounded-2',
                    image: '/img/patterns/rounded-2.png'
                },
                {
                    name: 'dots',
                    image: '/img/patterns/dots.png'
                },
                {
                    name: 'rounded-1',
                    image: '/img/patterns/rounded-1.png'
                },
                {
                    name: 'connect-horizontal',
                    image: '/img/patterns/connect-horizontal.png'
                },
                {
                    name: 'square',
                    image: '/img/patterns/square.png'
                }
            ];

            /**
             * Global variables
             */
            $scope.open = false;
            $scope.isMobile = ($window.innerWidth < 768);
            $scope.urlParameter = "&utm_source=app_website&utm_medium=managedview&inappusage=true";
            $scope.designUrl = "https://www.qr-code-generator.com/qr-code-marketing/individual-design-of-qr-codes/?utm_campaign=individual_design";

            /**
             * Edit mode for colors.
             * @type {boolean}
             */
            $scope.editing = false;

            /**
             * Set the margin-top for the warning message to use the animation more correctly.
             */
            $element.find('.message_warning').css({
                marginTop: - $element.find('.message_warning')[0].offsetHeight - 60
            });

            /**
             * @type {boolean}
             */
            $scope.openBackgroundColors = $scope.backgroundColor !== '#ffffff';

            $scope.designText = $sce.trustAsHtml(
                markup.convertToString(
                    gettextCatalog.getString(
                        "Some smartphones or apps may have trouble reading your QR Code. We recommend using dark QR Code colors and light background colors.[link={{url}}]Learn more[/link].",
                        {url: $scope.designUrl}
                    ),
                    "message__link"
                )
            );

            $scope.url = "";

            $timeout(function () {
                $('.qr-custom-download__ratio-warning').find('.message__link').on('click', function(event) {
                    event.preventDefault();
                    var clickedLink = $(this).attr("href");
                    $scope.openModal(clickedLink);
                    $scope.$apply();
                });
            }, 0);

            $scope.openModal = function (url) {
                if ($scope.isMobile) {
                    $window.open(url + $scope.urlParameter);
                } else {
                    $scope.url = $sce.trustAsResourceUrl(url + $scope.urlParameter);
                    $scope.open = true;
                }
            };

            $scope.$watch("open", function () {
                if ($scope.open === false) {
                    $scope.url = $sce.trustAsResourceUrl("about:blank");
                }
            });
        }]
    };
}]);
;
/**
 * Tab "Designs" for the new custom download dialog.
 */
app.directive('qrCustomDownloadDesigns', ['gettextCatalog', 'api', 'tracking', function (gettextCatalog, api, tracking) {
    'use strict';
    return {
        restrict: 'E',
        template:
            '<div class="qr-custom-download-designs">' +
                '<button class="qr-custom-download-designs__edit" type="button" ng-click="states.editing = true" ng-hide="states.editing || states.loading || designs.length === 0">' +
                    '<span class="icon icon-avatar-edit"></span>' +
                    '{{ ::editLabel }}' +
                '</button>' +
                '<button class="qr-custom-download-designs__edit" type="button" ng-click="states.editing = false" ng-show="states.editing" ng-bind="::doneLabel"></button>' +
                '<label class="qr-custom-download-designs__title" ng-bind="::title"></label>' +
                '<div class="qr-custom-download-designs__intro" ng-show="!states.loading && designs.length === 0 && !states.saving">' +
                    '<p class="qr-custom-download-designs__save-text" ng-bind="::saveText"></p>' +
                    '<button type="button" class="qr-custom-download-designs__save" ng-bind="::saveLabel" ng-click="saveDesign()"></button>' +
                '</div>' +
                '<div ng-show="!states.loading && (designs.length > 0 || states.saving)">' +
                    '<button type="button" class="qr-custom-download-designs__save-block" ng-click="saveDesign()">' +
                        '<span class="icon icon-plus-1"></span>' +
                        '{{ ::saveLabel }}' +
                    '</button>' +
                    '<qr-image-tile class="qr-custom-download-designs__design" ng-if="states.saving"></qr-image-tile>' +
                    '<qr-image-tile class="qr-custom-download-designs__design" ng-repeat="item in designs" image-url="::item.image_url" is-editing="states.editing" on-click="changeDesign(item)" on-delete="deleteDesign(item, $index)"></qr-image-tile>' +
                '</div>' +
                '<div class="qr-custom-download-designs__spinner-container" ng-show="states.loading">' +
                    '<qr-spinner loading="states.loading"></qr-spinner>' +
                '</div>' +
            '</div>',
        scope: {
            isVisible: '=',     // Tab visibility flag.
            qrCode: '=',        // QR Code data including design.
            actualStyles: '='   // Actual styles from the parent component. This is used to save correct design, if the QR code has empty values.
        },
        controller: ['$scope', function ($scope) {
            /**
             * Translations.
             */
            $scope.title = gettextCatalog.getString('My designs');
            $scope.editLabel = gettextCatalog.getString('Edit');
            $scope.doneLabel = gettextCatalog.getString('Done');
            $scope.saveLabel = gettextCatalog.getString('Save design');
            $scope.saveText = gettextCatalog.getString('Save designs to reuse them for other QR Codes. To save your current settings, click below.');

            /**
             * States of the tab.
             * @type {{loading: boolean, editing: boolean, saving: boolean}}
             */
            $scope.states = {
                editing: false,     // Editing of designs.
                loading: true,      // Loading designs from the server.
                saving: false       // The tab is saving a design (it will display a progress element in the list).
            };

            /**
             * List of account's designs.
             * @type {Array}
             */
            $scope.designs = [];

            /**
             * Save current design.
             */
            $scope.saveDesign = function () {
                var actualFrameStyles = { // @todo it's better to find real reason why QR code's frame styles are empty after creation.
                    frame_name: $scope.actualStyles.frameName,
                    frame_text: $scope.actualStyles.frameText,
                    frame_icon_name: $scope.actualStyles.frameIconName,
                    frame_color: $scope.actualStyles.frameColor
                };
                var designParams = angular.extend({}, $scope.qrCode.style || {}, $scope.qrCode.lastFrameTemplate || actualFrameStyles);

                if (Object.keys(designParams).length <= 0) {
                    return;
                }

                $scope.states.saving = true;

                designParams.qr_code_id = $scope.qrCode.id;
                designParams.frame_name = designParams.frame_name || 'bottom-frame'; // bottom-frame is the default value for frame name.
                designParams.qr_code_logo = '' + designParams.qr_code_logo === '1' ? '' : designParams.qr_code_logo;
                designParams.frame_icon_name = designParams.frame_icon_name || designParams.icon_name || '';
                designParams.frame_text = designParams.frame_text || designParams.text || '';

                api.createDesign(designParams, function (response) {
                    $scope.states.saving = false;
                    if (response.data && response.data instanceof Object) {
                        $scope.designs.splice(0, 0, response.data);
                    }
                    tracking.trackEvent('done_create_design_template');
                }, function () {
                    $scope.states.saving = false;
                });
            };

            /**
             * Changes current QR design.
             * @param item
             */
            $scope.changeDesign = function (item) {
                // This goes to the parent <qr-custom-download> and changes current QR design.
                $scope.$emit('qr-init-download-styles', item);
            };

            /**
             * Deletes design from the database.
             * @param item
             * @param index
             */
            $scope.deleteDesign = function (item, index) {
                if ($scope.states.editing && 'id' in item && item.id > 0) {
                    api.deleteDesign(item.id, function () {
                        $scope.designs.splice(index, 1);
                        if ($scope.designs.length <= 0) {
                            $scope.states.editing = false;
                        }
                    });
                }
            };

            // Load designs only when the tab becomes visible.
            $scope.$watch('isVisible', function () {
                if ($scope.isVisible && $scope.states.loading) {
                    api.getDesigns(function (response) {
                        $scope.states.loading = false;
                        $scope.designs = response.data || [];
                    });
                }
            });
        }]
    };
}]);
;
/**
 * Tab "Edges" for the new custom download dialog.
 */
app.directive('qrCustomDownloadEdges', ['$sce', '$window', '$timeout', 'gettextCatalog', 'markup', function ($sce, $window, $timeout, gettextCatalog, markup) {
    'use strict';
    return {
        restrict: 'E',
        template:
            '<div class="qr-resources">' +
                '<qr-modal open="open" close-icon="true">' +
                    '<iframe id="previewIframe" data-ng-src="{{ url }}"></iframe>' +
                '</qr-modal>' +
            '</div>' +
            '<div ng-show="isContrastRatio" class="message message_warning qr-custom-download__ratio-warning" ng-class="!isContrastRatio ? &apos;&apos; : &apos;qr-custom-download__ratio-warning-appear&apos;">' +
                '<h6 class="message__heading">{{ ::warningHeading }}</h6>' +
                '<div class="message__content" ng-bind-html="::designText">' +
                    '{{ ::designText }}' +
                    '<a href="" class="message__link" ng-click="!isMobile && openModal(designUrl)">{{ ::learnMoreLabel }}</a>' +
                '</div>' +
            '</div>' +
            '<div class="qr-custom-download-edges">' +
                '<label class="qr-custom-download-edges__title" ng-bind="::title"></label>' +
                '<qr-toggle class="qr-custom-download-edges__toggle" value="customMarkers" false-label="{{ ::allLabel }}" true-label="{{ ::customLabel }}"></qr-toggle>' +
                '<div class="qr-custom-download-edges__row">' +
                    '<div class="qr-custom-download-edges__marker">' +
                        '<label ng-bind="customMarkers ? topLeftLabel : shapeLabel"></label>' +
                        '<qr-marker-shape value="topLeftShape"></qr-marker-shape>' +
                    '</div>' +
                    '<div class="qr-custom-download-edges__outer">' +
                        '<label ng-bind="::outerColorLabel"></label>' +
                        '<qr-color-spot value="topLeftOuterColor" deleting="::true" palette="palette" new-value="newTopLeftOuterColor"></qr-color-spot>' +
                    '</div>' +
                    '<div class="qr-custom-download-edges__inner">' +
                        '<label ng-bind="::innerColorLabel"></label>' +
                        '<qr-color-spot value="topLeftInnerColor" deleting="::true" palette="palette" new-value="newTopLeftInnerColor"></qr-color-spot>' +
                    '</div>' +
                '</div>' +
                '<div class="qr-custom-download-edges__row" ng-show="customMarkers">' +
                    '<div class="qr-custom-download-edges__marker">' +
                        '<label ng-bind="::topRightLabel"></label>' +
                        '<qr-marker-shape value="topRightShape"></qr-marker-shape>' +
                    '</div>' +
                    '<div class="qr-custom-download-edges__outer">' +
                        '<label ng-bind="::outerColorLabel"></label>' +
                        '<qr-color-spot value="topRightOuterColor" deleting="::true" palette="palette" new-value="newTopRightOuterColor"></qr-color-spot>' +
                    '</div>' +
                    '<div class="qr-custom-download-edges__inner">' +
                        '<label ng-bind="::innerColorLabel"></label>' +
                        '<qr-color-spot value="topRightInnerColor" deleting="::true" palette="palette" new-value="newTopRightInnerColor"></qr-color-spot>' +
                    '</div>' +
                '</div>' +
                '<div class="qr-custom-download-edges__row" ng-show="customMarkers">' +
                    '<div class="qr-custom-download-edges__marker">' +
                        '<label ng-bind="::bottomLeftLabel"></label>' +
                        '<qr-marker-shape value="bottomLeftShape" drop-up="true"></qr-marker-shape>' +
                    '</div>' +
                    '<div class="qr-custom-download-edges__outer">' +
                        '<label ng-bind="::outerColorLabel"></label>' +
                        '<qr-color-spot value="bottomLeftOuterColor" deleting="::true" palette="palette" new-value="newBottomLeftOuterColor"></qr-color-spot>' +
                    '</div>' +
                    '<div class="qr-custom-download-edges__inner">' +
                        '<label ng-bind="::innerColorLabel"></label>' +
                        '<qr-color-spot value="bottomLeftInnerColor" deleting="::true" palette="palette" new-value="newBottomLeftInnerColor"></qr-color-spot>' +
                    '</div>' +
                '</div>' +
            '</div>',
        scope: {
            topLeftShape: '=',
            topLeftInnerColor: '=',
            topLeftOuterColor: '=',
            newTopLeftInnerColor: '=',
            newTopLeftOuterColor: '=',
            topRightShape: '=',
            topRightInnerColor: '=',
            topRightOuterColor: '=',
            newTopRightInnerColor: '=',
            newTopRightOuterColor: '=',
            bottomLeftShape: '=',
            bottomLeftInnerColor: '=',
            bottomLeftOuterColor: '=',
            newBottomLeftInnerColor: '=',
            newBottomLeftOuterColor: '=',
            palette: '=',                // Palette to use with color pickers.
            isContrastRatio: '='         // Is the contrast of two colors sufficient?
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            /**
             * Translations.
             */
            $scope.title = gettextCatalog.getString('Edges');
            $scope.allLabel = gettextCatalog.getString('All');
            $scope.customLabel = gettextCatalog.getString('Custom');
            $scope.shapeLabel = gettextCatalog.getString('Shape');
            $scope.topLeftLabel = gettextCatalog.getString('Top Left');
            $scope.topRightLabel = gettextCatalog.getString('Top Right');
            $scope.bottomLeftLabel = gettextCatalog.getString('Bottom Left');
            $scope.outerColorLabel = gettextCatalog.getString('Outer Color');
            $scope.innerColorLabel = gettextCatalog.getString('Inner Color');
            $scope.learnMoreLabel = gettextCatalog.getString('Learn more');
            $scope.warningHeading = gettextCatalog.getString('QR Code may not be scannable');
            $scope.warningParagraph = gettextCatalog.getString('Some smartphones or apps may have trouble reading your QR Code. We recommend using dark QR Code colors and light background colors.');

            /**
             * Global variables
             */
            $scope.open = false;
            $scope.isMobile = ($window.innerWidth < 768);
            $scope.urlParameter = "&utm_source=app_website&utm_medium=managedview&inappusage=true";
            $scope.designUrl = "https://www.qr-code-generator.com/qr-code-marketing/individual-design-of-qr-codes/?utm_campaign=individual_design";

            /**
             * Returns true, if a, b, c are not equal (at least one of them is different).
             * @param {string} a
             * @param {string} b
             * @param {string} c
             * @returns {boolean}
             */
            function diff3(a, b, c) {
                return a !== b || a !== c || b !== c;
            }

            /**
             * Are custom markers visible? Otherwise all markers have the same style.
             * @type {boolean}
             */
            $scope.customMarkers = diff3($scope.topRightShape, $scope.bottomLeftShape, $scope.topLeftShape) ||
                diff3($scope.topRightInnerColor, $scope.bottomLeftInnerColor, $scope.topLeftInnerColor) ||
                diff3($scope.topRightOuterColor, $scope.bottomLeftOuterColor, $scope.topLeftOuterColor);

            /**
             * Set the margin-top for the warning message to use the animation more correctly.
             */
            $element.find('.message_warning').css({
                marginTop: - $element.find('.message_warning')[0].offsetHeight - 60
            });

            // Sync values in case of custom maskers is not selected.
            $scope.$watch('[topLeftShape, topLeftInnerColor, topLeftOuterColor, customMarkers]', function () {
                if (!$scope.customMarkers) {
                    $scope.topRightShape = $scope.bottomLeftShape = $scope.topLeftShape;
                    $scope.topRightInnerColor = $scope.bottomLeftInnerColor = $scope.topLeftInnerColor;
                    $scope.topRightOuterColor = $scope.bottomLeftOuterColor = $scope.topLeftOuterColor;
                }
            }, true);

            // Sync the palette and the edges colors.
            $scope.$watch('[topLeftInnerColor, topLeftOuterColor, topRightInnerColor, topRightOuterColor, bottomLeftInnerColor, bottomLeftOuterColor]', function (colors) {
                angular.forEach(colors, function (color) {
                    if ($scope.palette.indexOf(color) < 0 && $scope.palette.length < 14) {
                        $scope.palette.push(color);
                    }
                });
            }, true);

            // This is needed to sync temporary values of edge colors as well.
            $scope.$watch('[newTopLeftInnerColor, newTopLeftOuterColor, customMarkers]', function () {
                if (!$scope.customMarkers) {
                    $scope.newTopRightInnerColor = $scope.newBottomLeftInnerColor = $scope.newTopLeftInnerColor;
                    $scope.newTopRightOuterColor = $scope.newBottomLeftOuterColor = $scope.newTopLeftOuterColor;
                }
            }, true);

            $scope.designText = $sce.trustAsHtml(
                markup.convertToString(
                    gettextCatalog.getString(
                        "Some smartphones or apps may have trouble reading your QR Code. We recommend using dark QR Code colors and light background colors.[link={{url}}]Learn more[/link].",
                        {url: $scope.designUrl}
                    ),
                    "message__link"
                )
            );

            $scope.url = "";

            $timeout(function () {
                $('.qr-custom-download__ratio-warning').find('.message__link').on('click', function(event) {
                    event.preventDefault();
                    var clickedLink = $(this).attr("href");
                    $scope.openModal(clickedLink);
                    $scope.$apply();
                });
            }, 0);

            $scope.openModal = function (url) {
                if ($scope.isMobile) {
                    $window.open(url + $scope.urlParameter);
                } else {
                    $scope.url = $sce.trustAsResourceUrl(url + $scope.urlParameter);
                    $scope.open = true;
                }
            };

            $scope.$watch("open", function () {
                if ($scope.open === false) {
                    $scope.url = $sce.trustAsResourceUrl("about:blank");
                }
            });
        }]
    };
}]);
;
/**
 * Tab "Frame" for the new custom download dialog.
 */
app.directive('qrCustomDownloadFrame', ['gettextCatalog', '$timeout', '$window', 'api', 'tracking', function (gettextCatalog, $timeout, $window, api, tracking) {
    'use strict';
    return {
        restrict: 'E',
        template:
            '<div class="qr-custom-download-frame" ng-class="{&apos;qr-custom-download-frame--switch&apos;: isCreateOwnVisible}">' +
                '<div class="qr-custom-download-frame__made" ng-class="{&apos;no-padding&apos; : frameName === &apos;no-frame&apos;}">' +
                    '<select ng-if="false" name="frameFonts" id="frameFonts" ng-options="font.name for font in fonts track by font.id" ng-model="data.selectedFont[0]" ng-change="updateFrameFont(data.selectedFont[0])"></select>' +
                    '<button class="qr-custom-download-frame__edit qr-custom-download-frame__edit_no-icon" type="button" ng-click="customFrames()">' +
                        '{{ ::customFramesLabel }}' +
                    '</button>' +
                    '<label class="qr-custom-download-frame__title qr-custom-download-frame__title--position" ng-bind="::titleMade"></label>' +
                    '<div class="qr-custom-download-frame__frame-container" ng-show="!states.loading">' +
                        '<button type="button" class="qr-custom-download-frame__frame" ng-repeat="frameStyle in ::frameStyles | limitTo: 1 track by $index" ng-class="{&apos;qr-custom-download-frame__frame--active&apos;: frameName === frameStyle.value}" ng-click="clickFrame(frameStyle)">' +
                            '<span ng-class="::frameStyle.icon" ng-show="::frameStyle.icon"></span>' +
                            '{{ ::frameStyle.label }}' +
                        '</button>' +
                        '<qr-image-tile class="qr-custom-download-designs__design" ng-if="states.saving"></qr-image-tile>' +
                        '<qr-image-tile class="qr-custom-download-frame__frame--saved" ng-repeat="frame in allUserFrames track by $index" is-selected="frame.id === accountFrameId" image-url="frame.image_url" fallback-url="getFrameFallbackUrl(frame)" is-editing="false" is-always-visible="true" on-click="changeFrame(frame)" loading-type="skeleton"></qr-image-tile>' +
                    '</div>' +
                    '<div class="qr-custom-download-frame__spinner-container" ng-if="states.loading">' +
                        '<button type="button" class="qr-custom-download-frame__frame" ng-repeat="frames in [].constructor(16) track by $index"></button>' +
                    '</div>' +
                    '<div class="qr-custom-download-frame__frame-container" ng-show="savedFrameStyles.length">' +
                        '<button class="qr-custom-download-frame__edit" type="button" ng-click="states.editing = true" ng-hide="states.editing || states.loading || !savedFrameStyles.length">' +
                            '<span class="icon icon-avatar-edit"></span>' +
                            '{{ ::editLabel }}' +
                        '</button>' +
                        '<button class="qr-custom-download-frame__edit" type="button" ng-click="states.editing = false" ng-show="states.editing && savedFrameStyles.length" ng-bind="::doneLabel"></button>' +
                        '<label class="qr-custom-download-frame__title qr-custom-download-frame__title--position" ng-bind="::titleMyFrames"></label>' +
                        '<div class="qr-custom-download-frame__frame-container" ng-show="!states.loading">' +
                            '<qr-image-tile class="qr-custom-download-designs__design" ng-if="states.saving"></qr-image-tile>' +
                            '<qr-image-tile class="qr-custom-download-frame__frame--saved" ng-repeat="frame in savedFrameStyles track by $index" is-selected="frame.id === accountFrameId" image-url="frame.image_url" fallback-url="getFrameFallbackUrl(frame)" is-editing="states.editing && frame.tags !== &apos;default&apos;" is-always-visible="true" on-click="changeFrame(frame)" on-delete="deleteFrameDesign(frame)"></qr-image-tile>' +
                        '</div>' +
                    '</div>' +
                    '<div class="qr-custom-download-frame__palette-container" ng-show="frameName !== &apos;no-frame&apos;">' +
                        '<div class="qr-custom-download-frame__options">' +
                            '<qr-color-palette class="qr-custom-download-frame__palette" colors="palette" deleting="editing" active="frameColor" max-colors="14" new-color="newFrameColor" read-only-length="1" full-spectrum-position="&apos;.qr-custom-download-frame__palette-container&apos;"></qr-color-palette>' +
                            '<button type="button" class="qr-custom-download-frame__option-text" ng-click="toggleCustomTextVisibility()" data-js="customTextAction" ng-show="showCustomTextOption">' +
                                '<span class="icon icon-text"></span>' +
                            '</button>' +
                        '</div>' +
                        '<div class="qr-custom-download-frame__custom-text-container" ng-show="isCustomTextVisible" data-js="customText">' +
                            '<div class="qr-custom-download-frame__custom-text-input">' +
                                '<input class="qr-custom-download-frame__custom-text-field" data-js="customTextInput" ng-model="frameText" ng-model-options="{updateOn: &apos;default blur&apos;, debounce: {default: 750, blur: 0}}">' +
                            '</div>' +
                            '<div class="qr-custom-download-frame__custom-text-action">' +
                                '<button type="button" class="qr-custom-download-frame__custom-text-button" ng-click="toggleCustomTextVisibility()">' +
                                    '{{ ::customTextButtonLabel }}' +
                                '</button>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="qr-custom-download-frame__own">' +
                    '<div class="qr-custom-download-frame__back-label clearfix">' +
                        '<label class="qr-custom-download-frame__title qr-custom-download-frame__title--back" class="btn-link" ng-click="revertFrameStyles()">' +
                            '<span class="icon icon-qr-insights qr-custom-download-frame__icon-back"></span>' +
                            '{{ ::titleBack }}' +
                        '</label>' +
                    '</div>' +
                    '<label class="qr-custom-download-frame__title" ng-bind="::titleFrame"></label>' +
                    '<div class="qr-custom-download-frame__frame-container">' +
                        '<button type="button" class="qr-custom-download-frame__frame" ng-repeat="frameStyle in ::frameStyles track by $index" ng-class="{&apos;qr-custom-download-frame__frame--active&apos;: frameName === frameStyle.value}" ng-click="clickFrame(frameStyle)">' +
                            '<span ng-class="::frameStyle.icon" ng-show="::frameStyle.icon"></span>' +
                            '{{ ::frameStyle.label }}' +
                        '</button>' +
                    '</div>' +
                    '<div class="clearfix">' +
                        '<button class="qr-custom-download-frame__edit" type="button" ng-click="editing = true" ng-hide="editing">' +
                            '<span class="icon icon-avatar-edit"></span>' +
                            '{{ ::editLabel }}' +
                        '</button>' +
                        '<button class="qr-custom-download-frame__edit" type="button" ng-click="editing = false" ng-show="editing" ng-bind="::doneLabel"></button>' +
                        '<label class="qr-custom-download-frame__subtitle" ng-bind="::colorLabel"></label>' +
                        '<qr-color-palette class="qr-custom-download-frame__palette" colors="palette" deleting="editing" active="frameColor" max-colors="14" new-color="newFrameColor" read-only-length="1"></qr-color-palette>' +
                        '<label class="qr-custom-download-frame__subtitle" ng-bind="::iconsLabel"></label>' +
                        '<button type="button" class="qr-custom-download-frame__icon" ng-repeat="icon in ::icons track by $index" ng-class="{&apos;qr-custom-download-frame__icon--active&apos;: frameIconName === icon.value}" ng-click="clickIcon(icon)">' +
                            '<span ng-class="::icon.class"></span>' +
                        '</button>' +
                        '<button class="qr-custom-download-frame__subtitle qr-custom-download-frame__subtitle--hover" ng-click="openCustomText = !openCustomText" ng-class="{&apos;qr-custom-download-frame__subtitle--open&apos;: openCustomText}" ng-switch="openCustomText">' +
                            '{{ ::addCustomTextLabel }}' +
                            '<span class="icon icon-down-open-mini" ng-switch-default=""></span>' +
                            '<span class="icon icon-up-open-mini" ng-switch-when="true"></span>' +
                        '</button>' +
                        '<input class="qr-custom-download-frame__text" ng-model="frameText" ng-show="openCustomText" ng-model-options="{updateOn: &apos;default blur&apos;, debounce: {default: 750, blur: 0}}">' +
                    '</div>' +
                    // '<span class="qr-custom-download-frame__try" ng-class="{&apos;qr-custom-download-frame__try--visible&apos;: frameName === &apos;no-frame&apos; && canTryFrameBeVisible}" ng-bind="tryFramesLabel"></span>' +
                '</div>' +
            '</div>',
        scope: {
            open: '=',                   // Open state of the modal.
            palette: '=',                // Palette for frame colors.
            accountFrameId: '=',         // Account frame id.
            frameColor: '=',             // Active frame color.
            newFrameColor: '=',          // New frame color that is currently inside the color picker.
            frameName: '=',              // Active frame name/type.
            frameText: '=',              // Frame caption.
            frameTextColor: '=',         // Frame caption color.
            frameTextAlignment: '=',     // Frame caption alignment.
            frameTextFont: '=',          // Frame caption font.
            frameIconName: '=',          // Name of the selected frame icon.
            isVisible: '=',              // Tab visibility flag.
            isCreateOwnVisible: '=',     // Create own frame visibility flag.
            isFrameStoreVisible: '=',    // Frame store visibility flag.
            qrCode: '=',                 // QR code data.
            fullSpectrumPosition: '=',   // Position for the colorPicker component.
            allUserFrames: '=',          // List of all user frames, only premium frames not custom saved.
            savedFrameStyles: '='        // List of all account saved custom frames.
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            /**
             * Translations.
             */
            $scope.titleFrame = gettextCatalog.getString('Frame');
            $scope.titleMade = gettextCatalog.getString('Ready-Made Frames');
            $scope.titleMyFrames = gettextCatalog.getString('My custom frames');
            $scope.titleOwn = gettextCatalog.getString('Frame');
            $scope.titleBack = gettextCatalog.getString('Back');
            $scope.colorLabel = gettextCatalog.getString('Color');
            $scope.iconsLabel = gettextCatalog.getString('Icons');
            $scope.addCustomTextLabel = gettextCatalog.getString('Add custom text');
            $scope.tryFramesLabel = gettextCatalog.getString('Try Frames');
            $scope.editLabel = gettextCatalog.getString('Edit');
            $scope.doneLabel = gettextCatalog.getString('Done');
            $scope.browseFramesLabel = gettextCatalog.getString('Browse Frames');
            $scope.customFramesLabel = gettextCatalog.getString('Custom Frames');
            $scope.orLabel = gettextCatalog.getString('or');
            $scope.customTextButtonLabel = gettextCatalog.getString('OK');

            /**
             * Global variables.
             */
            $scope.customTextInput = angular.element(document).find('[data-js="customTextInput"]');
            $scope.customTextAction = angular.element(document).find('[data-js="customTextAction"]');
            $scope.customText = angular.element(document).find('[data-js="customText"]');


            /**
             * States of the tab.
             * @type {{loading: boolean, editing: boolean, saving: boolean}}
             */
            $scope.states = {
                editing: false,                  // Editing of designs.
                loading: true,                   // Loading designs from the server.
                saving: false                    // The tab is saving a design (it will display a progress element in the list).
            };

            /**
             * Data for controller.
             * @type {{selectedFont: object}}
             */
            $scope.data = {
                singleSelect: null,
                selectedFont: [],
                currentFrameFont: ''
            };

            /**
             * Temporary frame styles, we will use it to return to the previous styles when we return from the section “Create your own”
             * @type {*}
             */
            $scope.tmpFrameStyles = {
                frameName: '',
                frameColor: '',
                frameIconName: '',
                frameText: $scope.frameText,
                frameTextColor: '',
                frameTextAlignment: '',
                frameTextFont: ''
            };

            /**
             * Edit mode for colors.
             * @type {boolean}
             */
            $scope.editing = false;

            $scope.isMobile = false;

            /**
             * Is the custom text section open.
             * @type {boolean}
             */
            $scope.openCustomText = false;
            $scope.isCustomTextVisible = false;

            /**
             * This is activated after a little time after the tab becomes open.
             * @type {boolean}
             */
            $scope.canTryFrameBeVisible = false;

            /**
             * This indicates if the custom text options should be visible to the users.
             * @type {boolean}
             */
            $scope.showCustomTextOption = true;

            /**
             * Frame styles for UI and for the API.
             * @type {*}
             */
            $scope.frameStyles = [
                {
                    label: gettextCatalog.getString('No Frame'),
                    value: 'no-frame'
                },
                {
                    icon: 'icon-qr-frame-2',
                    value: 'bottom-frame'
                },
                {
                    icon: 'icon-qr-frame-1',
                    value: 'bottom-tooltip'
                },
                {
                    icon: 'icon-qr-frame-3',
                    value: 'top-header'
                }
            ];

            /**
             * List of account's frames.
             * @type {*}
             */
            $scope.savedFrameStyles = [];

            /**
             * This flag will be set if styles got changed.
             * @type {boolean}
             */
            $scope.frameAreChanged = false;

            /**
             * This flag will be used to run AB testing to open custom text on frames the first time you click on a frame.
             * @type {boolean}
             */
            $scope.callCustomText = true;

            /**
             * Array of available icons.
             * @type {*}
             */
            $scope.icons = [
                {
                    class: 'icon-not-interested',
                    value: '',
                    text: gettextCatalog.getString('Scan me')
                },
                {
                    class: 'icon-qr-mobile',
                    value: 'mobile',
                    text: gettextCatalog.getString('Scan me')
                },
                {
                    class: 'icon-creation-code-app',
                    value: 'app',
                    text: gettextCatalog.getString('Get the app')
                },
                {
                    class: 'icon-creation-code-url',
                    value: 'url',
                    text: gettextCatalog.getString('Scan me')
                },
                {
                    class: 'icon-creation-code-rating',
                    value: 'rating',
                    text: gettextCatalog.getString('Rate us')
                },
                {
                    class: 'icon-creation-code-facebook',
                    value: 'facebook',
                    text: gettextCatalog.getString('Like us')
                },
                {
                    class: 'icon-creation-code-vcard',
                    value: 'vcard',
                    text: gettextCatalog.getString('My contact')
                },
                {
                    class: 'icon-creation-code-dmp3',
                    value: 'mp3',
                    text: gettextCatalog.getString('Play audio')
                },
                {
                    class: 'icon-manage-code-business-page',
                    value: 'business',
                    text: gettextCatalog.getString('Visit us')
                },
                {
                    class: 'icon-creation-code-gallery',
                    value: 'gallery',
                    text: gettextCatalog.getString('View gallery')
                },
                {
                    class: 'icon-coupon',
                    value: 'coupon',
                    text: gettextCatalog.getString('Get Coupon')
                },
                {
                    class: 'icon-creation-code-feedback',
                    value: 'feedback',
                    text: gettextCatalog.getString('Feedback')
                },
                {
                    class: 'icon-creation-code-social',
                    value: 'social',
                    text: gettextCatalog.getString('Follow us')
                },
                {
                    class: 'icon-creation-code-pdf',
                    value: 'pdf',
                    text: gettextCatalog.getString('View PDF')
                },
                {
                    class: 'icon-creation-code-event',
                    value: 'event',
                    text: gettextCatalog.getString('Save date')
                },
                {
                    class: 'icon-creation-add-video',
                    value: 'video',
                    text: gettextCatalog.getString('Watch video')
                }
            ];

            /**
             * On click handler for frames.
             * @param frameStyle
             */
            $scope.clickFrame = function (frameStyle) {
                $scope.frameName = frameStyle.value;
            };

            /**
             * On click toggle visibility for custom text on frames.
             */
            $scope.toggleCustomTextVisibility = function () {
                $scope.isCustomTextVisible = !$scope.isCustomTextVisible;

                if ($scope.isCustomTextVisible) {
                    $scope.customTextAction.addClass("active");

                    $timeout(function () {
                        $scope.customTextInput.focus();
                    }, 100);
                } else {
                    $scope.customTextAction.removeClass("active");
                }
            };

            /**
             * On click handler for icons.
             * @param icon
             */
            $scope.clickIcon = function (icon) {
                $scope.frameIconName = icon.value;
                $scope.frameText = icon.text;
            };


            /**
             * Changes current QR design.
             * @param item
             */
            $scope.changeFrame = function (item) {
                $scope.accountFrameId = item.id;
                $scope.frameName = item.frame_name || item.name;
                $scope.frameIconName = item.frame_icon_name;

                $scope.frameTextColor = item.frame_text_color;
                $scope.frameTextAlignment = item.frame_text_alignment;
                // TODO: Use this approach when we will have the select font family feature
                // $scope.frameTextFont = $scope.data.selectedFont.length ? $scope.data.selectedFont[0].name : 'noto-sans';

                $scope.frameTextFont = item.frame_text_font;
                $scope.data.currentFrameFont = item.frame_text_font;

                // Determine if we click on a saved design and apply the saved color
                if (!('category_id' in item)) {
                    $scope.frameColor = item.frame_color;
                    $scope.frameStyles.forEach(function(element) {
                        if (element.value === item.frame_name) {
                            $scope.frameText = item.frame_text;
                        }
                    });
                }
            };

            /**
             * If the new frame is a contactless-menue, we have to remove the text option.
             */
            $scope.$watch('frameName', function (newFrameName, oldFrameName) {
                if (newFrameName.includes("contactless-menu")) {
                    $scope.showCustomTextOption = false;
                    $timeout(function () {
                        angular.element(document).find('.qr-custom-download-frame__palette').addClass('hide_after_element');
                        angular.element(document).find('.qr-custom-download__code').addClass('show_box_shadow');
                    }, 500);
                } else {
                    angular.element(document).find('.qr-custom-download-frame__palette').removeClass('hide_after_element');
                    angular.element(document).find('.qr-custom-download__code').removeClass('show_box_shadow');

                    $scope.showCustomTextOption = true;
                }
            });

            /**
             * Get the fallback URL to re-generate the frame image.
             * @param frame
             * @returns {String}
             */
            $scope.getFrameFallbackUrl = function (frame) {
                return api.getUrl('/v1/account/frames/' + frame.id + '/refresh-image');
            };

            /**
             * Deletes frame design from user account.
             * @param item
             */
            $scope.deleteFrameDesign = function (item) {
                if ($scope.states.editing && 'id' in item && item.id > 0) {
                    var index = -1;    // Index variable, set to -1 to start with no index

                    // Go through all saved frames to determine the index of the frame to be deleted.
                    $scope.savedFrameStyles.forEach(function (element, i) {
                        if (element.id === item.id) {
                            index = i;
                        }
                    });

                    // API request to delete frame style from user account
                    api.deleteFrameDesign(item.id, function () {

                        // Delete frame from the list of saved frames
                        $scope.savedFrameStyles.splice(index, 1);

                        // If there are no frames saved after deleting, hide the edit label.
                        if ($scope.savedFrameStyles.length <= 0) {
                            $scope.states.editing = false;    // Set the edit state flag to false
                        }
                    });
                }
            };

            /**
             * Open frame store dialog
             */
            $scope.openFrameStore = function () {
                $scope.isFrameStoreVisible = !$scope.isFrameStoreVisible;    // Toggle frame store visibility flag.

                // Add css class
                angular.element(document).find('.qr-frame-store--hide').removeClass('qr-frame-store--hide');

                // Add event if user opens frame store
                tracking.trackEvent('frameshop_open');
            };

            /**
             * Open create your own section
             */
            $scope.customFrames = function () {
                // Save actual styles to temporary variable
                $scope.tmpFrameStyles.frameName = $scope.frameName;
                $scope.tmpFrameStyles.frameColor = $scope.frameColor;
                $scope.tmpFrameStyles.frameIconName = $scope.frameIconName;
                $scope.tmpFrameStyles.frameText = $scope.frameText;
                $scope.tmpFrameStyles.frameTextColor = $scope.frameTextColor;
                $scope.tmpFrameStyles.frameTextAlignment = $scope.frameTextAlignment;
                $scope.tmpFrameStyles.frameTextFont = $scope.frameTextFont;

                $scope.isCreateOwnVisible = true;

                // Set the default styles for the frame to create your own
                $scope.frameName = $scope.frameStyles[1].value;
                $scope.frameColor = '#000000';
                $scope.frameTextColor = '#FFFFFF';
                $scope.frameIconName = $scope.icons[1].value;
                $scope.frameText = $scope.icons[1].text;

                $timeout(function () {
                    angular.element(document).find('[data-button="savePremiumDesign"]').removeClass('hiddenAbsolute');
                    angular.element(document).find('[data-button="toggleDownload"]').addClass('hiddenAbsolute');
                    angular.element(document).find('.action-bar_download').addClass('hiddenAbsolute');
                }, 300);

                // Add event if user opens create own frame
                tracking.trackEvent('frameshop_custom_open');
            };

            $scope.revertFrameStyles = function () {
                $scope.frameName = $scope.tmpFrameStyles.frameName;
                $scope.frameColor = $scope.tmpFrameStyles.frameColor;
                $scope.frameIconName = $scope.tmpFrameStyles.frameIconName;
                $scope.frameText = $scope.tmpFrameStyles.frameText;
                $scope.frameTextColor = $scope.tmpFrameStyles.frameTextColor;

                $scope.isCreateOwnVisible = false;

                $timeout(function () {
                    angular.element(document).find('[data-button="savePremiumDesign"]').addClass('hiddenAbsolute');
                    angular.element(document).find('[data-button="toggleDownload"]').removeClass('hiddenAbsolute');
                    angular.element(document).find('.action-bar_download').removeClass('hiddenAbsolute');
                }, 300);
            };

            // Set frame text based on the icon, if frame text is null.
            if ($scope.frameText === null && $scope.frameIconName !== null) {
                angular.forEach($scope.icons, function (icon) {
                    if (icon.value === $scope.frameIconName) {
                        $scope.frameText = icon.text;
                    }
                });
            }

            $scope.defaultPremiumFrames = [];
            $scope.premiumFrames = [];
            $scope.industryFrames = [];

            // When openCustomText is change, we need to scroll the tab.
            $scope.$watch('openCustomText', function () {
                $timeout(function () {
                    var leftColumn = $element.closest('.qr-custom-download__left')[0];
                    if ("scrollTo" in leftColumn) {
                        leftColumn.scrollTo(0, 10000 * $scope.openCustomText);
                    }
                    $timeout(function () {
                        $(leftColumn).perfectScrollbar('update');
                    });
                });
            });

            $scope.$watch('open', function (newOpen, oldOpen) {
                if (!newOpen && oldOpen && $scope.isCreateOwnVisible) {
                    $scope.revertFrameStyles();
                }
            });

            // When frameName is "no-frame", we should to scroll to the top as the tab is almost empty.
            $scope.$watch('frameName', function (newFrameName, oldFrameName) {

                if ($scope.frameName !== 'no-frame') {
                    return;
                } else {
                    $scope.accountFrameId = 0;
                }

                $timeout(function () {
                    var leftColumn = $element.closest('.qr-custom-download__left')[0];
                    if ("scrollTo" in leftColumn) {
                        leftColumn.scrollTo(0, 0);
                    }
                    $timeout(function () {
                        $(leftColumn).perfectScrollbar('update');

                    });
                });
            });

            // "Try Frame" appears after 1.5 seconds a
            $scope.$watch('isVisible', function () {
                $scope.canTryFrameBeVisible = false;
                if ($scope.isVisible) {
                    $timeout(function () {
                        $scope.canTryFrameBeVisible = true;
                    }, 1500);
                }
            });

            $scope.allUserFrames = [];

            $scope.industryId = 0;
            api.getAccount('', function (response) {
                $scope.industryId = response.data.industry_id;
            });

            // Load frames only when the tab becomes visible.
            $scope.$watch('isVisible', function () {
                // Determine if the body is on AB testing for open custom text.
                var isCustomTextTest = document.body.classList.contains('ab-testing__open-custom-text');

                // Even if the frames tab is invisible, we should load the frame when current QR code has no default frame.
                // In this case, the default frame will be received from the server.
                if (($scope.isVisible || !$scope.frameName) && $scope.states.loading) {
                    api.getPremiumFrames($scope.qrCode.type_id, 'default',  function (response) {
                        $scope.defaultPremiumFrames = (response.data || []).filter(function(frame) {
                            return frame.category_id === 1;
                        });
                        $scope.allUserFrames = $scope.defaultPremiumFrames;
                        if (!$scope.frameName && !$scope.industryId) {
                            // Set default frame, if needed, as the first frame in the default list.
                            if (document.body.classList.contains('ab__premium-frame')) {
                                $scope.clickFrame($scope.frameStyles[1]);
                            } else {
                                $scope.changeFrame($scope.defaultPremiumFrames[0]);
                            }
                        }
                    });

                    api.getAccountFrames(function (response) {
                        $scope.savedFrameStyles = response.data.items || [];
                        $scope.allUserFrames = $scope.defaultPremiumFrames;

                        Object.keys(response.data.items).forEach(function(key) {
                            if (response.data.items[key].frame_name === $scope.frameName) {
                                $scope.frameText = response.data.items[key].frame_text;
                            }
                        });
                    });

                    $timeout(function () {
                        api.getPremiumFrames(0,'',function (response) {
                            $scope.premiumFrames = (response.data || []).filter(function(frame) {
                                if (frame.id === $scope.accountFrameId) {
                                    $scope.data.currentFrameFont = frame.frame_text_font;
                                }

                                return frame.category_id >= 2;
                            });

                            // If user have an industry_id, we put the industry frames to the top.
                            if ($scope.industryId) {
                                api.getPremiumFrames(0, 'for_industry', function (response) {
                                    $scope.industryFrames = (response.data || []).filter(function(frame) {
                                        return frame.industry_id === $scope.industryId;
                                    });

                                    // If there is not frame selected and we got frames for industry, select these only as default. If not, select a premium frame.
                                    if (!$scope.frameName) {
                                        if ($scope.industryFrames.length > 0) {
                                            $scope.changeFrame($scope.industryFrames[0]);
                                        } else {
                                            $scope.changeFrame($scope.defaultPremiumFrames[0]);
                                        }
                                    }

                                    $scope.allUserFrames = $scope.industryFrames.concat($scope.defaultPremiumFrames.concat($scope.premiumFrames));
                                })
                            } else {
                                $scope.allUserFrames = $scope.defaultPremiumFrames.concat($scope.premiumFrames);
                            }

                            $scope.states.loading = false;
                        });
                    }, 250);
                }

                if ($scope.isVisible) {
                    angular.element(document).find('[data-button="preview"]').addClass('qr-custom-download__button--preview-frame');
                    $scope.isMobile = $window.innerWidth > 790;

                    // Open custom text on frame component.
                    if ($scope.callCustomText && isCustomTextTest) {
                        $scope.isCustomTextVisible = true;
                        $scope.callCustomText = false;
                    }
                } else {
                    angular.element(document).find('[data-button="preview"]').removeClass('qr-custom-download__button--preview-frame');
                }
            });

            $scope.$on('add_frame', function (event, savedFrame) {
                // $scope.allUserFrames.push(savedFrame);
                $scope.savedFrameStyles.push(savedFrame);
            });

            angular.element($window).bind('resize', function () {
                $scope.isMobile = $window.innerWidth > 790;

                angular.element(document).find('[data-download-left]').addClass('remove_transition');
                angular.element(document).find('[data-download-right]').addClass('remove_transition');

                $timeout(function () {
                    angular.element(document).find('[data-download-left]').removeClass('remove_transition');
                    angular.element(document).find('[data-download-right]').removeClass('remove_transition');
                });
            });

            /**
             * Determine when we click outside the custom text on the frame container.
             * Also detect clicking on the icon text component.
             */
            angular.element(document).mousedown(function (e) {
                if (!$scope.customTextAction.is(e.target) && !$scope.customText.is(e.target) && !$scope.customTextInput.is(e.target) && e.target.parentElement.dataset.js !== 'customTextAction') {
                    $scope.isCustomTextVisible = false;
                    $scope.customTextAction.removeClass("active");
                }
            });

            /**
             * Determine when we press "Enter" key.
             * If we press "Enter", we need to hide the custom text component.
             */
            $scope.customTextInput.keyup(function (event) {
                // Unicode value of the "Enter" keyboard key === 13
                if(event.keyCode === 13) {
                    $timeout(function () {
                        $scope.isCustomTextVisible = false;    // Hide the custom text component
                        $scope.customTextAction.removeClass("active");    // Remove the active state of a text component button
                    });
                }
            });

            /**
             * When the user makes any changes to the font selection component, we send the
             * font name to the API to render a new preview using the selected font family.
             * @param {object} item
             */
            $scope.updateFrameFont = function (item) {
                $scope.frameTextFont = item.name;
            };
        }]
    };
}]);
;
/**
 * Tab "Logo" for the new custom download dialog.
 */
app.directive('qrCustomDownloadLogo', ['gettextCatalog', 'api', '$timeout', 'Upload', 'aws', function (gettextCatalog, api, $timeout, Upload, aws) {
    'use strict';
    return {
        restrict: 'E',
        template:
            '<div class="qr-custom-download-logo">' +
                '<button class="qr-custom-download-logo__edit" type="button" ng-click="editing = true" ng-hide="editing">' +
                    '<span class="icon icon-avatar-edit"></span>' +
                    '{{ ::editLabel }}' +
                '</button>' +
                '<button class="qr-custom-download-logo__edit" type="button" ng-click="editing = false" ng-show="editing" ng-bind="::doneLabel"></button>' +
                '<label class="qr-custom-download-logo__title" ng-bind="::title"></label>' +
                '<button type="button" class="qr-custom-download-logo__logo qr-custom-download-logo__logo--nologo" ng-class="{&apos;qr-custom-download-logo__logo--active&apos;: !logoName || logoName === &apos;no-logo&apos;}" ng-click="clickLogo({id: 0, value: &apos;no-logo&apos;})">' +
                    '<span class="icon icon-nologo"></span>' +
                    '{{ ::noLogoLabel }}' +
                '</button>' +
                '<span class="qr-custom-download-logo__logo-container" ng-show="loadingLogos">' +
                    '<qr-spinner class="qr-custom-download-logo__spinner" loading="loadingLogos"></qr-spinner>' +
                '</span>' +
                '<qr-image-tile class="qr-custom-download-logo__tile" ng-repeat="logo in logos | filter:{isSystem: true}" image-url="::logo.url" is-selected="logoName === logo.value || logoId === logo.id" on-click="clickLogo(logo)"></qr-image-tile>' +
                '<label class="qr-custom-download-logo__subtitle" ng-bind="::myLogosLabel"></label>' +
                '<input type="file" class="qr-custom-download-logo__input-upload" name="file" id="file" accept="image/png,image/jpeg">' +
                '<label for="file" class="qr-custom-download-logo__upload">' +
                    '<span class="icon icon-qr-upload"></span>' +
                    '{{ ::uploadLabel }}' +
                '</label>' +
                '<span class="qr-custom-download-logo__logo-container" ng-show="loadingLogos">' +
                    '<qr-spinner class="qr-custom-download-logo__spinner" loading="loadingLogos"></qr-spinner>' +
                '</span>' +
                '<qr-image-tile class="qr-custom-download-logo__tile" ng-repeat="logo in logos | filter:{isSystem: false}" image-url="::logo.url" is-editing="editing" delete-selected="true" is-selected="logoName === logo.value || logoId === logo.id" on-click="clickLogo(logo)" on-delete="deleteLogo(logo)"></qr-image-tile>' +
            '</div>',
        scope: {
            logoName: '=',      // Name of selected logo, if any.
            logoId: '=',        // ID of selected logo, if any.
            qrCodeTypeId: '=',  // ID of QR type (for logo search).
            isVisible: '='      // Tab visibility flag.
        },
        link: function (scope, element) {
            /**
             * Sets focus on the specified logo button.
             */
            scope.setFocusOnLogo = function (logoId) {
                $timeout(function () {
                    element.find('[data-logo-id=' + logoId + ']').focus();
                });
            };

            // Start uploading when user selects files.
            element.find('[name=file]').on('change', function () {
                if ('files' in this && this.files.length > 0) {
                    scope.uploadFile(this.files[0]);
                    this.value = "";
                }
            });
        },
        controller: ['$scope', function ($scope) {
            /**
             * Translations.
             */
            $scope.title = gettextCatalog.getString('Logo');
            $scope.editLabel = gettextCatalog.getString('Edit');
            $scope.doneLabel = gettextCatalog.getString('Done');
            $scope.myLogosLabel = gettextCatalog.getString('My Logos');
            $scope.uploadLabel = gettextCatalog.getString('Upload');
            $scope.noLogoLabel = gettextCatalog.getString('No Logo');

            /**
             * Edit mode for user logos.
             * @type {boolean}
             */
            $scope.editing = false;

            /**
             * True if we're loading logos.
             * @type {boolean}
             */
            $scope.loadingLogos = false;

            /**
             * Array of logo images.
             * @type {*}
             */
            $scope.logos = [];

            /**
             * Flag that logos need to be loaded.
             * @type {boolean}
             */
            $scope.logosAreLoaded = false;

            /**
             * Add a logo to the list (user's or system logo).
             * @param {Number} logoId
             * @param {String} logoPath
             * @param {String} logoUrl
             * @param {Boolean} isSystem
             * @param {Number} [pos] optional position to insert
             */
            $scope.addLogo = function (logoId, logoPath, logoUrl, isSystem, pos) {
                var logo = {
                    id: logoId,
                    url: logoUrl,
                    value: logoPath,
                    isSystem: !!isSystem
                };
                if (typeof pos === 'undefined') {
                    $scope.logos.push(logo);
                } else {
                    $scope.logos.splice(pos, 0, logo);
                }
            };

            /**
             * On click handler for logos.
             * @param logo
             */
            $scope.clickLogo = function (logo) {
                $scope.logoName = logo.value;
                $scope.logoId = logo.id;
            };

            /**
             * Deletes one user's logo from the array.
             * @param logo
             * @param {number} index
             */
            $scope.deleteLogo = function (logo) {
                if (logo.isSystem) {
                    return;
                }


                var index = -1;    // Index variable, set to -1 to start with no index

                // Go through all saved frames to determine the index of the frame to be deleted.
                $scope.logos.forEach(function (element, i) {
                    if (element.id === logo.id) {
                        index = i;
                    }
                });
                api.deleteLogo(logo.id, function () {
                    $scope.logos.splice(index, 1);
                    if (logo.value === $scope.logoName || logo.id === $scope.logoId) {
                        $scope.logoId = 0;
                        $scope.logoName = 'no-logo';
                    }
                });
            };

            /**
             * Upload one file from user/browser to AWS.
             * @param file
             */
            $scope.uploadFile = function (file) {
                api.createLogo(function (response) {
                    var reader = new FileReader(), data = {};
                    reader.onload = function () {
                        angular.forEach(aws.getCredentials().inputs, function (value, key) {
                            data[key] = value;
                        });
                        data.varname = 'logo';
                        data.filename = file.name;
                        data.key = response.data.logo_path;
                        data.file = Upload.dataUrltoBlob(reader.result);
                        Upload.upload({
                            url: aws.getCredentials().url,
                            data: data
                        }).then(function (result) {
                            // Success.
                            // console.log('success', result);
                            $scope.addLogo(response.data.id, response.data.logo_path, response.data.logo_url, false, 0);
                            $scope.logoName = response.data.logo_path;
                            $scope.logoId = response.data.id;
                            $scope.setFocusOnLogo(response.data.id);
                        }, function (result) {
                            // Error.
                            // console.log('error', result);
                        }, function (event) {
                            // Progress.
                            // console.log('event', event);
                        });
                    };
                    reader.readAsDataURL(file);
                });
            };

            /**
             * Reload logos from the server.
             */
            $scope.reloadLogos = function () {
                $scope.loadingLogos = true;
                api.getLogos($scope.qrCodeTypeId, function (response) {
                    $scope.logos = [];
                    angular.forEach(response.data.items || [], function (logo) {
                        $scope.addLogo(logo.id, logo.logo_path, logo.logo_url, logo.is_system || false);
                    });
                    $scope.loadingLogos = false;
                }, function () {
                    $scope.loadingLogos = false;
                });
            };

            // Load logos only when the tab becomes visible.
            $scope.$watch('isVisible', function () {
                if ($scope.isVisible && !$scope.logosAreLoaded) {
                    $scope.logosAreLoaded = true;
                    $timeout(function () {
                        $scope.reloadLogos();
                    });
                }
            });
        }]
    };
}]);
;
/**
 * Tab "URL" for the new custom download dialog.
 */
app.directive('qrCustomDownloadUrl', ['gettextCatalog', 'api', 'account', '$rootScope', 'tracking', function (gettextCatalog, api, account, $rootScope, tracking) {
    'use strict';
    return {
        restrict: 'E',
        template:
            '<div class="qr-custom-download-url">' +
                '<label class="qr-custom-download-url__title" ng-bind="::title"></label>' +
                '<qr-short-url short-url="shortUrl" is-editing="isEditing" short-code="shortCode" errors="errors" validation="true" short-domain="domain"></qr-short-url>' +
                '<div class="qr-custom-download-url__help">' +
                    '<button class="qr-custom-download-url__subtitle" ng-click="showText(1)" ng-class="{&apos;qr-custom-download-url__subtitle--open&apos;: visibleText === 1}" ng-switch="visibleText === 1">' +
                        '{{ ::help1Label }}&#65279;' + // &#65279; works as a zero-width non-breaking space.
                        '<span class="icon icon-down-open-mini" ng-switch-default></span>' +
                        '<span class="icon icon-up-open-mini" ng-switch-when="true"></span>' +
                    '</button>' +
                    '<p ng-bind="::help1Text" ng-show="visibleText === 1"></p>' +
                    '<button class="qr-custom-download-url__subtitle" ng-click="showText(2)" ng-class="{&apos;qr-custom-download-url__subtitle--open&apos;: visibleText === 2}" ng-switch="visibleText === 2">' +
                        '{{ ::help2Label }}&#65279;' + // &#65279; works as a zero-width non-breaking space.
                        '<span class="icon icon-down-open-mini" ng-switch-default></span>' +
                        '<span class="icon icon-up-open-mini" ng-switch-when="true"></span>' +
                    '</button>' +
                    '<p ng-bind="::help2Text" ng-show="visibleText === 2"></p>' +
                    '<p ng-bind="::help21Text" ng-show="visibleText === 2"></p>' +
                    '<p ng-show="visibleText === 2" style="margin-bottom: 0;">http://l.ead.me/<strong>your-company-name</strong></p>' +
                    '<p ng-show="visibleText === 2">http://l.ead.me/<strong>your-campaign-name</strong></p>' +
                '</div>' +
                '<div class="qr-custom-download-url__layer" ng-class="{&apos;qr-custom-download-url__layer--open&apos;: showMessage}"></div>' +
                '<div class="qr-custom-download-url__message" ng-class="{&apos;qr-custom-download-url__message--open&apos;: showMessage}">' +
                    '<h3 ng-bind="::messageTitle"></h3>' +
                    '<p ng-bind="::messageText"></p>' +
                    '<button type="button" class="qr-custom-download-url__message-button" ng-bind="::gotItLabel" ng-click="showMessage = false"></button>' +
                    '<button type="button" class="qr-custom-download-url__message-cancel" ng-bind="::cancelLabel" ng-click="isEditing = false"></button>' +
                '</div>' +
            '</div>',
        scope: {
            qrCode: '=' // QR code data.
        },
        link: function (scope, element) {
            // Move the layer and the message box to the parent element in order to fix overflow-related problems.
            var layer = element.find('.qr-custom-download-url__layer').detach(),
                message = element.find('.qr-custom-download-url__message').detach();

            element.parent().parent()
                .append(layer)
                .append(message);

            // And don't forget to remove detached elements after this component is destroyed.
            scope.$on('$destroy', function () {
                layer.remove();
                message.remove();
            });
        },
        controller: ['$scope', function ($scope) {
            /**
             * Translations.
             */
            $scope.title = gettextCatalog.getString('Short URL');
            $scope.help1Label = gettextCatalog.getString("What's a Short URL?");
            $scope.help1Text = gettextCatalog.getString(
                'The short URL redirects your customers to the website or target page you have stored in the QR Code. ' +
                'This means that your QR Code has to encrypt fewer characters and is easily scanned. ' +
                'Furthermore, the short URL enables you to edit the information stored in your QR Code at any time ' +
                'even after it has been printed, and also allows you to view scan statistics.'
            );
            $scope.help2Label = gettextCatalog.getString('Why and how should I customize my short URL?');
            $scope.help2Text = gettextCatalog.getString(
                'We recommend that you customize the short URLs of your QR Code, for example by entering your company name ' +
                'or drawing a connection to your campaign. This creates a closer link to your brand ' +
                'and builds trust among suspicious users.'
            );
            $scope.help21Text = gettextCatalog.getString('Try to keep your URL short, e.g.:');
            $scope.messageTitle = gettextCatalog.getString('Important note');
            $scope.messageText = gettextCatalog.getString(
                'Changes to the short URL of an already published QR Code will ' +
                'cause the previous version of the QR Code to be overwritten and ' +
                'it will no longer be scannable.'
            );
            $scope.gotItLabel = gettextCatalog.getString('Got it');
            $scope.cancelLabel = gettextCatalog.getString('Cancel');

            /**
             * Index of the FAQ text to display.
             * @type {number}
             */
            $scope.visibleText = 0;

            /**
             * Displays the message about already printed QR codes in a pop-up layer.
             * @type {boolean}
             */
            $scope.showMessage = false;

            /**
             * Open the specified FAQ text.
             * @param textIndex
             */
            $scope.showText = function (textIndex) {
                $scope.visibleText = $scope.visibleText !== textIndex ? textIndex : 0;
            };

            // Process changing of the short code by the component "qr-short-url".
            $scope.$watch('[shortCode, domain]', function (newData, oldData) {

                // Because we are watching the two parameters shortCode and domain as a result, the function will have
                // an array and we need to declare the first element of the array for shortCode and oldShortCode
                var domainId = 0,
                    shortCode = newData[0],
                    oldShortCode = oldData[0];

                // We pass through the list of user domains and if the domain we have chosen coincides with one of the
                // list, then we transfer the id of the same domain
                account.getAccount().domains.forEach(function (domain) {
                    if (domain.url === $scope.domain) {
                        domainId = domain.id;
                    }
                });

                if (shortCode && oldShortCode && (shortCode !== '' + oldShortCode || newData[1] !== '' + oldData[1])) {
                    api.updateShortCodeAndDomain($scope.qrCode.id, '' + shortCode, domainId, function (response) {
                        // console.log('Response from updateShortCode', response);
                        angular.extend($scope.qrCode, response.data);
                        angular.extend(account.getCodesByIds([$scope.qrCode.id])[0], response.data);
                        $scope.isEditing = false;
                        tracking.trackEvent('done_change_shorturl');
                    }, function (response) {
                        // console.log('Error response from updateShortCode', response);
                        if ('errors' in response.data) {
                            $scope.errors.code = response.data.errors[0].message;
                        } else {
                            $scope.errors.code = gettextCatalog.getString('Error while updating the short code');
                        }
                    });
                } else if (!shortCode && oldShortCode) {
                    // Restore the short code if it's empty.
                    $scope.shortCode = '';
                    $scope.shortUrl = $scope.qrCode.short_url;
                    $scope.isEditing = false;
                }
            }, true);

            // Sync short URL from QR code with local variable.
            $scope.$watch('qrCode.short_url', function (shortUrl) {
                $scope.shortUrl = shortUrl;
            });

            // When the short URL is in edit mode, close all FAQ section.
            $scope.$watch('isEditing', function (isEditing) {
                if (isEditing) {
                    $scope.visibleText = 0;
                    $scope.showMessage = !$scope.errors.code;
                } else {
                    $scope.showMessage = false;
                }
            });
        }]
    };
}]);
;
/**
 * A modal for Premium Frames Store
 */
app.directive('qrFrameStore', ['gettextCatalog', 'api', 'account', '$timeout', '$rootScope', 'tracking', function (gettextCatalog, api, account, $timeout, $rootScope, tracking) {
    "use strict";
    return {
        restrict: 'E',
        template:
            '<qr-modal class="qr-frame-store" open="open" data-title="{{ ::modalTitle }}" title-label="{{ ::titleLabel }}" description="{{ ::modalDescription }}" close-icon="true" ng-class="{&apos;testing&apos;: closeFrameStore}" min-width="1080px" left-offset="-540px">' +
                '<div class="qr-frame-store__container">' +
                    '<div class="qr-frame-store__list">' +
                        '<div class="qr-frame-store__list-wrapper">' +
                            '<qr-image-tile class="qr-frame-store__frame" ng-repeat="item in premiumFrames" is-selected="item.name === image.frameName" image-url="item.image_url" is-always-visible="true" on-click="setPreview(item)"></qr-image-tile>' +
                        '</div>' +
                    '</div>' +
                    '<div class="qr-frame-store__preview" ng-class="{&apos;qr-frame-store__preview--dark-mode&apos;: isDarkMode}">' +
                        '<qr-image-tile class="qr-frame-store__preview-frame" ng-if="open && premiumFrames.length > 0" image-url="image.url" is-always-visible="true"></qr-image-tile>' +
                        '<div class="qr-frame-store__color-container">' +
                            '<label class="qr-custom-download-frame__subtitle" ng-bind="::colorLabel"></label>' +
                            '<qr-color-palette class="qr-frame-store__palette" colors="palette" deleting="editing" active="image.frameColor" max-colors="14" new-color="image.newFrameColor" read-only-length="1"></qr-color-palette>' +
                        '</div>' +
                        '<button type="button" ng-click="chooseFrame()" class="qr-custom-download__button qr-frame-store__choose-frame" data-ng-disabled="isPremiumFrameSaving">' +
                            '<img class="qr-custom-download__spinner-image" src="/img/spinner-white.svg" ng-show="isPremiumFrameSaving" alt="">' +
                            '{{ ::chooseFrameLabel }}' +
                        '</button>' +
                    '</div>' +
                '</div>' +
            '</qr-modal>',
        scope: {
            open: '=',      // Open state of the modal.
            palette: '=',   // Palette for frame colors.
            accountFrameId: '=',
            frameColor: '=',
            frameName: '=',
            qrCode: '='
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            /**
             * Translations.
             */
            $scope.colorLabel = gettextCatalog.getString('Color');
            $scope.chooseFrameLabel = gettextCatalog.getString('Choose Frame');
            $scope.modalTitle = gettextCatalog.getString('Add a Frame to your QR Code');
            $scope.titleLabel = gettextCatalog.getString('New');
            $scope.modalDescription = gettextCatalog.getString('QR Code Frames are useful little helpers that bring more attention and scans to your QR Codes and give them a truly unique design. Simply pick your favorite, set your colors and download the whole thing in the next step.');

            /**
             * This indicates if the Frame is saving or not.
             * @type {boolean}
             */
            $scope.isPremiumFrameSaving = false;

            /**
             * List of account's frames.
             * @type {*}
             */
            $scope.premiumFrames = [];

            $scope.activeFrame = {};

            $scope.isDarkMode = false;

            $scope.image = {
                id: '',
                url: '',
                frameColor: $scope.frameColor,
                frameName: '',
                newFrameColor: ''
            };

            $scope.setPreview = function (item) {
                if ($scope.activeFrame.id !== item.id) {
                    $scope.image.frameName = item.name;
                }

                $scope.activeFrame = item;
            };

            $scope.chooseFrame = function () {
                $scope.isPremiumFrameSaving = true;

                tracking.trackEvent('frameshop_choose_frame');

                var selectedPremiumFrameStyles = {
                    frame_id: $scope.activeFrame.id,
                    frame_color: $scope.image.frameColor
                };

                api.saveFrameDesign(selectedPremiumFrameStyles, function (response) {
                    $scope.open = false;

                    $rootScope.$broadcast('add_frame', response.data);

                    $scope.accountFrameId = response.data.id;
                    $scope.frameColor = response.data.frame_color;
                    $scope.frameName = response.data.frame_name;

                    $scope.isPremiumFrameSaving = false;
                }, function () {
                    console.log('Error saving frame');
                });
            };

            // This is a timer used to accumulate some changes before API call.
            var timer = false;

            $scope.$watch('[image.frameColor, image.frameName, image.newFrameColor, open]', function () {
                if (timer) {
                    $timeout.cancel(timer);
                    timer = false;
                }
                if ($scope.open) {

                    $scope.isDarkMode = ($scope.image.newFrameColor || $scope.image.frameColor) === '#ffffff';

                    timer = $timeout(function () {
                        $scope.image.url = api.getFrameDownloadUrl({
                            qr_code_id: $scope.qrCode.id,
                            frame_color: $scope.image.newFrameColor || $scope.image.frameColor,
                            frame_name: $scope.image.frameName,
                            image_format: 'PNG',
                            image_width: 350
                        }) + '&rnd=' + (new Date().getTime()); // Random param is needed to always refresh the image.
                    }, 300);
                }
            }, true);

            $scope.$watch('frameColor', function () {
                $scope.image.frameColor = $scope.frameColor;
            });

            // Watch on the open state and define the old and new modal windows
            $scope.$watch('open', function (newOpen, oldOpen) {
                // If the open status is old, it means that we closed the modal window of the store and returned to downloading
                if (oldOpen) {
                    // Add class to custom download window
                    angular.element('body').find('.qr-custom-download').addClass('qr-custom-download--after-store');

                    // Remove class from custom download window after 600ms
                    $timeout(function () {
                        angular.element('body').find('.qr-custom-download').removeClass('qr-custom-download--after-store');
                    }, 600);
                } else {
                    // Add class to popup modal to use reverse animation when closing store modal window
                    $timeout(function () {
                        angular.element('body').find('.qr-popup--modal').addClass('qr-popup--block');
                    }, 300);
                }

                if (newOpen && $scope.premiumFrames.length === 0) {
                    api.getPremiumFrames(0,'',function (response) {

                        $scope.premiumFrames = (response.data || []).filter(function(frame) {
                            return frame.category_id >= 2;
                        });

                        $scope.image.frameName = $scope.premiumFrames[0].name;

                        $scope.activeFrame = $scope.premiumFrames[0];
                    });
                }
            });

            // Install perfect scrollbar for the list section.
            $timeout(function () {
                $($element.find('.qr-frame-store__list')[0]).perfectScrollbar({
                    suppressScrollX: true
                });
            });
        }]
    };
}]);
;
app.directive('qrAccountLocked', ['$window', 'gettextCatalog', function ($window, gettextCatalog) {
    return {
        restrict: 'E',
        template:
        '<div class="qr-account-locked">' +
            '<div class="alert alert-message alert-message-expired fade in">' +
                '<div class="qr-account-locked__content">' +
                    '<div class="cody">' +
                        '<img ng-src="{{open && cdnUrl+\'/img/_login/Cody_Concerned.svg\' || \'\'}}"/>' +
                    '</div>' +
                    '<div class="qr-account-locked__content--text">' +
                        '<h2 ng-bind="::titleLabel"></h2>' +
                        '<p>' +
                            '{{ ::text1Label }}<br>{{ ::text2Label }}' +
                        '</p>' +
                    '</div>' +
                    '<div class="qr-account-locked__content--buy-link">' +
                        '<a href="/billing/?showPaymentDialog=true" class="btn btn-lg btn-primary optimizly_clicktracking">' +
                            '{{ ::linkLabel }}' +
                            '<i class="icon icon-chevron-right-medium"></i>' +
                        '</a>' +
                    '</div>' +
                '</div>' +
            '</div>' +
        '</div>',
        scope: {
        },
        controller: ['$scope', function ($scope) {
            /**
             * Some translations.
             */
            $scope.titleLabel = gettextCatalog.getString('There is an open invoice');
            $scope.text1Label = gettextCatalog.getString('Your account has been locked due to an outstanding invoice.');
            $scope.text2Label = gettextCatalog.getString('Reactivate your account by updating your credit card information.');
            $scope.linkLabel = gettextCatalog.getString('Pay now by credit card');

            $scope.cdnUrl = $window.CDN_URL;
        }]
    };
}]);
;
/**
 * A modal for activating QR codes.
 */
app.directive('qrActivateCodeModal', ['api', 'gettextCatalog', 'account', '$sce', '$log', function (api, gettextCatalog, account, $sce, $log) {
    return {
        restrict: 'E',
        template:
            '<qr-limit-reached-modal open="openLimitReachedModal" limit="limitReachedCount"></qr-limit-reached-modal>' +
            '<qr-modal open="open" data-title="{{ getTitle() }}" buttons="::buttons" test-event="activate-code-modal">' +
                '<div class="qr-activate-code-modal__content" ng-bind-html="::message"></div>' +
            '</qr-modal>',
        scope: {
            open: '=',      // Open state of the modal.
            qrCode: '=',    // QR code data.
            codes: '='      // Array of QR codes IDs, if working with several codes at the same time.
        },
        controller: ['$scope', function ($scope) {
            /**
             * Translations
             */
            $scope.message = $sce.trustAsHtml(gettextCatalog.getString(
                'Activating QR Codes will move it under {{icon}} Active.', {
                    icon: '<span class="icon icon-active"></span>'
                })
            );

            /**
             * @returns {String}
             */
            $scope.getTitle = function () {
                if ($scope.qrCode || !$scope.codes) {
                    return gettextCatalog.getString('Activate QR Code');
                }
                return gettextCatalog.getPlural(
                    $scope.codes.length,
                    'Activate 1 QR Code',
                    'Activate {{$count}} QR Codes',
                    {}
                );
            };

            /**
             * @type {boolean}
             */
            $scope.openLimitReachedModal = false;

            /**
             * Limit for qrLimitReachedModal.
             * @type {number}
             */
            $scope.limitReachedCount = 0;

            /**
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Activate'),
                    testEvent: 'activate-code-modal-activate-btn',
                    callback: function () {
                        $scope.open = false;
                        if ($scope.qrCode) {
                            api.updateCodeStatus($scope.qrCode.id, 'active', function () {
                                $scope.qrCode.status = 'active';
                                account.reloadAccountWithoutFolders();
                                account.recheckCodesVisibility(true);
                            }, function (data) {
                                $scope.processActivationErrorResponse(data);
                            });
                        } else {
                            api.massActivateCodes($scope.codes, function () {
                                angular.forEach(account.getCodesByIds($scope.codes), function (qrCode) {
                                    qrCode.status = 'active';
                                });
                                account.reloadAccountWithoutFolders();
                                account.recheckCodesVisibility(true);
                            }, function (data) {
                                $scope.processActivationErrorResponse(data);
                            });
                        }
                    }
                },
                {
                    label: gettextCatalog.getString('Cancel'),
                    testEvent: 'activate-code-modal-cancel-btn',
                    type: 'link',
                    callback: function () {
                        $scope.open = false;
                    }
                }
            ];

            /**
             * Activation callback for API.
             * @param {*} data
             */
            $scope.processActivationErrorResponse = function (data) {
                $log.debug(data);
                if (data.status === 422 && data.data.errors[0].field === 'status') {
                    var message = '' + data.data.errors[0].message;
                    $scope.limitReachedCount = 0;
                    if (message.match(/[0-9]+/)) {
                        $scope.limitReachedCount = message.match(/([0-9]+)/)[1];
                    }
                    $scope.openLimitReachedModal = true;
                }
            };
        }]
    };
}]);
;
app.directive('qrCreditcardExpired', ['gettextCatalog', 'markup', function (gettextCatalog, markup) {
    return {
        restrict: 'E',
        template:
        '<div class="qr-creditcard-expired">' +
            '<div class="qr-creditcard-expired__container">' +
                '<i class="qr-creditcard-expired__icon icon icon-event-about"></i> ' +
                '<h6 class="qr-creditcard-expired__title" ng-bind="getTitle()"></h6>' +
                '<p class="qr-creditcard-expired__message" ng-bind-html="::messageLabel"></p>' +
            '</div>' +
        '</div>',
        scope: {
            paymentInfo: '='
        },
        controller: ['$scope', function ($scope) {
            /**
             * Translations.
             */
            $scope.messageLabel = markup.convertToHTML(
                gettextCatalog.getString(
                    'To update your credit card information, [link={{url}}]click here[/link]', {
                    url: '/creditcard/update/?expiremessage=1'
                }),
                'qr-creditcard-expired__link'
            );

            /**
             * @returns {string}
             */
            $scope.getTitle = function () {
                return gettextCatalog.getString('Your credit card expires on {{expireMonth}} 01, {{expireYear}}', {
                    expireMonth: $scope.expireMonth,
                    expireYear: $scope.expireYear
                });
            };

            var month = [
                gettextCatalog.getString("January"),
                gettextCatalog.getString("February"),
                gettextCatalog.getString("March"),
                gettextCatalog.getString("April"),
                gettextCatalog.getString("May"),
                gettextCatalog.getString("June"),
                gettextCatalog.getString("July"),
                gettextCatalog.getString("August"),
                gettextCatalog.getString("September"),
                gettextCatalog.getString("October"),
                gettextCatalog.getString("November"),
                gettextCatalog.getString("December")
            ];

            $scope.$watch('paymentInfo', function() {
                if ($scope.paymentInfo) {
                    var expireDate = new Date(
                        $scope.paymentInfo.creditcard_valid_till_year,
                        $scope.paymentInfo.creditcard_valid_till_month-1
                    );
                    $scope.expireMonth = month[expireDate.getMonth()];
                    $scope.expireYear = expireDate.getFullYear();
                }
            });
        }]
    };
}]);
;
/**
 * The modal for moving QR codes to folders.
 */
app.directive('qrExpiredModal', ['$window', 'gettextCatalog', '$sce', 'tracking', function ($window, gettextCatalog, $sce, tracking) {
    return {
        restrict: 'E',
        template:
        '<qr-modal open="open" close-icon="true">' +
            '<div class="qr-expire-modal__content" ng-show="messageVersion == 1">' +
                '<div class="cody">' +
                    '<img ng-src="{{open && cdnUrl+\'/img/_login/Cody_Concerned.svg\' || \'\'}}"/>' +
                '</div>' +
                '<div class="qr-expire-modal__content__text">' +
                    '<h2 ng-bind="::messageTitle"></h2>' +
                    '<p ng-bind-html="::messageText"></p>' +
                '</div>' +
                '<div class="qr-expire-modal__content__button--upgrade">' +
                    '<a href="/upgrade/?from=afterTrialPopup" class="btn btn-lg btn-primary optimizly_clicktracking">' +
                        '{{ ::buttonText }}' +
                        '<i class="icon icon-chevron-right-medium"></i>' +
                    '</a>' +
                '</div>' +
            '</div>' +
            '<div class="qr-expire-modal-v2__content" ng-show="messageVersion == 2">' +
                '<div class="cody cody-mobile">' +
                    '<img ng-src="{{open && cdnUrl+\'/img/generator/cody/CodyE_Down.svg\' || \'\'}}"/>' +
                '</div>' +
                '<div class="qr-expire-modal-v2__content__text">' +
                    '<h2 ng-bind="::messageTitleV2"></h2>' +
                    '<p ng-bind="::messageTextV2"></p>' +
                '</div>' +
                 '<div class="cody">' +
                     '<img ng-src="{{open && cdnUrl+\'/img/generator/cody/CodyE_PointingRight.svg\' || \'\'}}" />' +
                 '</div>' +
                '<div class="qr-expire-modal-v2__content__features-list">' +
                    '<ul ng-repeat="feature in ::featuresText">' +
                        '<li><i class="icon icon-check-circle"></i>{{ feature }}</li>' +
                    '</ul>' +
                '</div>' +
                '<div class="qr-expire-modal-v2__content__button--upgrade">' +
                    '<a href="/upgrade/?from=afterTrialPopup" class="btn btn-lg btn-primary optimizly_clicktracking">' +
                        '{{ ::buttonText }}' +
                        '<i class="icon icon-chevron-right-medium"></i>' +
                    '</a>' +
                '</div>' +
            '</div>' +
        '</qr-modal>',
        scope: {
             open: '=',           // Optional open state of the menu.
             messageVersion: '='  // Version of message which will be shown (1 - default)
        },
        controller: ['$scope', function ($scope) {
            $scope.messageVersion = 2;

            $scope.cdnUrl = $window.CDN_URL;

            $scope.messageTitle = gettextCatalog.getString("Your account requires an update");
            $scope.messageText = $sce.trustAsHtml(
                gettextCatalog.getString('The 14-day trial period of QR Code Generator Pro is over.<br>' +
                    'To continue, please upgrade your account to one of our plans.')
            );

            $scope.messageTitleV2 = gettextCatalog.getString("Your 14-day Trial is over");
            $scope.messageTextV2 = gettextCatalog.getString("To continue, please upgrade your account to one of our plans.");

            $scope.featuresText = [
                gettextCatalog.getString("Reactivate all your expired QR Codes"),
                gettextCatalog.getString("Choose between 20+ QR Code Types"),
                gettextCatalog.getString("Create customizable mobile pages"),
                gettextCatalog.getString("Measure your campaign success")
            ];

            $scope.buttonText = gettextCatalog.getString("Upgrade");

            // Track opening of the expired window.
            $scope.$watch('open', function () {
                if ($scope.open) {
                    tracking.trackEvent('saw_expired_screen');
                }
            });
        }]
    };
}]);
;
/** @var $data PayoneInvoice */
app.directive('qrViewBlocked', ['$window','gettextCatalog', '$sce','account', 'tracking', function ($window, gettextCatalog, $sce, account, tracking) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" close-icon="true">' +
                '<div class="qr-expire-modal-v2__content">' +
                    '<div class="qr-expire-modal-v2__content__text">' +
                        '<h2 ng-bind="::messageTitle"></h2>' +
                        '<p ng-bind="::messageText"></p>' +
                    '</div>' +
                    '<div class="qr-expire-modal-v2__content__button--overdue">' +
                        '<a href="/creditcard/payinvoice?invoice_txid={{urlAccountTxId}}" class="btn btn-lg btn-primary optimizly_clicktracking">' +
                            '{{ ::buttonText }}' +
                            '<i class="icon icon-chevron-right-medium"></i>' +
                        '</a>' +
                    '</div>' +
                '</div>' +
            '</qr-modal>',
        scope: {
            open: '=',           // Optional open state of the menu.
            messageVersion: '='  // Version of message which will be shown (1 - default)
        },
        controller: ['$scope', function ($scope) {
            $scope.cdnUrl = $window.CDN_URL;
            /**
             * Translation
             */
            $scope.messageTitle = gettextCatalog.getString("You have an outstanding invoice");
            $scope.messageText = $sce.trustAsHtml(
                gettextCatalog.getString('Due to a missing payment, we have temporarily locked your account. ' +
                    'All your QR Codes are currently deactivated. Please pay the outstanding invoice to regain access to your QR Codes and features.')
            );
            $scope.buttonText = gettextCatalog.getString("Pay invoice");
            $scope.urlAccountTxId = account.getAccountTxId();
            // Track opening of the expired window.
            $scope.$watch('open', function () {
                if ($scope.open) {
                    tracking.trackEvent('saw_expired_screen');
                }
            });
        }]
    };
}]);
;
/**
 * This modal appears when user has reached the max number of active QR codes.
 */
app.directive('qrLimitReachedModal', ['$window', 'gettextCatalog', 'tracking', function ($window, gettextCatalog, tracking) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" close-icon="true">' +
                '<div class="qr-limit-reached-modal__content" data-test="limit-reached-modal">' +
                    '<img class="qr-limit-reached-modal__image" ng-src="{{open && cdnUrl+\'/img/_login/Cody_Concerned.svg\' || \'\'}}">' +
                    '<h1 class="qr-limit-reached-modal__title" ng-bind="::title"></h1>' +
                    '<p class="qr-limit-reached-modal__message" ng-bind="getMessage()"></p>' +
                    '<a href="/upgrade/?from=afterLimitReachedPopup" class="qr-limit-reached-modal__button optimizly_clicktracking">' +
                        '{{ ::upgradeLabel }}' +
                        '<i class="icon icon-chevron-right-medium"></i>' +
                    '</a>' +
                '</div>' +
            '</qr-modal>',
        scope: {
            open: '=',      // Optional open state of the modal.
            limit: '='      // Optional limit.
        },
        controller: ['$scope', function ($scope) {
            // Translations.
            $scope.title = gettextCatalog.getString('Active QR Codes limit reached');
            $scope.upgradeLabel = gettextCatalog.getString('Upgrade');
            $scope.cdnUrl = $window.CDN_URL;

            /**
             * @returns {String}
             */
            $scope.getMessage = function () {
                return gettextCatalog.getString('You have reached the maximum number of {{count}} active Dynamic QR Codes available in your plans. To create more, pause QR Codes or upgrade your account to a higher plan.', {
                    count: $scope.limit || ''
                });
            };

            // Track opening of the window.
            $scope.$watch('open', function () {
                if ($scope.open) {
                    tracking.trackEvent('saw_limit_reached_screen');
                }
            });
        }]
    };
}]);
;
/**
 * This modal appears when free plan user wants to activate a QR Code with a type that is restricted for their plan
 * (free plan can only activate dynamic website code)
 *
 * Currently only copy for free plan available!
 *
 * Uses same styles as qrLimitReachedModal.js
 */
app.directive('qrTypeRestrictedModal', ['$window', 'gettextCatalog', 'tracking', function ($window, gettextCatalog, tracking) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" close-icon="true">' +
                '<div class="qr-limit-reached-modal__content" data-test="type-restriction-modal">' +
                    '<img class="qr-limit-reached-modal__image" ng-src="{{open && cdnUrl+\'/img/_login/Cody_Concerned.svg\' || \'\'}}">' +
                    '<h1 class="qr-limit-reached-modal__title" ng-bind="::title"></h1>' +
                    '<p class="qr-limit-reached-modal__message" ng-bind="::message"></p>' +
                    '<a href="/upgrade/?from=afterCodetypeRestrictionPopup" class="qr-limit-reached-modal__button optimizly_clicktracking">' +
                        '{{ ::upgradeLabel }}' +
                        '<i class="icon icon-chevron-right-medium"></i>' +
                    '</a>' +
                '</div>' +
            '</qr-modal>',
        scope: {
            open: '=',
        },
        controller: ['$scope', function ($scope) {
            $scope.title = gettextCatalog.getString('The selected QR Code Type is not available on your current plan');
            $scope.message = gettextCatalog.getString('As a Free Plan user, you may only have one Dynamic Website QR Code active. Any other Dynamic QR Code created during your free trial period cannot be reactivated with your current plan. You can activate all QR Code types by upgrading your plan.');
            $scope.upgradeLabel = gettextCatalog.getString('Upgrade now');
            $scope.cdnUrl = $window.CDN_URL;

            // Track opening of the modal
            $scope.$watch('open', function () {
                if ($scope.open) {
                    tracking.trackEvent('saw_qrcode_type_restricted_screen');
                }
            });
        }]
    };
}]);
;
/**
 * A modal for deleting QR codes.
 */
app.directive('qrDeleteCodeModal', ['api', 'gettextCatalog', 'account', function (api, gettextCatalog, account) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" data-title="{{ getTitle() }}" buttons="::buttons">' +
                '<div class="qr-delete-code-modal__content" ng-bind="::message"></div>' +
            '</qr-modal>',
        scope: {
            open: '=',      // Open state of the modal.
            qrCode: '=',    // QR code data.
            codes: '='      // Array of QR codes IDs, if working with several codes at the same time.
        },
        controller: ['$scope', function ($scope) {
            /**
             * Translations
             */
            $scope.message = gettextCatalog.getString('Deleting QR Codes is permanent and cannot be undone. All data related to it will be erased.');

            /**
             * @returns {String}
             */
            $scope.getTitle = function () {
                if ($scope.qrCode || !$scope.codes) {
                    return gettextCatalog.getString('Delete QR Code');
                }
                return gettextCatalog.getPlural(
                    $scope.codes.length,
                    'Delete 1 QR Code',
                    'Delete {{$count}} QR Codes',
                    {}
                );
            };

            /**
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Delete'),
                    type: 'danger',
                    callback: function () {
                        $scope.open = false;
                        if ($scope.qrCode) {
                            api.deleteCode($scope.qrCode.id, function () {
                                account.reloadAccountWithoutFolders();
                                account.reloadCodes();
                            });
                        } else {
                            api.massDeleteCodes($scope.codes, function () {
                                account.reloadAccountWithoutFolders();
                                account.reloadCodes();
                            });
                        }
                    }
                },
                {
                    label: gettextCatalog.getString('Cancel'),
                    type: 'link',
                    callback: function () {
                        $scope.open = false;
                    }
                }
            ];
        }]
    };
}]);
;
/**
 * Button "Create QR Code".
 */
app.directive('qrCreateCodeButton', ['gettextCatalog', 'account', function (gettextCatalog, account) {
    return {
        restrict: 'E',
        template:
            '<qr-paused-modal open="open.paused" ng-if="open.paused"></qr-paused-modal>' +
            '<qr-expired-modal open="open.expire" ng-if="open.expire"></qr-expired-modal>' +
            '<qr-view-blocked open="open.blockedInvoice" ng-if="open.blockedInvoice"></qr-view-blocked>' +
            '<a ng-if="!isAbTestEnabled_CNV2467()" class="qr-create-code-button" ng-href="{{ link }}" ng-click="checkAccount()" data-test="create-button">' +
                '<span class="qr-create-code-button__icon icon icon-plus-1"></span>' +
                '{{ getLabel() }}' +
            '</a>' +
            '<a ng-if="isAbTestEnabled_CNV2467()" style="background:#cccccc; cursor:not-allowed;" class="qr-create-code-button" ng-href="{{ link }}" ng-click="" data-test="create-button">' +
                '<span class="qr-create-code-button__icon icon icon-plus-1"></span>' +
                '{{ getLabel() }}' +
            '</a>',
        scope: {
            isAdmin: '='
        },
        controller: ['$scope', function ($scope) {
            /**
             * Returns label for the button.
             * @returns {string}
             */
            $scope.getLabel = function () {
                return gettextCatalog.getString('Create QR Code');
            };

            $scope.link = "";

            /**
             * Open states of the modals.
             * @type {{expire: boolean}}
             */
            $scope.open = {
                paused: false,
                expire: false,
                blockedInvoice: false,
            };

            $scope.checkAccount = function () {
                if (account.getAccountStatus() === 'paused' && !$scope.isAdmin) {
                    $scope.open.paused = true;
                } else if (account.getAccountStatus() === 'expired' && !$scope.isAdmin) {
                    $scope.open.expire = true;
                } else if (account.getAccountPaymentOverdue() === 1 && !$scope.isAdmin) {
                    $scope.open.blockedInvoice = true;
                }
                else {
                    $scope.link = "/create";
                }
            };

             $scope.isAbTestEnabled_CNV2467 = function() {
                return window.qr.utils.optimizely.isAbTestVariantActive('23988530195', '24017330211');
            };
        }]
    };
}]);
;
/**
 * The modal for moving QR codes to folders.
 */
app.directive('qrMoveToFolderModal', ['api', 'gettextCatalog', 'markup', 'account', function (api, gettextCatalog, markup, account) {
    return {
        restrict: 'E',
        template:
            '<qr-modal data-title="{{ ::titleLabel }}" open="open" buttons="getButtons()" test-event="move-to-folder-modal">' +
                '<div class="qr-move-to-folder-modal__content">' +
                    '<p class="qr-move-to-folder-modal__text" ng-bind="::selectMessage"></p>' +
                    '<qr-dropdown-folders has-no-folder="true" value="selectedFolder.id" default-value="0" field-readonly="true" placeholder="{{::inputPlaceholder}}..."></qr-dropdown-folders>' +
                '</div>' +
            '</qr-modal>',
        scope: {
            open: '=',      // Optional open state of the modal.
            qrCode: '=',    // QR code data.
            codes: '=',     // Array of QR codes IDs, if moving several codes at the same time.
            isAdmin: '='    // Show info about user if admin is logged in.
        },
        controller: ['$scope', function ($scope) {
            /**
             * Some translations for this directive.
             */
            $scope.selectMessage = gettextCatalog.getString('Select the folder you would like to move your QR Code to:');
            $scope.titleLabel = gettextCatalog.getString('Move QR Code');
            $scope.inputPlaceholder = gettextCatalog.getString('Choose folder');

            // This message requires special processing to replace some HTML inside.
            $scope.emptyMessage = markup.convertToHTML(gettextCatalog.getString(
                'You have not created any folders yet. To create your first, {{newLine}} click on {{beginItem}} New Folder {{endItem}} in the menu on the left.', {
                    beginItem: '<span class="qr-move-to-folder-modal__item"><span class="icon icon-plus-1"></span>',
                    endItem: '</span>',
                    newLine: '<br>'
                }));

            /**
             * ID of the selected folder.
             * @type {*}
             */
            $scope.selectedFolder = {id: 0};

            /**
             * Array of user's folders.
             * @type {Array}
             */
            $scope.folders = [];

            /**
             * Array of buttons for the move modal.
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Move'),
                    testEvent: 'move-to-folder-modal-approve',
                    callback: function () {
                        var needToReload = $scope.selectedFolder.id !== $scope.getCurrentFolderId() && account.getFilters().folderId > 0;
                        if ($scope.selectedFolder.id < 0) { // Probably it's not needed anymore.
                            return;
                        }
                        if ($scope.qrCode) {
                            api.updateCodeFolder($scope.qrCode.id, $scope.selectedFolder.id, function (response) {
                                angular.extend($scope.qrCode, response.data);
                                $scope.open = false;
                                if (needToReload) {
                                    account.reloadAccountWithoutFolders();
                                    account.reloadCodes();
                                }
                            });
                        } else {
                            api.massMoveCodes($scope.codes, $scope.selectedFolder.id, function () {
                                $scope.open = false;
                                // if (needToReload) { this check doesn't work now as it expects that the codes are updated.
                                account.reloadAccountWithoutFolders();
                                account.reloadCodes();
                                // }
                            });
                        }
                    }
                },
                {
                    label: gettextCatalog.getString('Cancel'),
                    type: 'link',
                    testEvent: 'move-to-folder-modal-cancel',
                    callback: function () {
                        $scope.open = false;
                    }
                }
            ];

            /**
             * This array of buttons is used if there's no folders.
             * @type {*[]}
             */
            $scope.buttonsForNoFolders = [
                {
                    label: gettextCatalog.getString('Got it'),
                    callback: function () {
                        $scope.open = false;
                    }
                }
            ];

            /**
             * Returns actual array of buttons for the modal.
             * @returns {Array}
             */
            $scope.getButtons = function () {
                return $scope.buttons;
            };

            /**
             * Get actual current folder ID.
             * It returns folder_id of QR code, if one code.
             * Or it tries to find common folder ID for several codes.
             * @returns {Number} folderID or -1 if there is no common ID.
             */
            $scope.getCurrentFolderId = function () {
                if ($scope.qrCode) {
                    return $scope.qrCode.folder_id;
                }
                var folders = {};
                angular.forEach(account.getCodesByIds($scope.codes), function (code) {
                    folders[code.folder_id] = true;
                });
                return Object.keys(folders).length === 1 ? Object.keys(folders)[0] : -1;
            };

            // Sync folder ID when opening.
            $scope.$watch('open', function () {
                if ($scope.open) {
                    $scope.selectedFolder.id = $scope.getCurrentFolderId();
                    if ($scope.selectedFolder.id <= 1) { // ID 1 is the same as 0. And we should migrate all to 0.
                        $scope.selectedFolder.id = 0;
                    }
                }
            });
        }]
    };
}]);
;
/**
 * Top navigation panel for the content area of the new manage view.
 */
app.directive('qrManageBar', ['gettextCatalog', 'account', '$location', function (gettextCatalog, account, $location) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-manage-bar" ng-switch="totalSelected">' +
                '<div class="qr-manage-bar__folder" ng-switch-when="0">' +
                    '<span class="qr-manage-bar__folder-icon" ng-class="getFolderIconClass()"></span>' +
                    '<span class="qr-manage-bar__folder-name" ng-bind="getFolderName()"></span>' +
                    '<div class="qr-manage-bar__dynamic-count">' +
                        '<span class="qr-manage-bar__count" ng-class="{ &apos;qr-manage-bar__count--normal&apos; : !isUserTrial() }" ng-show="getCountString()" ng-bind="getCountString()" data-test="manage-qrcode-list-counter"></span>' +
                        '<a class="qr-manage-bar__allocation-link" ng-if="showNeedMoreLink()" ng-href="{{ getUpgradeUrl() }}" target="_blank">' +
                            '{{ ::allocationLinkLabel }}' +
                        '</a>' +
                    '</div>' +
                '</div>' +
                '<div class="qr-manage-bar__select" ng-switch-default>' +
                    '<span class="qr-manage-bar__select-count" ng-show="totalSelected > 0" ng-bind="getTotalSelected()"></span>' +
                    '<qr-manage-mass-selection selected-codes="selectedCodes"></qr-manage-mass-selection>' +
                '</div>' +
                '<div ng-show="searchQuery" class="qr-manage-bar__search">' +
                    '/ {{ ::searchPhrase }} <span class="qr-manage-bar__search-query" ng-bind="searchQuery"></span>' +
                '</div>' +
                '<qr-choice-button class="qr-manage-bar__filter" items="::filterItems" value="filter" ng-show="isFilterVisible()"></qr-choice-button>' +
                '<qr-create-code-button class="qr-manage-bar__button" ng-click="" is-admin="isAdmin"></qr-create-code-button>' +
                '<qr-choice-button ng-hide="searchQuery" class="qr-manage-bar__sort" items="::sortItems" right="true" value="sort"></qr-choice-button>' +
                '<qr-multidropdown filter-items="::filterItems" sort-items="::sortItems" show-filter="isFilterVisible()" filter="filter" sort="sort"></qr-multidropdown>' +
            '</div>',
        scope: {
            isAdmin: '=',             // Admin mode.
            totalSelected: '=',       // Amount of selected codes.
            selectedCodes: '=',       // Array of selected codes (IDs).
            searchQuery: '=',
        },
        controller: ['$scope', function ($scope) {

            $scope.upgradeLink = '';
            $scope.searchPhrase = gettextCatalog.getString('Search results for');
            $scope.allocationLinkLabel = gettextCatalog.getString('Need more?');

            /**
             * Current sorting mode.
             * @type {{value: string}}
             */
            $scope.sort = {
                value: account.getSorting().codes
            };

            /**
             * Current filtering mode (by status, for QR codes).
             * @type {{value: string}}
             */
            $scope.filter = {
                value: account.getFilters().status
            };

            /**
             * Items for the sort menu.
             * @type {Array}
             */
            $scope.sortItems = [
                {
                    label: gettextCatalog.getString('Last Created'),
                    value: '-created' // "-" means DESC sorting.
                },
                {
                    label: gettextCatalog.getString('Name'),
                    value: 'title'
                },
                {
                    label: gettextCatalog.getString('Most Scanned'),
                    value: '-total_scans'
                }
            ];

            /**
             * Items for the filter menu.
             * @type {Array}
             */
            $scope.filterItems = [
                {
                    label: gettextCatalog.getString('All QR Codes'),
                    value: 'all',
                    testEvent: 'manage-qrcode-list-filter-all'
                },
                {
                    label: gettextCatalog.getString('Active QR Codes'),
                    value: 'active',
                    testEvent: 'manage-qrcode-list-filter-active'
                },
                {
                    label: gettextCatalog.getString('Paused QR Codes'),
                    value: 'paused',
                    testEvent: 'manage-qrcode-list-filter-paused'
                }
            ];

            /**
             * Returns a folder icon, if any, or the default one.
             * @returns {String}
             */
            $scope.getFolderIconClass = function () {
                var activeFolderId = account.getCurrentFolderId();
                if (activeFolderId === 0) {
                    return 'icon icon-qr-all';
                }
                if (activeFolderId === -1) {
                    return 'icon icon-active';
                }
                if (activeFolderId === -2) {
                    return 'icon icon-qr-paused';
                }
                if (activeFolderId === -3) {
                    return 'icon icon-qr-expired';
                }
                return 'icon icon-qr-folder';
            };

            /**
             * @returns {boolean}
             */
            $scope.isFilterVisible = function () {
                return account.getCurrentFolderId() > 0 && !$scope.searchQuery;
            };

            /**
             * Get name of current folder.
             * @returns {String}
             */
            $scope.getFolderName = function () {
                var activeFolderId = account.getCurrentFolderId();
                if (activeFolderId === 0) {
                    return gettextCatalog.getString('All QR Codes');
                }
                if (activeFolderId === -1) {
                    return gettextCatalog.getString('Active QR Codes');
                }
                if (activeFolderId === -2) {
                    return gettextCatalog.getString('Paused QR Codes');
                }
                if (activeFolderId === -3) {
                    return gettextCatalog.getString('Expired QR Codes');
                }
                return account.findFolderById(account.getCurrentFolderId()).name;
            };

            /**
             * @returns {string}
             */
            $scope.getCountString = function () {
                var activeFolderId = account.getCurrentFolderId();
                if (account.isLoadingCodes()) {
                    return "";
                }
                if (account.getPagination().totalCount < 0) {
                    return "";
                }
                if (account.isTrial()) {
                    return "(" + account.getPagination().totalCount + ")";
                }
                if (account.getAccount().qrcodes && activeFolderId === -1) {
                    return "(" + account.getAccount().qrcodes.current + "/" + account.getAccount().qrcodes.allowed + " " + gettextCatalog.getString("Dynamic codes") + ")";
                }
            };

            /**
             * Show need more link
             * @returns {boolean}
             */
            $scope.showNeedMoreLink = function (){
                var activeFolderId = account.getCurrentFolderId();
                if (account.getAccount().qrcodes && activeFolderId === -1) {
                    switch (true) {
                        // Check if the account is loading
                        case (account.isLoadingCodes()):
                            break;
                        // Check if user is in trial version
                        case (account.isTrial()):
                            return false;
                        // Check if we have reached the limit for the starter plan
                        case ((account.getAccount().qrcodes.current === account.getAccount().qrcodes.allowed) && !account.isTrial()):
                            return true;
                        // Calculate if we have reached 90% of the current allowed dynamic QR Codes
                        case ((account.getAccount().qrcodes.allowed - account.getAccount().qrcodes.current <= 10/100 * account.getAccount().qrcodes.allowed) && !account.isTrial()):
                            return true;
                        default:
                            return false;
                    }
                }
            }

            /**
             * Returns URL of the upgrade link.
             * @returns {string}
             */
            $scope.getUpgradeUrl = function () {
                return account.getAccount().qrcodes.allowed <= 50 ? '/upgrade/?from=allocation-counter' : 'https://form.asana.com/?k=0FszAJp6r2L5vtEiSrj9Ag&d=1174264937396';
            };

            $scope.getTotalSelected = function () {
                return $scope.totalSelected + " " + gettextCatalog.getString("Selected");
            };

            $scope.isUserTrial = function () {
                return account.isTrial();
            }

            // Sync sorting mode with account.
            $scope.$watch('sort.value', function () {
                if (account.getSorting().codes !== $scope.sort.value) {
                    $location.url(account.getCurrentUrl({
                        sort: $scope.sort.value
                    }).substr(2));
                }
            });

            // Sync status filtering with account.
            $scope.$watch('filter.value', function () {
                if (account.getFilters().status !== $scope.filter.value) {
                    $location.url(account.getCurrentUrl({
                        status: $scope.filter.value
                    }).substr(2));
                }
            });
        }]
    };
}]);
;
/**
 * QR code information block for new manage view.
 */
app.directive('qrManageCode', ['$timeout', '$window', '$rootScope', 'qrTypeService', 'api', 'gettextCatalog', 'account', function ($timeout, $window, $rootScope, qrTypeService, api, gettextCatalog, account) {
    return {
        restrict: "E",
        template:
            '<qr-paused-modal open="open.paused" ng-if="open.paused"></qr-paused-modal>' +
            '<qr-expired-modal open="open.expire" ng-if="open.expire"></qr-expired-modal>' +
            '<qr-view-blocked open="open.blockedInvoice" ng-if="open.blockedInvoice"></qr-view-blocked>' +
            '<qr-demo-modal open="open.demo" ng-if="open.demo"></qr-demo-modal>' +

            //We need this empty ng-click due to iOS issues.
            //In order to ng-blur correctly work in iOS devices
            //it's necessarily that clicked item had event handler.
            //Even empty.
            '<div class="qr-manage-code" ng-click="" ng-class="getCodeClass()" data-test="manage-qrcode-list-item">' +
            '<span class="checkboxes-container qr-manage-code__checkbox" ng-class="getCheckboxClass()">' +
            '<input ng-checked="selected" type="checkbox">' +
            '<label class="qr-manage-code__checkbox-label"><input type="checkbox" ng-click="select()" data-test="manage-qrcode-list-item-select"></label>' +
            "</span>" +
            '<div class="qr-manage-code--row-first">' +
            '<div ng-if="isTrialUserWithDynamicCodes()">' +
            '<qr-trial-expires-modal ng-if="isFeatureToggleExpiredModal() || isAbTestEnabled_CNV2467()" class="qr-manage-code__countdown"></qr-trial-expires-modal>' +
            "</div>" +
            '<div class="qr-manage-code__type" ng-bind="::qrCodeTypeNames[value.type_id]" data-test="manage-qrcode-list-item-type"></div>' +
            '<span class="qr-manage-code__type-icon icon" ng-class="getTypeIcon()"></span>' +
            '<div ng-switch="titleEditing">' +
            '<div class="qr-manage-code__title" ng-click="startTitleEdit()" ng-class="getTitleClass()" ng-switch-default ng-bind="getVisibleTitle()" data-test="manage-qrcode-list-item-title"></div>' +
            '<input autofocus class="qr-manage-code__title-input" placeholder="{{ ::titlePlaceholder }}" ng-model="value.title" ng-switch-when="true" ng-blur="stopTitleEdit($event)" ng-keyup="stopTitleEdit($event)" ng-if="!isDemo" data-test="manage-qrcode-list-item-title-input">' +
            "</div>" +
            '<div class="qr-manage-code--row-first--col-left">' +
            '<span class="qr-manage-code__folder-icon icon icon-qr-folder-outline"></span>' +
            '<div class="qr-manage-code__folder">' +
            '<span ng-if="!isAbTestEnabled_CNV2467()" class="qr-manage-code__folder-name" ng-click="openFolderModal()" ng-bind="getFolderName()" data-test="manage-qrcode-list-item-folder"></span>' +
            '<span ng-if="isAbTestEnabled_CNV2467()" style="cursor:not-allowed; opacity: 0.5" class="qr-manage-code__folder-name" ng-click="" ng-bind="getFolderName()" data-test="manage-qrcode-list-item-folder"></span>' +
            "</div>" +
            '<div class="qr-manage-code__date">' +
            '<span class="qr-manage-code__date-icon icon icon-business-time"></span>' +
            "{{ getCreated() }}" +
            "</div>" +
            "</div>" +
            '<div class="qr-manage-code__stats qr-manage-code--visible-mobile">' +
            '<div class="qr-manage-code__scans" ng-bind="getTotalScans()"></div>' +
            '<div class="qr-manage-code__scans-label" ng-bind="::scansLabel"></div>' +
            '<a ng-href="{{ ::getInsightsUrl() }}" class="qr-manage-code__insights" ng-click="openInsights($event)">' +
            "{{ ::insightsLabel }}" +
            '<span class="qr-manage-code__insights-icon icon icon-qr-insights"></span>' +
            "</a>" +
            "</div>" +
            '<div class="qr-manage-code--row-first--col-right">' +
            '<div class="qr-manage-code__url" ng-show="::(getUrl() || !value.trackable)">' +
            '<span class="qr-manage-code__url-icon icon icon-qr-link" ng-show="::getUrl()"></span>' +
            '<div class="qr-manage-code__url-container">' +
            '<a class="qr-manage-code__url-link" ng-href="{{ getShortUrl() }}" target="_blank" ng-show="::getUrl()" ng-bind="getUrl()" data-test="manage-qrcode-list-item-shorturl"></a>' +
            '<i ng-if="!isAbTestEnabled_CNV2467()" class="qr-manage-code__edit-icon icon icon-avatar-edit" ng-show="::getUrl()" ng-click="openShortUrlEdit()" data-toggle="tooltip" data-placement="bottom" title="{{ editShortUrl }}"></i>' +
            '<i ng-if="isAbTestEnabled_CNV2467()" style="cursor:not-allowed; opacity: 0.5" class="qr-manage-code__edit-icon icon icon-avatar-edit" ng-show="::getUrl()" ng-click="" data-toggle="tooltip" data-placement="bottom" title="{{ editShortUrl }}"></i>' +
            "</div>" +
            '<span class="qr-manage-code__static" ng-hide="::value.trackable" ng-bind="::staticLabel"></span>' +
            '<div class="qr-manage-code__target" ng-show="getTarget()" ng-if="!isDemo">' +
            '<span class="qr-manage-code__target-icon icon icon-qr-link-arrow" ng-show="::value.trackable"></span>' +
            '<a ng-href="{{ ::value.target_url }}" target="_blank" data-test="manage-qrcode-list-item-url">{{ getTarget() }}<span ng-bind="getSecondTargetPart()"></span></a>' +
            "</div>" +
            "</div>" +
            "</div>" +
            "</div>" +
            '<div class="qr-manage-code--row-second">' +
            '<div class="qr-manage-code--row-second--col-left">' +
            '<div class="">' +
            "</div>" +
            '<div class="qr-manage-code__stats" ng-show="::value.trackable">' +
            '<div class="qr-manage-code__scans" ng-bind="getTotalScans()"></div>' +
            '<div class="qr-manage-code__scans-label" ng-bind="::scansLabel"></div>' +
            '<a ng-if="!isAbTestEnabled_CNV2467()"  ng-href="{{ ::getInsightsUrl() }}" class="qr-manage-code__insights" ng-click="openInsights($event)" data-test="manage-qrcode-list-item-open-insights">' +
            "{{ ::insightsLabel }}" +
            '<span class="qr-manage-code__insights-icon icon icon-qr-insights"></span>' +
            "</a>" +
            '<a ng-if="isAbTestEnabled_CNV2467()" style="cursor:not-allowed; opacity: 0.5" class="qr-manage-code__insights disabled" ng-click="trackInsightsButtonClick()" data-test="manage-qrcode-list-item-open-insights">' +
            "{{ ::insightsLabel }}" +
            '<span class="qr-manage-code__insights-icon icon icon-qr-insights"></span>' +
            "</a>" +
            "</div>" +
            '<qr-code-image class="qr-manage-code__qr" url="value.image_url" code-id="value.id">' +
            "</div>" +
            '<div class="qr-manage-code--row-second--col-right">' +
            '<qr-manage-download class="qr-manage-code__download" value="value" is-admin="isAdmin" open="open.download" is-demo="isDemo"></qr-manage-download>' +
            "</div>" +
            "</div>" +
            "</div>" +
            '<qr-upselling-banner ng-if="isUpsellingBannerVisible()"></qr-upselling-banner>',
        scope: {
            value: "=", // QR code data.
            isAdmin: "=",
            checkbox: "=",
            isDemo: "=",
            index: "=",
            currentPage: "=",
            currentFolderId: "=",
        },
        link: function (scope, element) {
            /**
             * Focus on the title input.
             */
            scope.setFocusOnTitle = function () {
                $timeout(function () {
                    element.find(".qr-manage-code__title-input").focus();
                }, 500);
            };
        },
        controller: [
            "$scope",
            "$element",
            function ($scope, $element) {
                /**
                 * Some translations.
                 */
                $scope.noTitleLabel = gettextCatalog.getString("No title");
                $scope.scansLabel = gettextCatalog.getString("Scans");

                /**
                 * ENG-1536: Mapping the QR Code types, because we're not having translations for our the QR Code names
                 * This is because we never defined these in any angular directives and only in php,
                 * which uses separate po files.
                 * Having the types listed like this, enables us to extract them into po files.
                 */
                $scope.qrCodeTypeNames = {
                    1 : gettextCatalog.getString('Website'),
                    2 : gettextCatalog.getString('vCard'),
                    3 : gettextCatalog.getString('App'),
                    4 : gettextCatalog.getString('Facebook'),
                    5 : gettextCatalog.getString('MP3'),
                    6 : gettextCatalog.getString('PDF'),
                    7 : gettextCatalog.getString('Gallery'),
                    8 : gettextCatalog.getString('Email'),
                    9 : gettextCatalog.getString('SMS'),
                    10 : gettextCatalog.getString('Text'),
                    11 : gettextCatalog.getString('Multi URL'),
                    12 : gettextCatalog.getString('vCard Plus'),
                    13 : gettextCatalog.getString('Event'),
                    14 : gettextCatalog.getString('Social'),
                    15 : gettextCatalog.getString('Business'),
                    16 : gettextCatalog.getString('Video'),
                    17 : gettextCatalog.getString('Feedback'),
                    18 : gettextCatalog.getString('Coupon'),
                    19 : gettextCatalog.getString('Rating'),
                    20 : gettextCatalog.getString('PDF'),
                    21 : gettextCatalog.getString('App'),
                    22 : gettextCatalog.getString('MP3'),
                    23 : gettextCatalog.getString('Gallery'),
                    24 : gettextCatalog.getString('WiFi'),
                    25 : gettextCatalog.getString('Instagram'),
                    26 : gettextCatalog.getString('GS1'),
                };

                // START: ENG-1690 A/B test for different insights labels
                // Please remove variants that lost and tidy this up after A/B test again.
                var bodyClasses = document.getElementsByTagName('body')[0].className;

                if(bodyClasses.includes("ab-test-variant-statistics")) {
                    $scope.insightsLabel = gettextCatalog.getString("Statistics");
                } else if(bodyClasses.includes("ab-test-variant-scan-data")) {
                    $scope.insightsLabel = gettextCatalog.getString("Scan data");
                } else {
                    $scope.insightsLabel = gettextCatalog.getString("Details");
                }
                // END: ENG-1690 A/B test for different insights labels

                $scope.staticLabel = gettextCatalog.getString("Static/Non-trackable");
                $scope.titlePlaceholder = gettextCatalog.getString(
                    "Name your QR Code..."
                );
                $scope.editShortUrl = gettextCatalog.getString("Edit Short URL");

                /**
                 * Open states of the modals.
                 * @type {*}
                 */
                $scope.open = {
                    paused: false,
                    expire: false,
                    blockedInvoice: false,
                    demo: false,
                    download: {}
                };

                $timeout(function () {
                    $element.find('[data-toggle="tooltip"]').tooltip({animation: false});
                });

                $scope.$watch('checkbox.checkAllState', function () {
                    if ($scope.checkbox.checkAll === true && $scope.checkbox.checkAllState === true) {
                        if (!$scope.selected) {
                            $scope.select();
                        }
                    }

                    if ($scope.checkbox.checkAll === false) {
                        if ($scope.selected) {
                            $scope.select();
                        }
                    }
                });

                $scope.$watch('checkbox.visible', function () {
                    if (!$scope.checkbox.visible) {
                        $scope.selected = false;
                    }
                });

                /**
                 * Is it title editing mode?
                 * @type {boolean}
                 */
                $scope.titleEditing = false;

                /**
                 * Get the total amount of scans
                 * @returns {string}
                 */
                $scope.getTotalScans = function () {
                    if ($scope.value.status === 'expired' && !$scope.isAdmin) {
                        return "???";
                    } else {
                        return $scope.value.total_scans;
                    }
                };
                /**
                 * Get the creation date.
                 * @returns {String}
                 */
                $scope.getCreated = function () {
                    return $window.moment($scope.value.created).format('MMM D, YYYY');
                };

                /**
                 * Get the status.
                 * @returns {String}
                 */
                $scope.getStatus = function () {
                    if ($scope.value.status === 'paused') {
                        return gettextCatalog.getString('Paused');
                    }
                    if ($scope.value.status === 'expired') {
                        return gettextCatalog.getString('Expired');
                    }
                    return '';
                };

                /**
                 * Get status CSS classes.
                 * @returns {*}
                 */
                $scope.getStatusClass = function () {
                    return {
                        'qr-manage-code__status--expired': $scope.value.status === 'expired'
                    };
                };

                /**
                 * Set the url for short URL. In development there will be the long url, in production will be the short url
                 * @returns {*}
                 */
                $scope.getShortUrl = function () {
                    return $scope.value.short_url;
                };
                /**
                 * Get status CSS classes.
                 * @returns {*}
                 */
                $scope.getCheckboxClass = function () {
                    return {
                        'qr-manage-code__checkbox--visible': $scope.checkbox.visible
                    };
                };

                /**
                 * Set the url for short URL. In development there will be the long url, in production will be the short url
                 * @returns {*}
                 */
                $scope.getShortUrl = function () {
                    return $scope.value.short_url;
                };

                /**
                 * Get the short URL of the QR code.
                 * @returns {String}
                 */
                $scope.getUrl = function () {
                    var url = "" + $scope.value.short_url;
                    if (url.substr(0, 7) === "http://") {
                        return url.substr(7);
                    }
                    if (url.substr(0, 8) === "https://") {
                        return url.substr(8);
                    }
                    if (url.substr(0, 2) === "//") {
                        return url.substr(2);
                    }
                    return url;
                };

                /**
                 * Get icon for the QR type.
                 * @returns {String}
                 */
                $scope.getTypeIcon = function () {
                    return qrTypeService.getTypeIconFromTypeId($scope.value.type_id);
                };

                /**
                 * Get the target URL, if any.
                 * @returns {string}
                 */
                $scope.getTarget = function () {
                    var match,
                        url = "" + $scope.value.target_url;
                    if ((match = url.match(/^https?:\/\/([a-z0-9.-]+)/i))) {
                        url = match[1];
                    }
                    return url;
                };

                /**
                 * Get the second part of the target URL, if any.
                 * @returns {string}
                 */
                $scope.getSecondTargetPart = function () {
                    var match = ("" + $scope.value.target_url).match(
                        /^https?:\/\/[a-z0-9.-]+(\/.*)$/i
                    );
                    return match ? match[1] : "";
                };

                /**
                 * Start title editing.
                 * Expired codes can't be edited.
                 */
                $scope.startTitleEdit = function () {
                    if ($scope.value.status !== "expired" && !$scope.isDemo) {
                        $scope.titleEditing = true;
                        $scope.setFocusOnTitle();
                    } else {
                        $scope.open.demo = true;
                    }
                };

                /**
                 * Stop title editing depending on event data.
                 * @param $event
                 */
                $scope.stopTitleEdit = function ($event) {
                    if (
                        $event.type === "blur" ||
                        $event.keyCode === 13 ||
                        $event.keyCode === 27
                    ) {
                        api.updateCodeTitle(
                            $scope.value.id,
                            $scope.value.title,
                            function () {
                                $scope.titleEditing = false;
                            }
                        );
                    }
                };

                /**
                 * Get actual folder name.
                 * @returns {string}
                 */
                $scope.getFolderName = function () {
                    var name = gettextCatalog.getString("No folder");
                    if ("folder" in $scope.value && $scope.value.folder) {
                        name = $scope.value.folder.name;
                    }
                    angular.forEach(account.getFolders(), function (folder) {
                        if (folder.id === $scope.value.folder_id) {
                            name = folder.name;
                        }
                    });
                    return name;
                };

                /**
                 * This is called on clicks on Insights link.
                 * @param $event
                 */

                $scope.openInsights = function ($event) {
                    if (account.getAccountStatus() === "paused" && $scope.isAdmin) {
                        $event.preventDefault();
                        $scope.open.paused = true;
                    } else if (
                        account.getAccountStatus() === "expired" &&
                        !$scope.isAdmin
                    ) {
                        $event.preventDefault();
                        $scope.open.expire = true;
                    } else if (
                        account.getAccountPaymentOverdue() === 1 &&
                        !$scope.isAdmin
                    ) {
                        $event.preventDefault();
                        $scope.open.blockedInvoice = true;
                    }

                    // Track every click on the insights-button
                    $scope.trackInsightsButtonClick();
                };

                $scope.trackInsightsButtonClick = function () {
                    window.qr.utils.optimizely.trackOptimizelyEvent('qrapp_click_insights_button');
                };

                /**
                 * Returns URL of the statistics page.
                 * @returns {string}
                 */
                $scope.getInsightsUrl = function () {
                    return account.getCurrentUrl({
                        view: "insights",
                        id: $scope.value.id,
                    });
                };

                /**
                 * Opens Short URL modal window in qr-manage-download
                 */
                $scope.openShortUrlEdit = function () {
                    $rootScope.$broadcast(
                        "qr-open-download-dialog",
                        $scope.value.id,
                        "url"
                    );
                };

                /**
                 * Control some CSS classes of the title DIV.
                 * @returns {*}
                 */
                $scope.getTitleClass = function () {
                    return {
                        "qr-manage-code__title--editable":
                            $scope.value.status !== "expired",
                    };
                };

                /**
                 * Get the title for displaying.
                 * It can be different from real title in the database.
                 * @returns {String}
                 */
                $scope.getVisibleTitle = function () {
                    return (
                        $scope.value.title ||
                        $scope.value.target_url ||
                        $scope.noTitleLabel
                    );
                };

                $scope.select = function () {
                    $scope.selected = !$scope.selected;

                    if ($scope.selected) {
                        $scope.checkbox.totalSelected += 1;
                        $scope.checkbox.visible = true;
                        $scope.checkbox.selectedCodes.push($scope.value.id);
                    } else {
                        $scope.checkbox.totalSelected -= 1;
                        $scope.checkbox.selectedCodes.splice(
                            $scope.checkbox.selectedCodes.indexOf($scope.value.id),
                            1
                        );
                        $scope.checkbox.checkAllState = false;
                        if ($scope.checkbox.totalSelected <= 0) {
                            $scope.checkbox.visible = false;
                            $scope.checkbox.totalSelected = 0;
                        }
                    }
                };

                $scope.getCodeClass = function () {
                    return {
                        "qr-manage-code--selected": $scope.selected,
                    };
                };

                /**
                 * Opens MoveToFolder modal window in qr-manage-download
                 */
                $scope.openFolderModal = function () {
                    if ($scope.isDemo) {
                        $scope.open.demo = true;
                    } else {
                        $scope.open.download.move = true;
                    }
                };

                /**
                 * Check if the user is on trial and have active dynamic code
                 */
                $scope.isTrialUserWithDynamicCodes = function () {
                    return $scope.value.trackable === 1 && account.isTrial();
                };

                $scope.isFeatureToggleExpiredModal = function () {
                    return window.GLOBAL_FEATURE_TRIAL_EXPIRED_MODAL === '1';
                };

                $scope.isUpsellingBannerVisible = function() {
                    /**
                     * Only show if
                     * - User is on starter-plan
                     * - User has 2/2 QR Codes
                     * - App language is en
                     * - "active" folder selected
                     * - Page 1
                     * - After 2 QR Codes were displayed in the list
                     */
                    return account.getAccount().type === 'paid1' &&
                           account.isQrCodeLimitReached() &&
                           $scope.currentFolderId === -1 &&
                           $scope.currentPage === 1 &&
                           $scope.index === 1;
                };

                $scope.isAbTestEnabled_CNV2467 = function() {
                    return window.qr.utils.optimizely.isAbTestVariantActive('23988530195', '24017330211');
                };
            },
        ],
    };
},
]);
;
/**
 * Content area of the new manage view.
 */
app.directive('qrManageContent', ['gettextCatalog', '$window', 'account', '$location', '$timeout', 'api', 'tracking', function (gettextCatalog, $window, account, $location, $timeout, api, tracking) {
    return {
        restrict: 'E',
        template:
            '<qr-subscription-resume-modal open="openResumeModal" ng-if="openResumeModal"></qr-subscription-resume-modal>' +

            '<div class="qr-manage-content qr-manage-content--panel-close" data-manage-content>' +
                '<div ng-show="!isAdmin" class="qr-manage-content__banner" data-alert-banner>' +
                    '<qr-account-locked ng-if="account.trial && account.payment_open"></qr-account-locked>' +
                    '<qr-free-plan-banner ng-if="isFreePlanBannerVisible()"></qr-free-plan-banner>' +
                    '<qr-creditcard-expired ng-if="account.payment_creditcard_expired && !account.payment_open" payment-info="account.paymentInfo" ng-class="{forceDisplayBlock: account.payment_creditcard_expired && !account.payment_open}"></qr-creditcard-expired>' +
                    '<qr-trial-ended ng-if="account.status === &apos;expired&apos; && !isAbTestEnabled_CNV2467()" ng-class="{forceDisplayBlock: account.status === &apos;expired&apos;}"></qr-trial-ended>' +
                    '<qr-paused-banner ng-if="account.status === &apos;paused&apos;" ng-class="{forceDisplayBlock: account.status === &apos;paused&apos;}"></qr-paused-banner>' +
                    '<qr-open-invoice open="account.payment_open && !account.trial" payment-tx-id="account.payment_txid" ng-class="{forceDisplayBlock: account.payment_open && !account.trial}"></qr-open-invoice>' +
                '</div>' +
                '<qr-user-info account="account" ng-if="isAdmin"></qr-user-info>' +
                '<div class="qr-manage-content__items" ng-show="!statistics.open">' +
                    '<qr-trial-expired-banner ng-if="isAbTestEnabled_CNV2467()"></qr-trial-expired-banner>' +
                    '<span class="qr-manage-content__checkbox checkboxes-container blue-checkbox" ng-show="checkbox.visible">' +
                        '<input type="checkbox" id="qr-manage-content-checkbox" ng-click="checkAll()" ng-checked="checkbox.checkAllState">' +
                        '<label class="qr-manage-content__checkbox-label" for="qr-manage-content-checkbox"></label>' +
                    '</span>' +
                    '<qr-manage-bar is-admin="isAdmin" total-selected="checkbox.totalSelected" selected-codes="checkbox.selectedCodes" search-query="getSearchQuery()"></qr-manage-bar>' +
                    '<div ng-hide="isLoadingCodes">' +
                        '<qr-manage-code ng-repeat="code in codes track by code.id" index="$index" current-page="currentPage" current-folder-id="currentFolderId" value="code" is-admin="isAdmin" checkbox="checkbox"></qr-manage-code>' +
                    '</div>' +
                    '<div class="qr-manage-content__loading" ng-show="isLoadingCodes" ng-style="getLoadingAreaStyles(windowHeight)">' +
                        '<qr-spinner class="qr-manage-content__spinner" loading="isLoadingCodes" size="32px" test-event="manage-qrcode-list-spinner"></qr-spinner>' +
                        '<div class="qr-manage-content__loading-message" ng-bind="::loadingMessage"></div>' +
                    '</div>' +
                    '<div class="qr-manage-content__empty" ng-show="!isLoadingCodes && codes.length === 0 && !getSearchQuery()">' +
                        '<span class="qr-manage-content__icon" ng-class="getFolderIconClass()"></span>' +
                        '<p class="qr-manage-content__empty-text" ng-bind="getEmptyText()"></p>' +
                    '</div>' +
                    '<div class="qr-manage-content__empty qr-manage-content__empty--search" ng-show="!isLoadingCodes && codes.length === 0 && getSearchQuery()">' +
                        '<img class="qr-manage-content__cody" ng-src="{{(!isLoadingCodes && codes.length === 0 && getSearchQuery()) && cdnUrl+\'/img/generator/cody/CodyE_Concerned.svg\' || \'\'}}">' +
                        '<p class="qr-manage-content__empty-text" ng-bind="getNoSearchResultsMessage()"></p>' +
                        '<button type="button" class="qr-manage-content__search-all" ng-click="searchAll()" ng-show="isSearchAllVisible()" ng-bind="::searchInAllLabel"></button>' +
                    '</div>' +
                    '<qr-resources ng-if="isResourcesVisible()"></qr-resources>' +
                    '<qr-pagination ng-if="isPaginationVisible()"></qr-pagination>' +
                    '<div id="qrcg-web-component-recommended-for-accordion" ng-hide="isLoadingCodes"></div>' +
                '</div>' +
                '<qr-statistics-view open="statistics.open" code="statistics.code" is-demo="statistics.demo"></qr-statistics-view>' +
                '<div id="vue-custom-download" class="vue-custom-download" ng-non-bindable>' +
                    '<v-app v-if="open">' +
                        '<v-main>' +
                            '<custom-download :current-language="currentLanguage" :force-download="forceDownload" :open.sync="open" :item="item" :snowplow-collector-endpoint="snowplowCollectorEndpoint"></custom-download>' +
                        '</v-main>' +
                    '</v-app>' +
                '</div>' +
            '</div>',
        scope: {
            isAdmin: '='        // Show info about user if admin is logged in
        },
        controller: ['$scope', function ($scope) {
            $scope.openResumeModal = false;

            /**
             * Catch opening event for resume modal
             */
            $scope.$on('openResumeModal', function () {
                $scope.openResumeModal = true;
            });

            /**
             * Catch closing event for resume modal
             */
            $scope.$on('closeResumeModal', function () {
                $scope.openResumeModal = false;
            });

            /**
             * Some translations.
             */
            $scope.noQRCodesLabel = gettextCatalog.getString('There are no QR Codes');
            $scope.noActiveQRCodesLabel = gettextCatalog.getString('There are no active QR Codes');
            $scope.noPausedQRCodesLabel = gettextCatalog.getString('There are no paused QR Codes');
            $scope.noQRCodesInFolderLabel = gettextCatalog.getString('There are no QR Codes in this folder');
            $scope.searchInAllLabel = gettextCatalog.getString('Search in All QR Codes?');
            $scope.loadingMessage = gettextCatalog.getString('Loading QR Codes...');

            $scope.cdnUrl = $window.CDN_URL;

            $scope.scrollY = 0;

            /**
             * Array of user's QR codes.
             * @type {Array}
             */
            $scope.codes = [];

            /**
             * Account data.
             * @type {*}
             */
            $scope.account = {};

            $scope.statistics = {
                open: false,
                demo: false,
                code: {}
            };

            // Banner variable
            var alertBanner = $('[data-alert-banner]');

            // Declare a variable to switch queries to sample data
            var demoStatisticSwitch;

            // Function to get sample data
            var loadDemoCodeStatistic = function() {
                account.loadDemoCode(function (response) {
                    $scope.statistics.code = response.data;
                    $scope.statistics.demo = true;
                });

                // Submit a request to the API every 5 seconds to get new data
                demoStatisticSwitch = $timeout(loadDemoCodeStatistic, 5000);
            };

            // Sync with current view from account service.
            $scope.$watch(function () {
                return account.getCurrentView();
            }, function () {
                $scope.syncViewWithAccountService();
            });

            // Move sync account service to function so we can reuse it in multiple places
            $scope.syncViewWithAccountService = function () {

                if ('insights' === account.getCurrentView()) {
                    var codes = account.getCodesByIds([account.getCurrentViewId()]);
                    if (codes[0]) {
                        $scope.statistics.open = true;
                        $scope.statistics.demo = false;
                        $scope.statistics.code = codes[0];

                        // When we click on the exit demo button, we stop requesting changes from the API
                        $timeout.cancel(demoStatisticSwitch);
                        demoStatisticSwitch = null;

                    } else if (account.getCurrentViewId() == 1124) {
                        account.loadDemoCode(function (response) {
                            $scope.statistics.code = response.data;
                            $scope.statistics.open = true;
                            $scope.statistics.demo = true;
                        });
                    } else {
                        $scope.statistics.open = false;
                        $scope.statistics.demo = false;
                        $scope.statistics.code = {};
                        account.setCurrentView('');
                    }
                } else if ('demo' === account.getCurrentView()) {

                    // Load sample demo data when we click on the view demo button
                    loadDemoCodeStatistic();

                    // Submit a request to the API every 5 seconds to get new data
                    // Create a delay of 5 seconds to avoid double loading on first request
                    if (demoStatisticSwitch === null) {
                        _.delay(loadDemoCodeStatistic, 5000);
                    }


                } else {
                    $scope.statistics.open = false;
                    $scope.statistics.code = {};
                }
            };

            /**
             * @returns {string}
             */
            $scope.getNoSearchResultsMessage = function () {
                return gettextCatalog.getString('No search results found for "{{searchQuery}}" in this folder.', {
                    searchQuery: account.getSearchQuery()
                });
            };

            /**
             * Checks whether the body has the ab-test class to determine whether to show the recommendations
             *
             * TODO: Remove hasClass after A/B test
             *
             * @returns {*|jQuery}
             */
            $scope.checkDisplayRecommendations = function () {
                return $('body').hasClass('ab-test-type-recommendation') &&
                    account.getPagination().totalCount >= 1 &&
                    account.getPagination().totalCount < 10;
            };

            /**
             * @returns {string}
             */
            $scope.getSearchQuery = account.getSearchQuery;

            /**
             * Show "Search All" button only when it's not "All" folder.
             * @returns {boolean}
             */
            $scope.isSearchAllVisible = function () {
                return account.getCurrentFolderId() !== 0;
            };

            /**
             *
             * @returns {boolean}
             */
            $scope.isFreePlanBannerVisible = function () {
                return window.location.search.substring(1) === 'freeplan=true';
            };

            /**
             * Returns the text for displaying in empty folders.
             * @returns {String}
             */
            $scope.getEmptyText = function () {
                var activeFolderId = account.getCurrentFolderId();
                if (activeFolderId === 0) {
                    return $scope.noQRCodesLabel;
                }
                if (activeFolderId === -1) {
                    return $scope.noActiveQRCodesLabel;
                }
                if (activeFolderId === -2) {
                    return $scope.noPausedQRCodesLabel;
                }
                return $scope.noQRCodesInFolderLabel;
            };

            /**
             * Returns true when the pagination should be visible.
             * @returns {boolean}
             */
            $scope.isPaginationVisible = function () {
                return !account.isLoadingCodes() && account.getPagination().totalCount > 10;
            };

            /**
             * Returns a folder icon, if any, or the default one.
             * @returns {String}
             */
            $scope.getFolderIconClass = function () {
                var activeFolderId = account.getCurrentFolderId();
                if (activeFolderId === 0) {
                    return 'icon icon-qr-all';
                }
                if (activeFolderId === -1) {
                    return 'icon icon-active';
                }
                if (activeFolderId === -2) {
                    return 'icon icon-qr-paused';
                }
                if (activeFolderId === -3) {
                    return 'icon icon-qr-expired';
                }
                return 'icon icon-qr-folder';
            };

            /**
             * Switch to the All folder, but keep the same search query.
             */
            $scope.searchAll = function () {
                $location.url(account.getCurrentUrl({
                    folder: 0,
                    page: 1
                }).substr(2));
            };

            /**
             * Center the spinner vertically and horizontally.
             * @param {number} windowHeight
             * @returns {*}
             */
            $scope.getLoadingAreaStyles = function (windowHeight) {
                return {
                    paddingTop: Math.max(windowHeight / 2 - 150, 0) + 'px'
                };
            };

            /**
             * Handle mass selection mode
             */
            $scope.checkAll = function () {
                $scope.checkbox.checkAllState = !$scope.checkbox.checkAllState;
                $scope.checkbox.checkAll = $scope.checkbox.checkAllState;
            };

            /**
             * When to show the resources.
             * @returns {boolean}
             */
            $scope.isResourcesVisible = function () {
                return !$scope.checkDisplayRecommendations() && !$scope.isLoadingCodes &&
                    $scope.account.statistics && $scope.account.statistics.all <= 10 &&
                    account.getCurrentFolderId() <= 0 && account.getPagination().totalCount > 0;
            };

            /**
             * Reset the selection of QR codes.
             */
            $scope.resetSelection = function () {
                $scope.checkbox = {
                    visible: false,
                    checkAll: false,
                    checkAllState: false,
                    totalSelected: 0,
                    selectedCodes: []
                };
            };

            /**
             * True if the codes are loading.
             * @type {boolean}
             */
            $scope.isLoadingCodes = false;

            // Sync current page
            $scope.$watch(function () {
                return account.getPagination().page;
            }, function () {
                $scope.currentPage = account.getPagination().page;
            });

            // Sync isLoadingCodes.
            $scope.$watch(function () {
                return account.isLoadingCodes();
            }, function () {
                $scope.isLoadingCodes = account.isLoadingCodes();
            });

            /**
             * Height of the browser window.
             * @type {number}
             */
            $scope.windowHeight = $window.innerHeight;

            // Sync the height of the window.
            angular.element($window).on('resize', function () {
                $scope.windowHeight = $window.innerHeight;
                $scope.$apply();
            });

            // Sync internal array of codes with the service.
            $scope.$watch(function () {
                return account.getCodes();
            }, function () {
                $scope.codes = account.getCodes();
                $scope.resetSelection();
            }, true);

            // Change scrolling position to the top when loaded.
            $scope.$watch(function () {
                return account.isLoadingCodes();
            }, function () {
                if (!account.isLoadingCodes()) {
                    if ('scrollTo' in $window) {
                        $window.scrollTo({top: 0});
                    }
                }
            }, true);

            // Sync with the account service.
            $scope.$watch(function () {
                return account.getAccount();
            }, function () {
                $scope.account = account.getAccount();
            }, true);

            $scope.$watch(function () {
                $scope.currentFolderId = account.getCurrentFolderId();
                return account.getCurrentFolderId();
            }, function () {
                $scope.resetSelection();
            });

            $scope.$watch('statistics.open', function () {
                if (!$scope.statistics.open) {
                    $timeout(function () {
                        $window.scrollTo(0, $scope.scrollY);
                    });

                    alertBanner.addClass('qr-manage-content__banner_open').removeClass('qr-manage-content__banner_close');
                } else {
                    $scope.scrollY = $window.scrollY;
                    alertBanner.addClass('qr-manage-content__banner_close').removeClass('qr-manage-content__banner_open');
                }
            });

            $scope.refreshView = false; // Variable to watch for code changes

            // Watch for code changes and reload UI (Details view) once we update code
            $scope.$watch(function () {
                return $scope.refreshView;
            }, function (val) {
                // Refresh only if refreshView is happening
                if(val) {
                    // Add small delay so we can get fresh changes
                    $timeout(function () {
                        $scope.syncViewWithAccountService();
                        $scope.$apply();
                    }, 150);
                }
            }, true);

            // Name of vue modal
            $scope.vueModalName = 'vue-custom-download';

            // Close Download Modal (via click outside)
            $scope.closeDownloadModal = function () {
                window.vueapps[$scope.vueModalName].open = false;
            };

            // Listen to child emit event and open modal once its triggered
            $scope.$on('openDownloadModal', function (_, value, forceDownload) {
                window.vueapps[$scope.vueModalName].open = true;
                window.vueapps[$scope.vueModalName].item = value;
                window.vueapps[$scope.vueModalName].forceDownload = forceDownload;
                window.vueapps[$scope.vueModalName].currentLanguage = gettextCatalog.currentLanguage;
                // Angular.js way to support click outside for download modal since this current implementation does not support native vue event listeners
                $timeout(function () {
                    var element = document.querySelector('.v-overlay');
                    if(element) {
                        // Add custom event listener on modal overlay
                        element.addEventListener("click", function() {
                            $scope.closeDownloadModal();
                            $timeout(function () {
                                $scope.reloadAccountCodes();
                            }, 50);
                        }, { once: true }); // Use once option, so we do not have to call removeEventListener
                    }
                }, 150);
            });

            // Function to launch custom download modal
            $scope.launchVueCustomDownload = function () {
                if(!window.vueapps) {
                    window.vueapps = {};
                }

                var el = document.getElementById($scope.vueModalName);
                // Populate store inside modal
                VueCustomDownload.default.store.dispatch('api/setOldApiRootUrl',api.getBaseUrl() + '/');
                VueCustomDownload.default.store.dispatch('auth/setToken', api.getApiToken());
                VueCustomDownload.default.store.dispatch('auth/setTokenV1', api.getApiToken());

                // Listen to download event
                VueCustomDownload.default.events.$on('download', function (data) {
                    var vueapp = window.vueapps[$scope.vueModalName];
                    if (!vueapp.open) {
                        return;
                    }

                    // Push event to dataLayer
                    window.dataLayer.push({
                        event: 'download_code',
                        category: 'Action',
                        label: 'QR Code'
                    });

                    if(vueapp.forceDownload) {
                        window.qr.utils.optimizely.trackOptimizelyEvent("qrapp_manage_view_download_button_ab",
                            {qr_code_type_id: vueapp.item.type_id, trackable: vueapp.item.trackable})
                    } else {
                        window.qr.utils.optimizely.trackOptimizelyEvent("qrapp_downloaded_qr_code",
                            {qr_code_type_id: vueapp.item.type_id, trackable: vueapp.item.trackable});
                    }


                    // If QR Code has a frame.
                    if(data.qrCode) {
                        window.dataLayer.push({
                            event: 'download_code_with_frame',
                            frame_name: data.qrCode.lastFrameTemplate.frame_name,
                        });
                    }

                    tracking.trackEvent('done_download_code');

                    var frameName = vueapp.item.lastFrameTemplate.frame_name || vueapp.item.style.frame_name;
                    if (frameName !== 'no-frame') {
                        tracking.trackEvent('done_download_code_with_frame');
                    }
                });

                // Listen to modal close/open events and based on its state reload codes to fetch fresh data in UI list
                VueCustomDownload.default.events.$on('visible', function (state) {
                    if(!state) {
                        $scope.reloadAccountCodes();
                    }
                });

                // Reload account codes to apply latest changes once we close download dialog
                $scope.reloadAccountCodes = function () {
                    account.reloadCodes(function () {
                        // Add trigger which will reload UI (Mainly made for details view of code)
                        $scope.refreshView = true;
                        $timeout(function () {
                            $scope.refreshView = false;
                        }, 100);
                    });
                };

                window.vueapps[$scope.vueModalName] = new Vue({
                    components: {
                        'custom-download': VueCustomDownload.default.CustomDownload,
                        'v-app': VueCustomDownload.default.VApp,
                        'v-main': VueCustomDownload.default.VMain,
                    },
                    i18n: VueCustomDownload.default.i18n,
                    vuetify: VueCustomDownload.default.vuetify,
                    data: {
                        open: false,
                        item: null,
                        snowplowCollectorEndpoint: window.GLOBAL_VUE_APP_SNOWPLOW_ENABLED === "true" ? window.GLOBAL_VUE_APP_SNOWPLOW_ENDPOINT : "",
                        forceDownload: false,
                        currentLanguage: 'en'
                    },
                }).$mount(el);
            };

            $scope.initRecommendedForAccordionWebComponent = function () {
                window.qr.utils.webcomponents.init({
                    element: "qrcg-web-component-recommended-for-accordion",
                    attributes: [
                        {
                            key: 'industry-id',
                            value: '12'
                        },
                        {
                            key: 'visible',
                            value: $scope.checkDisplayRecommendations()
                        },
                        {
                            key: '_language',
                            value: gettextCatalog.currentLanguage
                        }
                    ],
                    renderElement: '#qrcg-web-component-recommended-for-accordion'
                });
            };

            // Initialize vue custom download modal
            $timeout(function () {
                $scope.initRecommendedForAccordionWebComponent();
                $scope.launchVueCustomDownload();
            }, 100);

            $scope.isAbTestEnabled_CNV2467 = function() {
                return window.qr.utils.optimizely.isAbTestVariantActive('23988530195', '24017330211');
            }
        }]
    };
}]);
;
/**
 * The download button for QR codes.
 */
app.directive('qrManageDownload', ['$window', '$timeout', 'gettextCatalog', 'account', 'api', function ($window, $timeout, gettextCatalog, account, api) {
    'use strict';
    return {
        restrict: 'E',
        template:
            '<qr-demo-modal open="open.demo" ng-if="open.demo"></qr-demo-modal>' +
            '<qr-paused-modal open="open.paused" ng-if="open.paused"></qr-paused-modal>' +
            '<qr-expired-modal open="open.expire" ng-if="open.expire"></qr-expired-modal>' +
            '<qr-view-blocked open="open.blockedInvoice" ng-if="open.blockedInvoice"></qr-view-blocked>' +
            '<div class="qr-manage-download--new">' +
                '<div class="qr-manage-download" ng-class="open.menu ? &apos;qr-manage-download--active&apos; : &apos;&apos;">' +
                    // Download button
                    '<button class="qr-manage-download__button" type="button" ng-click="buttonClick()" ng-class="getButtonClass()"' +
                        'data-test="{{value.status === &apos;paused&apos; ? &apos;manage-qrcode-list-item-activate&apos; : &apos;manage-qrcode-list-item-download&apos;}}">' +
                        '<svg ng-if="isAbTestEnabled_CNV2467()" style="margin-right:8px;" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">' +
                            '<g clip-path="url(#clip0_1115_26682)">' +
                                '<path d="M15.7 10.2176C15.301 11.5974 14.5384 12.8442 13.4922 13.8276C12.4461 14.8109 11.1548 15.4945 9.75382 15.8066C8.35285 16.1187 6.89377 16.0479 5.52955 15.6016C4.16533 15.1553 2.94621 14.3499 2 13.2699L0.89 14.3507C0.819089 14.4228 0.728717 14.4727 0.629941 14.4942C0.531165 14.5157 0.428268 14.5079 0.333838 14.4718C0.239408 14.4357 0.15754 14.3728 0.0982493 14.2909C0.0389587 14.209 0.00481664 14.1115 0 14.0105L0 10.5279C0 10.3899 0.0547856 10.2575 0.152304 10.1599C0.249823 10.0623 0.382087 10.0075 0.52 10.0075H4C4.10352 10.0066 4.20496 10.0366 4.29133 10.0937C4.3777 10.1508 4.44506 10.2324 4.4848 10.3281C4.52454 10.4237 4.53485 10.5291 4.5144 10.6307C4.49394 10.7322 4.44366 10.8254 4.37 10.8981L3 12.2091C3.75872 13.1192 4.7515 13.8046 5.87111 14.1912C6.99071 14.5778 8.19458 14.6509 9.35267 14.4026C10.5108 14.1543 11.5791 13.5941 12.4422 12.7825C13.3053 11.9708 13.9304 10.9386 14.25 9.79733C14.3057 9.6049 14.4355 9.4425 14.6108 9.34584C14.7862 9.24919 14.9927 9.2262 15.185 9.28194C15.3773 9.33768 15.5396 9.46757 15.6361 9.64305C15.7327 9.81853 15.7557 10.0252 15.7 10.2176V10.2176ZM15.1 1.64123L14 2.73205C13.0535 1.64948 11.833 0.84211 10.4669 0.394819C9.10078 -0.0524731 7.63947 -0.123162 6.23661 0.190184C4.83374 0.50353 3.54115 1.18934 2.49473 2.1755C1.4483 3.16166 0.686703 4.41175 0.29 5.79434C0.234305 5.98543 0.256747 6.19085 0.352391 6.36539C0.448034 6.53993 0.609044 6.66929 0.8 6.72503C0.869663 6.73476 0.940337 6.73476 1.01 6.72503C1.17357 6.72441 1.33245 6.67029 1.46244 6.57092C1.59242 6.47156 1.68638 6.33239 1.73 6.17462C2.05401 5.03352 2.68321 4.0026 3.54972 3.1931C4.41623 2.38359 5.48716 1.82622 6.64697 1.5811C7.80678 1.33599 9.01146 1.41244 10.131 1.80221C11.2506 2.19198 12.2426 2.88028 13 3.79284L11.64 5.10382C11.5634 5.1754 11.5102 5.26846 11.4874 5.37082C11.4646 5.47317 11.4732 5.58003 11.5121 5.6774C11.551 5.77476 11.6185 5.85809 11.7055 5.91646C11.7926 5.97483 11.8952 6.00551 12 6.00449H15.45C15.5216 6.00865 15.5933 5.99793 15.6606 5.97301C15.7279 5.9481 15.7893 5.90951 15.8409 5.8597C15.8926 5.80988 15.9334 5.74991 15.9608 5.68355C15.9881 5.61718 16.0015 5.54587 16 5.4741V2.0015C16.001 1.89664 15.9704 1.79392 15.912 1.70679C15.8537 1.61967 15.7704 1.55221 15.6731 1.51327C15.5759 1.47432 15.4691 1.4657 15.3668 1.48853C15.2645 1.51137 15.1715 1.56459 15.1 1.64123V1.64123Z" fill="#47BDEF"/>' +
                            '</g>"' +
                            '<defs>' +
                                '<clipPath id="clip0_1115_26682">' +
                                    '<rect width="16" height="16" fill="white"/>' +
                                '</clipPath>' +
                            '</defs>' +
                        '</svg>' +
                        '<span ng-bind="getLabel()"></span>' +
                        '</button>' +

                    // Modals
                    '<qr-move-to-folder-modal open="open.move" qr-code="value" ng-if="open.move" is-admin="isAdmin"></qr-move-to-folder-modal>' +
                    '<qr-delete-code-modal open="open.delete" qr-code="value" ng-if="open.delete"></qr-delete-code-modal>' +
                    '<qr-pause-code-modal open="open.pause" qr-code="value" ng-if="open.pause"></qr-pause-code-modal>' +
                    '<qr-activate-code-modal open="open.activate" qr-code="value" ng-if="open.activate"></qr-activate-code-modal>' +
                    '<qr-limit-reached-modal open="open.openLimitReachedModal" limit="limitReachedCount" ng-if="open.openLimitReachedModal"></qr-limit-reached-modal>' +
                    '<qr-type-restricted-modal open="open.openTypeRestrictedModal" ng-if="open.openTypeRestrictedModal"></qr-type-restricted-modal>' +
                '</div>' +
                '<div class="qr-manage-download__actions" ng-class="open.menu ? &apos;qr-manage-download__actions--active&apos; : &apos;&apos;">' +
                    '<qr-download-manage items="::actions" ng-if="windowWidth > 1200" is-demo="isDemo"></qr-download-manage>' +
                    '<button ng-style="{cursor:cursorType}" class="qr-manage-download__actions-more" type="button" ng-class="item.class" ng-click="menuClick()" ng-class="open.menu ? &apos;qr-manage-download__actions-more--active&apos; : &apos;&apos;" data-test="manage-qrcode-list-item-actions-more">' +
                        '<span class="qr-manage-download__icon icon icon-menu-vertical" data-toggle="tooltip" data-placement="bottom" title="{{ ::moreLabel }}"></span>' +
                    '</button>' +
                    '<qr-popup-menu open="open.menu" items="::popupItems" right="true" top-offset="2px" ng-if="open.menu"></qr-popup-menu>' +
                '</div>' +
            '</div>',
        scope: {
            open: '=',      // Optional open states of modals.
            value: '=',     // QR code data.
            isAdmin: '=',   // Show info about user if admin is logged in.
            isDemo: '='
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            /**
             * Open states of all modals.
             * @type {*}
             */
            $scope.open = {
                paused: false,
                expire: false,
                blockedInvoice: false,
                menu: false,
                move: false,
                delete: false,
                pause: false,
                activate: false,
                openLimitReachedModal: false,
                openTypeRestrictedModal: false,
                demo: false,
                download: false, // This activates download dialog in DOM, but doesn't open it.
                download_dialog: false, // This one real opens the dialog.
                tab: false // ID of the tab to open (on the download dialog).
            };

            $scope.isFreeAccount = account.getAccount().type === 'free';
            $scope.isDynamicCodeOtherThanDynamicWebsite = $scope.value.trackable === 1 && $scope.value.type_id !== 1;

            // Return actions based on feature toggle
            $scope.populateActions = function () {
                if($scope.isFeatureToggleDuplicateCodeEnabled()) {
                    return [
                        {
                            label: gettextCatalog.getString('Edit'),
                            tooltip: gettextCatalog.getString('Edit content'),
                            icon: 'avatar-edit',
                            class: 'qr-popup-menu__item--edit',
                            testEvent: 'manage-qrcode-list-item-edit',
                            callback: function () {
                                if (account.getAccountStatus() === 'expired' && !$scope.isAdmin) {
                                    $scope.open.expire = true;
                                }
                                else if( account.getAccountPaymentOverdue() === 1 && !$scope.isAdmin ){
                                    $scope.open.blockedInvoice = true;
                                }
                                else if ($scope.isDemo) {
                                    $scope.open.demo = true;
                                    $scope.open.menu = false;
                                } else {
                                    $window.location.href = '/editbarcode/' + $scope.value.id;
                                }
                            },
                            visible: function () {
                                // Hide edit link on static QR Code except static vCard
                                if (($scope.value.trackable === 0 && $scope.value.type_name === 'vCard') || ($scope.value.trackable === 1)) {
                                    return true;
                                }
                            }
                        },
                        {
                            label: gettextCatalog.getString('Design'),
                            tooltip: gettextCatalog.getString('Design QR Code'),
                            icon: 'qr-palette',
                            class: 'qr-popup-menu__item--design',
                            testEvent: 'manage-qrcode-list-item-design',
                            callback: function () {
                                if (account.getAccountStatus() === 'expired' && !$scope.isAdmin) {
                                    $scope.open.expire = true;
                                }else if( account.getAccountPaymentOverdue() === 1 && !$scope.isAdmin ){
                                    $scope.open.blockedInvoice = true;
                                }
                                else if ($scope.isDemo) {
                                    $scope.open.demo = true;
                                    $scope.open.menu = false;
                                } else {
                                    // A timeout is needed to display the modal after the menu is already hidden.
                                    $timeout(function () {
                                        $scope.openDownload();
                                    });
                                }
                            }
                        },
                        {
                            label: gettextCatalog.getString('Move to folder'),
                            tooltip: gettextCatalog.getString('Move to folder'),
                            icon: 'qr-folder',
                            class: 'qr-popup-menu__item--folder',
                            testEvent: 'manage-qrcode-list-item-move-folder',
                            callback: function () {
                                if (account.getAccountStatus() === 'expired' && !$scope.isAdmin) {
                                    $scope.open.expire = true;
                                }else if( account.getAccountPaymentOverdue() === 1 && !$scope.isAdmin ){
                                    $scope.open.blockedInvoice = true;
                                }
                                else if ($scope.isDemo) {
                                    $scope.open.demo = true;
                                    $scope.open.menu = false;
                                } else {
                                    // A timeout is needed to display the modal after the menu is already hidden.
                                    $timeout(function () {
                                        $scope.open.move = true;
                                    });
                                }
                            }
                        },
                        {
                            label: gettextCatalog.getString('Duplicate'),
                            tooltip: gettextCatalog.getString('Duplicate'),
                            icon: 'duplicate',
                            class: 'qr-popup-menu__item--duplicate',
                            testEvent: 'manage-qrcode-list-item-duplicate',
                            callback: function () {
                                if (!$scope.isDemo) {
                                    if (account.getAccountStatus() === 'paused' && !$scope.isAdmin) {
                                        $scope.open.paused = true;
                                    } else if (account.getAccountStatus() === 'expired' && !$scope.isAdmin) {
                                        $scope.open.expire = true;
                                    } else if (account.getAccountPaymentOverdue() === 1 && !$scope.isAdmin ) {
                                        $scope.open.blockedInvoice = true;
                                    }
                                    else {
                                        $scope.initDuplicateCodeModal();
                                    }
                                } else {
                                    $scope.open.demo = true;
                                }
                            },
                            visible: function () {
                                return $scope.duplicateCodeIsVisibleForTypes();
                            }
                        },
                        {
                            //this is for line in dropdown menu between 'Move to folder' and 'Pause'
                            label: '',
                            visible: function () {
                                if ($scope.windowWidth <= 1200) return true; // If mobile view always show
                                return $scope.duplicateCodeIsVisibleForTypes();
                            }
                        },
                        {
                            label: gettextCatalog.getString('Pause'),
                            icon: 'qr-paused',
                            class: 'qr-popup-menu__item--pause',
                            testEvent: 'manage-qrcode-list-item-pause',
                            callback: function () {
                                if (account.getAccountStatus() === 'expired') {
                                    $scope.open.expire = true;
                                }else if( account.getAccountPaymentOverdue() === 1 && !$scope.isAdmin ){
                                    $scope.open.blockedInvoice = true;
                                }
                                else if ($scope.isDemo) {
                                    $scope.open.demo = true;
                                    $scope.open.menu = false;
                                } else {
                                    $scope.open.pause = true;
                                }
                            },
                            visible: function () {
                                return $scope.value.status !== 'paused';
                            }
                        },
                        {
                            label: gettextCatalog.getString('Delete'),
                            icon: 'action-delete',
                            class: 'qr-popup-menu__item--delete',
                            testEvent: 'manage-qrcode-list-item-delete',
                            callback: function () {
                                if (account.getAccountStatus() === 'expired') {
                                    $scope.open.expire = true;
                                }else if( account.getAccountPaymentOverdue() === 1 && !$scope.isAdmin ){
                                    $scope.open.blockedInvoice = true;
                                }
                                else if ($scope.isDemo) {
                                    $scope.open.demo = true;
                                    $scope.open.menu = false;
                                } else {
                                    $scope.open.delete = true;
                                }
                            }
                        }
                    ];
                } else {
                    return [
                        {
                            label: gettextCatalog.getString('Edit'),
                            tooltip: gettextCatalog.getString('Edit content'),
                            icon: 'avatar-edit',
                            class: 'qr-popup-menu__item--edit',
                            testEvent: 'manage-qrcode-list-item-edit',
                            callback: function () {
                                if (account.getAccountStatus() === 'expired' && !$scope.isAdmin) {
                                    $scope.open.expire = true;
                                }
                                else if( account.getAccountPaymentOverdue() === 1 && !$scope.isAdmin ){
                                    $scope.open.blockedInvoice = true;
                                }
                                else if ($scope.isDemo) {
                                    $scope.open.demo = true;
                                    $scope.open.menu = false;
                                } else {
                                    $window.location.href = '/editbarcode/' + $scope.value.id;
                                }
                            },
                            visible: function () {
                                // Hide edit link on static QR Code except static vCard
                                if (($scope.value.trackable === 0 && $scope.value.type_name === 'vCard') || ($scope.value.trackable === 1)) {
                                    return true;
                                }
                            }
                        },
                        {
                            label: gettextCatalog.getString('Design'),
                            tooltip: gettextCatalog.getString('Design QR Code'),
                            icon: 'qr-palette',
                            class: 'qr-popup-menu__item--design',
                            testEvent: 'manage-qrcode-list-item-design',
                            callback: function () {
                                if (account.getAccountStatus() === 'expired' && !$scope.isAdmin) {
                                    $scope.open.expire = true;
                                }else if( account.getAccountPaymentOverdue() === 1 && !$scope.isAdmin ){
                                    $scope.open.blockedInvoice = true;
                                }
                                else if ($scope.isDemo) {
                                    $scope.open.demo = true;
                                    $scope.open.menu = false;
                                } else {
                                    // A timeout is needed to display the modal after the menu is already hidden.
                                    $timeout(function () {
                                        $scope.openDownload();
                                    });
                                }
                            }
                        },
                        {
                            label: gettextCatalog.getString('Move to folder'),
                            tooltip: gettextCatalog.getString('Move to folder'),
                            icon: 'qr-folder',
                            class: 'qr-popup-menu__item--folder',
                            testEvent: 'manage-qrcode-list-item-move-folder',
                            callback: function () {
                                if (account.getAccountStatus() === 'expired' && !$scope.isAdmin) {
                                    $scope.open.expire = true;
                                }else if( account.getAccountPaymentOverdue() === 1 && !$scope.isAdmin ){
                                    $scope.open.blockedInvoice = true;
                                }
                                else if ($scope.isDemo) {
                                    $scope.open.demo = true;
                                    $scope.open.menu = false;
                                } else {
                                    // A timeout is needed to display the modal after the menu is already hidden.
                                    $timeout(function () {
                                        $scope.open.move = true;
                                    });
                                }
                            }
                        },
                        {
                            //this is for line in dropdown menu between 'Move to folder' and 'Pause'
                            label: ''
                        },
                        {
                            label: gettextCatalog.getString('Pause'),
                            icon: 'qr-paused',
                            class: 'qr-popup-menu__item--pause',
                            testEvent: 'manage-qrcode-list-item-pause',
                            callback: function () {
                                if (account.getAccountStatus() === 'expired') {
                                    $scope.open.expire = true;
                                }else if( account.getAccountPaymentOverdue() === 1 && !$scope.isAdmin ){
                                    $scope.open.blockedInvoice = true;
                                }
                                else if ($scope.isDemo) {
                                    $scope.open.demo = true;
                                    $scope.open.menu = false;
                                } else {
                                    $scope.open.pause = true;
                                }
                            },
                            visible: function () {
                                return $scope.value.status !== 'paused';
                            }
                        },
                        {
                            label: gettextCatalog.getString('Delete'),
                            icon: 'action-delete',
                            class: 'qr-popup-menu__item--delete',
                            testEvent: 'manage-qrcode-list-item-delete',
                            callback: function () {
                                if (account.getAccountStatus() === 'expired') {
                                    $scope.open.expire = true;
                                }else if( account.getAccountPaymentOverdue() === 1 && !$scope.isAdmin ){
                                    $scope.open.blockedInvoice = true;
                                }
                                else if ($scope.isDemo) {
                                    $scope.open.demo = true;
                                    $scope.open.menu = false;
                                } else {
                                    $scope.open.delete = true;
                                }
                            }
                        }
                    ];
                }
            };

            // Feature toggle to enable duplicate code option
            $scope.duplicateCodeIsVisibleForTypes = function () {
                var allowedTypes = [
                    1, // Website
                    2, // vCard Static
                    8, // Email Static
                    9, // SMS Static
                    10, // Text Static
                    24, // Wi-Fi Static
                ];
                // Show duplicate action only to specific code types
                if($scope.value && $scope.value.type_id) {
                    return allowedTypes.includes($scope.value.type_id);
                }
                return false;
            };

            // Feature toggle to enable duplicate code option
            $scope.isFeatureToggleDuplicateCodeEnabled = function () {
                return window.GLOBAL_FEATURE_ENABLE_DUPLICATE_CODE === 'true';
            };

            /**
             * Actions for the menu.
             * @type {*}
             */
            $scope.actions = $scope.populateActions();

            $scope.initDuplicateCodeModal = function () {
                var isDynamicCode = $scope.value.trackable;
                var duplicateCodeModalTag = 'qrcg-web-component-duplicate-code-modal';
                var attributes = [
                    {
                        key: 'api-base-url',
                        value: api.getBaseUrl()
                    },
                    {
                        key: 'visible',
                        value: 'true'
                    },
                    {
                        key: '_language',
                        value: gettextCatalog.currentLanguage
                    },
                    {
                        key: 'code-id',
                        value: $scope.value.id
                    },
                    {
                        key: 'static-code',
                        value: !isDynamicCode ? 'true' : 'false'
                    },
                    {
                        key: 'code-name',
                        value: $scope.value.title || $scope.value.target_url || $scope.noTitleLabel || ''
                    },
                    {
                        key: 'populate-input-value',
                        value: 'true'
                    },
                    {
                        key: 'auto-select-input-value',
                        value: 'true'
                    },
                ];

                if ($scope.value.status !== 'paused') {
                    if (!isDynamicCode && account.isStaticQrCodeLimitReached()) {
                        attributes.push({
                            key: 'capacity-exceeded',
                            value: 'true'
                        });
                        attributes.push({
                            key: 'capacity-exceeded-message',
                            value: getStaticCapacityExceededMessage()
                        });
                    }

                    if (isDynamicCode && account.isQrCodeLimitReached()) {
                        attributes.push({
                            key: 'capacity-exceeded',
                            value: 'true'
                        });
                        attributes.push({
                            key: 'capacity-exceeded-message',
                            value: getCapacityExceededMessage()
                        });
                    }
                }
                window.qr.utils.webcomponents.init({
                    element: duplicateCodeModalTag,
                    attributes: attributes,
                    renderElement: '#qrcg-web-component-duplicate-code-modal--qrManageDownload'
                });
                // Listen to event from web-component so we can reload codes when needed
                var duplicateModalElements = document.getElementsByTagName(duplicateCodeModalTag);
                if(duplicateModalElements.length) {
                    // Listen to reload event in case API call was success and then reload all codes to get new codes in list
                    duplicateModalElements[0].addEventListener('reload', function () {
                        account.reloadAccount(function () {
                            account.reloadCodes();
                            $scope.$apply();
                        });
                    }, {
                        once: true
                    });
                }
            };

            /**
             * @returns {String}
             */
            var getCapacityExceededMessage = function () {
                return gettextCatalog.getString('You have reached the Dynamic QR Code limit. You can create up to <b>{{count}} Dynamic QR Codes</b> with your account. If you need more Dynamic QR Codes, please upgrade your account.', {
                    count: account.getAccount().qrcodes.allowed || ''
                });
            };

            /**
             * @returns {String}
             */
            var getStaticCapacityExceededMessage = function () {
                var part1 = gettextCatalog.getString('You have reached the trial period quota.');
                var part2 = gettextCatalog.getString('Thanks for testing our software, if you like to create more static codes you should consider to upgrade. With an upgrade you will be able to create unlimited static qr codes.')
                return account.isTrial() ? part1 + ' ' + part2 : part2;
            };

            /**
             * Detect window size dimensions
             * @type {*}
             */

            $scope.getWindowDimensions = function () {
                return {
                    'h': window.innerHeight,
                    'w': window.innerWidth
                };
            };

            $scope.$watch($scope.getWindowDimensions, function (newValue) {
                $scope.windowHeight = newValue.h;
                $scope.windowWidth = newValue.w;
            }, true);

            $scope.openDownload = function (forceDownload = false) {

                // Emit event to parent component so we can trigger modal from there
                $scope.$emit('openDownloadModal', $scope.value, forceDownload);

                window.dataLayer.push({
                    event: 'open_download_dialog',
                    download_dialog_open: '1'
                });
            };

            /**
             * Close pop-up menu on window resize
             */
            angular.element($window).bind('resize', function () {
                $scope.open.menu = false;
            });

            /**
             * Handler for button clicks.
             * It starts the download dialog or activates paused QR codes.
             */
            $scope.buttonClick = function () {
                if (!$scope.isDemo) {
                    if (account.getAccountStatus() === 'paused' && !$scope.isAdmin) {
                        $scope.open.paused = true;
                    } else if (account.getAccountStatus() === 'expired' && !$scope.isAdmin) {
                        if($scope.isAbTestEnabled_CNV2467()) {
                            window.qr.utils.optimizely.trackOptimizelyEvent("qrapp_manage_view_reactivate_button");
                            window.location.href = '/upgrade/?trial=ended';
                            return;
                        }
                        $scope.open.expire = true;
                    } else if ( account.getAccountPaymentOverdue() === 1 && !$scope.isAdmin ) {
                        $scope.open.blockedInvoice = true;
                    }
                    else if ( $scope.isFreeAccount && $scope.isDynamicCodeOtherThanDynamicWebsite ) {
                        $scope.open.openTypeRestrictedModal = true;
                    }
                    else if ($scope.value.status === 'paused' && account.isQrCodeLimitReached()) {
                        $scope.open.openLimitReachedModal = true;
                    } else if ($scope.value.status === 'paused' && !account.isQrCodeLimitReached()) {
                        $scope.open.activate = true;
                    }
                    else {
                        $scope.openDownload();
                        window.qr.utils.optimizely.trackOptimizelyEvent("qrapp_manage_view_download_button");
                    }
                }
                else {
                    $scope.open.demo = true;
                }
            };

            /**
             * Handler for clicks on the menu button.
             * It simply opens the menu.
             */
            $scope.menuClick = function () {
                if($scope.isAbTestEnabled_CNV2467()) {
                    return;
                }
                $scope.open.menu = !$scope.open.menu;


                window.qr.utils.optimizely.trackOptimizelyEvent("qrapp_manage_view_options_button_click");

                // Determine if the window width is less than 1200, then display the entire list in a pop-up menu
                // Otherwise display the last 2 items
                if ($scope.windowWidth <= 1200) {
                    $scope.popupItems = $scope.actions;
                } else {
                    if($scope.isFeatureToggleDuplicateCodeEnabled()) {
                        $scope.popupItems = $scope.actions.slice(-4);
                    } else {
                        $scope.popupItems = $scope.actions.slice(-2);
                    }
                }
            };

            /**
             * Get button label for the current state.
             * @returns {string}
             */
            $scope.getLabel = function () {
                if ($scope.value.status === 'paused') {
                    return gettextCatalog.getString('Activate');
                }
                if($scope.isAbTestEnabled_CNV2467()){
                    return gettextCatalog.getString('Reactivate');
                }
                return gettextCatalog.getString('Download');
            };

            // Support opening of the download dialog automatically by the event.
            $scope.$on('qr-open-download-dialog', function (event, qrCodeId, openTab) {
                if ($scope.value.id === qrCodeId) {
                    $timeout(function () { // Does not work without timeout.
                        $scope.openDownload();
                    });
                }
            });

            $timeout(function () {
                $element.find('[data-toggle="tooltip"]').tooltip({animation: false});
            });

            $scope.isAbTestEnabled_CNV2467 = function() {
                return window.qr.utils.optimizely.isAbTestVariantActive('23988530195', '24017330211');
            };

            $scope.cursorType = function() {
                if($scope.isAbTestEnabled_CNV2467()) {
                    return 'not-allowed';
                } else {
                    return 'pointer';
                }
            };
        }]
    };
}]);
;
/**
 * Folder directive for the new manage view.
 */
app.directive('qrManageFolder', ['$timeout', 'api', 'gettextCatalog', 'account', function ($timeout, api, gettextCatalog, account) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-manage-folder" ng-class="{&apos;qr-manage-folder--animated&apos;: animated}" ng-switch="isEditing()">' +
                '<div ng-switch-default>' +
                    '<a class="qr-manage-folder__button" ng-href="{{ getUrl() }}" ng-class="getClass()" data-test="{{value.testEvent || &apos;manage-folder&apos;}}">' +
                        '<span class="qr-manage-folder__icon" ng-class="getIconClass()"></span>' +
                        '<span class="qr-manage-folder__label" ng-bind="value.name"></span>' +
                        '<span class="qr-manage-folder__count" ng-show="count >= 0" data-test="manage-filter-counter">&nbsp;({{ count }})</span>' +
                        '<i class="qr-manage-folder__menu icon icon-menu-vertical" ng-click="clickMenu($event)" ng-if="menu !== false" ng-class="{\'icon-menu-vertical--visible\' : isMenuAvailable()}" data-test="manage-folder-dropdown-open"></i>' +
                    '</a>' +
                '</div>' +
                '<div class="qr-manage-folder__edit" ng-switch-when="true">' +
                    '<span class="qr-manage-folder__icon" ng-class="getIconClass()"></span>' +
                    '<input class="qr-manage-folder__input" ng-model="folderName.value" ng-blur="finishEditing()" ng-keyup="keyUp($event)" ng-disabled="sendingRequest">' +
                '</div>' +
                '<qr-popup-menu items="::actions" open="open.actions" right="true" top-offset="-10px" ng-if="open.actions" popup-menu-class="qr-popup--no-overflow {{popupMenuClass}}"></qr-popup-menu>' +
            '</div>',
        scope: {
            value: '=',         // Folder information in format {id: 123, name: 'Abc'}.
            icon: '=',          // Optional icon CSS class(es).
            count: '=',         // Optional count.
            editing: '=',       // Optional data of the folder which is editing currently.
            menu: '=',          // Optional data for show/hide the 3 dots menu.
            isMenuVisible: '=', // Optional one-way-binding variable to watch for the menu visibility.
            animated: '='       // Optional. Css class for animation
        },
        require: '^^qrManagePanel',
        link: function (scope, element, attributes, qrManagePanel) {
            scope.qrManagePanel = qrManagePanel;
            /**
             * Focus on the input.
             */
            scope.setFocus = function () {
                $timeout(function () {
                    element.find('.qr-manage-folder__input').focus();
                }, 500);
            };
        },
        controller: ['$scope', function ($scope) {
            /**
             * Indicator of sending requests to the server.
             * @type {boolean}
             */
            $scope.sendingRequest = false;

            /**
             * Opening state of actions menu.
             * @type {*}
             */
            $scope.open = {
                actions: false
            };

            /**
             * Temp buffer for editing the name (it has to be an object to work well with angular scopes).
             * @type {*}
             */
            $scope.folderName = {value: ''};

            /**
             * Class of popup menu. Used to add qr-popup--above class.
             * @type {string}
             */
            $scope.popupMenuClass = '';

            /**
             * Actions for the menu.
             * @type {*}
             */
            $scope.actions = [
                {
                    label: gettextCatalog.getString('Bulk Update'),
                    icon: 'folder-update',
                    testEvent: 'manage-folder-dropdown-bulk-update',
                    callback: function () {
                        $scope.$emit('qr-bulk-update-folder', {
                            folderId: $scope.value.id,
                            folderName: $scope.value.name,
                        });
                    }
                },
                {
                    label: gettextCatalog.getString('Rename'),
                    icon: 'avatar-edit',
                    testEvent: 'manage-folder-dropdown-rename',
                    callback: function () {
                        $scope.editing.id = $scope.value.id;
                    }
                },
                {
                    label: gettextCatalog.getString('Bulk Download'),
                    icon: 'bulk-download',
                    testEvent: 'manage-folder-dropdown-bulk-download',
                    callback: function () {
                        // Validate if queue for mass_download is already running
                        api.getJobsByType('mass_download', function (response) {
                            var inQueue = false;
                            if(response && response.data) {
                                inQueue =  !!response.data.length;
                            }
                            window.qr.utils.webcomponents.init({
                                element: "qrcg-web-component-bulk-download-modal",
                                attributes: [
                                    {
                                        key: 'folder-id',
                                        value: $scope.value.id
                                    },
                                    {
                                        key: 'api-base-url',
                                        value: api.getBaseUrl()
                                    },
                                    {
                                        key: 'visible',
                                        value: 'true'
                                    },
                                    {
                                        key: 'in-progress',
                                        value: inQueue
                                    },
                                    {
                                        key: '_language',
                                        value: gettextCatalog.currentLanguage
                                    }
                                ],
                                renderElement: '#qrcg-web-component-bulk-download-modal--qrManageFolder'
                            });
                        });
                    },
                    visible: function () {
                        return account.getCodes().length && (account.isTrial() || ['paid3', 'paid4', 'paid5'].includes(account.getAccount().type)); // Visibility validation
                    }
                },
                {
                    label: gettextCatalog.getString('Delete'),
                    icon: 'action-delete',
                    testEvent: 'manage-folder-dropdown-delete',
                    callback: function () {
                        $scope.qrManagePanel.deleteFolder($scope.value);
                    }
                },
            ];

            /**
             * Returns true if this folder is active currently.
             * @returns {boolean}
             */
            $scope.isFolderActive = function () {
               return $scope.value.id === account.getCurrentFolderId();
            };

            /**
             * Returns true if the menu is available for this folder.
             * @returns {boolean}
             */
            $scope.isMenuAvailable = function () {
                return $scope.value.id > 0 && $scope.isFolderActive();
            };

            /**
             * Open the menu.
             */
            $scope.clickMenu = function ($event) {
                if ($event) {
                    var buttonBottomPosition = $event.target.getBoundingClientRect().bottom; // Get bottom most position of click target
                    var viewportHeight = document.body.clientHeight; // Get available height
                    var popupMenuSize = 145; // Height of popup menu + some extra space

                    // Check if there is enough space to the bottom for the popup menu
                    if (viewportHeight - buttonBottomPosition < popupMenuSize) {
                        $scope.popupMenuClass = 'qr-popup--above'; // Display popup menu above
                    } else {
                        $scope.popupMenuClass = ''; // Display popup menu below
                    }
                }
                $scope.open.actions = !$scope.open.actions;
            };

            /**
             * Get CSS classes of the folder button.
             * @returns {*}
             */
            $scope.getClass = function () {
                return {
                    'qr-manage-folder__button--active': $scope.isFolderActive(),
                    'qr-manage-folder__button--expired': $scope.value.id === -3
                };
            };

            /**
             * Get folder icon CSS class.
             * @returns {string}
             */
            $scope.getIconClass = function () {
                return $scope.icon || 'icon icon-qr-folder';
            };

            /**
             * Finish editing of the label.
             */
            $scope.finishEditing = function () {
                var newFolderName = ('' + $scope.folderName.value).trim();
                if (newFolderName.length <= 0) {
                    newFolderName = gettextCatalog.getString('Untitled folder');
                }
                $scope.sendingRequest = true;
                api.updateFolder($scope.value.id, $scope.qrManagePanel.findUniqueFolderName(newFolderName, $scope.value.id), function (response) {
                    $scope.sendingRequest = false;
                    $scope.value.name = response.data.name;
                    $scope.editing.id = 0;
                    if ($scope.isFolderActive()) {
                        account.findFolderById(account.getCurrentFolderId()).name = $scope.value.name;
                    }
                }, function () {
                    $scope.sendingRequest = false;
                    $scope.editing.id = 0;
                });
            };

            /**
             * Is editing mode now?
             * @returns {boolean}
             */
            $scope.isEditing = function () {
                return $scope.editing && $scope.value.id === $scope.editing.id;
            };

            /**
             * Returns URL of the folder link.
             * @returns {string}
             */
            $scope.getUrl = function () {
                return '#!/?folder=' + account.convertFolderIdToShortName($scope.value.id);
            };

            /**
             * Process some keys for the input.
             * Finish editing when Enter or ESC is pressed.
             * @param $event
             */
            $scope.keyUp = function ($event) {
                if ($scope.isEditing() && ($event.keyCode === 13 || $event.keyCode === 27)) {
                    $scope.finishEditing();
                }
            };

            // Set focus when it's edit mode.
            $scope.$watch('editing.id', function () {
                if ($scope.isEditing()) {
                    $scope.folderName.value = $scope.value.name;
                    $scope.setFocus();
                }
            });

            // Sync isMenuVisible (one way only).
            $scope.$watch('open.actions', function () {
                $scope.isMenuVisible = $scope.open.actions;
            });
        }]
    };
}]);
;
/**
 * The download button for QR codes.
 */
app.directive('qrManageMassSelection', ['gettextCatalog', 'account', '$timeout', 'api', function (gettextCatalog, account, $timeout, api) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-manage-mass-selection">' +
                '<button type="button" class="qr-choice-button__button" ng-class="getButtonClass()" ng-click="click()" data-test="manage-mass-selection-actions">' +
                    '{{ ::title }}' +
                    '<span class="qr-choice-button__caret" ng-class="getCaretClass()"></span>' +
                '</button>' +
                '<qr-popup-menu open="open.menu" items="::actions"></qr-popup-menu>' +
                '<qr-move-to-folder-modal open="open.moveModal" codes="selectedCodes" ng-if="open.moveModal"></qr-move-to-folder-modal>' +
                '<qr-delete-code-modal open="open.deleteModal" codes="selectedCodes" ng-if="open.deleteModal"></qr-delete-code-modal>' +
                '<qr-pause-code-modal open="open.pauseModal" codes="selectedCodes" ng-if="open.pauseModal"></qr-pause-code-modal>' +
                '<qr-activate-code-modal open="open.activateModal" codes="selectedCodes" ng-if="open.activateModal"></qr-activate-code-modal>' +
                '<qr-mass-download-modal open="open.downloadModal" codes="selectedCodes" ng-if="open.downloadModal"></qr-mass-download-modal>' +
                '<qr-expired-modal open="open.expireModal" ng-if="open.expireModal"></qr-expired-modal>' +
                '<qr-paused-modal open="open.accountPausedModal" ng-if="open.accountPausedModal"></qr-paused-modal>' +
            '</div>',
        scope: {
            open: '=',          // Optional open state of the menu.
            selectedCodes: '='  // Array of selected codes (IDs).
        },
        controller: ['$scope', function ($scope) {
            /**
             * Translations.
             */
            $scope.title = gettextCatalog.getString('Actions');

            /**
             * Open states of all modals.
             * @type {*}
             */
            $scope.open = {
                menu: false,
                pauseModal: false,
                moveModal: false,
                deleteModal: false,
                activateModal: false,
                downloadModal: false,
                expireModal: false,
                accountPausedModal: false,
            };

            /**
             * Actions for the menu.
             * @type {*}
             */
            $scope.actions = [
                {
                    label: gettextCatalog.getString('Pause'),
                    testEvent: 'manage-mass-selection-action-pause',
                    callback: function () {
                        if (account.getAccountStatus() === 'paused') {
                            $scope.open.accountPausedModal = true;
                        } else if (account.getAccountStatus() === 'expired') {
                            $scope.open.expireModal = true;
                        } else {
                            $scope.open.pauseModal = true;
                        }
                    },
                    visible: function () {
                        return $scope.getSelectedCodesStatus() === 'active' ||
                            $scope.getSelectedCodesStatus() === '';
                    }
                },
                {
                    label: gettextCatalog.getString('Activate'),
                    testEvent: 'manage-mass-selection-action-activate',
                    callback: function () {
                        if (account.getAccountStatus() === 'expired') {
                            $scope.open.expireModal = true;
                        } else {
                            $scope.open.activateModal = true;
                        }
                    },
                    visible: function () {
                        return $scope.getSelectedCodesStatus() === 'paused' ||
                            $scope.getSelectedCodesStatus() === '';
                    }
                },
                {
                    label: gettextCatalog.getString('Move to folder'),
                    testEvent: 'manage-mass-selection-action-move-to-folder',
                    callback: function () {
                        if (account.getAccountStatus() === 'expired') {
                            $scope.open.expireModal = true;
                        } else {
                            // A timeout is needed to display the modal after the menu is already hidden.
                            $timeout(function () {
                                $scope.open.moveModal = true;
                            });
                        }
                    }
                },
                {
                    label: gettextCatalog.getString('Download'),
                    testEvent: 'manage-mass-selection-action-download',
                    callback: function () {
                        if (account.getAccountStatus() === 'expired') {
                            $scope.open.expireModal = true;
                        } else {
                            $scope.open.downloadModal = true;
                        }
                    },
                    visible: function () { // Hidden because it's too slow at the moment.
                        return false;
                    }
                },
                {
                    label: gettextCatalog.getString('Bulk download'),
                    testEvent: 'manage-mass-selection-action-bulk-download',
                    callback: function () {
                        // Validate if queue for mass_download is already running
                        api.getJobsByType('mass_download', function (response) {
                            var inQueue = false;
                            if(response && response.data) {
                                inQueue =  !!response.data.length;
                            }
                            window.qr.utils.webcomponents.init({
                                element: "qrcg-web-component-bulk-download-modal",
                                attributes: [
                                    {
                                        key: 'code-ids',
                                        value: JSON.stringify($scope.selectedCodes)
                                    },
                                    {
                                        key: 'api-base-url',
                                        value: api.getBaseUrl()
                                    },
                                    {
                                        key: 'visible',
                                        value: 'true'
                                    },
                                    {
                                        key: 'in-progress',
                                        value: inQueue
                                    },
                                    {
                                        key: '_language',
                                        value: gettextCatalog.currentLanguage
                                    }
                                ],
                                renderElement: '#qrcg-web-component-bulk-download-modal--qrManageMassSelection'
                            });
                        });
                    },
                    visible: function () {
                        return account.isTrial() || ['paid3', 'paid4', 'paid5'].includes(account.getAccount().type); // Visibility validation for selected plans
                    }
                },
                {
                    label: gettextCatalog.getString('Delete'),
                    testEvent: 'manage-mass-selection-action-delete',
                    callback: function () {
                        if (account.getAccountStatus() === 'expired') {
                            $scope.open.expireModal = true;
                        } else {
                            $scope.open.deleteModal = true;
                        }
                    },
                    visible: function () {
                        return $scope.getSelectedCodesStatus() === 'paused';
                    }
                },
            ];


            /**
             * Return one single status of all selected codes, if possible.
             * If the codes are different, it returns an empty string.
             * @returns {string}
             */
            $scope.getSelectedCodesStatus = function () {
                var statuses = {};
                angular.forEach(account.getCodes(), function (code) {
                    if ($scope.selectedCodes.indexOf(code.id) >= 0) {
                        statuses[code.status] = true;
                    }
                });
                return Object.keys(statuses).length === 1 ? Object.keys(statuses)[0] : '';
            };

            /**
             * Open the menu.
             */
            $scope.click = function () {
                $scope.open.menu = !$scope.open.menu;
            };

            $scope.getButtonClass = function () {
                return {
                    'qr-choice-button__button--open': $scope.open.menu
                };
            };

            /**
             * Get CSS classes of the caret icon.
             * @returns {*}
             */
            $scope.getCaretClass = function () {
                return {
                    'qr-choice-button__caret--open': $scope.open.menu
                };
            };

        }]
    };
}]);
;
/**
 * A modal for pausing QR codes.
 */
app.directive('qrPauseCodeModal', ['api', 'gettextCatalog', 'account', '$sce', function (api, gettextCatalog, account, $sce) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" data-title="{{ getTitle() }}" buttons="::buttons">' +
                '<div class="qr-pause-code-modal__content" ng-bind-html="::message"></div>' +
            '</qr-modal>',
        scope: {
            open: '=',      // Open state of the modal.
            qrCode: '=',    // QR code data.
            codes: '='      // Array of QR codes IDs, if working with several codes at the same time.
        },
        controller: ['$scope', function ($scope) {
            /**
             * Translations
             */
            $scope.message = $sce.trustAsHtml(gettextCatalog.getString(
                'Pausing QR Codes will deactivate it and make it no longer accessible for your customers. ' +
                'You can reactivate paused QR Codes under {{icon}} Paused anytime.', {
                    icon: '<span class="icon icon-qr-paused"></span>'
                })
            );

            /**
             * @returns {String}
             */
            $scope.getTitle = function () {
                if ($scope.qrCode || !$scope.codes) {
                    return gettextCatalog.getString('Pause QR Code');
                }
                return gettextCatalog.getPlural(
                    $scope.codes.length,
                    'Pause 1 QR Code',
                    'Pause {{$count}} QR Codes',
                    {}
                );
            };

            /**
             * Array of buttons for the Pause QR Code modal.
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Pause'),
                    callback: function () {
                        $scope.open = false;
                        if ($scope.qrCode) {
                            api.updateCodeStatus($scope.qrCode.id, 'paused', function () {
                                $scope.qrCode.status = 'paused';
                                account.reloadAccountWithoutFolders();
                                account.recheckCodesVisibility(true);
                            });
                        } else {
                            api.massPauseCodes($scope.codes, function () {
                                angular.forEach(account.getCodesByIds($scope.codes), function (qrCode) {
                                    qrCode.status = 'paused';
                                });
                                account.reloadAccountWithoutFolders();
                                account.recheckCodesVisibility(true);
                            });
                        }
                    }
                },
                {
                    label: gettextCatalog.getString('Cancel'),
                    type: 'link',
                    callback: function () {
                        $scope.open = false;
                    }
                }
            ];
        }]
    };
}]);
;
/**
 * Navigation panel on the right for the new manage view.
 */
app.directive('qrManagePanel', ['api', '$window', '$timeout', '$rootScope', 'gettextCatalog', 'account', '$location', '$log', '$document', 'tracking', function (api, $window, $timeout, $rootScope, gettextCatalog, account, $location, $log, $document, tracking) {
    return {
        restrict: 'E',
        template:
            '<qr-expired-modal open="open.expire" ng-if="open.expire"></qr-expired-modal>' +
            '<div class="qr-manage-panel qr-manage-panel--close">' +
                '<div class="qr-manage-panel__scrollable-container" ng-style="getPanelStyle()" ng-class="{\'qr-manage-panel--trial\': isTrialMessageVisible()}">' +
                    '<div class="qr-manage-panel__search">' +
                        '<i class="qr-manage-panel__search__icon icon-qr-search"></i>' +
                        '<input class="qr-manage-panel__search__input" placeholder="{{ ::searchPlaceholder }}" ng-model="searchQuery" ng-model-options="{debounce: 300, getterSetter: true}" data-test="manage-qrcode-search">' +
                        '<i class="qr-manage-panel__search__icon-delete icon-event-close" ng-show="searchQuery()" ng-click="searchQuery(&apos;&apos;)"></i>' +
                    '</div>' +
                    '<h6 class="qr-manage-panel__heading" ng-bind="::qrHeading"></h6>' +
                    '<qr-manage-folder ng-repeat="filter in filters" value="::filter" icon="::filter.icon" count="filter.count" ng-show="filter.visible" menu="false"></qr-manage-folder>' +
                    '<div ng-class="lineClass"></div>' +
                    '<h6 class="qr-manage-panel__heading" ng-bind="::foldersHeading"></h6>' +
                    '<qr-manage-folder ng-repeat="folder in getFolders()" value="folder" editing="editing" is-menu-visible="isAnyFolderMenuVisible.value" animated="true"></qr-manage-folder>' +
                    '<button type="button" class="qr-manage-panel__add" ng-click="addFolder()" data-ng-disabled="addingFolder" data-test="manage-add-folder">' +
                        '<span class="qr-manage-panel__icon icon icon-plus-1"></span>' +
                        '{{ ::newFolderLabel }}' +
                    '</button>' +
                    '<qr-modal data-title="{{ ::deleteFolderTitle }}" open="open.delete" buttons="::deleteButtons" ng-if="open.delete">' +
                        '<div class="qr-manage-panel__delete-modal-content">' +
                            '{{ ::deleteMessage }} <span class="icon icon-qr-all"></span> {{ ::allLabel }}' +
                        '</div>' +
                    '</qr-modal>' +
                '</div>' +
                '<qr-trial-left ng-if="isTrialMessageVisible()" trial-date="getTrialDate()" class="sidebar-trial" trial-countdown="false"></qr-trial-left>' +
            '</div>' +
            '<qr-mass-update-modal open="massUpdate.open" folder-id="massUpdate.folderId" folder-name="massUpdate.folderName" code-type="d_url"></qr-mass-update-modal>',
        scope: {
            isAdmin: '='
        },
        controller: ['$scope', function ($scope) {
            /**
             * Translations.
             */
            $scope.searchPlaceholder = gettextCatalog.getString('Search QR Codes...');
            $scope.qrHeading = gettextCatalog.getString('My QR Codes');
            $scope.foldersHeading = gettextCatalog.getString('My Folders');
            $scope.newFolderLabel = gettextCatalog.getString('New Folder');
            $scope.deleteFolderTitle = gettextCatalog.getString('Delete Folder');
            $scope.allLabel = gettextCatalog.getString('All');
            $scope.deleteMessage = gettextCatalog.getString('Deleting this folder will not delete any QR Codes. They remain under');

            $scope.lineClass = "qr-manage-panel__line--loading";

            /**
             * Get the array of user's folders.
             * @type {Array}
             */
            $scope.getFolders = function () {
                return account.getFolders();
            };

            /**
             * Search query for the search functionality.
             * @param {string} [newValue]
             * @returns {string}
             */
            $scope.searchQuery = function (newValue) {
                if (arguments.length) {
                    var oldValue = account.getSearchQuery();
                    if (oldValue !== newValue) {
                        $location.url(account.getCurrentUrl({
                            page: 1,
                            search: newValue
                        }).substr(2));
                    }
                    return newValue;
                }
                return account.getSearchQuery();
            };

            /**
             * @returns {boolean}
             */
            $scope.isTrialMessageVisible = function () {
                return account.getAccountStatus() === 'trial';
            };

            /**
             * @returns {string}
             */
            $scope.getTrialDate = function () {
                return account.getAccount().trial_date;
            };

            /**
             * Open states of the modals.
             * @type {{expire: boolean, delete: boolean}}
             */
            $scope.open = {
                expire: false,
                delete: false
            };

            /**
             * Indicator of adding a folder.
             * @type {boolean}
             */
            $scope.addingFolder = false;

            /**
             * Data of the folder that is in edit mode now.
             * @type {{id: number}}
             */
            $scope.editing = {id: 0};

            /**
             * ID of folder to delete.
             * @type {boolean|number}
             */
            $scope.deleteFolderId = false;

            /**
             * This variable will be updated inside qrManageFolder.
             * It's needed to watch for the folder menus.
             * An object is required to deal with ng-repeat scopes.
             * @type {*}
             */
            $scope.isAnyFolderMenuVisible = {value: false};

            /**
             * Array of built-in filters.
             * @type {*}
             */
            $scope.filters = [
                {
                    id: 0,
                    icon: 'icon icon-qr-all',
                    name: gettextCatalog.getString('All'),
                    visible: true,
                    testEvent: 'manage-filter-all'
                },
                {
                    id: -1,
                    icon: 'icon icon-active',
                    name: gettextCatalog.getString('Active'),
                    visible: true,
                    testEvent: 'manage-filter-active'
                },
                {
                    id: -2,
                    icon: 'icon icon-qr-paused',
                    name: gettextCatalog.getString('Paused'),
                    visible: true,
                    testEvent: 'manage-filter-paused'
                },
                {
                    id: -3,
                    icon: 'icon icon-qr-expired',
                    name: gettextCatalog.getString('Expired'),
                    visible: false,
                    testEvent: 'manage-filter-expired'
                }
            ];

            /**
             * Array of buttons for the delete modal.
             * @type {Array}
             */
            $scope.deleteButtons = [
                {
                    label: gettextCatalog.getString('Delete'),
                    type: 'danger',
                    callback: function () {
                        api.deleteFolder($scope.deleteFolderId, function () {
                            $location.replace().url('/?folder=all'); // Switch to All from current folder, replacing history state.
                            account.deleteFolderById($scope.deleteFolderId);
                            $scope.open.delete = false;
                        });
                    }
                },
                {
                    label: gettextCatalog.getString('Cancel'),
                    type: 'link',
                    callback: function () {
                        $scope.open.delete = false;
                    }
                }
            ];

            $scope.massUpdate = {
                open: false,
                folderId: null,
                folderName: '',
            };

            // Sync internal data with account info.
            $scope.$watch(function () {
                return account.getAccount();
            }, function (acc) {
                if ('statistics' in acc) {
                    $scope.filters[0].count = acc.statistics.all || 0;
                    $scope.filters[1].count = acc.statistics.active || 0;
                    $scope.filters[2].count = acc.statistics.paused || 0;
                    $scope.filters[3].count = acc.statistics.expired || 0;
                }
                $scope.filters[3].visible = acc.status === 'expired' && $scope.filters[3].count > 0;

                // Switch to Expired tab, if it's an expired account with QR codes.
                if ($scope.filters[3].visible) {
                    $location.url('/?folder=expired'); // This line switched to folder, but keeps the browser history.
                }
            }, true);

            /**
             * Find folder by name.
             * @param {string} folderName
             * @param {number} [ignoreFolderId]
             * @returns {*}
             */
            $scope.findFolderByName = function (folderName, ignoreFolderId) {
                var result = false;
                angular.forEach(account.getFolders(), function (folder) {
                    if (folder.name === folderName && folder.id !== ignoreFolderId) {
                        result = folder;
                    }
                });
                return result;
            };

            /**
             * Find an unique folder name.
             * @param {string} baseFolderName
             * @param {number} [ignoreFolderId]
             * @returns {string}
             */
            $scope.findUniqueFolderName = function (baseFolderName, ignoreFolderId) {
                var i, folderName = baseFolderName;
                for (i = 2; $scope.findFolderByName(folderName, ignoreFolderId); ++i) {
                    folderName = baseFolderName + ' ' + i;
                }
                return folderName;
            };

            /**
             * Create new folder and select it.
             */
            $scope.addFolder = function () {
                if (account.getAccountStatus() === 'expired' && !$scope.isAdmin) {
                    $scope.open.expire = true;
                } else {
                    $scope.addingFolder = true;
                    api.createFolder($scope.findUniqueFolderName(gettextCatalog.getString('Untitled folder')), function (response) {
                        $scope.addingFolder = false;
                        account.pushFolder(response.data);
                        $location.url('/?folder=' + response.data.id);
                        $scope.editing.id = response.data.id; // This option enables edit-mode for the folder.
                        // Track creating of folders.
                        $timeout(function () {
                            tracking.trackEvent('create_folder');
                        });
                    }, function () {
                        $scope.addingFolder = false;
                    });
                }
            };

            /**
             * Close manage panel on options click
             */
            $scope.closePanel = function () {
                // A timeout is needed to get the latest value of isAnyFolderMenuVisible.
                //$timeout(function () {
                    if (/**!$scope.isAnyFolderMenuVisible.value && */$window.innerWidth < 1025) {
                        $(".qr-manage-panel").addClass("qr-manage-panel--close");
                        $("body").addClass("panelIsClosed");
                        $(".qr-manage-content").addClass("qr-manage-content--panel-close");
                        $(".qr-manage-content").removeClass("qr-manage-content--panel-open");
                        //$(".qr-popup__layer").removeClass("qr-popup__layer--open");
                    } else {
                        $("body").removeClass("panelIsClosed");

                        $(".qr-manage-content").addClass("qr-manage-content--panel-open");
                    }
                //});
            };

            //@todo - comment
            $scope.getPanelStyle = function () {
                if (account.getAccountStatus() === "trial") {
                    return {
                        paddingBottom: "109px"
                    };
                }
            };

            // Try to close panel on every filters/folders change.
            // It reacted to clicks before, but it didn't work because of editing and deleting functions that require clicks too.
            $scope.$watch(function () {
                return account.getCurrentFolderId();
            }, function () {
                // If editing is in progress, then don't close the panel.
                if ($scope.editing.id === 0) {
                    $scope.closePanel();
                }
            });

            /**
             * Delete a folder (API for folders).
             * @param folder
             */
            this.deleteFolder = function (folder) {
                $scope.deleteFolderId = folder.id;
                // If there's 0 codes, delete the folder without confirmation.
                if (account.getCodes().length === 0) {
                    $scope.deleteButtons[0].callback();
                } else {
                    $scope.open.delete = true;
                }
            };

            /**
             * Find an unique folder name (API for folders).
             * @param {string} baseFolderName
             * @param {number} [ignoreFolderId]
             * @returns {string}
             */
            this.findUniqueFolderName = function (baseFolderName, ignoreFolderId) {
                return $scope.findUniqueFolderName(baseFolderName, ignoreFolderId);
            };

            // Update perfect scrollbar in case of changing folders.
            $scope.$watch(function () {
                return account.getFolders().length;
            }, function () {
                if (account.getFolders().length > 0) {
                    setTimeout(function () {
                        $('.qr-manage-panel .qr-manage-panel__scrollable-container').perfectScrollbar('update');
                    }, 0);

                    $timeout(function () {
                        $scope.lineClass = "qr-manage-panel__line";
                    }, 800);
                }

                $timeout(function () {
                    if (account.getFolders().length === 0 && !account.isLoadingFolders()) {
                        $scope.lineClass = "qr-manage-panel__line";
                    }
                }, 1000);

            });

            // Initialize the perfect scrollbar plugin.
            angular.element($document).ready(function () {
                $('.qr-manage-panel .qr-manage-panel__scrollable-container').perfectScrollbar({includePadding: true, swipePropagation: false});
            });

            // Listen for bulk update trigger
            $scope.$on('qr-bulk-update-folder', function (event, params) {
                $scope.massUpdate.open = true;
                $scope.massUpdate.folderId = params.folderId;
                $scope.massUpdate.folderName = params.folderName;
            });
        }]
    };
}]);
;
/**
 * New manage view for users' QR codes.
 */
app.directive('qrManageView', ['$log', '$timeout', 'api', 'account', '$window', '$rootScope', '$location', 'aws', '$cookies', 'tracking', function ($log, $timeout, api, account, $window, $rootScope, $location, aws, $cookies, tracking) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-manage-view">' +
                '<qr-manage-panel is-admin="isAdmin"></qr-manage-panel>' +
                '<qr-manage-content is-admin="isAdmin"></qr-manage-content>' +
                '<qr-error-modal open="open.error" ng-if="open.error"></qr-error-modal>' +
            '</div>',
        scope: {
            isAdmin: '=',           // True if the user is admin.
            awsCredentials: '='     // Credentials for AWS uploading.
        },
        controller: ['$scope', function ($scope) {
            $scope.manageContentItems = angular.element(".qr-manage-content__items");
            $scope.menuPanel = angular.element(".qr-manage-panel");
            $scope.alertBanner = angular.element(".qr-manage-content__banner");

            // Some init things before everything else.
            aws.setCredentials($scope.awsCredentials);

            /**
             * Open states of the modals.
             * @type {*}
             */
            $scope.open = {
                error: false
            };

            /**
             * Update some information in mixpanel and intercom.
             * It's called on init only once.
             */
            $scope.updateExternalServices = function () {
                if (account.getCodes().length <= 0) {
                    return;
                }
                var open, match, firstCode = account.getCodes()[0];

                // $log.debug('updateExternalServices... [QR type ' + firstCode.type_id + ']');

                // Process some URL params on init (it usually means a redirect from /create/ page).
                if ($window.location.href.match(/aftercreate=1/)) {

                    if(firstCode.trackable === 1) {
                        // Tracking created dynamic QR Codes
                        window.dataLayer.push({
                            event: 'created_code',
                            qr_code_type: firstCode.type_name
                        });
                    } else {
                        // Tracking created static QR Codes
                        window.dataLayer.push({
                            event: 'created_static_code',
                            qr_code_type: firstCode.type_name
                        });
                    }

                    // If the user already has 1 QR Code or more, we track this
                    if(account.getCodes().length > 1) {
                        window.dataLayer.push({
                            event: 'created_multiple_codes',
                        });
                    }

                    // Open new custom download dialog on new created codes
                    // Store cookie to avoid reopening on history.back
                    $timeout(function () {

                        if (!$cookies.get('qr_download_opened_'+firstCode.id)) {
                            $rootScope.$broadcast('qr-open-download-dialog', firstCode.id);

                            // Open only once per 7 days.
                            $cookies.put('qr_download_opened_'+firstCode.id, 1, {
                                path: '/',
                                secure: false,
                                expires: new Date(5 * 60 * 1000 + (+new Date())), // 5 minutes.
                                domain: '.qr-code-generator.com'
                            });

                            //Track the created code type
                            tracking.trackEvent('created_code_type_' + firstCode.type_id);
                        }
                    }, 750);

                    match = $window.location.href.match(/count=(\d+)/);
                    if (match && match[1] === '1') {

                        // Track type of created QR Code dynamic/static
                        if (firstCode.short_url.length === 0) { // Static Code
                            tracking.trackEvent('created_static_codes');
                        } else { // Dynamic Code
                            tracking.trackEvent('created_dynamic_codes');
                        }

                        mixpanel.track('code created', {
                            code_type_id: firstCode.type_id
                        });
                        Intercom('update', {
                            id: $window.intercomSettings.user_id,
                            first_qr_code_type: firstCode.type_id,
                            latest_qr_code_type: firstCode.type_id
                        });

                    } else {

                        // Track type of created QR Code dynamic/static
                        if (firstCode.short_url.length === 0) { // Static Code
                            tracking.trackEvent('created_static_codes');
                        } else { // Dynamic Code
                            tracking.trackEvent('created_dynamic_codes');
                        }

                        mixpanel.track('code created', {
                            code_type_id: firstCode.type_id
                        });
                        Intercom('update', {
                            id: $window.intercomSettings.user_id,
                            latest_qr_code_type: firstCode.type_id
                        });
                    }
                }

                // Support opening of the download dialog by a sessionStorage parameter.
                if ((open = $cookies.get('open_download'))) {
                    $cookies.put('open_download', '', { // Removing a cookie doesn't work sometimes, so set it to empty value.
                        path: '/'
                    });
                    $cookies.remove('open_download');
                    open = open.split(':'); // format: "<tab_id>:<qr_code_id>", e.g. "url:12345".
                    if (open.length === 2 && open[0].length > 0 && open[1] > 0) {
                        // $log.debug('Opening the download dialog for QR code #' + open[1] + ' (' + open[0] + ')');
                        $timeout(function () {
                            $rootScope.$broadcast('qr-open-download-dialog', parseInt(open[1], 10), open[0]);
                        }, 500);
                    }
                }
            };

            // Initial loading of account including folders and statistics.
            $timeout(function () {
                // $log.debug('qrManageView init...');
                account.reloadCodes(function () {
                    // updateExternalServices() should be called after QR codes are loaded and ready.
                    $scope.updateExternalServices();
                }, true);
                account.reloadAccount();
            });

            // Open the error modal if needed.
            $scope.$watch(function () {
                return account.hasErrors();
            }, function () {
                if (account.hasErrors()) {
                    account.clearErrors();
                    $scope.open.error = true;
                }
            });

            $scope.$watch(function() {
                return account.getAccountStatus();
            }, function() {
                // $scope.open.paused = account.getAccountStatus() === 'paused';
            });

            // Support deep links to folders.
            $rootScope.$on('$locationChangeStart', function () {
                // $log.debug('Changing path to ' + $location.path() + ' (URL ' + $location.url() + ')');
                if ('/' === $location.path()) {

                    var oldUrl = account.getCurrentUrl({view: '', id: 0});

                    account.setCurrentView('');
                    account.setCurrentState($location.search());
                    if (account.getCodes().length <= 0 || oldUrl !== account.getCurrentUrl()) {
                        account.reloadCodes();
                    }

                    $scope.menuPanel.removeClass('qr-manage-panel--statistics-close');
                } else if ('/insights' === $location.path()) {
                    account.setCurrentView('');
                    account.setCurrentState($location.search());
                    if (account.getCodes().length <= 0) {

                        // When we open directly page '/insights' by default we hide panel and qr codes content
                        $scope.manageContentItems.addClass('hidden');
                        $scope.alertBanner.addClass('hidden');
                        $scope.menuPanel.addClass('hidden qr-manage-panel--statistics-close');

                        account.reloadCodes(function () {

                            // Switch to insights only when QR codes are loaded and ready.
                            account.setCurrentView('insights');

                            $timeout(function () {
                                $scope.manageContentItems.removeClass('hidden');
                                $scope.menuPanel.removeClass('hidden');
                            }, 2000);

                        });
                    } else {
                        account.setCurrentView('insights');
                    }
                }
            });

            // Update statistics periodically (every 60 seconds).
            function updateAccountAndScans () {
                var oldScans = (account.getAccount().statistics || {}).scans || 0;
                account.reloadAccountWithoutFolders(function () {
                    var newScans = (account.getAccount().statistics || {}).scans || 0;
                    if (oldScans !== newScans) {
                        account.reloadCodesScans();
                    }
                    $timeout(updateAccountAndScans, 60 * 1000);
                }, true);
            }
            $timeout(updateAccountAndScans, 60 * 1000);
        }]
    };
}]);
;
app.directive('qrTrialEnded', ['gettextCatalog', 'markup', function (gettextCatalog, markup) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-trial-ended">' +
                '<div class="qr-trial-ended__container">' +
                    '<h6 class="qr-trial-ended__title" ng-bind="::titleLabel"></h6>' +
                    '<p class="qr-trial-ended__message" ng-bind-html="::messageLabel" ng-if="!isAbTestEnabled_CNV2467()"></p>' +
                    '<p class="qr-trial-ended__message" ng-if="isAbTestEnabled_CNV2467()">' +
                        'To continue using QR Code Generator Pro, ' +
                        '<a href="/upgrade/?from=afterTrialBar&expired=1" class="qr-trial-ended__link" ng-click="clickUpgrade()">upgrade your account</a>.' +
                    '</p>' +
                '</div>' +
            '</div>',
        scope: {
            imageUrl: '@'
        },
        controller: ['$scope', function ($scope) {
            /**
             * Translations.
             */
            $scope.titleLabel = gettextCatalog.getString('Your 14-day trial has ended');

            $scope.messageLabel = markup.convertToHTML(
                gettextCatalog.getString(
                    'To continue using QR Code Generator Pro, [link={{url}}]upgrade your account[/link].', {
                        url: '/upgrade/?from=afterTrialBar&expired=1'
                    }),
                'qr-trial-ended__link'
            );

            $scope.clickUpgrade = function () {
                window.qr.utils.optimizely.trackOptimizelyEvent("qrapp_trial_expired_view_upgrade");
            };

            $scope.isAbTestEnabled_CNV2467 = function() {
                // Checking for "original" variant here
                return window.qr.utils.optimizely.isAbTestVariantActive('23988530195', '23975420264');
            };
        }]
    };
}]);
;
/**
 * The banner, that shows users, that their account is paused.
 */
app.directive('qrFreePlanBanner', ['api', 'gettextCatalog', function (api, gettextCatalog) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-paused-banner">' +
            '<div class="qr-paused-banner__container">' +

            '<div class="qr-paused-banner__container--text floated">' +
            '<h3 class="qr-paused-banner__title" ng-bind="titleLabel"></h3>' +
            '<p class="qr-paused-banner__message" ng-bind="::messageLabelTop"></p>' +
            '</div>' +

            '</div>' +
            '</div>',
        scope: {
            resumeModal: '='
        },
        controller: ['$scope', function ($scope) {
            /**
             * Translations.
             */
            $scope.titleLabel = gettextCatalog.getString('Thank you for activating the Free Plan!');
            $scope.messageLabelTop = gettextCatalog.getString('The Free Plan has been successfully activated for your account.');
        }]
    };
}]);
;
app.directive('qrTrialLeft', ['gettextCatalog', 'account', '$timeout', function (gettextCatalog, account, $timeout) {
    return {
        restrict: 'E',
        template:
        '<div class="qr-trial-left">' +
            '<div class="qr-trial-left__days-left" ng-bind="trialMessage"></div>' +
            '<qr-countdown-timer ng-if="trialCountdown && isTrialCountdownTimerEnabled()"></qr-countdown-timer>' +
            '<div ng-if="trialCountdown && isTrialCountdownTimerEnabled()" class="qr-trial-left__subtitle" ng-bind="trialSubtitle"></div>' +
            '<div class="qr-trial-left__upgrade-link">' +
                '<a ng-href="{{ trialLink }}" ng-bind="::upgradeLabel" ng-click="trackNavUpgreadeButtonClick()" data-trial-link></a>' +
            '</div>' +
        '</div>',
        scope: {
            trialDate: '=',
            trialCountdown: '='
        },
        controller: ['$scope', function ($scope) {

            // Current window size
            var windowWidth = window.innerWidth ? window.innerWidth : $(window).width();

            /**
             * Translations.
             */
            $scope.upgradeLabel = gettextCatalog.getString('Upgrade');

            $scope.trialSubtitle = gettextCatalog.getString(
                "After which all of your dynamic QR Codes will expire until you upgrade to a plan."
            );
            $scope.trialLeft = 0;
            $scope.trialMessage = '';
            $scope.trialLink = '/upgrade/?trial=sidebar';

            $scope.$watch('trialDate', function() {
                if ($scope.trialDate) {
                    $scope.trialLeft = account.getAccountTrialDaysLeft();
                    $scope.trialMessage = $scope.trialCountdown && $scope.isTrialCountdownTimerEnabled() ?
                        gettextCatalog.getString("Free Trial ends in") : gettextCatalog.getPlural(
                        $scope.trialLeft,
                        'Free Trial ends in {{$count}} day',
                        'Free Trial ends in {{$count}} days',
                        {}
                    );
                }
            });

            $timeout(function () {
               if (angular.element('body').hasClass('trial-banner--navbar')) {
                   $scope.trialLink = '/upgrade/?trial=navbar';

                   // If statement to change the link for the "Upgrade" button, if windowWidth < 1025
                   if (windowWidth < 1025) {
                       $scope.trialLink = '/upgrade/?trial=navbarToSidebar';
                   }
               }
            }, 100);

            $scope.trackNavUpgreadeButtonClick = function () {
                window.qr.utils.optimizely.trackOptimizelyEvent("qrapp_nav_upgrade_button");
            };

            $scope.isTrialCountdownTimerEnabled = function () {
                var userCreatedDate = new Date(window.GLOBAL_USER_CREATED_AT);
                var featureStartedDate = new Date('2022-08-25 00:00:00');

                return window.GLOBAL_FEATURE_ENABLE_TRIAL_COUNTDOWN_TIMER === 'true' && userCreatedDate > featureStartedDate;
            };
        }]
    };
}]);

;
app.directive('qrOpenInvoice', ['tracking', function (tracking) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-open-invoice" ng-show="open">' +
                '<div class="qr-open-invoice__container">' +
                    '<h6 class="qr-open-invoice__title" ng-bind="::title"></h6>' +
                    '<p class="qr-open-invoice__message" ng-bind-html="getMessage()"></p>' +
                '</div>' +
            '</div>',
        scope: {
            paymentTxId: '=',   // Transaction ID.
            open: '='           // Open/Close flag.
        },
        controller: ['$scope', 'gettextCatalog', '$sce', '$window', 'markup', function ($scope, gettextCatalog, $sce, $window, markup) {
            /**
             * Translations.
             */
            $scope.title = gettextCatalog.getString('There is an unpaid invoice in your account');

            $scope.getMessage = function () {
                return markup.convertToHTML(
                    gettextCatalog.getString('[link={{payUrl}}][[Pay now by credit card]][/link] or go to [link={{billingUrl}}][[Billing]][/link] for more information.', {
                        payUrl: '/billing/?unpaidinvoice',
                        billingUrl: '/billing/?unpaidinvoice'
                    }),
                    'qr-open-invoice__link'
                );
            };

            // Track opening of the window.
            $scope.$watch('open', function () {
                if ($scope.open) {
                    tracking.trackEvent('saw_open_invoice_screen');
                }
            });
        }]
    };
}]);
;
/**
 * Displays pagination bar.
 */
app.directive('qrPagination', ['account', '$location', function (account, $location) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-pagination">' +
                '<a class="qr-pagination__button qr-pagination__button--first" ng-href="{{ getFirstPageUrl() }}">' +
                    '<span class="icon icon-qr-chevron-left-2x"></span>' +
                '</a>' +
                '<a class="qr-pagination__button qr-pagination__button--prev" ng-href="{{ getPrevPageUrl() }}">' +
                    '<span class="icon icon-qr-chevron-left"></span>' +
                '</a>' +
                '<a ng-repeat="index in getPages()" class="qr-pagination__button" ng-class="getPageClass(index)" ng-href="{{ getPageUrl(index) }}">' +
                    '{{ index }}' +
                '</a>' +
                '<a class="qr-pagination__button qr-pagination__button--next" ng-href="{{ getNextPageUrl() }}">' +
                    '<span class="icon icon-qr-chevron-right"></span>' +
                '</a>' +
                '<a class="qr-pagination__button qr-pagination__button--last" ng-href="{{ getLastPageUrl() }}">' +
                    '<span class="icon icon-qr-chevron-right-2x"></span>' +
                '</a>' +
                '<qr-choice-button class="qr-pagination__sizes" items="sizes" right="true" value="sizeValue" type="small,bordered"></qr-choice-button>' +
            '</div>',
        scope: {
        },
        controller: ['$scope', function ($scope) {
            /**
             * Page sizes.
             * @type {Array}
             */
            $scope.sizes = [
                {label: 10, value: 10},
                {label: 20, value: 20},
                {label: 50, value: 50},
                {label: 100, value: 100}
            ];

            // Sync size value
            $scope.sizeValue = angular.extend({}, $scope.sizes[0]);
            $scope.$watch('sizeValue.value', function () {
                if (arguments[0] === arguments[1]) { // Otherwise the next command will always redirect to the first page of current folder.
                    return;
                }
                $location.url(account.getCurrentUrl({
                    page: 1,
                    pageSize: $scope.sizeValue.value
                }).substr(2));
            });

            /**
             * Get CSS classes for one page button.
             * @param {number} index 1..pageCount
             * @returns {*}
             */
            $scope.getPageClass = function (index) {
                return {
                    'qr-pagination__button--active': index === account.getPagination().page
                };
            };

            /**
             * Get pages array.
             * @returns {number[]}
             */
            $scope.getPages = function () {
                var pagination = account.getPagination(), pages = [], n = pagination.pageCount, a, b;
                if (n <= 5) {
                    a = 1;
                    b = n;
                } else {
                    a = pagination.page - 2;
                    b = pagination.page + 2;
                    if (a < 1) {
                        b += 1 - a;
                        a = 1;
                    }
                    if (b > n) {
                        a -= b - n;
                        b = n;
                    }
                }
                for (var i = a; i <= b; ++i) {
                    pages.push(i);
                }
                return pages;
            };

            /**
             * Get URL for pagination links.
             * @param {number|string} index
             * @returns {string}
             */
            $scope.getPageUrl = function (index) {
                if (index < 1 || index > account.getPagination().pageCount) {
                    return '#';
                }
                return account.getCurrentUrl({
                    page: index
                });
            };

            /**
             * @returns {string}
             */
            $scope.getNextPageUrl = function () {
                var pagination = account.getPagination();
                return account.getCurrentUrl({
                    page: pagination.page >= pagination.pageCount ? +pagination.pageCount : pagination.page + 1
                });
            };

            /**
             * @returns {string}
             */
            $scope.getPrevPageUrl = function () {
                var pagination = account.getPagination();
                return account.getCurrentUrl({
                    page: pagination.page <= 1 ? 1 : pagination.page - 1
                });
            };

            /**
             * @returns {string}
             */
            $scope.getLastPageUrl = function () {
                return account.getCurrentUrl({
                    page: +account.getPagination().pageCount
                });
            };

            /**
             * @returns {string}
             */
            $scope.getFirstPageUrl = function () {
                return account.getCurrentUrl({
                    page: 1
                });
            };
        }]
    };
}]);
;
/**
 * The banner, that shows users, that their account is paused.
 */
app.directive('qrPausedBanner', ['api', 'gettextCatalog', function (api, gettextCatalog) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-paused-banner">' +
            '<div class="qr-paused-banner__container">' +

            '<div class="qr-paused-banner__container--text floated">' +
            '<h3 class="qr-paused-banner__title" ng-bind="titleLabel"></h3>' +
            '<p class="qr-paused-banner__message" ng-bind="::messageLabelTop"></p>' +
            '<p class="qr-paused-banner__message" ng-bind="::messageLabelBottom"></p>' +
            '</div>' +

            '<div class="qr-paused-banner__container--button floated">' +
            '<button class="qr-paused-banner__button" type="button" ng-click="buttonClick()" ng-bind="::buttonText"></button>' +
            '</div>' +

            '</div>' +
            '</div>',
        scope: {
            resumeModal: '='
        },
        controller: ['$scope', function ($scope) {
            /**
             * Translations.
             */
            $scope.titleLabelBase = gettextCatalog.getString('Your subscription is paused until %s');
            $scope.titleLabel = gettextCatalog.getString('');
            $scope.messageLabelTop = gettextCatalog.getString('In the meantime, your Dynamic QR Codes are temporarily deactivated.');
            $scope.messageLabelBottom = gettextCatalog.getString('To activate and access all features again, resume your subscription.');
            $scope.buttonText = gettextCatalog.getString('Resume subscription');

            /**
             * Get enddate of account pausing
             */
            api.getIsAccountPaused(function (response) {
                var pausedUntil = moment.unix(response.data.paused_until);
                $scope.titleLabel = $scope.titleLabelBase.replace(/%s/g, pausedUntil.format('MMM DD, YYYY'));
            });

            /**
             * Fire event for opening the resume modal
             */
            $scope.buttonClick = function () {
                $scope.$emit('openResumeModal');
            };

        }]
    };
}]);
;
/**
 * The modal that shows users, that their account is paused.
 */
app.directive('qrPausedModal', ['api', '$window', 'gettextCatalog', '$sce', 'tracking', function (api, $window, gettextCatalog, $sce, tracking) {
    return {
        restrict: 'E',
        template:
            '<qr-modal open="open" close-icon="true">' +
            '<div class="qr-paused-modal__content">' +
            '<img class="cody" ng-src="{{open && cdnUrl+\'/img/_login/Cody_Concerned.svg\' || \'\'}}"/>' +
            '<h2 class="qr-paused-modal__content__text" ng-bind="::messageTitle"></h2>' +
            '<p class="qr-paused-modal__content__text" ng-bind="messageTextTop"></p>' +
            '<p class="qr-paused-modal__content__text" ng-bind="::messageTextBottom"></p>' +
            '<button class="qr-paused-modal__button" type="button" ng-click="buttonClick()" ng-bind="::buttonText"></button>' +
            '</qr-modal>',
        scope: {
            open: '=',           // Optional open state of the menu.
            pausedUntil: '='
        },
        controller: ['$scope', function ($scope) {
            $scope.cdnUrl = $window.CDN_URL;

            $scope.messageTitle = gettextCatalog.getString("Your subscription is temporarily paused");
            $scope.messageTextTopBase = gettextCatalog.getString('You have decided to pause your subscription until %s.');
            $scope.messageTextTop = gettextCatalog.getString('');
            $scope.messageTextBottom = gettextCatalog.getString('To activate your Dynamic QR Codes and access all features again, resume your subscription.');
            $scope.buttonText = gettextCatalog.getString("Resume subscription");

            $scope.openResumeModal = false;

            /**
             * Get enddate of account pausing
             */
            if ($scope.pausedUntil !== false) {
                var pausedUntil = moment.unix($scope.pausedUntil);
                $scope.messageTextTop = $scope.messageTextTopBase.replace(/%s/g, pausedUntil.format('MMM DD, YYYY'));
            }

            // Track opening of the expired window.
            $scope.$watch('open', function () {
                if ($scope.open) {
                    tracking.trackEvent('saw_paused_screen');
                }
            });

            $scope.buttonClick = function () {
                $scope.open = false;
                $scope.$emit('openResumeModal');
            };
        }]
    };
}]);
;
app.directive('qrTrialExpiresModal', [
  'gettextCatalog',
  'account',
  function (gettextCatalog, account) {
    'use strict';
    return {
      restrict: 'E',
      template:
'<div class="trial-expires">' +
  '<button class="trial-expires__button" type="button" ng-click="buttonClick()" ng-class="getExpirationClass()">' +
    '<span class="trial-expires__label" ng-class="getExpirationClass()">{{ getLabel() }}</span>' +
  '</button>' +
'</div>' +
'<qr-modal class="qr-countdown-modal" popup-menu-class="{{ popupMenuClass }}" button-blue-look="true" open="open" data-title="{{ getTitle() }}" buttons="::buttons()" close-icon="true" bottom-information="isDateExpired() === true">' +
  '<div ng-if="isDateExpired() === false" class="trial-expires__modal-img">' +
    '<img class="" ng-src="{{cdnUrl+ \'/css/img/countdown/subscription-required.png\'}}"/>' +
    '<h6 class="trial-expires__modal-title"> {{ mainTitleExpired }} </h6>' +
  '</div>' +
  '<div ng-if="isDateExpired() === false" class="trial-expires__wrapper trial-expires__wrapper--mt">' +
    '<p class="trial-expires__subtitle-expired">{{ titleExpired }}</p>' +
    '<p class="trial-expires__subtitle-expired">{{ subtitleExpired }}</p>' +
    '<qr-list-of-contents lists="::getList()"></qr-list-of-contents>' +
  '</div>' +
  '<div ng-if="isDateExpired() === true" class="trial-expires__wrapper">' +
    '<p class="trial-expires__subtitle">{{ getTitleDescription() }}</p>' +
    '<p class="trial-expires__subtitle trial-expires__subtitle--underdescription">{{ activeModalUnderDescription }}</p>' +
  '</div>' +
  '<div ng-if="isDateExpired() === true" class="main-modal-cards-container" style="">' +
    '<div class="modal__row" ng-repeat="featureRow in featureCards">' +
      '<div class="modal__column--small" ng-repeat="featureCard in featureRow">' +
        '<div class="card modal__padding--horizontal">' +
          '<div class="row">' +
            '<div class="col-xs-2 element__padding--small">' +
              '<img class="card-img-left image__height--medium" ng-src="{{cdnUrl+ featureCard.imgSrc}}"/>' +
            '</div>' +
          '<div class="col-xs-10">' +
            '<div class="text-left card-title trial-expires__image-title">{{ featureCard.getTitle() }}</div>' +
            '<div class="text-left card-subtitle trial-expires__image-subtitle">{{ featureCard.getDescription() }}</div>' +
          '</div>' +
          '</div>' +
        '</div>' +
      '</div>' +
    '</div>' +
  '</div>' +
'</qr-modal>',
      scope: {
        open: '=', // Optional open states of modals.
      },
      controller: [
        '$scope',
        '$window',
        function ($scope, $window) {
          $scope.open = false;
          var trialExpirationDate = new Date(account.getAccount().trial_date);
          var dateDifference = Date.parse(trialExpirationDate) - new Date();

          $scope.featureCards = [
            [
              {
                getTitle: function() { return $scope.activeModalDynamicTitle; },
                getDescription: function() { return $scope.activeModalDynamicDescription; },
                imgSrc: '/css/img/countdown/trial-expires-modal/icons/dynamic_qr_codes.svg'
              },
              {
                getTitle: function() { return $scope.activeModalBrandedTitle; },
                getDescription: function() { return $scope.activeModalBrandedDescription; },
                imgSrc: '/css/img/countdown/trial-expires-modal/icons/branded_designs.svg'
              },
            ],
            [
              {
                getTitle: function() { return $scope.activeModalSolutionsTitle; },
                getDescription: function() { return $scope.activeModalSolutionsDescription; },
                imgSrc: '/css/img/countdown/trial-expires-modal/icons/20_plus_solutions.svg'
              },
              {
                getTitle: function() { return $scope.activeModalAnalyticsTitle; },
                getDescription: function() { return $scope.activeModalAnalyticsDescription; },
                imgSrc: '/css/img/countdown/trial-expires-modal/icons/analytics.svg'
              }
            ]
          ];

          $scope.isDateExpired = function () {
            return dateDifference > 0;
          };

          $scope.isTrial3DaysOrLess = function () {
            return $scope.trialDaysLeft <= 3;
          };
          $scope.getTitle = function () {
            return !$scope.isDateExpired()
              ? ""
              : gettextCatalog.getString("Upgrade or keep exploring?");
          };

          $scope.getTitleDescription = function () {
            return gettextCatalog.getPlural(
              $scope.trialDaysLeft,
              "Enjoy your trial for {{$count}} more day",
              "Enjoy your trial for {{$count}} more days",
              {}
            );
          };
          $scope.activeModalUnderDescription = gettextCatalog.getString(
            "Take advantage of your trial to make powerful, flexible, branded QR Codes. Upgrade to keep your Dynamic QR Codes and these valuable features."
          );

          $scope.mainTitleExpired = gettextCatalog.getString(
            "Your trial period is over"
          );
          $scope.titleExpired = gettextCatalog.getString(
            "To continue, please upgrade your account to one of our plans."
          );
          $scope.subtitleExpired = gettextCatalog.getString(
            "With a paid plan, you can:"
          );
          $scope.popupMenuClass = "qr-countdown-popup";

          $scope.trialDaysLeft = 0;

          $scope.activeModalDynamicTitle =
            gettextCatalog.getString("Dynamic QR Codes");

          $scope.activeModalDynamicDescription = gettextCatalog.getString(
            "with editable content and target URL, even post-print"
          );

          $scope.activeModalBrandedTitle =
            gettextCatalog.getString("Branded designs");

          $scope.activeModalBrandedDescription = gettextCatalog.getString(
            "with custom logo, colors, and frames"
          );

          $scope.activeModalSolutionsTitle =
            gettextCatalog.getString("20+ Solutions");

          $scope.activeModalSolutionsDescription = gettextCatalog.getString(
            "for PDFs, vCards, MP3s, and many more"
          );

          $scope.activeModalAnalyticsTitle =
            gettextCatalog.getString("Analytics");

          $scope.activeModalAnalyticsDescription = gettextCatalog.getString(
            "for scans, locations, and OS"
          );

          /**
           * Returns label for trial button.
           * @returns {string}
           */
          $scope.getLabel = function () {
            $scope.trialDaysLeft = account.getAccountTrialDaysLeft();
            if ($scope.isDateExpired() === false) {
              return gettextCatalog.getString("Expired");
            }
            if ($scope.trialDaysLeft === 0) {
              return gettextCatalog.getString("Expires today");
            }

            return gettextCatalog.getPlural(
              $scope.trialDaysLeft,
              "Active for {{$count}} day",
              "Active for {{$count}} days",
              {}
            );
          };
          /**
           * Returns user account trial date
           * @returns {string}
           */
          $scope.getTrialDate = function () {
            return account.getAccount().trial_date;
          };

          $scope.getExpirationClass = function () {
            if ($scope.isDateExpired() === false) {
              return "trial-expires__button--expired";
            } else if ($scope.isTrial3DaysOrLess()) {
              return "trial-expires__button--expires-soon";
            } else {
              return "";
            }
          };

          /**
           * Handler for button clicks.
           */
          $scope.buttonClick = function () {
            window.qr.utils.optimizely.trackOptimizelyEvent("qrapp_expiring_in_tag");
            $scope.open = true;
          };

          $scope.listActiveButtons = [
            {
              icon: false,
              label: gettextCatalog.getString("Upgrade today"),
              type: "link",
              testEvent: "upgradeButton",
              callback: function () {
                window.qr.utils.optimizely.trackOptimizelyEvent("qrapp_trial_countdown_modal_button_upgrade_now");
                $scope.open = false;
                $window.location.href = "/upgrade";
              },
            },
            {
              label: gettextCatalog.getString("Remind me later"),
              type: "link",
              testEvent: "remindLaterButton",
              callback: function () {
                window.qr.utils.optimizely.trackOptimizelyEvent("qrapp_trial_countdown_modal_button_close");
                $scope.open = false;
              },
            },
          ];

          $scope.listExpiredButtons = [
            {
              icon: true,
              label: gettextCatalog.getString("Select a plan"),
              type: "link",
              callback: function () {
                $scope.open = false;
                $window.location.href = "/upgrade";
              },
            },
          ];

          $scope.listExpired = [
            {
              label: gettextCatalog.getString(
                "Reactivate your expired QR Codes"
              ),
              imgPath: "/css/img/countdown/vector-check.png",
            },
            {
              label: gettextCatalog.getString(
                "Access over 20 QR Code solutions"
              ),
              imgPath: "/css/img/countdown/vector-check.png",
            },
            {
              label: gettextCatalog.getString("Customize landing pages"),
              imgPath: "/css/img/countdown/vector-check.png",
            },
            {
              label: gettextCatalog.getString("Track and share scan metrics"),
              imgPath: "/css/img/countdown/vector-check.png",
            },
          ];

          $scope.getList = () => $scope.listExpired;

          $scope.buttons = () =>
            $scope.isDateExpired()
              ? $scope.listActiveButtons
              : $scope.listExpiredButtons;
        },
      ],
    };
  },
]);
;
/**
 * Directive for displaying one news item in the popup window with the latest news.
 */
app.directive('qrNewsItem', function () {
    return {
        restrict: 'E',
        template:
            '<div class="qr-news-item">' +
                '<div class="qr-news-item__message">{{ value.message }}</div>' +
                '<a class="qr-news-item__action qr-navbar-v2__button" href="{{ normalizeUrl(value.url) }}" target="_blank" ng-show="value.label && value.url">' +
                    '{{ value.label }}' +
                    '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16">\n' +
                        '<path class="b" d="M15.942,7.674a.75.75,0,0,0-.162-.241L9.98,1.669a.753.753,0,0,0-1.042.018A.742.742,0,0,0,8.92,2.722l4.52,4.492H.75A.745.745,0,1,0,.75,8.7H13.44L8.92,13.2a.742.742,0,0,0,0,1.054.753.753,0,0,0,1.061,0l5.8-5.764a.745.745,0,0,0,.162-.812Z" transform="translate(0 0.031)"/>\n' +
                    '</svg>' +
                '</a>' +
                '<div class="qr-news-item__date">{{ getDate() | date: "mediumDate" }}</div>' +
            '</div>',
        scope: {
            value: '=' // Data in format {message: '', updated_at: '', icon: '', color: '', label: '', url: ''}.
        },
        controller: ['$scope', function ($scope) {
            /**
             * Ensure that we always have a valid URL.
             * @param {string} url
             * @returns {*}
             */
            $scope.normalizeUrl = function (url) {
                if (!url) {
                    return url;
                }
                if (/^https?:\/\//i.test(url)) {
                    return url;
                }
                return 'http://' + url;
            };

            /**
             * Convert internal date format to JS date.
             * @returns {Date}
             */
            $scope.getDate = function () {
                return new Date($scope.value.updated_at.replace(/-/g, '/') || $scope.value.created_at.replace(/-/g, '/'));
            };
        }]
    };
});
;
/**
 * Directive for displaying the news form for adding/editing system updates.
 */
app.directive('qrNewsForm', ['$filter', 'http', '$log', '$window', function ($filter, http, $log, $window) {
    return {
        restrict: 'E',
        template:
            '<form class="qr-news-form" action="" method="post" ng-if="open" ng-hide="isCancelling.value">' +
                '<span class="qr-news-form__icon" ng-class="value.icon" ng-style="{color: value.color}"></span>' +
                '<qr-color class="qr-news-form__color" value="value.color"></qr-color>' +
                '<input class="qr-news-form__message canHaveError" name="message" ng-model="value.message" maxlength="255" placeholder="{{ messages.messagePlaceholder }}" required>' +
                '<qr-input-error name="message" messages="messages"></qr-input-error>' +
                '<input class="qr-news-form__icon-search canHaveError" name="icon" ng-model="value.icon" maxlength="32" placeholder="{{ messages.iconPlaceholder }}" required>' +
                '<qr-input-error name="icon" messages="messages"></qr-input-error>' +
                '<qr-icon-menu open="openIconMenu" value="value.icon" items="foundIcons" top-offset="-16px" use-raw-icon-name="true"></qr-icon-menu>' +
                '<qr-action-button value="value" max-label-length="70" max-url-length="255" error-messages="messages" items="predefinedLabels" url-placeholder="{{ messages.urlPlaceholder }}" default-value="actionDefaultValue" custom-label="{{ customLabel }}" editable="true"></qr-action-button>' +
                '<div class="qr-news-form__actions">' +
                    '<button class="qr-news-form__save" type="button" ng-click="save()">{{ saveLabel }}</button>' +
                    '<button class="qr-news-form__cancel" type="button" ng-click="isCancelling.value = true">{{ cancelLabel }}</button>' +
                '</div>' +
            '</form>' +
            '<div class="qr-news-form__cancel-message" ng-if="open" ng-show="isCancelling.value">' +
                '<div class="qr-news-form__question">{{ messages.cancelQuestion }}</div>' +
                '<button type="button" class="qr-news-form__no" ng-click="isCancelling.value = false">{{ noLabel }}</button>' +
                '<button type="button" class="qr-news-form__yes" ng-click="cancel()">{{ yesLabel }}</button>' +
            '</div>',
        scope: {
            value: '=',     // Data in format {message: '', updated_at: '', icon: '', color: '', label: '', url: ''}.
            messages: '=',  // Translations.
            icons: '=',     // Array of icons to search.
            open: '='       // This flag controls the visibility of the form.
        },
        controller: ['$scope', '$element', function ($scope, $element) {
            $scope.value = $scope.value || {};
            $scope.messages = $scope.messages || {};
            $scope.openIconMenu = false;
            $scope.foundIcons = [];

            $scope.saveLabel = $scope.messages.save || $filter("translate")("Save");
            $scope.cancelLabel = $scope.messages.cancel || $filter("translate")("Cancel");
            $scope.customLabel = $scope.messages.custom || "";
            $scope.predefinedLabels = [
                $scope.messages.learnMore || $filter("translate")("Learn More")
            ];
            $scope.actionDefaultValue = {
                label: $scope.predefinedLabels[0],
                url: ""
            };

            $scope.noLabel = $scope.messages.noCancel || $filter("translate")("No");
            $scope.yesLabel = $scope.messages.yesCancel || $filter("translate")("Yes");
            $scope.isCancelling = { // An object is needed here to use it inside ngIf (it creates new scope and simple values don't work).
                value: false
            };

            // Search icons.
            $scope.$watch("value.icon", function () {
                $scope.foundIcons = [];
                angular.forEach($scope.icons, function (iconName) {
                    if (iconName.indexOf($scope.value.icon) >= 0 && $scope.foundIcons.length < 25) {
                        $scope.foundIcons.push(iconName);
                    }
                });
                $scope.openIconMenu = $scope.foundIcons.length > 1 || ($scope.foundIcons.length === 1 && $scope.value.icon !== $scope.foundIcons[0]);
            });

            /**
             * Save the form.
             */
            $scope.save = function () {
                if ($element.find(".canHaveError.ng-invalid").length > 0) {
                    // Bad idea to do it right here, but there's no support for this outside of the QR creation form currently.
                    // Does not work. We really need to implement angular-only popup error messages.
                    // angular.forEach($element.find(".canHaveError.ng-invalid"), function (el) {
                    //     var message = $element.find(".errorHolder[data-error-container=#qr-error-" + el.name + "]").attr("data-error-msg");
                    //     window.qr.utils.formValidationTooltip('#qr-error-' + el.name, message, true, true);
                    // });
                    alert("Please enter a message and an icon. Thanks.");
                    return;
                }
                var action = "/news/create";
                if ("id" in $scope.value && $scope.value.id > 0) {
                    action = "/news/update?id=" + $scope.value.id;
                } else {
                    $scope.value.color = "#90c52d";
                }
                http.post(action, $scope.value,
                    function (response) {
                        if (response.data.success) {
                            $window.location.reload();
                        } else {
                            $log.error("ERROR WHILE EDITING NEWS", response);
                        }
                    },
                    function () {
                        $log.error("ERROR WHILE EDITING NEWS");
                    }
                );
            };

            /**
             * Cancel the form.
             */
            $scope.cancel = function () {
                $scope.open = false;
                $scope.isCancelling.value = false;
            };
        }]
    };
}]);
;
/**
 * Directive for displaying one news block on the news admin page.
 */
app.directive('qrNewsBlock', ['$filter', 'http', '$log', '$window', function ($filter, http, $log, $window) {
    return {
        restrict: 'E',
        template:
            '<div class="qr-news-block" ng-hide="openForm || isDeleting">' +
                '<span class="qr-news-block__icon" ng-class="value.icon" ng-style="{color: value.color}"></span>' +
                '<div class="qr-news-block__message">{{ value.message }}</div>' +
                '<span class="qr-news-block__date">{{ getDate() | date: "mediumDate" }}</span>' +
                '<div class="qr-news-block__actions">' +
                    '<button class="qr-news-block__edit" ng-click="edit()">' +
                        '<span class="qr-news-block__action-icon icon icon-avatar-edit"></span>{{ editLabel }}</button>' +
                    '<button class="qr-news-block__delete" ng-click="isDeleting = true">' +
                        '<span class="qr-news-block__action-icon icon icon-action-delete"></span>{{ deleteLabel }}</button>' +
                '</div>' +
            '</div>' +
            '<qr-news-form value="value" messages="messages" icons="icons" open="openForm"></qr-news-form>' +
            '<div class="qr-news-block__delete-message" ng-show="isDeleting">' +
                '<div class="qr-news-block__question">{{ messages.deleteQuestion }}</div>' +
                '<button type="button" class="qr-news-block__no" ng-click="isDeleting = false">{{ noLabel }}</button>' +
                '<button type="button" class="qr-news-block__yes" ng-click="delete()">{{ yesLabel }}</button>' +
            '</div>',
        scope: {
            value: '=',     // Data in format {message: '', updated_at: '', icon: '', color: '', label: '', url: ''}.
            messages: '=',  // Translations.
            icons: '='      // Icons for the news form to search icons.
        },
        controller: ['$scope', function ($scope) {
            $scope.messages = $scope.messages || {};
            $scope.editLabel = $scope.messages.edit || $filter("translate")("Edit");
            $scope.deleteLabel = $scope.messages.delete || $filter("translate")("Delete");
            $scope.noLabel = $scope.messages.noDelete || $filter("translate")("No");
            $scope.yesLabel = $scope.messages.yesDelete || $filter("translate")("Yes");
            $scope.isDeleting = false;

            /**
             * If the form is visible or not.
             * @type {boolean}
             */
            $scope.openForm = false;

            /**
             * Convert internal date format to JS date.
             * @returns {Date}
             */
            $scope.getDate = function () {
                return new Date($scope.value.updated_at || $scope.value.created_at);
            };

            /**
             * Open the form for editing.
             */
            $scope.edit = function () {
                $scope.openForm = true;
            };

            /**
             * Delete this news item.
             */
            $scope.delete = function () {
                if (!("id" in $scope.value)) {
                    $log.error("ID doesn't exist in $scope.value", $scope.value);
                    return;
                }
                http.post('/news/delete?id=' + $scope.value.id, {},
                    function (response) {
                        if (response.data.success) {
                            $window.location.reload();
                        } else {
                            $log.error("ERROR WHILE DELETING NEWS", response);
                        }
                    },
                    function () {
                        $log.error("ERROR WHILE DELETING NEWS");
                    }
                );
            };
        }]
    };
}]);
;
/**
 * Popup window with latest news. You can find it on the main nav bar.
 */
app.directive('qrNewsWindow', ['http', 'gettextCatalog', function (http, gettextCatalog) {
    return {
        restrict: 'E',
        template:
            '<qr-popup id="qr-news-v2" open="open" mobile-mode="{{ mobileMode }}" top-offset="{{ topOffset }}" right="{{ right }}">' +
                '<div class="qr-news-window">' +
                    '<div class="qr-news-window__content">' +
                        '<h6 class="qr-news-window__title">{{ title }}</h6>' +
                        '<span class="qr-news-window__close qr-navbar-v2__button" ng-click="closeIt()">' +
                            '<svg xmlns="http://www.w3.org/2000/svg" width="23.999" height="23.999" viewBox="0 0 23.999 23.999">' +
                                '<path class="b" d="M13.414,12l7.293-7.293a1,1,0,1,0-1.414-1.414L12,10.586,4.707,3.293A1,1,0,1,0,3.293,4.707L10.586,12,3.293,19.293a1,1,0,1,0,1.414,1.414L12,13.414l7.293,7.293a1,1,0,1,0,1.414-1.414Z"/>' +
                            '</svg>' +
                        '</span>' +
                        '<qr-news-item class="qr-news-window__item" ng-repeat="item in items track by $index" value="item"></qr-news-item>' +
                    '</div>' +
                    '<div class="qr-news-window__actions" ng-switch="isLoading">' +
                        '<div ng-switch-default><button class="qr-news-window__action qr-navbar-v2__button" type="button" ng-click="loadMore()">{{ ::loadMoreLabel }}</button></div>' +
                    '</div>' +
                '</div>' +
            '</qr-popup>',
        scope: {
            open: '=',          // Is window open? Default: false.
            right: '@',         // Optional. Set to "true" if it should be aligned to the right.
            topOffset: '@',     // Optional. The top offset of the menu. It can be used to adjust the vertical position.
            title: '@',         // Optional. Title of the window.
            items: '=',          // News items to show in format {message: '', updated_at: '', icon: '', color: '', label: '', url: ''}.
            mobileMode: '='      // Show popup menu in mobile mode
        },
        controller: ['$scope', function ($scope) {
            $scope.loadMoreLabel = gettextCatalog.getString('Load more');
            $scope.whatsNewLabel = gettextCatalog.getString("What's new?");

            $scope.title = $scope.title || $scope.whatsNewLabel;

            /**
             * Loading state.
             * @type {boolean}
             */
            $scope.isLoading = false;

            /**
             * Close this window.
             */
            $scope.closeIt = function () {
                $scope.open = false;
            };

            /**
             * Load more items.
             */
            $scope.loadMore = function () {
                $scope.isLoading = true;
                http.get('/news/load?offset=' + $scope.items.length, {}, function (response) {
                    if (response.data.success) {
                        $scope.items = $scope.items.concat(response.data.items || []);
                    }
                    $scope.isLoading = false;
                }, function () {
                    $scope.isLoading = false;
                });
            };
            angular.element(document).ready(function () {
                $('.qr-news-window__content').perfectScrollbar({includePadding: true});
                setTimeout(function () {
                    $('.qr-news-window__content').perfectScrollbar('update');
                }, 0);
            });
        }]
    };
}]);
;
/**
 * This is an indicator of latest news from the system.
 * It's used in the main nav bar of the app.
 */
app.directive('qrNewsBell', ['http', function (http) {
    return {
        restrict: 'E',
        template:
        '<div class="qr-news-bell qr-navbar-v2__button qr-navbar-v2__button--news-bell" ng-class="getElementClass()">' +
            '<span ng-click="click($event)">' +
                '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">' +
                    '<path d="M14.613,21.01a2.718,2.718,0,0,1-5.237,0Zm6.437-1.5H2.94a.931.931,0,0,1-.75-1.5l2.7-3.572v-4.3a7.131,7.131,0,0,1,6.107-7V2a1,1,0,1,1,2,0V3.081a7.121,7.121,0,0,1,6.147,7.053v4.352L21.8,18.008a.931.931,0,0,1-.75,1.5Zm-2.139-2L17.542,15.7l-.4-.53v-5a5.127,5.127,0,1,0-10.255,0v5l-.4.54-1.409,1.8Z" transform="translate(0.006)"/>' +
                '</svg>' +
            '</span>' +
            '<qr-news-window open="open" mobile-mode="mobileMode" items="items" right="true"></qr-news-window>' +
        '</div>',
        scope: {
            status: '=',    // Status of the icon: true for news, false for no news.
            items: '=',      // News items to show.
            iconAsSvg: '=',      // Show the icon as svg code, for better css manipulation.
            mobileMode: '='      // Show popup menu in mobile mode
        },
        controller: ['$scope', function ($scope) {
            /**
             * Is the message window open?
             * @type {boolean}
             */
            $scope.open = false;

            /**
             * Get the CSS class of the bell icon.
             * @returns {{}}
             */
            $scope.getIconClass = function () {
                if ($scope.iconAsSvg)
                    return '';
                return {
                    'icon-bell': $scope.status,
                    'icon-bell-empty': !$scope.status,
                    'qr-news-bell__icon--mark': $scope.status,
                    'qr-news-bell__icon--open': $scope.open
                };
            };

            /**
             * Get CSS class of the element.
             * It's needed to display the red dot notification marker.
             * @returns {{}}
             */
            $scope.getElementClass = function () {
                return {
                    'qr-navbar-v2__button--with-badge': $scope.status
                };
            };

            /**
             * Click handler. It opens the message window.
             * @param $event
             */
            $scope.click = function ($event) {
                $event.preventDefault();
                $scope.open = !$scope.open;
                if ($scope.open) {
                    $scope.markAsRead();
                }
                $scope.status = false;
            };

            /**
             * Mark current news as read.
             */
            $scope.markAsRead = function () {
                http.post('/news/markAsRead', {}, function () {
                    // Do nothing here.
                });
            };
        }]
    };
}]);
;
/**
 * Modals to tell the customer that this action is currently not available.
 */
app.directive('qrPayoneActionNotPossibleModal', ['api', 'gettextCatalog','$sce', 'markup', function (api, gettextCatalog, $sce, markup) {
    return {
        restrict: 'E',
        template:
            '<qr-modal data-title="{{ ::titleLabel }}" open="open" buttons="getButtons()">' +
            '<div class="qr-payone-action-not-possible-modal__content">' +
            '<p class="qr-payone-action-not-possible-modal__text" ng-bind="::selectMessage"></p>' +
            '</div>' +
            '</qr-modal>',
        scope: {
            open: '='      // Optional open state of the modal.
        },
        controller: ['$scope', function ($scope) {
            /**
             * Some translations for this directive.
             */
            $scope.selectMessage = gettextCatalog.getString('This feature is temporarily inaccessible. We are currently improving our payment system as part of our promise to deliver the best experience for you. Need this urgently? Contact support@qr-code-gemerator.com');
            $scope.titleLabel = gettextCatalog.getString("Oops, you've stumbled upon a work in progress");

            /**
             * Array of buttons for the modal.
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Got it'),
                    callback: function () {
                        $scope.open = false;
                    }
                }
            ];

            /**
             * Returns actual array of buttons for the modal.
             * @returns {Array}
             */
            $scope.getButtons = function () {
                return $scope.buttons;
            };
        }]
    };
}]);
;
/**
 * Modals to prevent user to cancel their subscription. Contains a modal that will be shown to the user within 12 hours after purchase to block the cancellation.
 * After 12 hours, but within 14 days after purchase, the user will see a modal to concat the support to cancel.
 */
app.directive('qrCancellationNotPossibleModal', ['api', 'gettextCatalog','$sce', 'markup', function (api, gettextCatalog, $sce, markup) {
    return {
        restrict: 'E',
        template:
            // Modal "Cancellation not possible"
            '<qr-modal data-title="{{ ::titleLabel_notPossible }}" open="openNotPossibleModal" buttons="getButtons()">' +
            '<div class="qr-cancellation-not-possible-modal__content">' +
            '<p class="qr-cancellation-not-possible-modal__text" ng-bind="::selectMessage_notPossible"></p>' +
            '</div>' +
            '</qr-modal>' +

            // Modal "Cancellation possible only via support "
            '<qr-modal data-title="{{ ::titleLabel_onlyViaSupport }}" open="openSupportModal" buttons="getButtons()">' +
            '<div class="qr-cancellation-not-possible-modal__content">' +
            '<p class="qr-cancellation-not-possible-modal__text" ng-bind-html="::selectMessage_onlyViaSupport"></p>' +
            '</div>' +
            '</qr-modal>',
        scope: {
            openNotPossibleModal: '=',      // Optional open state of the modal.
            openSupportModal: '=',      // Optional open state of the modal.
        },
        controller: ['$scope', function ($scope) {
            /**
             * Some translations for this directive.
             */
            $scope.selectMessage_notPossible = gettextCatalog.getString('This feature is temporarily unavailable while we are processing your subscription data.');
            //$scope.selectMessage_onlyViaSupport = gettextCatalog.getString('Changed your mind?');
            $scope.selectMessage_onlyViaSupport = $sce.trustAsHtml(
                markup.convertToString(
                    gettextCatalog.getString(
                        "If you request for a cancelation, you will not be able to access your QR Codes and other features in your selected plan. To proceed, please send your request to [link={{mail}}]support@qr-code-generator.com[/link].",
                        {mail: "mailto:support@qr-code-generator.com"}
                    ),
                    "qr-cancellation-not-possible-modal__text"
                )
            );

            $scope.titleLabel_notPossible = gettextCatalog.getString('Please try again later');
            $scope.titleLabel_onlyViaSupport = gettextCatalog.getString('Changed your mind?');


            /**
             * Array of buttons for the modal.
             * @type {Array}
             */
            $scope.buttons = [
                {
                    label: gettextCatalog.getString('Got it'),
                    callback: function () {
                        $scope.openNotPossibleModal = false;
                        $scope.openSupportModal = false;
                    }
                }
            ];

            /**
             * Returns actual array of buttons for the modal.
             * @returns {Array}
             */
            $scope.getButtons = function () {
                return $scope.buttons;
            };
        }]
    };
}]);
;
/**
 * The modal to offer pausing of the subscription instead of cancelling.
 */
app.directive('qrSubscriptionPauseModal', ['api', 'gettextCatalog', '$timeout', '$sce', 'markup', function (api, gettextCatalog, $timeout, $sce, markup) {
    return {
        restrict: 'E',
        template:
            '<qr-modal data-title="{{ ::startModalTitle }}" open="states.startModal" buttons="getButtons(\'start\')">' +
            '<i class="qr-popup__close-icon icon-thin-close" ng-click="closeWindow()"></i>' +
            '<div class="qr-subscription-pause__content">' +
            '<p class="qr-subscription-pause__text" ng-bind-html="::startModalContent"></p>' +
            '</div>' +
            '</qr-modal>' +

            '<qr-modal data-title="{{ ::durationModalTitle }}" open="states.durationModal" buttons="getButtons(\'duration\')">' +
            '<i class="qr-popup__close-icon icon-thin-close" ng-click="closeWindow()"></i>' +
            '<div class="qr-subscription-pause__content">' +
            '<p class="qr-subscription-pause__text" ng-bind="::durationModalContent"></p>' +
            '<div style="float: left; padding-top: 17px">' +
            '<p class="qr-subscription-pause__text" ng-bind="::durationModalPauseAccount"></p>' +
            '</div>' +
            '<div>' +
            '<button class="qr-subscription-pause__select-duration ml-0" type="button" ng-click="showDurationDropdown()">' +
            '<span class="icon-qr-calendar"></span>' +
            '{{ selectedData.durationLabel }}' +
            '<span ng-hide="states.durationDropdown" class="icon-down-open-mini"></span>' +
            '<span ng-show="states.durationDropdown" class="icon-up-open-mini"></span>' +
            '</button>' +
            '</div>' +
            '<div class="qr-subscription-pause__select-duration__popup">' +
            '<qr-popup-menu open="states.durationDropdown" items="::items" ng-if="states.durationDropdown"></qr-popup-menu>' +
            '</div>' +
            '<p class="qr-subscription-pause__text-hint" ng-bind="durationModalContentHint"></p>' +
            '</div>' +
            '</qr-modal>' +

            '<qr-modal data-title="{{ ::confirmModalTitle }}" open="states.confirmModal" buttons="getButtons(\'confirm\')">' +
            '<i class="qr-popup__close-icon icon-thin-close" ng-click="closeWindow()"></i>' +
            '<div class="qr-subscription-pause__content">' +
            '<p class="qr-subscription-pause__text" ng-bind="confirmModalContent"></p>' +
            '</div>' +
            '</qr-modal>' +

            '<qr-modal data-title="{{ ::failedModalTitle }}" open="states.failedModal" buttons="getButtons(\'failed\')">' +
            '<i class="qr-popup__close-icon icon-thin-close" ng-click="closeWindow()"></i>' +
            '<div class="qr-subscription-pause__content">' +
            '<p class="qr-subscription-pause__text" ng-bind-html="::failedModalContent"></p>' +
            '</div>' +
            '</qr-modal>',
        scope: {
            open: '=',      // Optional open state of the modal.
            expiretime: '='
        },
        controller: ['$scope', function ($scope) {
            /**
             * Some translations for this directive.
             */
            $scope.durationModalTitle = gettextCatalog.getString('Select the pause duration');
            $scope.durationModalContent = gettextCatalog.getString('You have the option to pause your subscription for a maximum of 6 months. But not to worry, you can resume at any time.');
            $scope.durationModalContentHintBase = gettextCatalog.getString('Your subscription will be paused until %s1. Your subscription period will be extended until %s2.');
            $scope.durationModalContentHint = '';
            $scope.durationModalPauseAccount = gettextCatalog.getString('Pause my subscription for');

            $scope.confirmModalTitle = gettextCatalog.getString('Pausing your subscription');
            $scope.confirmModalContentBase = gettextCatalog.getString('We are now processing your request to pause your subscription until %s1. A confirmation email will follow shortly.');
            $scope.confirmModalContent = '';

            $scope.failedModalTitle = gettextCatalog.getString("Your subscription couldn't be paused");
            $scope.failedModalContent = $sce.trustAsHtml(
                markup.convertToString(
                    gettextCatalog.getString(
                        "Please send an email to [link={{url}}]support@qr-code-generator.com[/link] to pause your subscription.",
                        {url: "mailto:support@qr-code-generator.com"}
                    ),
                    "qr-subscription-pause__text"
                )
            );

            $scope.startModalTitle = gettextCatalog.getString('Would you like to pause instead?');
            $scope.startModalContent = $sce.trustAsHtml(
                markup.convertToString(
                    gettextCatalog.getString(
                        "If you have no need for QR Codes right now, you can pause your subscription and QR Codes for up to 6 months at no additional cost. While on pause, your Dynamic QR Codes will be temporarily deactivated. You can resume your subscription at any time and continue where you left off. [link={{url}}]Learn more[/link]",
                        {url: "http://help.qr-code-generator.com/en/articles/4198274-how-can-i-pause-my-subscription-and-what-happens-when-i-pause"}
                    ),
                    "qr-subscription-pause__text"
                )
            );

            // Holds the current states of the views
            $scope.states = {
                failedModal: false,
                startModal: false,
                durationModal: false,
                confirmModal: false,
                durationDropdown: false
            };

            // Holds the current selected data of the duration dropdown
            $scope.selectedData = {
                durationLabel: gettextCatalog.getString('1 Month'),
                durationValue: 1
            };

            $scope.timestamps = {
                originSubscriptionExpireTime: 0,
                newSubscriptionExpireTime: 0,
                accountPauseUntil: 0
            };

            $scope.formatedDates = {
                accountPauseUntil: 0,
                newSubscriptionEnd: 0
            };

            // Indicates if action is in progress. Used to prevent multiple pausing requests.
            $scope.actionInProgress = false;

            $scope.showDurationDropdown = function () {
                $timeout(function () {
                    $('.qr-subscription-pause__select-duration_popup .qr-popup').css('width', $('.qr-subscription-pause__select-duration').innerWidth());
                });

                $scope.states.durationDropdown = !$scope.states.durationDropdown;
            };

            $scope.closeWindow = function() {
                $scope.open = false;
            };

            // Holds the items for the duration dropdown
            $scope.items = [
                {
                    label: gettextCatalog.getString('1 Month'),
                    callback: function () {
                        $scope.selectedData.durationLabel = this.label;
                        $scope.selectedData.durationValue = 1;
                    }
                },
                {
                    label: gettextCatalog.getString('2 Months'),
                    callback: function () {
                        $scope.selectedData.durationLabel = this.label;
                        $scope.selectedData.durationValue = 2;
                    }
                },
                {
                    label: gettextCatalog.getString('3 Months'),
                    callback: function () {
                        $scope.selectedData.durationLabel = this.label;
                        $scope.selectedData.durationValue = 3;
                    }
                },
                {
                    label: gettextCatalog.getString('4 Months'),
                    callback: function () {
                        $scope.selectedData.durationLabel = this.label;
                        $scope.selectedData.durationValue = 4;
                    }
                },
                {
                    label: gettextCatalog.getString('5 Months'),
                    callback: function () {
                        $scope.selectedData.durationLabel = this.label;
                        $scope.selectedData.durationValue = 5;
                    }
                },
                {
                    label: gettextCatalog.getString('6 Months'),
                    callback: function () {
                        $scope.selectedData.durationLabel = this.label;
                        $scope.selectedData.durationValue = 6;
                    }
                },

            ];


            $scope.$watch('open', function (newOpen, oldOpen) {
                if ($scope.open) {
                    $scope.states.startModal = true;
                }

                if (!$scope.open) {
                    $scope.states.startModal = false;
                    $scope.states.durationModal = false;
                    $scope.states.confirmModal = false;
                    $scope.states.failedModal = false;
                }
            });

            $scope.$watch('[states.startModal, states.durationModal, states.confirmModal, states.failedModal]', function (newOpen, oldOpen) {
                if (!$scope.states.startModal && !$scope.states.durationModal && !$scope.states.confirmModal && !$scope.states.failedModal) {
                    $scope.open = false;
                }
            });

            $scope.$watch('selectedData.durationValue', function (newVal, oldVal) {
                var currentTime = moment();
                var subscriptionTime = moment.unix($scope.expiretime);

                currentTime.add(newVal, 'months');
                subscriptionTime.add(newVal, 'months');

                $scope.formatedDates.accountPauseUntil = currentTime.format('MMM DD, YYYY');
                $scope.formatedDates.newSubscriptionEnd = subscriptionTime.format('MMM DD, YYYY');
                $scope.durationModalContentHint = $scope.durationModalContentHintBase.replace(/%s1/g, $scope.formatedDates.accountPauseUntil);
                $scope.durationModalContentHint = $scope.durationModalContentHint.replace(/%s2/g, $scope.formatedDates.newSubscriptionEnd);
                $scope.confirmModalContent = $scope.confirmModalContentBase.replace(/%s1/g, $scope.formatedDates.accountPauseUntil);
            });

            /**
             * Array of buttons for the modal.
             * @type {Array}
             */
            $scope.buttonsStartModal = [
                {
                    label: gettextCatalog.getString('Pause subscription'),
                    callback: function () {
                        $scope.states.durationModal = true;
                        $scope.states.startModal = false;
                    }
                },
                {
                    label: gettextCatalog.getString('Cancel subscription'),
                    type: 'link',
                    callback: function () {
                        window.location.href = "/account/unsubscribe/";
                    }
                }
            ];

            $scope.buttonsDurationModal = [
                {
                    label: gettextCatalog.getString('Pause now'),
                    callback: function () {
                        if ($scope.actionInProgress === false) {
                            $scope.actionInProgress = true;

                            $.post('/subscription/pause', {
                                duration: $scope.selectedData.durationValue,
                                YII_CSRF_TOKEN: GLOBAL_CSRF_TOKEN
                            }).done(function (response) {
                                if (response.includes('error')) {
                                    $scope.states.durationModal = false;
                                    $scope.states.failedModal = true;
                                    $scope.$apply();
                                } else {
                                    $scope.states.durationModal = false;
                                    $scope.states.confirmModal = true;
                                    $scope.$apply();
                                }
                            }).fail(function (response) {
                                console.log("Couldnt pause account!");
                            });
                        }
                    }
                },
                {
                    label: gettextCatalog.getString('Back'),
                    type: 'link',
                    callback: function () {
                        $scope.states.durationModal = false;
                        $scope.states.startModal = true;
                    }
                }
            ];

            $scope.buttonsConfirmModal = [
                {
                    label: gettextCatalog.getString('Got it'),
                    callback: function () {
                        $scope.states.durationModal = false;
                        $scope.open = false;
                        window.location.reload();
                    }
                }
            ];

            $scope.buttonsFailedModal = [
                {
                    label: gettextCatalog.getString('Got it'),
                    callback: function () {
                        $scope.states.failedModal = false;
                        $scope.open = false;
                    }
                }
            ];

            /**
             * Returns actual array of buttons for the modal.
             * @returns {Array}
             */
            $scope.getButtons = function (modalName) {
                if (modalName === 'start') {
                    return $scope.buttonsStartModal;
                }

                if (modalName === 'duration') {
                    return $scope.buttonsDurationModal;
                }

                if (modalName === 'confirm') {
                    return $scope.buttonsConfirmModal;
                }

                if (modalName === 'failed') {
                    return $scope.buttonsFailedModal;
                }
            };

        }]
    };
}]);
;
/**
 * The modal to offer resuming of the paused subscription.
 */
app.directive('qrSubscriptionResumeModal', ['api', 'gettextCatalog', '$sce', 'markup', function (api, gettextCatalog, $sce, markup) {
    return {
        restrict: 'E',
        template:
            '<qr-modal class="qr-subscription-resume__modal" data-title="{{ ::resumeModalTitle }}" open="states.resumeModal" buttons="buttonsResumeModal">' +
            '<div class="qr-subscription-resume__content">' +
            '<p class="qr-subscription-resume__text" ng-bind="::resumeModalContent"></p>' +
            '</div>' +
            '</qr-modal>' +

            '<qr-modal class="qr-subscription-resume__modal" data-title="{{ ::successModalTitle }}" open="states.successModal" buttons="buttonsSuccessModal">' +
            '<div class="qr-subscription-resume__content">' +
            '<p class="qr-subscription-resume__text" ng-bind="::successModalContent"></p>' +
            '</div>' +
            '</qr-modal>' +

            '<qr-modal class="qr-subscription-resume__modal" data-title="{{ ::failedModalTitle }}" open="states.failedModal" buttons="buttonsFailedModal">' +
            '<div class="qr-subscription-resume__content">' +
            '<p class="qr-subscription-resume__text" ng-bind-html="::failedModalContent"></p>' +
            '</div>' +
            '</qr-modal>',
        scope: {
            open: '=',      // Optional open state of the modal.
        },
        controller: ['$scope', function ($scope) {
            /**
             * Some translations for this directive.
             */
            $scope.resumeModalTitle = gettextCatalog.getString('Would you like to resume your subscription?');
            $scope.resumeModalContent = gettextCatalog.getString('By resuming your paused subscription, you can create new QR Codes, reactivate existing Dynamic QR Codes, and access all features again.');

            $scope.successModalTitle = gettextCatalog.getString('Your subscription is now resumed');
            $scope.successModalContent = gettextCatalog.getString('Immediately jump back where you left off and start creating QR Codes again. A confirmation email will follow shortly.');

            $scope.failedModalTitle = gettextCatalog.getString("Your subscription couldn't be resumed");
            $scope.failedModalContent = $sce.trustAsHtml(
                markup.convertToString(
                    gettextCatalog.getString(
                        "There was an error with your request. Please contact [link={{url}}]support@qr-code-generator.com[/link] to resume your subscription.",
                        {url: "mailto:support@qr-code-generator.com"}
                    ),
                    "qr-subscription-resume__text"
                )
            );

            // Holds the current states of the views
            $scope.states = {
                resumeModal: false,
                successModal: false,
                failedModal: false,
            };

            // Indicates if action is in progress. Used to prevent multiple pausing requests.
            $scope.actionInProgress = false;

            $scope.closeWindow = function() {
                $scope.open = false;
            };

            $scope.$watch('open', function (newOpen, oldOpen) {
                if ($scope.open) {
                    $scope.states.resumeModal = true;
                }

                if (!$scope.open) {
                    $scope.states.resumeModal = false;
                    $scope.states.successModal = false;
                    $scope.states.failedModal = false;
                    $scope.$emit('closeResumeModal');
                }
            });

            $scope.$watch('[states.resumeModal, states.successModal, states.failedModal]', function (newOpen, oldOpen) {
                if (!$scope.states.resumeModal && !$scope.states.successModal && !$scope.states.failedModal) {
                    $scope.open = false;
                }
            });

            /**
             * Array of buttons for the modal.
             * @type {Array}
             */
            $scope.buttonsResumeModal = [
                {
                    label: gettextCatalog.getString('Confirm'),
                    callback: function () {
                        if ($scope.actionInProgress === false) {
                            $scope.actionInProgress = true;

                            $.post('/subscription/resume', {
                                YII_CSRF_TOKEN: GLOBAL_CSRF_TOKEN
                            }).done(function (response) {
                                if (response.includes('error')) {
                                    $scope.states.resumeModal = false;
                                    $scope.states.failedModal = true;
                                    $scope.$apply();
                                } else {
                                    $scope.states.resumeModal = false;
                                    $scope.states.successModal = true;
                                    $scope.$apply();
                                }
                            }).fail(function (response) {
                                console.log("Couldnt pause subscription!");
                            });
                        }

                    }
                },
                {
                    label: gettextCatalog.getString('Cancel'),
                    type: 'link',
                    callback: function () {
                        $scope.closeWindow();
                    }
                }
            ];

            $scope.buttonsSuccessModal = [
                {
                    label: gettextCatalog.getString('Got it'),
                    callback: function () {
                        $scope.states.successModal = false;
                        $scope.open = false;
                        window.location.reload();
                    }
                }
            ];

            $scope.buttonsFailedModal = [
                {
                    label: gettextCatalog.getString('Got it'),
                    callback: function () {
                        $scope.states.failedModal = false;
                        $scope.open = false;
                    }
                }
            ];
        }]
    };
}]);
